diff -pbBEwurNa --ignore-matching-lines='.*vc_id.*' HTK-3.4.1/HTKLVRec/HDecode.c HTS-2.2_for_HTK-3.4.1/HTKLVRec/HDecode.c
--- HTK-3.4.1/HTKLVRec/HDecode.c	2009-03-13 03:55:15.000000000 +0900
+++ HTS-2.2_for_HTK-3.4.1/HTKLVRec/HDecode.c	2011-02-10 17:23:06.000000000 +0900
@@ -27,8 +27,53 @@
 /*         File: HDecode.c  HTK Large Vocabulary Decoder       */
 /* ----------------------------------------------------------- */
 
+/*  *** THIS IS A MODIFIED VERSION OF HTK ***                        */
+/* ----------------------------------------------------------------- */
+/*           The HMM-Based Speech Synthesis System (HTS)             */
+/*           developed by HTS Working Group                          */
+/*           http://hts.sp.nitech.ac.jp/                             */
+/* ----------------------------------------------------------------- */
+/*                                                                   */
+/*  Copyright (c) 2001-2011  Nagoya Institute of Technology          */
+/*                           Department of Computer Science          */
+/*                                                                   */
+/*                2001-2008  Tokyo Institute of Technology           */
+/*                           Interdisciplinary Graduate School of    */
+/*                           Science and Engineering                 */
+/*                                                                   */
+/* All rights reserved.                                              */
+/*                                                                   */
+/* Redistribution and use in source and binary forms, with or        */
+/* without modification, are permitted provided that the following   */
+/* conditions are met:                                               */
+/*                                                                   */
+/* - Redistributions of source code must retain the above copyright  */
+/*   notice, this list of conditions and the following disclaimer.   */
+/* - Redistributions in binary form must reproduce the above         */
+/*   copyright notice, this list of conditions and the following     */
+/*   disclaimer in the documentation and/or other materials provided */
+/*   with the distribution.                                          */
+/* - Neither the name of the HTS working group nor the names of its  */
+/*   contributors may be used to endorse or promote products derived */
+/*   from this software without specific prior written permission.   */
+/*                                                                   */
+/* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND            */
+/* CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,       */
+/* INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF          */
+/* MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE          */
+/* DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS */
+/* BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,          */
+/* EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED   */
+/* TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,     */
+/* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON */
+/* ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,   */
+/* OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY    */
+/* OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE           */
+/* POSSIBILITY OF SUCH DAMAGE.                                       */
+/* ----------------------------------------------------------------- */
+
 char *hdecode_version = "!HVER!HDecode:   3.4.1 [GE 12/03/09]";
-char *hdecode_sccs_id = "$Id: HDecode.c,v 1.1.1.1 2006/10/11 09:54:55 jal58 Exp $";
+char *hdecode_sccs_id = "$Id: HDecode.c,v 1.13 2011/02/10 08:23:06 uratec Exp $";
 
 /* this is just the tool that handles command line arguments and
    stuff, all the real magic is in HLVNet and HLVRec */
@@ -240,7 +285,7 @@ ReportUsage (void)
 #ifdef TSIDOPT
    printf ("TSIDOPT ");
 #endif   
-   printf ("\n  sizes: PronId=%d  LMId=%d \n", sizeof (PronId), sizeof (LMId));
+   printf ("\n  sizes: PronId=%zd  LMId=%zd \n", sizeof (PronId), sizeof (LMId));
 }
 
 int
@@ -266,7 +311,7 @@ main (int argc, char *argv[])
    InitLVNet ();
    InitLVLM ();
    InitLVRec ();
-   InitAdapt (&xfInfo);
+   InitAdapt (&xfInfo, NULL);
    InitLat ();
 
    if (!InfoPrinted () && NumArgs () == 0)
@@ -679,7 +724,7 @@ DecoderInst *Initialise (void)
    obs = (Observation *) New (&gcheap, outpBlocksize * sizeof (Observation));
    for (i = 0; i < outpBlocksize; ++i)
       obs[i] = MakeObservation (&gcheap, hset.swidth, hset.pkind, 
-                                (hset.hsKind == DISCRETEHS), eSep);
+                                ((hset.hsKind == DISCRETEHS) ? TRUE:FALSE), eSep);
 
    CreateHeap (&inputBufHeap, "Input Buffer Heap", MSTAK, 1, 1.0, 80000, 800000);
 
@@ -692,7 +737,7 @@ DecoderInst *Initialise (void)
    if (xfInfo.useOutXForm) {
       CreateHeap(&regHeap,   "regClassStore",  MSTAK, 1, 0.5, 1000, 8000 );
       /* This initialises things - temporary hack - THINK!! */
-      CreateAdaptXForm(&hset, "tmp");
+      CreateAdaptXForm(&hset, &xfInfo, "tmp");
 
       /* online adaptation not supported yet! */
    }
@@ -1069,10 +1114,13 @@ void DoRecognition (DecoderInst *dec, ch
 
       if (labForm != NULL)
          ReFormatTranscription (trans, pbInfo.tgtSampRate, FALSE, FALSE,
-                                strchr(labForm,'X')!=NULL,
-                                strchr(labForm,'N')!=NULL,strchr(labForm,'S')!=NULL,
-                                strchr(labForm,'C')!=NULL,strchr(labForm,'T')!=NULL,
-                                strchr(labForm,'W')!=NULL,strchr(labForm,'M')!=NULL);
+                                (strchr(labForm,'X')!=NULL) ? TRUE:FALSE,
+                                (strchr(labForm,'N')!=NULL) ? TRUE:FALSE,
+                                (strchr(labForm,'S')!=NULL) ? TRUE:FALSE,
+                                (strchr(labForm,'C')!=NULL) ? TRUE:FALSE,
+                                (strchr(labForm,'T')!=NULL) ? TRUE:FALSE,
+                                (strchr(labForm,'W')!=NULL) ? TRUE:FALSE,
+                                (strchr(labForm,'M')!=NULL) ? TRUE:FALSE);
       
       MakeFN (fn, labDir, labExt, labfn);
 
diff -pbBEwurNa --ignore-matching-lines='.*vc_id.*' HTK-3.4.1/HTKLVRec/HDecode.mod.c HTS-2.2_for_HTK-3.4.1/HTKLVRec/HDecode.mod.c
--- HTK-3.4.1/HTKLVRec/HDecode.mod.c	2009-03-13 03:55:28.000000000 +0900
+++ HTS-2.2_for_HTK-3.4.1/HTKLVRec/HDecode.mod.c	2011-02-10 17:23:06.000000000 +0900
@@ -27,8 +27,53 @@
 /*         File: HDecode.c  HTK Large Vocabulary Decoder       */
 /* ----------------------------------------------------------- */
 
+/*  *** THIS IS A MODIFIED VERSION OF HTK ***                        */
+/* ----------------------------------------------------------------- */
+/*           The HMM-Based Speech Synthesis System (HTS)             */
+/*           developed by HTS Working Group                          */
+/*           http://hts.sp.nitech.ac.jp/                             */
+/* ----------------------------------------------------------------- */
+/*                                                                   */
+/*  Copyright (c) 2001-2011  Nagoya Institute of Technology          */
+/*                           Department of Computer Science          */
+/*                                                                   */
+/*                2001-2008  Tokyo Institute of Technology           */
+/*                           Interdisciplinary Graduate School of    */
+/*                           Science and Engineering                 */
+/*                                                                   */
+/* All rights reserved.                                              */
+/*                                                                   */
+/* Redistribution and use in source and binary forms, with or        */
+/* without modification, are permitted provided that the following   */
+/* conditions are met:                                               */
+/*                                                                   */
+/* - Redistributions of source code must retain the above copyright  */
+/*   notice, this list of conditions and the following disclaimer.   */
+/* - Redistributions in binary form must reproduce the above         */
+/*   copyright notice, this list of conditions and the following     */
+/*   disclaimer in the documentation and/or other materials provided */
+/*   with the distribution.                                          */
+/* - Neither the name of the HTS working group nor the names of its  */
+/*   contributors may be used to endorse or promote products derived */
+/*   from this software without specific prior written permission.   */
+/*                                                                   */
+/* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND            */
+/* CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,       */
+/* INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF          */
+/* MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE          */
+/* DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS */
+/* BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,          */
+/* EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED   */
+/* TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,     */
+/* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON */
+/* ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,   */
+/* OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY    */
+/* OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE           */
+/* POSSIBILITY OF SUCH DAMAGE.                                       */
+/* ----------------------------------------------------------------- */
+
 char *hdecode_version = "!HVER!HDecode:   3.4.1 [GE 12/03/09]";
-char *hdecode_sccs_id = "$Id: HDecode.mod.c,v 1.1.1.1 2006/10/11 09:54:55 jal58 Exp $";
+char *hdecode_sccs_id = "$Id: HDecode.mod.c,v 1.8 2011/02/10 08:23:06 uratec Exp $";
 
 /* this is just the tool that handles command line arguments and
    stuff, all the real magic is in HLVNet and HLVRec */
@@ -260,7 +305,7 @@ main (int argc, char *argv[])
    InitLVNet ();
    InitLVLM ();
    InitLVRec ();
-   InitAdapt (&xfInfo);
+   InitAdapt (&xfInfo, NULL);
    InitLat ();
 
    if (!InfoPrinted () && NumArgs () == 0)
diff -pbBEwurNa --ignore-matching-lines='.*vc_id.*' HTK-3.4.1/HTKLVRec/HLVLM.c HTS-2.2_for_HTK-3.4.1/HTKLVRec/HLVLM.c
--- HTK-3.4.1/HTKLVRec/HLVLM.c	2009-03-13 03:55:37.000000000 +0900
+++ HTS-2.2_for_HTK-3.4.1/HTKLVRec/HLVLM.c	2011-02-10 17:23:06.000000000 +0900
@@ -27,8 +27,53 @@
 /*         File: HLVLM.c Language model for HTK LV Decoder     */
 /* ----------------------------------------------------------- */
 
+/*  *** THIS IS A MODIFIED VERSION OF HTK ***                        */
+/* ----------------------------------------------------------------- */
+/*           The HMM-Based Speech Synthesis System (HTS)             */
+/*           developed by HTS Working Group                          */
+/*           http://hts.sp.nitech.ac.jp/                             */
+/* ----------------------------------------------------------------- */
+/*                                                                   */
+/*  Copyright (c) 2001-2011  Nagoya Institute of Technology          */
+/*                           Department of Computer Science          */
+/*                                                                   */
+/*                2001-2008  Tokyo Institute of Technology           */
+/*                           Interdisciplinary Graduate School of    */
+/*                           Science and Engineering                 */
+/*                                                                   */
+/* All rights reserved.                                              */
+/*                                                                   */
+/* Redistribution and use in source and binary forms, with or        */
+/* without modification, are permitted provided that the following   */
+/* conditions are met:                                               */
+/*                                                                   */
+/* - Redistributions of source code must retain the above copyright  */
+/*   notice, this list of conditions and the following disclaimer.   */
+/* - Redistributions in binary form must reproduce the above         */
+/*   copyright notice, this list of conditions and the following     */
+/*   disclaimer in the documentation and/or other materials provided */
+/*   with the distribution.                                          */
+/* - Neither the name of the HTS working group nor the names of its  */
+/*   contributors may be used to endorse or promote products derived */
+/*   from this software without specific prior written permission.   */
+/*                                                                   */
+/* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND            */
+/* CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,       */
+/* INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF          */
+/* MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE          */
+/* DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS */
+/* BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,          */
+/* EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED   */
+/* TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,     */
+/* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON */
+/* ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,   */
+/* OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY    */
+/* OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE           */
+/* POSSIBILITY OF SUCH DAMAGE.                                       */
+/* ----------------------------------------------------------------- */
+
 char *hlvlm_version = "!HVER!HLVLM:   3.4.1 [GE 12/03/09]";
-char *hlvlm_vc_id = "$Id: HLVLM.c,v 1.1.1.1 2006/10/11 09:54:55 jal58 Exp $";
+char *hlvlm_vc_id = "$Id: HLVLM.c,v 1.9 2011/02/10 08:23:06 uratec Exp $";
 
 #include "HShell.h"
 #include "HMem.h"
@@ -237,7 +282,7 @@ static void GetLMEntry (FSLM_ngram *nglm
                         LMId word2lmid(FSLM_ngram *, char*), 
                         LogFloat *prob, Boolean *hasBO, LogFloat *bo, Boolean *hasUNK)
 {
-   unsigned char size, flags;
+   unsigned char size, flags='\0';
    char buf[MAXSTRLEN];
    int i;
    unsigned short us;
@@ -311,12 +356,12 @@ static void GetLMEntry (FSLM_ngram *nglm
 static void ReadARPAngram (FSLM_ngram *nglm, Source *lmSrc, int n, int count, Boolean bin,
                            Vocab *vocab)
 {
-   LogFloat prob, bo;
+   LogFloat prob, bo=LZERO;
    Boolean hasBO, hasUNK;
    int i;
    LMId ndx[NSIZE+1];
    NEntry *ne, *le = NULL;
-   SEntry *tmpSE, *curtmpSE;
+   SEntry *tmpSE, *curtmpSE=NULL;
    int ntmpSE = 0;
    LMId (*word2lmid)(FSLM_ngram *, char *);
    Word word;
@@ -934,7 +979,7 @@ SEntry *FindMinSEntry (SEntry *se, int n
 */
 static SEntry *FindMinSEntryP (SEntry *low, SEntry *hi, PronId minPron)
 {
-  SEntry *mid;
+  SEntry *mid=NULL;
 
   if (minPron > hi->word)
     return NULL;
@@ -1044,7 +1089,7 @@ LogFloat LMLookAhead_2gram (FSLM *lm, LM
 LogFloat LMLookAhead_3gram (FSLM *lm, LMState src, PronId minPron, PronId maxPron)
 {
    NEntry *ne_tg, *ne_bg;
-   SEntry *se_tg, *seLast_tg, *se_bg, *seLast_bg;
+   SEntry *se_tg=NULL, *seLast_tg=NULL, *se_bg=NULL, *seLast_bg=NULL;
    PronId p, pend;
    NGLM_Prob *unigrams;
    NGLM_Prob maxScore = NGLM_PROB_LZERO;
@@ -1511,7 +1556,7 @@ FSLM_ngram *CreateBoNGram (MemHeap *heap
 
 FSLM_LatArc *FindMinLatArc (FSLM_LatArc *low, FSLM_LatArc *hi, PronId minPron)
 {
-   FSLM_LatArc *mid;
+   FSLM_LatArc *mid=NULL;
 
    if (minPron > hi->word)
       return NULL;
diff -pbBEwurNa --ignore-matching-lines='.*vc_id.*' HTK-3.4.1/HTKLVRec/HLVModel.c HTS-2.2_for_HTK-3.4.1/HTKLVRec/HLVModel.c
--- HTK-3.4.1/HTKLVRec/HLVModel.c	2009-03-13 03:55:50.000000000 +0900
+++ HTS-2.2_for_HTK-3.4.1/HTKLVRec/HLVModel.c	2011-02-10 17:23:06.000000000 +0900
@@ -27,8 +27,53 @@
 /*         File: HLVmodel.c Model handling for HTK LV Decoder  */
 /* ----------------------------------------------------------- */
 
+/*  *** THIS IS A MODIFIED VERSION OF HTK ***                        */
+/* ----------------------------------------------------------------- */
+/*           The HMM-Based Speech Synthesis System (HTS)             */
+/*           developed by HTS Working Group                          */
+/*           http://hts.sp.nitech.ac.jp/                             */
+/* ----------------------------------------------------------------- */
+/*                                                                   */
+/*  Copyright (c) 2001-2011  Nagoya Institute of Technology          */
+/*                           Department of Computer Science          */
+/*                                                                   */
+/*                2001-2008  Tokyo Institute of Technology           */
+/*                           Interdisciplinary Graduate School of    */
+/*                           Science and Engineering                 */
+/*                                                                   */
+/* All rights reserved.                                              */
+/*                                                                   */
+/* Redistribution and use in source and binary forms, with or        */
+/* without modification, are permitted provided that the following   */
+/* conditions are met:                                               */
+/*                                                                   */
+/* - Redistributions of source code must retain the above copyright  */
+/*   notice, this list of conditions and the following disclaimer.   */
+/* - Redistributions in binary form must reproduce the above         */
+/*   copyright notice, this list of conditions and the following     */
+/*   disclaimer in the documentation and/or other materials provided */
+/*   with the distribution.                                          */
+/* - Neither the name of the HTS working group nor the names of its  */
+/*   contributors may be used to endorse or promote products derived */
+/*   from this software without specific prior written permission.   */
+/*                                                                   */
+/* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND            */
+/* CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,       */
+/* INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF          */
+/* MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE          */
+/* DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS */
+/* BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,          */
+/* EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED   */
+/* TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,     */
+/* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON */
+/* ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,   */
+/* OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY    */
+/* OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE           */
+/* POSSIBILITY OF SUCH DAMAGE.                                       */
+/* ----------------------------------------------------------------- */
+
 char *hlvmodel_version = "!HVER!HLVmodel:   3.4.1 [GE 12/03/09]";
-char *hlvmodel_vc_id = "$Id: HLVModel.c,v 1.1.1.1 2006/10/11 09:54:55 jal58 Exp $";
+char *hlvmodel_vc_id = "$Id: HLVModel.c,v 1.8 2011/02/10 08:23:06 uratec Exp $";
 
 
 #include "HShell.h"
@@ -63,7 +108,7 @@ static int nParm = 0;
 
 /* --------------------------- Initialisation ---------------------- */
 
-/* EXPORT->InitLvmodel: register module & set configuration parameters */
+/* EXPORT->InitLVModel: register module & set configuration parameters */
 void InitLVModel(void)
 {
    int i;
@@ -76,6 +121,12 @@ void InitLVModel(void)
 
 }
 
+/* EXPORT->ResetLVmodel: reset module */
+void ResetLVModel(void)
+{
+   return;
+}
+
 /* --------------------------- the real code  ---------------------- */
 
 size_t RoundAlign(size_t addr, size_t align)
@@ -103,20 +154,20 @@ StateInfo_lv *ConvertHSet(MemHeap *heap,
    NewHMMScan (hset, &hss);
    while (GoNextState (&hss, FALSE)) {
       hss.si->sIdx=-1;
-      if (hss.si->pdf[1].nMix < minNMix)
-         minNMix = hss.si->pdf[1].nMix;
+      if (hss.si->pdf[1].info->nMix < minNMix)
+         minNMix = hss.si->pdf[1].info->nMix;
    } 
    EndHMMScan (&hss);
 
    NewHMMScan (hset, &hss);
    while (GoNextState (&hss, FALSE)) {
       if (hss.si->sIdx == -1) {
-         if (hss.si->pdf[1].nMix == minNMix) {
+         if (hss.si->pdf[1].info->nMix == minNMix) {
             hss.si->sIdx = sIdx;
             ++sIdx;
          } else {       /* need multiple blocks */
             hss.si->sIdx = sIdx;
-            sIdx += RoundAlign (hss.si->pdf[1].nMix,minNMix) / minNMix;
+            sIdx += RoundAlign (hss.si->pdf[1].info->nMix,minNMix) / minNMix;
          }
       }
       else {
@@ -147,13 +198,13 @@ StateInfo_lv *ConvertHSet(MemHeap *heap,
          se = &hss.si->pdf[1];
 
          base = HLVMODEL_BLOCK_BASE(si, hss.si->sIdx);
-         HLVMODEL_BLOCK_NMIX(si,base) = se->nMix;
+         HLVMODEL_BLOCK_NMIX(si,base) = se->info->nMix;
 
          mean = base + HLVMODEL_BLOCK_MEAN_OFFSET(si);
          invVar = base + HLVMODEL_BLOCK_INVVAR_OFFSET(si);
 
-         for (m = 1; m <= se->nMix; ++m) {
-            me = &se->spdf.cpdf[m];
+         for (m = 1; m <= se->info->nMix; ++m) {
+            me = &se->info->spdf.cpdf[m];
             mp = me->mpdf;
             assert (mp->ckind == INVDIAGC);
 
diff -pbBEwurNa --ignore-matching-lines='.*vc_id.*' HTK-3.4.1/HTKLVRec/HLVRec-GC.c HTS-2.2_for_HTK-3.4.1/HTKLVRec/HLVRec-GC.c
--- HTK-3.4.1/HTKLVRec/HLVRec-GC.c	2009-03-11 18:56:05.000000000 +0900
+++ HTS-2.2_for_HTK-3.4.1/HTKLVRec/HLVRec-GC.c	2009-12-14 17:46:00.000000000 +0900
@@ -234,13 +234,14 @@ static void SweepModPaths (MemHeap *heap
    int iMapPos, iMapMask;
    int total, freed;
 
+   if(heap != NULL){
    assert (heap->type == MHEAP);
 
    total = freed = 0;
    elemSize = heap->elemSize;
 
-   for (b = heap->heap; b; b = b->next) {
-      for (i = 0, path = b->data; i < b->numElem; 
+   for (b = heap->heap; b != NULL; b = b->next) {
+      for (i = 0, path = b->data; path != NULL && i < b->numElem; 
            ++i, path = (ModendHyp *) (((char *) path) + elemSize)) {
          iMapPos = i/8;
          iMapMask = 1 << (i&7);
@@ -276,6 +277,7 @@ static void SweepModPaths (MemHeap *heap
    if (trace&T_GC)
       printf ("freed %d of %d ModPaths\n", freed, total);
 }
+}
 #endif
 
 /* GarbageCollectPaths
diff -pbBEwurNa --ignore-matching-lines='.*vc_id.*' HTK-3.4.1/HTKLVRec/HLVRec-LM.c HTS-2.2_for_HTK-3.4.1/HTKLVRec/HLVRec-LM.c
--- HTK-3.4.1/HTKLVRec/HLVRec-LM.c	2009-03-11 18:56:05.000000000 +0900
+++ HTS-2.2_for_HTK-3.4.1/HTKLVRec/HLVRec-LM.c	2011-02-10 17:19:09.000000000 +0900
@@ -28,6 +28,51 @@
 /*                           HTK LV Decoder                    */
 /* ----------------------------------------------------------- */
 
+/*  *** THIS IS A MODIFIED VERSION OF HTK ***                        */
+/* ----------------------------------------------------------------- */
+/*           The HMM-Based Speech Synthesis System (HTS)             */
+/*           developed by HTS Working Group                          */
+/*           http://hts.sp.nitech.ac.jp/                             */
+/* ----------------------------------------------------------------- */
+/*                                                                   */
+/*  Copyright (c) 2001-2011  Nagoya Institute of Technology          */
+/*                           Department of Computer Science          */
+/*                                                                   */
+/*                2001-2008  Tokyo Institute of Technology           */
+/*                           Interdisciplinary Graduate School of    */
+/*                           Science and Engineering                 */
+/*                                                                   */
+/* All rights reserved.                                              */
+/*                                                                   */
+/* Redistribution and use in source and binary forms, with or        */
+/* without modification, are permitted provided that the following   */
+/* conditions are met:                                               */
+/*                                                                   */
+/* - Redistributions of source code must retain the above copyright  */
+/*   notice, this list of conditions and the following disclaimer.   */
+/* - Redistributions in binary form must reproduce the above         */
+/*   copyright notice, this list of conditions and the following     */
+/*   disclaimer in the documentation and/or other materials provided */
+/*   with the distribution.                                          */
+/* - Neither the name of the HTS working group nor the names of its  */
+/*   contributors may be used to endorse or promote products derived */
+/*   from this software without specific prior written permission.   */
+/*                                                                   */
+/* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND            */
+/* CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,       */
+/* INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF          */
+/* MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE          */
+/* DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS */
+/* BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,          */
+/* EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED   */
+/* TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,     */
+/* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON */
+/* ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,   */
+/* OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY    */
+/* OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE           */
+/* POSSIBILITY OF SUCH DAMAGE.                                       */
+/* ----------------------------------------------------------------- */
+
 /* UpdateLMlookahead
 
      update LM lookahead info for all RelToks in entry state of ln
@@ -66,7 +111,7 @@ static void UpdateLMlookahead(DecoderIns
       }
       else {    /* if we ever do fastLMLA, be careful as tok->lmscore might increase! */
          lmscore = LMCacheLookaheadProb (dec, tok->lmState, lmlaIdx, 
-                                         tok->delta < dec->fastlmlaBeam);
+                                         (tok->delta < dec->fastlmlaBeam) ? TRUE:FALSE);
          if (lmscore > tok->lmscore)    /* if lmla goes up, leave old estimate */
             lmscore = tok->lmscore;
       }
diff -pbBEwurNa --ignore-matching-lines='.*vc_id.*' HTK-3.4.1/HTKLVRec/HLVRec-outP.c HTS-2.2_for_HTK-3.4.1/HTKLVRec/HLVRec-outP.c
--- HTK-3.4.1/HTKLVRec/HLVRec-outP.c	2009-03-11 18:56:05.000000000 +0900
+++ HTS-2.2_for_HTK-3.4.1/HTKLVRec/HLVRec-outP.c	2011-02-10 17:19:09.000000000 +0900
@@ -27,6 +27,50 @@
 /*         File: HLVRec-outP.c OutP calculation and caching    */
 /* ----------------------------------------------------------- */
 
+/*  *** THIS IS A MODIFIED VERSION OF HTK ***                        */
+/* ----------------------------------------------------------------- */
+/*           The HMM-Based Speech Synthesis System (HTS)             */
+/*           developed by HTS Working Group                          */
+/*           http://hts.sp.nitech.ac.jp/                             */
+/* ----------------------------------------------------------------- */
+/*                                                                   */
+/*  Copyright (c) 2001-2011  Nagoya Institute of Technology          */
+/*                           Department of Computer Science          */
+/*                                                                   */
+/*                2001-2008  Tokyo Institute of Technology           */
+/*                           Interdisciplinary Graduate School of    */
+/*                           Science and Engineering                 */
+/*                                                                   */
+/* All rights reserved.                                              */
+/*                                                                   */
+/* Redistribution and use in source and binary forms, with or        */
+/* without modification, are permitted provided that the following   */
+/* conditions are met:                                               */
+/*                                                                   */
+/* - Redistributions of source code must retain the above copyright  */
+/*   notice, this list of conditions and the following disclaimer.   */
+/* - Redistributions in binary form must reproduce the above         */
+/*   copyright notice, this list of conditions and the following     */
+/*   disclaimer in the documentation and/or other materials provided */
+/*   with the distribution.                                          */
+/* - Neither the name of the HTS working group nor the names of its  */
+/*   contributors may be used to endorse or promote products derived */
+/*   from this software without specific prior written permission.   */
+/*                                                                   */
+/* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND            */
+/* CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,       */
+/* INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF          */
+/* MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE          */
+/* DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS */
+/* BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,          */
+/* EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED   */
+/* TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,     */
+/* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON */
+/* ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,   */
+/* OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY    */
+/* OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE           */
+/* POSSIBILITY OF SUCH DAMAGE.                                       */
+/* ----------------------------------------------------------------- */
 
 static void ResetOutPCache (OutPCache *cache)
 {
@@ -69,7 +113,7 @@ static OutPCache *CreateOutPCache (MemHe
 }
 
 /* SOutP_ID_mix_Block: returns log prob of stream s of observation x */
-LogFloat SOutP_ID_mix_Block(HMMSet *hset, int s, Observation *x, StreamElem *se)
+LogFloat SOutP_ID_mix_Block(HMMSet *hset, int s, Observation *x, StreamInfo *sti)
 {
    int vSize;
    LogDouble px;
@@ -81,10 +125,14 @@ LogFloat SOutP_ID_mix_Block(HMMSet *hset
    assert (hset->hsKind == PLAINHS && hset->hsKind == SHAREDHS);
    
    v = x->fv[s];
+   if (hset->msdflag[s]) {
+      vSize = SpaceOrder(v);
+   } else {
    vSize = VectorSize(v);
    assert (vSize == hset->swidth[s]);
-   me = se->spdf.cpdf+1;
-   if (se->nMix == 1){     /* Single Mixture Case */
+   }
+   me = sti->spdf.cpdf+1;
+   if (sti->nMix == 1){     /* Single Mixture Case */
       mp = me->mpdf; 
       assert (mp->ckind == INVDIAGC);
       /*       px = IDOutP(v,vSize,mp); */
@@ -109,10 +157,11 @@ LogFloat SOutP_ID_mix_Block(HMMSet *hset
       LogDouble bx = LZERO;                   
       int m;
 
-      for (m=1; m<=se->nMix; m++,me++) {
+      for (m=1; m<=sti->nMix; m++,me++) {
          wt = MixLogWeight(hset,me->weight);
          if (wt>LMINMIX) {  
             mp = me->mpdf; 
+            if (!hset->msdflag[s] || vSize == VectorSize(mp->mean))
             /*       px = IDOutP(v,vSize,mp);   */
             {
                int i;
@@ -265,7 +314,7 @@ x      CACHE_FLAG_SET(dec, sIdx);
 /*  outP calculation from HModel.c and extended for new adapt code */
 
 
-static LogFloat SOutP_HMod (HMMSet *hset, int s, Observation *x, StreamElem *se,
+static LogFloat SOutP_HMod (HMMSet *hset, int s, Observation *x, StreamInfo *sti,
                             int id)
 {
    int m;
@@ -278,13 +327,13 @@ static LogFloat SOutP_HMod (HMMSet *hset
    assert (hset->hsKind == SHAREDHS);
 
    v=x->fv[s];
-   me=se->spdf.cpdf+1;
-   if (se->nMix==1){     /* Single Mixture Case */
+   me=sti->spdf.cpdf+1;
+   if (sti->nMix==1){     /* Single Mixture Case */
       bx= MOutP(ApplyCompFXForm(me->mpdf,v,inXForm,&det,id),me->mpdf);
       bx += det;
    } else if (!pde) {
       bx=LZERO;                   /* Multi Mixture Case */
-      for (m=1; m<=se->nMix; m++,me++) {
+      for (m=1; m<=sti->nMix; m++,me++) {
          wt = MixLogWeight(hset,me->weight);
          if (wt>LMINMIX) {   
             px= MOutP(ApplyCompFXForm(me->mpdf,v,inXForm,&det,id),me->mpdf);
@@ -295,10 +344,15 @@ static LogFloat SOutP_HMod (HMMSet *hset
    } else {   /* Partial distance elimination */
       wt = MixLogWeight(hset,me->weight);
       mp = me->mpdf;
+      if (!hset->msdflag[s] || SpaceOrder(v)==VectorSize(mp->mean)) {
       otvs = ApplyCompFXForm(mp,v,inXForm,&det,id);
       px = IDOutP(otvs,VectorSize(otvs),mp);
+      } else {
+         px = LZERO;
+         det = 0.0;
+      }
       bx = wt+px+det;
-      for (m=2,me=se->spdf.cpdf+2;m<=se->nMix;m++,me++) {
+      for (m=2,me=sti->spdf.cpdf+2;m<=sti->nMix;m++,me++) {
          wt = MixLogWeight(hset,me->weight);
 	 if (wt>LMINMIX){
 	    mp = me->mpdf;
@@ -319,10 +373,10 @@ LogFloat POutP_HModel (HMMSet *hset,Obse
    int s,S = x->swidth[0];
    
    if (S==1 && si->weights==NULL)
-      return SOutP_HMod(hset,1,x,si->pdf+1, id);
+      return SOutP_HMod(hset,1,x,si->pdf[1].info, id);
    bx=0.0; se=si->pdf+1; w = si->weights;
    for (s=1;s<=S;s++,se++)
-      bx += w[s]*SOutP_HMod(hset,s,x,se, id);
+      bx += w[s]*SOutP_HMod(hset,s,x,se->info, id);
    return bx;
 }
 
diff -pbBEwurNa --ignore-matching-lines='.*vc_id.*' HTK-3.4.1/HTKLVRec/HLVRec-propagate.c HTS-2.2_for_HTK-3.4.1/HTKLVRec/HLVRec-propagate.c
--- HTK-3.4.1/HTKLVRec/HLVRec-propagate.c	2009-03-11 18:56:05.000000000 +0900
+++ HTS-2.2_for_HTK-3.4.1/HTKLVRec/HLVRec-propagate.c	2011-02-10 17:23:06.000000000 +0900
@@ -29,7 +29,52 @@
 /*                                  propagation                */
 /* ----------------------------------------------------------- */
 
-char *hlvrec_prop_vc_id = "$Id: HLVRec-propagate.c,v 1.1.1.1 2006/10/11 09:54:56 jal58 Exp $";
+/*  *** THIS IS A MODIFIED VERSION OF HTK ***                        */
+/* ----------------------------------------------------------------- */
+/*           The HMM-Based Speech Synthesis System (HTS)             */
+/*           developed by HTS Working Group                          */
+/*           http://hts.sp.nitech.ac.jp/                             */
+/* ----------------------------------------------------------------- */
+/*                                                                   */
+/*  Copyright (c) 2001-2011  Nagoya Institute of Technology          */
+/*                           Department of Computer Science          */
+/*                                                                   */
+/*                2001-2008  Tokyo Institute of Technology           */
+/*                           Interdisciplinary Graduate School of    */
+/*                           Science and Engineering                 */
+/*                                                                   */
+/* All rights reserved.                                              */
+/*                                                                   */
+/* Redistribution and use in source and binary forms, with or        */
+/* without modification, are permitted provided that the following   */
+/* conditions are met:                                               */
+/*                                                                   */
+/* - Redistributions of source code must retain the above copyright  */
+/*   notice, this list of conditions and the following disclaimer.   */
+/* - Redistributions in binary form must reproduce the above         */
+/*   copyright notice, this list of conditions and the following     */
+/*   disclaimer in the documentation and/or other materials provided */
+/*   with the distribution.                                          */
+/* - Neither the name of the HTS working group nor the names of its  */
+/*   contributors may be used to endorse or promote products derived */
+/*   from this software without specific prior written permission.   */
+/*                                                                   */
+/* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND            */
+/* CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,       */
+/* INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF          */
+/* MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE          */
+/* DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS */
+/* BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,          */
+/* EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED   */
+/* TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,     */
+/* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON */
+/* ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,   */
+/* OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY    */
+/* OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE           */
+/* POSSIBILITY OF SUCH DAMAGE.                                       */
+/* ----------------------------------------------------------------- */
+
+char *hlvrec_prop_vc_id = "$Id: HLVRec-propagate.c,v 1.8 2011/02/10 08:23:06 uratec Exp $";
 
 
 static int winTok_cmp (const void *v1,const void *v2)
@@ -1413,9 +1458,9 @@ void ProcessFrame (DecoderInst *dec, Obs
                }
 #endif
 
-               PropagateExternal (dec, inst, !(dec->weBeamWidth < dec->beamWidth) || 
-                                  (l == LAYER_SIL) || (l == LAYER_AB),
-                                  l == LAYER_BY);
+               PropagateExternal (dec, inst, (!(dec->weBeamWidth < dec->beamWidth) || 
+                                  (l == LAYER_SIL) || (l == LAYER_AB)) ? TRUE:FALSE,
+                                  (l == LAYER_BY) ? TRUE:FALSE);
             }
 
             
diff -pbBEwurNa --ignore-matching-lines='.*vc_id.*' HTK-3.4.1/HTKLVRec/HLVRec-traceback.c HTS-2.2_for_HTK-3.4.1/HTKLVRec/HLVRec-traceback.c
--- HTK-3.4.1/HTKLVRec/HLVRec-traceback.c	2009-03-11 18:56:05.000000000 +0900
+++ HTS-2.2_for_HTK-3.4.1/HTKLVRec/HLVRec-traceback.c	2011-02-10 17:19:09.000000000 +0900
@@ -28,6 +28,51 @@
 /*                                  HTK LV Decoder             */
 /* ----------------------------------------------------------- */
 
+/*  *** THIS IS A MODIFIED VERSION OF HTK ***                        */
+/* ----------------------------------------------------------------- */
+/*           The HMM-Based Speech Synthesis System (HTS)             */
+/*           developed by HTS Working Group                          */
+/*           http://hts.sp.nitech.ac.jp/                             */
+/* ----------------------------------------------------------------- */
+/*                                                                   */
+/*  Copyright (c) 2001-2011  Nagoya Institute of Technology          */
+/*                           Department of Computer Science          */
+/*                                                                   */
+/*                2001-2008  Tokyo Institute of Technology           */
+/*                           Interdisciplinary Graduate School of    */
+/*                           Science and Engineering                 */
+/*                                                                   */
+/* All rights reserved.                                              */
+/*                                                                   */
+/* Redistribution and use in source and binary forms, with or        */
+/* without modification, are permitted provided that the following   */
+/* conditions are met:                                               */
+/*                                                                   */
+/* - Redistributions of source code must retain the above copyright  */
+/*   notice, this list of conditions and the following disclaimer.   */
+/* - Redistributions in binary form must reproduce the above         */
+/*   copyright notice, this list of conditions and the following     */
+/*   disclaimer in the documentation and/or other materials provided */
+/*   with the distribution.                                          */
+/* - Neither the name of the HTS working group nor the names of its  */
+/*   contributors may be used to endorse or promote products derived */
+/*   from this software without specific prior written permission.   */
+/*                                                                   */
+/* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND            */
+/* CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,       */
+/* INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF          */
+/* MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE          */
+/* DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS */
+/* BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,          */
+/* EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED   */
+/* TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,     */
+/* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON */
+/* ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,   */
+/* OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY    */
+/* OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE           */
+/* POSSIBILITY OF SUCH DAMAGE.                                       */
+/* ----------------------------------------------------------------- */
+
 /* Print Path
  */
 static void PrintPath (DecoderInst *dec, WordendHyp *we)
@@ -126,7 +171,7 @@ Transcription *TraceBack(MemHeap *heap, 
    LLink lab, nextlab;
    WordendHyp *weHyp;
    TokenSet *ts;
-   RelToken *bestTok;
+   RelToken *bestTok=NULL;
    LogFloat prevScore, score;
    RelTokScore bestDelta;
    Pron pron;
@@ -558,7 +603,7 @@ LAlign *LAlignFromAltModpath (DecoderIns
 void PrintModPath (DecoderInst *dec, ModendHyp *m)
 {
    MLink ml;
-   char *s, *t;
+   char *s, *t=NULL;
 
    for (; m; m = m->prev) {
       s = "?";
@@ -688,7 +733,7 @@ AltWordendHyp *FakeSEpath (DecoderInst *
 WordendHyp *AltPathList2Path (DecoderInst *dec, AltWordendHyp *alt, PronId pron)
 {
    WordendHyp *path;
-   AltWordendHyp *bestAlt, *a;
+   AltWordendHyp *bestAlt=NULL, *a;
    TokScore bestAltScore = LZERO;
    AltWordendHyp **pAlt;
    int i;
diff -pbBEwurNa --ignore-matching-lines='.*vc_id.*' HTK-3.4.1/HTKLVRec/HLVRec.c HTS-2.2_for_HTK-3.4.1/HTKLVRec/HLVRec.c
--- HTK-3.4.1/HTKLVRec/HLVRec.c	2009-03-13 03:56:16.000000000 +0900
+++ HTS-2.2_for_HTK-3.4.1/HTKLVRec/HLVRec.c	2011-02-10 17:23:06.000000000 +0900
@@ -28,9 +28,53 @@
 /*                        HTK LV Decoder                       */
 /* ----------------------------------------------------------- */
 
+/*  *** THIS IS A MODIFIED VERSION OF HTK ***                        */
+/* ----------------------------------------------------------------- */
+/*           The HMM-Based Speech Synthesis System (HTS)             */
+/*           developed by HTS Working Group                          */
+/*           http://hts.sp.nitech.ac.jp/                             */
+/* ----------------------------------------------------------------- */
+/*                                                                   */
+/*  Copyright (c) 2001-2011  Nagoya Institute of Technology          */
+/*                           Department of Computer Science          */
+/*                                                                   */
+/*                2001-2008  Tokyo Institute of Technology           */
+/*                           Interdisciplinary Graduate School of    */
+/*                           Science and Engineering                 */
+/*                                                                   */
+/* All rights reserved.                                              */
+/*                                                                   */
+/* Redistribution and use in source and binary forms, with or        */
+/* without modification, are permitted provided that the following   */
+/* conditions are met:                                               */
+/*                                                                   */
+/* - Redistributions of source code must retain the above copyright  */
+/*   notice, this list of conditions and the following disclaimer.   */
+/* - Redistributions in binary form must reproduce the above         */
+/*   copyright notice, this list of conditions and the following     */
+/*   disclaimer in the documentation and/or other materials provided */
+/*   with the distribution.                                          */
+/* - Neither the name of the HTS working group nor the names of its  */
+/*   contributors may be used to endorse or promote products derived */
+/*   from this software without specific prior written permission.   */
+/*                                                                   */
+/* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND            */
+/* CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,       */
+/* INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF          */
+/* MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE          */
+/* DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS */
+/* BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,          */
+/* EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED   */
+/* TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,     */
+/* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON */
+/* ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,   */
+/* OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY    */
+/* OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE           */
+/* POSSIBILITY OF SUCH DAMAGE.                                       */
+/* ----------------------------------------------------------------- */
 
 char *hlvrec_version = "!HVER!HLVRec:   3.4.1 [GE 12/03/09]";
-char *hlvrec_vc_id = "$Id: HLVRec.c,v 1.1.1.1 2006/10/11 09:54:56 jal58 Exp $";
+char *hlvrec_vc_id = "$Id: HLVRec.c,v 1.8 2011/02/10 08:23:06 uratec Exp $";
 
 
 #include "HShell.h"
@@ -201,7 +245,7 @@ static void GarbageCollectPaths (Decoder
 /* HLVRec-outP.c */
 static void ResetOutPCache (OutPCache *cache);
 static OutPCache *CreateOutPCache (MemHeap *heap, HMMSet *hset, int block);
-LogFloat SOutP_ID_mix_Block(HMMSet *hset, int s, Observation *x, StreamElem *se);
+LogFloat SOutP_ID_mix_Block(HMMSet *hset, int s, Observation *x, StreamInfo *sti);
 static LogFloat cOutP (DecoderInst *dec, Observation *x, HLink hmm, int state);
 void OutPBlock_HMod (StateInfo_lv *si, Observation **obsBlock, 
                      int n, int sIdx, float acScale, LogFloat *outP, int id);
@@ -322,7 +366,7 @@ DecoderInst *CreateDecoderInst(HMMSet *h
                   MHEAP, (i+1) * sizeof (TokenSet), 9, 10, 5000);
    }   
 
-   dec->tempTS = (TokenSet **) New (&dec->heap, N * sizeof (TokenSet *));
+   dec->tempTS = (TokenSet **) New (&dec->heap, (N+1) * sizeof (TokenSet *));
 
 
    /* alloc Heap for RelToken arrays */
diff -pbBEwurNa --ignore-matching-lines='.*vc_id.*' HTK-3.4.1/HTKLib/HAdapt.c HTS-2.2_for_HTK-3.4.1/HTKLib/HAdapt.c
--- HTK-3.4.1/HTKLib/HAdapt.c	2009-03-13 03:41:39.000000000 +0900
+++ HTS-2.2_for_HTK-3.4.1/HTKLib/HAdapt.c	2011-06-16 13:15:50.000000000 +0900
@@ -28,9 +28,56 @@
 /*         File: HAdapt.c      Adaptation Library module       */
 /* ----------------------------------------------------------- */
 
-char *hadapt_version = "!HVER!HAdapt:   3.4.1  [CUED 12/03/09]";
-char *hadapt_vc_id =  "$Id: HAdapt.c,v 1.2 2006/12/07 11:09:07 mjfg Exp $";
+/*  *** THIS IS A MODIFIED VERSION OF HTK ***                        */
+/* ----------------------------------------------------------------- */
+/*           The HMM-Based Speech Synthesis System (HTS)             */
+/*           developed by HTS Working Group                          */
+/*           http://hts.sp.nitech.ac.jp/                             */
+/* ----------------------------------------------------------------- */
+/*                                                                   */
+/*  Copyright (c) 2001-2011  Nagoya Institute of Technology          */
+/*                           Department of Computer Science          */
+/*                                                                   */
+/*                2001-2008  Tokyo Institute of Technology           */
+/*                           Interdisciplinary Graduate School of    */
+/*                           Science and Engineering                 */
+/*                                                                   */
+/*                2008-2009  University of Edinburgh                 */
+/*                           Centre for Speech Technology Research   */
+/*                                                                   */
+/* All rights reserved.                                              */
+/*                                                                   */
+/* Redistribution and use in source and binary forms, with or        */
+/* without modification, are permitted provided that the following   */
+/* conditions are met:                                               */
+/*                                                                   */
+/* - Redistributions of source code must retain the above copyright  */
+/*   notice, this list of conditions and the following disclaimer.   */
+/* - Redistributions in binary form must reproduce the above         */
+/*   copyright notice, this list of conditions and the following     */
+/*   disclaimer in the documentation and/or other materials provided */
+/*   with the distribution.                                          */
+/* - Neither the name of the HTS working group nor the names of its  */
+/*   contributors may be used to endorse or promote products derived */
+/*   from this software without specific prior written permission.   */
+/*                                                                   */
+/* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND            */
+/* CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,       */
+/* INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF          */
+/* MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE          */
+/* DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS */
+/* BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,          */
+/* EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED   */
+/* TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,     */
+/* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON */
+/* ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,   */
+/* OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY    */
+/* OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE           */
+/* POSSIBILITY OF SUCH DAMAGE.                                       */
+/* ----------------------------------------------------------------- */
 
+char *hadapt_version = "!HVER!HAdapt:   3.4.1  [CUED 12/03/09]";
+char *hadapt_vc_id =  "$Id: HAdapt.c,v 1.64 2011/06/16 04:15:50 uratec Exp $";
 
 #include <stdio.h>      /* Standard C Libraries */
 #include <stdlib.h>
@@ -67,9 +114,11 @@ char *hadapt_vc_id =  "$Id: HAdapt.c,v 1
 
 typedef struct {
    XFormKind xkind;
+   Boolean useBias;
    int dim;
    double occ;  
    IntVec blockSize;
+   IntVec bandWidth;
    DVector *K, D;
    DMatrix *G;
 } AccStruct;
@@ -81,33 +130,19 @@ typedef struct _AInfo {
 } AInfo;
 
 typedef struct {
-   Vector mean;
+   SVector mean;
+   CovKind ckind;
    Covariance cov;
    float gConst;
 } MInfo;
 
-typedef struct _ObsCache{
-   int time;
-   Vector obs;
-   float det;
-   struct _ObsCache *next;
-} ObsCache;                        /* observation cache to save rotated observations */
-
-typedef struct _AccCache{
-   int     baseclass;
-   DVector bVector;
-   TriMat  *bTriMat;
-   struct _AccCache *next;
-} AccCache;                       /* acc cache to save accumulators related to parent XForm */  
-
 typedef struct {
-   float occ;
-   Vector spSum;
-   Vector spSumSq;
-   TriMat *bTriMat;
-   TriMat *bDiagMat;
+   double  occ;
+   DVector spSum;
+   DVector spSumSq;
+   DTriMat *bTriMat;
+   DTriMat *bDiagMat;
    DVector bVector;
-   Vector  obsVec;
 } RegAcc;
 
 typedef struct {
@@ -125,77 +160,30 @@ static ConfParam *cParm[MAXGLOBS];      
 static int nParm = 0;
 static int trace = 0;                   /* trace info */
 
-/* Global information about current set of transforms */
-/* 
-static AdaptXForm* curXForm = NULL;
-static AdaptXForm* parentXForm = NULL;
-*/
-static AdaptXForm* outXForm = NULL;
-static AdaptXForm* diagCovXForm = NULL;
-
 /* Local stack to allow storage of internal structrures */
 static MemHeap infoStack;
-static MemHeap acccaStack;
-static MemHeap bobcaStack; /* base obscache */
-static MemHeap pobcaStack; /* parent obscache */
 
 /* Global variables */
-static XFormKind xKind     = MLLRMEAN;  /* Transform Kind to be created */
-
 /* also have the option of storing a model set for each of the speakers */
 static Boolean saveSpkrModels = FALSE;
 
 /* The xform config variable information */
 static float minOccThresh = 0.0;       /* minimum occupancy to accumulate stats to estimate xform */
-static Boolean useBias = TRUE;         /* whether a bias is to be estimated for the xform */
 static Boolean storeMInfo = TRUE;      /* whether original model information  is to be stored */
 static Boolean keepXFormDistinct = TRUE;
 static Boolean swapXForms = FALSE;     /* swap the transforms around after generating transform */
 static Boolean mllrCov2CMLLR= FALSE;   /* apply mllrcov transforms as cmllr transform */ 
 static Boolean mllrDiagCov = FALSE;    /* perform diagonal covariance adaptation */
+static Boolean useSMAPcriterion = FALSE;  /* perform SMAPLR and CSMAPLR adaptation */
+static Boolean SaveAllSMAPXForms = FALSE; /* Save intermediate matrices estimated in SMAP */
+static float   sigmascale = 1.0;          /* prior parameter for SMAP creterion*/
 
 static IntVec enableBlockAdapt = NULL;
 
-/* split threshold definitions for each xform kind */
-static float xformSplitThresh = -1000.0;
-static float mllrMeanSplitThresh = 1000.0;
-static float mllrCovSplitThresh = 1000.0;
-static float cmllrSplitThresh = 1000.0;
-
-/* adaptation kind  definitions for each xform kind */
-static AdaptKind xformAdaptKind = BASE;
-static AdaptKind mllrMeanAdaptKind = BASE;
-static AdaptKind mllrCovAdaptKind = BASE;
-static AdaptKind cmllrAdaptKind = BASE;
-
-/* regression tree definitions for each xform kind */
-static char *xformRegTree = NULL;
-static char *mllrMeanRegTree = NULL;
-static char *mllrCovRegTree = NULL;
-static char *cmllrRegTree = NULL;
-
-/* baseclass definitions for each xform kind */
-static char *xformBaseClass = NULL;
-static char *mllrMeanBaseClass = NULL;
-static char *mllrCovBaseClass = NULL;
-static char *cmllrBaseClass = NULL;
-
-/* block size definitions for each xform kind */
-static IntVec xformBlockSize = NULL;
-static IntVec mllrMeanBlockSize = NULL;
-static IntVec mllrCovBlockSize = NULL;
-static IntVec cmllrBlockSize = NULL;
-
-/* current time when this changes accumulate complete stats */
-/* -1 indicates that this is the first frame of a new file */
-static int baseTriMatTime=-1;  
-static double maxXFormIter = 10; /* something big, for CMLLR */ 
-static ObsCache *headpoc = NULL; 
-static ObsCache *headboc = NULL; 
-static AccCache *headac = NULL;
+static int maxXFormIter = 10; /* something big, for CMLLR */ 
 
 /* new variables to support semi-tied transforms */
-static float semiTiedFloorScale = 0.1;
+static Vector semiTiedFloorScale = NULL;  /* stream-dependent flooring scales */
 static int maxSemiTiedIter = 10;
 static char *semiTiedMacro = NULL;
 static Boolean semiTied2InputXForm = FALSE;
@@ -207,10 +195,6 @@ static Boolean initNuisanceFR = TRUE;
 static Boolean initNuisanceFRIdent = FALSE;
 static Boolean saveSemiTiedBinary = FALSE;
 
-/* specifies whether the transforms change the model variances */
-static Boolean covarChanged = FALSE;
-static Boolean covarPChanged = FALSE;
-
 /*------------------------------------------------------------------------*/
 /*    Support Routines for determining internal structures required       */
 /*    Note: these only act on the transform NOT any parents.              */
@@ -246,33 +230,48 @@ static Boolean AccAdaptBaseTriMat(AdaptX
 Boolean HardAssign(AdaptXForm *xform)
 {
    AdaptKind akind = xform->akind;
-   return ((akind == TREE) || (akind == BASE));
+   if ((akind == TREE) || (akind == BASE))
+      return TRUE;
+   else
+      return FALSE;
 }
 
 static Boolean StoreObsCache(AdaptXForm *xform)
 {
    XFormKind xkind = xform->xformSet->xkind;
-   return ((xkind == CMLLR)  || (xkind == MLLRCOV) || (xkind == SEMIT));
+   if ((xkind == CMLLR)  || (xkind == MLLRCOV) || (xkind == SEMIT))
+      return TRUE;
+   else
+      return FALSE;
 }
 
 static Boolean StoreAdaptMean(AdaptXForm *xform)
 {
    XFormKind xkind = xform->xformSet->xkind;
-   return ((xkind == MLLRMEAN) || (xkind == MLLRCOV));
+   if ((xkind == MLLRMEAN) || (xkind == MLLRCOV) || (xkind == CMLLR) || (xkind == SEMIT))
+      return TRUE;
+   else
+      return FALSE;
 }
 
 static Boolean StoreAdaptCov(AdaptXForm *xform)
 {
    XFormKind xkind = xform->xformSet->xkind;
-   return (xkind == MLLRVAR);
+   if ((xkind == MLLRVAR)  || (xkind == MLLRCOV) || (xkind == CMLLR) || (xkind == SEMIT))
+      return TRUE;
+   else
+      return FALSE;
 }
 
 /*------------------------------------------------------------------------*/
 /*            Initialisations and general structures allocation           */
 /*------------------------------------------------------------------------*/
 
-static void CheckAdaptOptions()
+static void CheckAdaptOptions(XFInfo *xfinfo)
 {
+   XFormKind xKind = xfinfo->outXKind;
+   Boolean useBias = xfinfo->useBias;
+   
    if ((!keepXFormDistinct) && (swapXForms))
       HError(999,"Cannot save swapped XForms in a TMF");
    if (((xKind == MLLRCOV)||(xKind == SEMIT)) && (useBias))
@@ -289,55 +288,257 @@ static void CheckAdaptOptions()
    }
    if (staticSemiTied) {
       if (xKind != SEMIT) 
-         HError(999,"Can only use ststic semiTied  with SEMIT transforms");
+         HError(999,"Can only use static semiTied with SEMIT transforms");
+   }
+   if (((mllrDiagCov)|| (xKind == MLLRCOV)||(xKind == SEMIT)) && (useSMAPcriterion))
+     HError(999,"Can use only SMAP with MLLRMEAN and CMLLR currently");
+   if ((xfinfo->xformAdaptKind == BASE) && (useSMAPcriterion))
+     HError(999,"Can use only SMAP with TREE currently");
+}
+
+/* EXPORT->CheckAdaptSetUp: check adapt setting */
+void CheckAdaptSetUp (HMMSet *hset, XFInfo *xfinfo)
+{
+   int i,s,vsize;
+   
+   XFormKind xKind = xfinfo->outXKind;
+   IntVec *xformBlockSize     = xfinfo->xformBlockSize;
+   IntVec *mllrMeanBlockSize  = xfinfo->mllrMeanBlockSize;
+   IntVec *mllrCovBlockSize   = xfinfo->mllrCovBlockSize;
+   IntVec *cmllrBlockSize     = xfinfo->cmllrBlockSize;
+   IntVec *xformBandWidth     = xfinfo->xformBandWidth;
+   IntVec *mllrMeanBandWidth  = xfinfo->mllrMeanBandWidth;
+   IntVec *mllrCovBandWidth   = xfinfo->mllrCovBandWidth;
+   IntVec *cmllrBandWidth     = xfinfo->cmllrBandWidth;
+   Vector xformSplitThresh    = xfinfo->xformSplitThresh;
+   Vector mllrMeanSplitThresh = xfinfo->mllrMeanSplitThresh;
+   Vector mllrCovSplitThresh  = xfinfo->mllrCovSplitThresh;
+   Vector cmllrSplitThresh    = xfinfo->cmllrSplitThresh;
+      
+   /* check block size */
+   for (s=1; s<=hset->swidth[0]; s++) {
+      if (xformBlockSize[s] != NULL) {
+         vsize = 0;
+         for (i=1; i<=IntVecSize(xformBlockSize[s]); i++)
+            vsize += xformBlockSize[s][i];
+         if (vsize!=hset->swidth[s])
+            HError(9999,"CheckAdaptSetup: %d-th stream width (%d) and transform size (%d) is inconsistent",s,hset->swidth[s],vsize);
+      }
+      else {
+         switch(xKind) {
+         case MLLRMEAN:
+            if (mllrMeanBlockSize[s]!=NULL) {
+               vsize = 0;
+               for (i=1; i<=IntVecSize(mllrMeanBlockSize[s]); i++) 
+                  vsize += mllrMeanBlockSize[s][i];
+               if (vsize!=hset->swidth[s])
+                  HError(9999,"CheckAdaptSetup: %d-th stream width (%d) and transform size (%d) is inconsistent",s,hset->swidth[s],vsize);
+            }
+            break;
+         case MLLRCOV:
+            if (mllrCovBlockSize[s]!=NULL) {
+               vsize = 0;
+               for (i=1; i<=IntVecSize(mllrCovBlockSize[s]); i++)
+                  vsize += mllrCovBlockSize[s][i];
+               if (vsize!=hset->swidth[s])
+                  HError(9999,"CheckAdaptSetup: %d-th stream width (%d) and transform size (%d) is inconsistent",s,hset->swidth[s],vsize);
+            }
+            break;
+         case CMLLR:
+            if (cmllrBlockSize[s]!=NULL) {
+               vsize = 0;
+               for (i=1; i<=IntVecSize(cmllrBlockSize[s]); i++)
+                  vsize += cmllrBlockSize[s][i];
+               if (vsize!=hset->swidth[s])
+                  HError(9999,"CheckAdaptSetup: %d-th stream width (%d) and transform size (%d) is inconsistent",s,hset->swidth[s],vsize);
+            }
+            break;
+         case SEMIT:
+         default:
+            break;
+         }
    }
 }
 
-/* ParseConfIntVec: interpret config string as integer array */
-static IntVec ParseConfIntVec(MemHeap *x, char *inbuf)
-{
-   IntVec ivec = NULL;
-   int size,cnt;
-   char buf[MAXSTRLEN],tbuf[MAXSTRLEN];
+   /* check band width */
+   for (s=1; s<=hset->swidth[0]; s++) {
+      if (xformBandWidth[s] != NULL) {
+         for (i=1; i<=IntVecSize(xformBandWidth[s]); i++)
+            if (xformBandWidth[s][i]>xformBlockSize[s][i])
+               HError(9999,"CheckAdaptSetup: band width (%d) at %d-th block in %d-th stream of transform is larger than block size (%d)",
+                      xformBandWidth[s][i],i,s,xformBlockSize[s][i]);
+      }
+      else {
+         switch(xKind) {
+         case MLLRMEAN:
+            if (mllrMeanBlockSize[s]!=NULL) {
+               for (i=1; i<=IntVecSize(mllrMeanBandWidth[s]); i++) 
+                  if (mllrMeanBandWidth[s][i]>mllrMeanBlockSize[s][i])
+                     HError(9999,"CheckAdaptSetup: band width (%d) at %d-th block in %d-th stream of MLLRMEAN transform is larger than block size (%d)",
+                            mllrMeanBandWidth[s][i],i,s,mllrMeanBlockSize[s][i]);
+            }
+            break;
+         case MLLRCOV:
+            if (mllrCovBlockSize[s]!=NULL) {
+               for (i=1; i<=IntVecSize(mllrCovBandWidth[s]); i++) 
+                  if (mllrCovBandWidth[s][i]>mllrCovBlockSize[s][i])
+                     HError(9999,"CheckAdaptSetup: band width (%d) at %d-th block in %d-th stream of MLLRCOV transform is larger than block size (%d)",
+                            mllrCovBandWidth[s][i],i,s,mllrCovBlockSize[s][i]);
+            }
+            break;
+         case CMLLR:
+            if (cmllrBlockSize[s]!=NULL) {
+               for (i=1; i<=IntVecSize(cmllrBandWidth[s]); i++) 
+                  if (cmllrBandWidth[s][i]>cmllrBlockSize[s][i])
+                     HError(9999,"CheckAdaptSetup: band width (%d) at %d-th block in %d-th stream of CMLLR transform is larger than block size (%d)",
+                            cmllrBandWidth[s][i],i,s,cmllrBlockSize[s][i]);
+            }
+            break;
+         case SEMIT:
+         default:
+            break;
+         }
+      }
+   }
 
-   if (sscanf(inbuf,"%s",buf)>0) {
-      if (strcmp(buf,"IntVec") != 0)
-         HError(999,"ParseConfIntVec: format is IntVec d d d ....");
-      inbuf=strstr(inbuf,"IntVec")+strlen("IntVec");
-      sscanf(inbuf,"%d",&size);
-      sprintf(tbuf,"%d",size);
-      inbuf=strstr(inbuf,tbuf)+(int)strlen(tbuf);
-      ivec = CreateIntVec(x,size);
-      cnt = 1;
-      while ((strlen(inbuf)>0) && (cnt<=size) &&
-             (sscanf(inbuf,"%d",&(ivec[cnt])))) {
-         sprintf(tbuf,"%d",ivec[cnt]);
-         inbuf=strstr(inbuf,tbuf)+(int)strlen(tbuf);
-         cnt++;
+   /* check threshold */
+   if (xformSplitThresh==NULL) {
+      xfinfo->xformSplitThresh = xformSplitThresh = CreateVector(&infoStack, hset->swidth[0]);
+      for (s=1; s<=hset->swidth[0]; s++)
+         xformSplitThresh[s] = -1000.0;
       }
-      if (strlen(inbuf)>0)
-         HError(999,"ParseConfIntVec: residual elements - format is  n b1 ... bn");
-   } else 
-      HError(999,"ParseConfIntVec: format is  n b1 ... bn");
-   return ivec;
+   switch (xKind) {
+   case MLLRMEAN: 
+      if (mllrMeanSplitThresh==NULL) {
+         xfinfo->mllrMeanSplitThresh = mllrMeanSplitThresh = CreateVector(&infoStack, hset->swidth[0]);
+         for (s=1; s<=hset->swidth[0]; s++)
+            mllrMeanSplitThresh[s] = 1000.0;
+      }
+      break;
+   case MLLRCOV:
+      if (mllrCovSplitThresh==NULL) {
+         xfinfo->mllrCovSplitThresh = mllrCovSplitThresh = CreateVector(&infoStack, hset->swidth[0]);
+         for (s=1; s<=hset->swidth[0]; s++)
+            mllrCovSplitThresh[s] = 1000.0;
+      }
+      break;
+   case CMLLR:
+      if (cmllrSplitThresh==NULL) {
+         xfinfo->cmllrSplitThresh = cmllrSplitThresh = CreateVector(&infoStack, hset->swidth[0]);
+         for (s=1; s<=hset->swidth[0]; s++)
+            cmllrSplitThresh[s] = 1000.0;
+      }
+      break; 
+   case SEMIT:
+   default:
+      break;
+   }
+   
+   /* check variance flooring scales for semi-tied covariance */
+   if (semiTiedFloorScale==NULL) {
+      semiTiedFloorScale = CreateVector(&infoStack, hset->swidth[0]);
+      for (s=1; s<=hset->swidth[0]; s++)
+         semiTiedFloorScale[s] = 0.1;
+   }
+   
+   return;
+}
+
+/* InitXFInfo: initialise XFInfo */
+static void InitXFInfo (XFInfo *xfinfo)
+{
+   int s;
+
+   xfinfo->outSpkrPat = "*.%%%";
+   xfinfo->inSpkrPat = NULL;
+   xfinfo->paSpkrPat = NULL;
+   xfinfo->outXFormExt = NULL;
+   xfinfo->inXFormExt = NULL;
+   xfinfo->paXFormExt = NULL;
+   xfinfo->al_inXFormExt = NULL;
+   xfinfo->al_paXFormExt = NULL;
+   xfinfo->outXFormDir = NULL;
+   xfinfo->paXFormDir = NULL;
+   xfinfo->al_inXFormDir = NULL;
+   xfinfo->al_paXFormDir = NULL;
+   xfinfo->useOutXForm = FALSE;
+   xfinfo->useInXForm = FALSE;
+   xfinfo->usePaXForm = FALSE;
+   xfinfo->use_alInXForm = FALSE;
+   xfinfo->use_alPaXForm = FALSE;
+   xfinfo->outFullC = FALSE;
+   xfinfo->inFullC  = FALSE;
+   xfinfo->xformTMF = NULL;
+   xfinfo->inXForm = NULL;
+   xfinfo->outXForm = NULL;
+   xfinfo->paXForm = NULL;
+   xfinfo->diagCovXForm = NULL;
+   xfinfo->al_hset = NULL;
+   xfinfo->al_inXForm = NULL;
+   xfinfo->al_paXForm = NULL;
+         
+   xfinfo->useBias = TRUE;
+   xfinfo->outXKind = MLLRMEAN;
+
+   xfinfo->xformSplitThresh    = NULL;
+   xfinfo->mllrMeanSplitThresh = NULL;
+   xfinfo->mllrCovSplitThresh  = NULL;
+   xfinfo->cmllrSplitThresh    = NULL;
+
+   xfinfo->xformAdaptKind    = BASE;
+   xfinfo->mllrMeanAdaptKind = BASE;
+   xfinfo->mllrCovAdaptKind  = BASE;
+   xfinfo->cmllrAdaptKind    = BASE;
+
+   xfinfo->xformRegTree    = NULL;
+   xfinfo->mllrMeanRegTree = NULL;
+   xfinfo->mllrCovRegTree  = NULL;
+   xfinfo->cmllrRegTree    = NULL;
+
+   xfinfo->xformBaseClass    = NULL;
+   xfinfo->mllrMeanBaseClass = NULL;
+   xfinfo->mllrCovBaseClass  = NULL;
+   xfinfo->cmllrBaseClass    = NULL;
+
+   /* initialize blocksize vector and occ threshold for each stream */
+   for (s=0; s<SMAX; s++) {
+      xfinfo->xformBlockSize  [s] = xfinfo->mllrMeanBlockSize[s] = NULL;
+      xfinfo->mllrCovBlockSize[s] = xfinfo->cmllrBlockSize   [s] = NULL;
+      xfinfo->xformBandWidth  [s] = xfinfo->mllrMeanBandWidth[s] = NULL;
+      xfinfo->mllrCovBandWidth[s] = xfinfo->cmllrBandWidth   [s] = NULL;
+   }
+   
+   for (s=0; s<MAXSTRLEN; s++)
+     xfinfo->coutspkr[s] = xfinfo->cinspkr[s] = xfinfo->cpaspkr[s] = '\0';
+   xfinfo->nspkr = 0;
+   
+   xfinfo->baseTriMatTime = -1;
+   xfinfo->headpoc = NULL;
+   xfinfo->headboc = NULL;
+   xfinfo->headac = NULL;
+
+   CreateHeap(&xfinfo->acccaStack,"AccStore", MSTAK, 1, 1.0, 50000, 500000);
+   CreateHeap(&xfinfo->bobcaStack,"baseObsStore", MSTAK, 1, 1.0, 50000, 500000);
+   CreateHeap(&xfinfo->pobcaStack,"parentObsStore", MSTAK, 1, 1.0, 50000, 500000);
 }
 
 /* EXPORT->InitAdapt: initialise configuration parameters */
-void InitAdapt (XFInfo *xfinfo) 
+void InitAdapt (XFInfo *xfinfo_hmm, XFInfo *xfinfo_dur) 
 {
-   int i;
+   int i,s;
    Boolean b;
    double d;
-   char buf[MAXSTRLEN];
+   char *c,buf[MAXSTRLEN],tmp[MAXSTRLEN];
   
    Register(hadapt_version,hadapt_vc_id);
    nParm = GetConfig("HADAPT", TRUE, cParm, MAXGLOBS);
 
    /* setup the local memory management - defaults sensible? */
    CreateHeap(&infoStack,"InfoStore", MSTAK, 1, 1.0, 50000, 500000);
-   CreateHeap(&acccaStack,"AccStore", MSTAK, 1, 1.0, 50000, 500000);
-   CreateHeap(&bobcaStack,"baseObsStore", MSTAK, 1, 1.0, 50000, 500000);
-   CreateHeap(&pobcaStack,"parentObsStore", MSTAK, 1, 1.0, 50000, 500000);
+
+   /* Initialise the XFInfo values */
+   if (xfinfo_hmm!=NULL) InitXFInfo(xfinfo_hmm);
+   if (xfinfo_dur!=NULL) InitXFInfo(xfinfo_dur);
 
    if (nParm>0){
       /* general adaptation config variables */
@@ -346,27 +547,15 @@ void InitAdapt (XFInfo *xfinfo) 
       if (GetConfBool(cParm,nParm,"STOREMINFO",&b)) storeMInfo = b;
       if (GetConfBool(cParm,nParm,"KEEPXFORMDISTINCT",&b)) keepXFormDistinct = b;
       if (GetConfBool(cParm,nParm,"SAVESPKRMODELS",&b)) saveSpkrModels = b;
-      /* Adaptation transformation set-up */
-      if (GetConfBool(cParm,nParm,"USEBIAS",&b)) useBias = b;
-      if (GetConfFlt(cParm,nParm,"SPLITTHRESH",&d)) xformSplitThresh = (float) d;
-      if (GetConfStr (cParm,nParm,"TRANSKIND",buf)) xKind = Str2XFormKind(buf);
-      if (GetConfStr (cParm,nParm,"BLOCKSIZE",buf)) 
-	 xformBlockSize = ParseConfIntVec(&infoStack,buf);
-      if (GetConfStr (cParm,nParm,"BASECLASS",buf)) 
-         xformBaseClass = CopyString(&infoStack,buf);
-      if (GetConfStr (cParm,nParm,"REGTREE",buf)) 
-         xformRegTree = CopyString(&infoStack,buf);
-      if (GetConfStr (cParm,nParm,"ADAPTKIND",buf)) 
-         xformAdaptKind = Str2AdaptKind(buf);
+      
       if (GetConfInt(cParm,nParm,"MAXXFORMITER",&i)) maxXFormIter = i;
       if (GetConfBool(cParm,nParm,"MLLRDIAGCOV",&b)) mllrDiagCov = b;      
       if (GetConfBool(cParm,nParm,"SWAPXFORMS",&b)) swapXForms = b;      
       if (GetConfBool(cParm,nParm,"MLLRCOV2CMLLR",&b)) mllrCov2CMLLR = b; 
-
-      if (GetConfFlt(cParm,nParm,"SEMITIEDFLOOR",&d)) semiTiedFloorScale = (float) d;
+      if (GetConfStr (cParm,nParm,"SEMITIEDFLOOR",buf))
+         semiTiedFloorScale = ParseConfVector(&infoStack,buf,TRUE);
       if (GetConfInt(cParm,nParm,"MAXSEMITIEDITER",&i)) maxSemiTiedIter = i;
-      if (GetConfStr (cParm,nParm,"SEMITIEDMACRO",buf)) 
-         semiTiedMacro = CopyString(&infoStack,buf);
+      if (GetConfStr (cParm,nParm,"SEMITIEDMACRO",buf)) semiTiedMacro = CopyString(&infoStack,buf);
       if (GetConfBool(cParm,nParm,"SEMITIED2INPUTXFORM",&b)) semiTied2InputXForm = b; 
       if (GetConfBool(cParm,nParm,"SEMITIEDVFLOOR",&b)) semiTiedVFloor = b; 
       if (GetConfInt(cParm,nParm,"NUMNUISANCEDIM",&i)) numNuisanceDim = i;
@@ -375,93 +564,318 @@ void InitAdapt (XFInfo *xfinfo) 
       if (GetConfBool(cParm,nParm,"INITNUISANCEFRIDENT",&b)) initNuisanceFRIdent = b; 
       if (GetConfBool(cParm,nParm,"SAVESEMITIEDBINARY",&b)) saveSemiTiedBinary = b; 
 
+      /* Adaptation transformation set-up for HMMs */
+      if (xfinfo_hmm!=NULL) {
+         if (GetConfBool(cParm,nParm,"SAVEFULLC",&b)) xfinfo_hmm->outFullC = b;
+         if (GetConfBool(cParm,nParm,"USESMAP",&b)) useSMAPcriterion = b;
+         if (GetConfBool(cParm,nParm,"SAVEALLSMAPXFORM",&b)) SaveAllSMAPXForms = b;
+         if (GetConfFlt(cParm,nParm,"SMAPSIGMA",&d)) sigmascale = (float) d;
+         if (GetConfBool(cParm,nParm,"USEBIAS",&b)) xfinfo_hmm->useBias = b;
+         if (GetConfStr (cParm,nParm,"SPLITTHRESH",buf)) 
+            xfinfo_hmm->xformSplitThresh = ParseConfVector(&infoStack,buf,TRUE);
+         if (GetConfStr (cParm,nParm,"TRANSKIND",buf)) 
+            xfinfo_hmm->outXKind = Str2XFormKind(buf);
+         if (GetConfStr (cParm,nParm,"BLOCKSIZE",buf)) {
+            for (s=1,c=buf; s<SMAX && c!=NULL; s++) {
+               xfinfo_hmm->xformBlockSize[s] = ParseConfIntVec(&infoStack,c,FALSE);
+               for (i=1; i<=IntVecSize(xfinfo_hmm->xformBlockSize[s])+2; i++) 
+                  c = ParseString(c,tmp);
+               if (ParseString(c,tmp)==NULL)
+                  break;
+            }
+         }
+         if (GetConfStr (cParm,nParm,"BANDWIDTH",buf)) {
+            for (s=1,c=buf; s<SMAX && c!=NULL; s++) {
+               xfinfo_hmm->xformBandWidth[s] = ParseConfIntVec(&infoStack,c,FALSE);
+               for (i=1; i<=IntVecSize(xfinfo_hmm->xformBandWidth[s])+2; i++) 
+                  c = ParseString(c,tmp);
+               if (ParseString(c,tmp)==NULL)
+                  break;
+            }
+         }
+         if (GetConfStr (cParm,nParm,"BASECLASS",buf)) 
+            xfinfo_hmm->xformBaseClass = CopyString(&infoStack,buf);
+         if (GetConfStr (cParm,nParm,"REGTREE",buf)) 
+            xfinfo_hmm->xformRegTree = CopyString(&infoStack,buf);
+         if (GetConfStr (cParm,nParm,"ADAPTKIND",buf)) 
+            xfinfo_hmm->xformAdaptKind = Str2AdaptKind(buf);
+         
       /* Backward compatibility with old configuration options */
       /* MLLRMEAN specification */
-      if (GetConfFlt(cParm,nParm,"MLLRMEANSPLITTHRESH",&d)) mllrMeanSplitThresh = (float) d;
-      if (GetConfStr (cParm,nParm,"MLLRMEANBLOCKSIZE",buf)) 
-         mllrMeanBlockSize = ParseConfIntVec(&infoStack,buf);
+         if (GetConfStr (cParm,nParm,"MLLRMEANSPLITTHRESH",buf)) 
+            xfinfo_hmm->mllrMeanSplitThresh = ParseConfVector(&infoStack,buf,TRUE);
+         if (GetConfStr (cParm,nParm,"MLLRMEANBLOCKSIZE",buf)) {
+            for (s=1,c=buf; s<SMAX && c!=NULL; s++) {
+               xfinfo_hmm->mllrMeanBlockSize[s] = ParseConfIntVec(&infoStack,c,FALSE);
+               for (i=1; i<=IntVecSize(xfinfo_hmm->mllrMeanBlockSize[s])+2; i++) 
+                  c = ParseString(c,tmp);
+               if (ParseString(c,tmp)==NULL)
+                  break;
+            }
+         }
+         if (GetConfStr (cParm,nParm,"MLLRMEANBANDWIDTH",buf)) {
+            for (s=1,c=buf; s<SMAX && c!=NULL; s++) {
+               xfinfo_hmm->mllrMeanBandWidth[s] = ParseConfIntVec(&infoStack,c,FALSE);
+               for (i=1; i<=IntVecSize(xfinfo_hmm->mllrMeanBandWidth[s])+2; i++) 
+                  c = ParseString(c,tmp);
+               if (ParseString(c,tmp)==NULL)
+                  break;
+            }
+         }
       if (GetConfStr (cParm,nParm,"MLLRMEANBASECLASS",buf)) 
-         mllrMeanBaseClass = CopyString(&infoStack,buf);
+            xfinfo_hmm->mllrMeanBaseClass = CopyString(&infoStack,buf);
       if (GetConfStr (cParm,nParm,"MLLRMEANREGTREE",buf)) 
-         mllrMeanRegTree = CopyString(&infoStack,buf);
+            xfinfo_hmm->mllrMeanRegTree = CopyString(&infoStack,buf);
       if (GetConfStr (cParm,nParm,"MLLRMEANADAPTKIND",buf)) 
-         mllrMeanAdaptKind = Str2AdaptKind(buf);
+            xfinfo_hmm->mllrMeanAdaptKind = Str2AdaptKind(buf);
       /* MLLRCOV specification */      
-      if (GetConfFlt(cParm,nParm,"MLLRCOVSPLITTHRESH",&d)) mllrCovSplitThresh = (float) d;
-      if (GetConfStr (cParm,nParm,"MLLRCOVBLOCKSIZE",buf)) 
-         mllrCovBlockSize = ParseConfIntVec(&infoStack,buf);
+         if (GetConfStr (cParm,nParm,"MLLRCOVSPLITTHRESH",buf))
+            xfinfo_hmm->mllrCovSplitThresh = ParseConfVector(&infoStack,buf,TRUE);
+         if (GetConfStr (cParm,nParm,"MLLRCOVBLOCKSIZE",buf)) {
+            for (s=1,c=buf; s<SMAX && c!=NULL; s++) {
+               xfinfo_hmm->mllrCovBlockSize[s] = ParseConfIntVec(&infoStack,c,FALSE);
+               for (i=1; i<=IntVecSize(xfinfo_hmm->mllrCovBlockSize[s])+2; i++) 
+                  c = ParseString(c,tmp);
+               if (ParseString(c,tmp)==NULL)
+                  break;
+            }
+         }
+         if (GetConfStr (cParm,nParm,"MLLRCOVBANDWIDTH",buf)) {
+            for (s=1,c=buf; s<SMAX && c!=NULL; s++) {
+               xfinfo_hmm->mllrCovBandWidth[s] = ParseConfIntVec(&infoStack,c,FALSE);
+               for (i=1; i<=IntVecSize(xfinfo_hmm->mllrCovBandWidth[s])+2; i++) 
+                  c = ParseString(c,tmp);
+               if (ParseString(c,tmp)==NULL)
+                  break;
+            }
+         }
       if (GetConfStr (cParm,nParm,"MLLRCOVBASECLASS",buf)) 
-         mllrCovBaseClass = CopyString(&infoStack,buf);
+            xfinfo_hmm->mllrCovBaseClass = CopyString(&infoStack,buf);
       if (GetConfStr (cParm,nParm,"MLLRCOVREGTREE",buf)) 
-         mllrCovRegTree = CopyString(&infoStack,buf);
+            xfinfo_hmm->mllrCovRegTree = CopyString(&infoStack,buf);
       if (GetConfStr (cParm,nParm,"MLLRCOVADAPTKIND",buf)) 
-         mllrCovAdaptKind = Str2AdaptKind(buf);
+            xfinfo_hmm->mllrCovAdaptKind = Str2AdaptKind(buf);
       /* CMLLR specification */
-      if (GetConfFlt(cParm,nParm,"CMLLRSPLITTHRESH",&d)) cmllrSplitThresh = (float) d;
-      if (GetConfStr (cParm,nParm,"CMLLRBLOCKSIZE",buf))
-         cmllrBlockSize = ParseConfIntVec(&infoStack,buf);
+         if (GetConfStr (cParm,nParm,"CMLLRSPLITTHRESH",buf))
+            xfinfo_hmm->cmllrSplitThresh = ParseConfVector(&infoStack,buf,TRUE);
+         if (GetConfStr (cParm,nParm,"CMLLRBLOCKSIZE",buf)) {
+            for (s=1,c=buf; s<SMAX && c!=NULL; s++) {
+               xfinfo_hmm->cmllrBlockSize[s] = ParseConfIntVec(&infoStack,c,FALSE);
+               for (i=1; i<=IntVecSize(xfinfo_hmm->cmllrBlockSize[s])+2; i++) 
+                  c = ParseString(c,tmp);
+               if (ParseString(c,tmp)==NULL)
+                  break;
+            }
+         }
+         if (GetConfStr (cParm,nParm,"CMLLRBANDWIDTH",buf)) {
+            for (s=1,c=buf; s<SMAX && c!=NULL; s++) {
+               xfinfo_hmm->cmllrBandWidth[s] = ParseConfIntVec(&infoStack,c,FALSE);
+               for (i=1; i<=IntVecSize(xfinfo_hmm->cmllrBandWidth[s])+2; i++) 
+                  c = ParseString(c,tmp);
+               if (ParseString(c,tmp)==NULL)
+                  break;
+            }
+         }
       if (GetConfStr (cParm,nParm,"CMLLRBASECLASS",buf))
-         cmllrBaseClass = CopyString(&infoStack,buf);
+            xfinfo_hmm->cmllrBaseClass = CopyString(&infoStack,buf);
       if (GetConfStr (cParm,nParm,"CMLLRREGTREE",buf))
-         cmllrRegTree = CopyString(&infoStack,buf);
+            xfinfo_hmm->cmllrRegTree = CopyString(&infoStack,buf);
       if (GetConfStr (cParm,nParm,"CMLLRADAPTKIND",buf))
-         cmllrAdaptKind = Str2AdaptKind(buf);
+            xfinfo_hmm->cmllrAdaptKind = Str2AdaptKind(buf);
+         
+         CheckAdaptOptions(xfinfo_hmm);
    }
 
-   /* Initialise the XFInfo values */
-   xfinfo->outSpkrPat = "*.%%%";
-   xfinfo->inSpkrPat = NULL;
-   xfinfo->paSpkrPat = NULL;
-   xfinfo->outXFormExt = NULL;
-   xfinfo->inXFormExt = NULL;
-   xfinfo->paXFormExt = NULL;
-   xfinfo->outXFormDir = NULL;
-   xfinfo->paXFormDir = NULL;
-   xfinfo->useOutXForm = FALSE;
-   xfinfo->useInXForm = FALSE;
-   xfinfo->usePaXForm = FALSE;
-   xfinfo->xformTMF = NULL;
-   xfinfo->inXForm = NULL;
-   xfinfo->outXForm = NULL;
-   xfinfo->paXForm = NULL;
-   xfinfo->al_hset = NULL;
-   xfinfo->alXFormExt = NULL;
-   xfinfo->alXFormDir = NULL;
-   CheckAdaptOptions();
+      /* Adaptation transformation set-up for duration models */
+      if (xfinfo_dur!=NULL) {
+         if (GetConfBool(cParm,nParm,"DURUSEBIAS",&b)) xfinfo_dur->useBias = b;
+         if (GetConfStr (cParm,nParm,"DURSPLITTHRESH",buf)) 
+            xfinfo_dur->xformSplitThresh = ParseConfVector(&infoStack,buf,TRUE);
+         if (GetConfStr (cParm,nParm,"DURTRANSKIND",buf)) 
+            xfinfo_dur->outXKind = Str2XFormKind(buf);
+         if (GetConfStr (cParm,nParm,"DURBLOCKSIZE",buf)) {
+            for (s=1,c=buf; s<SMAX && c!=NULL; s++) {
+               xfinfo_dur->xformBlockSize[s] = ParseConfIntVec(&infoStack,c,FALSE);
+               for (i=1; i<=IntVecSize(xfinfo_dur->xformBlockSize[s])+2; i++) 
+                  c = ParseString(c,tmp);
+               if (ParseString(c,tmp)==NULL)
+                  break;
+            }
+         }
+         if (GetConfStr (cParm,nParm,"DURBANDWIDTH",buf)) {
+            for (s=1,c=buf; s<SMAX && c!=NULL; s++) {
+               xfinfo_dur->xformBandWidth[s] = ParseConfIntVec(&infoStack,c,FALSE);
+               for (i=1; i<=IntVecSize(xfinfo_dur->xformBandWidth[s])+2; i++) 
+                  c = ParseString(c,tmp);
+               if (ParseString(c,tmp)==NULL)
+                  break;
+            }
+         }
+         if (GetConfStr (cParm,nParm,"DURBASECLASS",buf)) 
+            xfinfo_dur->xformBaseClass = CopyString(&infoStack,buf);
+         if (GetConfStr (cParm,nParm,"DURREGTREE",buf)) 
+            xfinfo_dur->xformRegTree = CopyString(&infoStack,buf);
+         if (GetConfStr (cParm,nParm,"DURADAPTKIND",buf)) 
+            xfinfo_dur->xformAdaptKind = Str2AdaptKind(buf);
+
+         /* Backward compatibility with old configuration options */
+         /* MLLRMEAN specification */
+         if (GetConfStr (cParm,nParm,"DURMLLRMEANSPLITTHRESH",buf)) 
+            xfinfo_dur->mllrMeanSplitThresh = ParseConfVector(&infoStack,buf,TRUE);
+         if (GetConfStr (cParm,nParm,"DURMLLRMEANBLOCKSIZE",buf)) {
+            for (s=1,c=buf; s<SMAX && c!=NULL; s++) {
+               xfinfo_dur->mllrMeanBlockSize[s] = ParseConfIntVec(&infoStack,c,FALSE);
+               for (i=1; i<=IntVecSize(xfinfo_dur->mllrMeanBlockSize[s])+2; i++) 
+                  c = ParseString(c,tmp);
+               if (ParseString(c,tmp)==NULL)
+                  break;
+            }
+         }
+         if (GetConfStr (cParm,nParm,"DURMLLRMEANBANDWIDTH",buf)) {
+            for (s=1,c=buf; s<SMAX && c!=NULL; s++) {
+               xfinfo_dur->mllrMeanBandWidth[s] = ParseConfIntVec(&infoStack,c,FALSE);
+               for (i=1; i<=IntVecSize(xfinfo_dur->mllrMeanBandWidth[s])+2; i++) 
+                  c = ParseString(c,tmp);
+               if (ParseString(c,tmp)==NULL)
+                  break;
+            }
+         }
+         if (GetConfStr (cParm,nParm,"DURMLLRMEANBASECLASS",buf)) 
+            xfinfo_dur->mllrMeanBaseClass = CopyString(&infoStack,buf);
+         if (GetConfStr (cParm,nParm,"DURMLLRMEANREGTREE",buf)) 
+            xfinfo_dur->mllrMeanRegTree = CopyString(&infoStack,buf);
+         if (GetConfStr (cParm,nParm,"DURMLLRMEANADAPTKIND",buf)) 
+            xfinfo_dur->mllrMeanAdaptKind = Str2AdaptKind(buf);
+         /* MLLRCOV specification */      
+         if (GetConfStr (cParm,nParm,"DURMLLRCOVSPLITTHRESH",buf))
+            xfinfo_dur->mllrCovSplitThresh = ParseConfVector(&infoStack,buf,TRUE);
+         if (GetConfStr (cParm,nParm,"DURMLLRCOVBLOCKSIZE",buf)) {
+            for (s=1,c=buf; s<SMAX && c!=NULL; s++) {
+               xfinfo_dur->mllrCovBlockSize[s] = ParseConfIntVec(&infoStack,c,FALSE);
+               for (i=1; i<=IntVecSize(xfinfo_dur->mllrCovBlockSize[s])+2; i++) 
+                  c = ParseString(c,tmp);
+               if (ParseString(c,tmp)==NULL)
+                  break;
+            }
+         }
+         if (GetConfStr (cParm,nParm,"DURMLLRCOVBANDWIDTH",buf)) {
+            for (s=1,c=buf; s<SMAX && c!=NULL; s++) {
+               xfinfo_dur->mllrCovBandWidth[s] = ParseConfIntVec(&infoStack,c,FALSE);
+               for (i=1; i<=IntVecSize(xfinfo_dur->mllrCovBandWidth[s])+2; i++) 
+                  c = ParseString(c,tmp);
+               if (ParseString(c,tmp)==NULL)
+                  break;
+            }
+         }
+         if (GetConfStr (cParm,nParm,"DURMLLRCOVBASECLASS",buf)) 
+            xfinfo_dur->mllrCovBaseClass = CopyString(&infoStack,buf);
+         if (GetConfStr (cParm,nParm,"DURMLLRCOVREGTREE",buf)) 
+            xfinfo_dur->mllrCovRegTree = CopyString(&infoStack,buf);
+         if (GetConfStr (cParm,nParm,"DURMLLRCOVADAPTKIND",buf)) 
+            xfinfo_dur->mllrCovAdaptKind = Str2AdaptKind(buf);
+         /* CMLLR specification */
+         if (GetConfStr (cParm,nParm,"DURCMLLRSPLITTHRESH",buf))
+            xfinfo_dur->cmllrSplitThresh = ParseConfVector(&infoStack,buf,TRUE);
+         if (GetConfStr (cParm,nParm,"DURCMLLRBLOCKSIZE",buf)) {
+            for (s=1,c=buf; s<SMAX && c!=NULL; s++) {
+               xfinfo_dur->cmllrBlockSize[s] = ParseConfIntVec(&infoStack,c,FALSE);
+               for (i=1; i<=IntVecSize(xfinfo_dur->cmllrBlockSize[s])+2; i++) 
+                  c = ParseString(c,tmp);
+               if (ParseString(c,tmp)==NULL)
+                  break;
+            }
+         }
+         if (GetConfStr (cParm,nParm,"DURCMLLRBANDWIDTH",buf)) {
+            for (s=1,c=buf; s<SMAX && c!=NULL; s++) {
+               xfinfo_dur->cmllrBandWidth[s] = ParseConfIntVec(&infoStack,c,FALSE);
+               for (i=1; i<=IntVecSize(xfinfo_dur->cmllrBandWidth[s])+2; i++) 
+                  c = ParseString(c,tmp);
+               if (ParseString(c,tmp)==NULL)
+                  break;
+            }
+         }
+         if (GetConfStr (cParm,nParm,"DURCMLLRBASECLASS",buf))
+            xfinfo_dur->cmllrBaseClass = CopyString(&infoStack,buf);
+         if (GetConfStr (cParm,nParm,"DURCMLLRREGTREE",buf))
+            xfinfo_dur->cmllrRegTree = CopyString(&infoStack,buf);
+         if (GetConfStr (cParm,nParm,"DURCMLLRADAPTKIND",buf))
+            xfinfo_dur->cmllrAdaptKind = Str2AdaptKind(buf);
+         
+         CheckAdaptOptions(xfinfo_dur);
+      }
+   }
+}
+
+/* EXPORT->ResetAdapt: reset adaptation module */
+void ResetAdapt (XFInfo *xfinfo_hmm, XFInfo *xfinfo_dur) 
+{
+   ResetHeap(&infoStack);
+   if (xfinfo_hmm!=NULL) {
+      ResetHeap(&xfinfo_hmm->acccaStack);
+      ResetHeap(&xfinfo_hmm->bobcaStack);
+      ResetHeap(&xfinfo_hmm->pobcaStack);
+   }
+   if (xfinfo_dur!=NULL) {
+      ResetHeap(&xfinfo_dur->acccaStack);
+      ResetHeap(&xfinfo_dur->bobcaStack);
+      ResetHeap(&xfinfo_dur->pobcaStack);
+   }
+   
+   return;
 }
 
 /* Additional code to parse configs to for appropriate thresholds */
 
-static float GetSplitThresh(AdaptXForm *xform)
+static float GetSplitThresh(XFInfo *xfinfo, float *thresh)
 {
-   float thresh=0.0;
+   int s;
+   float min=0.0;
 
-   if (xformSplitThresh > 0) {
-     thresh = xformSplitThresh;
-   } else {
+   AdaptXForm *xform          = xfinfo->outXForm;
+   Vector xformSplitThresh    = xfinfo->xformSplitThresh;
+   Vector mllrMeanSplitThresh = xfinfo->mllrMeanSplitThresh;
+   Vector mllrCovSplitThresh  = xfinfo->mllrCovSplitThresh;
+   Vector cmllrSplitThresh    = xfinfo->cmllrSplitThresh;
+
+   for (s=1; s<=xform->hset->swidth[0]; s++) {
+      thresh[s] = 0.0;
+      if (xformSplitThresh[s] > 0.0) {
+         thresh[s] = xformSplitThresh[s];
+      } 
+      else {
      switch(xform->xformSet->xkind) {
      case MLLRMEAN:
-       thresh = mllrMeanSplitThresh;
+            thresh[s] = mllrMeanSplitThresh[s];
        break;
      case MLLRCOV:
-       thresh = mllrCovSplitThresh;
+            thresh[s] = mllrCovSplitThresh[s];
        break;
      case CMLLR:
-       thresh = cmllrSplitThresh;
+            thresh[s] = cmllrSplitThresh[s];
        break;
      }
    }
-   return thresh;
+      if (thresh[s]<min)
+         min = thresh[s];
+   }
+
+   return min;
 }
 
-static AdaptKind GetAdaptKind(AdaptXForm *xform)
+static AdaptKind GetAdaptKind(XFInfo *xfinfo)
 {
    AdaptKind akind = BASE;
 
+   AdaptKind xformAdaptKind    = xfinfo->xformAdaptKind;
+   AdaptKind mllrMeanAdaptKind = xfinfo->mllrMeanAdaptKind;
+   AdaptKind mllrCovAdaptKind  = xfinfo->mllrCovAdaptKind;
+   AdaptKind cmllrAdaptKind    = xfinfo->cmllrAdaptKind;
+
    if (xformAdaptKind != BASE) {
      akind = xformAdaptKind;
-   } else {
-     switch(xform->xformSet->xkind) {
+   } 
+   else {
+      switch(xfinfo->outXKind) {
      case MLLRMEAN:
        akind = mllrMeanAdaptKind;
        break;
@@ -476,14 +890,21 @@ static AdaptKind GetAdaptKind(AdaptXForm
    return akind;
 }
 
-static RegTree* GetRegTree(HMMSet *hset, AdaptXForm *xform)
+static RegTree* GetRegTree(HMMSet *hset, XFInfo *xfinfo)
 {
    char* basename = NULL;
    char macroname[MAXSTRLEN];
 
+   AdaptXForm *xform     = xfinfo->outXForm;
+   char *xformRegTree    = xfinfo->xformRegTree;
+   char *mllrMeanRegTree = xfinfo->mllrMeanRegTree;
+   char *mllrCovRegTree  = xfinfo->mllrCovRegTree;
+   char *cmllrRegTree    = xfinfo->cmllrRegTree;
+   
    if (xformRegTree != NULL) {
      basename = xformRegTree;
-   } else {
+   } 
+   else {
      switch(xform->xformSet->xkind) {
      case MLLRMEAN:
        basename = mllrMeanRegTree;
@@ -497,20 +918,27 @@ static RegTree* GetRegTree(HMMSet *hset,
      }
    }
    if (basename == NULL) {
-      /* must have specified a regression class tree with TREE adapt kind */
-      HError(999, "GetRegTree: No regression tree macro name specified\n");
+      HError(9999, "GetRegTree: No regression tree macro name specified\n");
+      return NULL;
    } 
    return LoadRegTree(hset,NameOf(basename,macroname),basename);  
 }
 
-static BaseClass* GetBaseClass(HMMSet *hset,AdaptXForm *xform)
+static BaseClass* GetBaseClass(HMMSet *hset, XFInfo *xfinfo)
 {
    char* basename = NULL;
    char macroname[MAXSTRLEN];
 
+   AdaptXForm *xform       = xfinfo->outXForm;
+   char *xformBaseClass    = xfinfo->xformBaseClass;
+   char *mllrMeanBaseClass = xfinfo->mllrMeanBaseClass;
+   char *mllrCovBaseClass  = xfinfo->mllrCovBaseClass;
+   char *cmllrBaseClass    = xfinfo->cmllrBaseClass;
+   
    if (xformBaseClass != NULL) {
      basename = xformBaseClass;
-   } else {
+   } 
+   else {
      switch(xform->xformSet->xkind) {
      case MLLRMEAN:
        basename = mllrMeanBaseClass;
@@ -531,7 +959,7 @@ static BaseClass* GetBaseClass(HMMSet *h
    return LoadBaseClass(hset,NameOf(basename,macroname),basename);
 }
 
-static int GetVecSizeClass(BaseClass *bclass, int class)
+static int GetBaseClassVSize(BaseClass *bclass, const int class)
 {
    ILink i;
    MixtureElem *me;
@@ -542,22 +970,36 @@ static int GetVecSizeClass(BaseClass *bc
    return VectorSize(me->mpdf->mean);
 }
 
-static IntVec GetBlockSize(AdaptXForm *xform, int class)
+/* GetBlockSize: return block size vector for given xform */
+static IntVec GetBlockSize(XFInfo *xfinfo, const int b)
 {
    IntVec blockSize = NULL;
+   int s;
 
-   if (xformBlockSize != NULL) {
-     blockSize = xformBlockSize;
-   } else {
+   AdaptXForm *xform = xfinfo->outXForm;
+   IntVec *xformBlockSize    = xfinfo->xformBlockSize;
+   IntVec *mllrMeanBlockSize = xfinfo->mllrMeanBlockSize;
+   IntVec *mllrCovBlockSize  = xfinfo->mllrCovBlockSize;
+   IntVec *cmllrBlockSize    = xfinfo->cmllrBlockSize;
+   
+   /* stream index */
+   s = xform->bclass->stream[b];
+   
+   if (xformBlockSize[s] != NULL) {
+      blockSize = xformBlockSize[s];
+   } 
+   else {
      switch(xform->xformSet->xkind) {
      case MLLRMEAN:
-       blockSize = mllrMeanBlockSize;
+         blockSize = mllrMeanBlockSize[s];
        break;
      case MLLRCOV:
-       blockSize = mllrCovBlockSize;
+         blockSize = mllrCovBlockSize[s];
        break;
      case CMLLR:
-       blockSize = cmllrBlockSize;
+         blockSize = cmllrBlockSize[s];
+         break;
+      default:
        break;
      }
    }
@@ -566,13 +1008,56 @@ static IntVec GetBlockSize(AdaptXForm *x
          HError(-1,"For stream projection only full transform used");
       blockSize = CreateIntVec(xform->mem,1);
       blockSize[1] = xform->hset->vecSize;
-   } else if (blockSize == NULL) {    
+   }
+   else if (blockSize == NULL) {
       blockSize = CreateIntVec(xform->mem,1);
-      blockSize[1] = GetVecSizeClass(xform->bclass,class);
+      blockSize[1] = GetBaseClassVSize(xform->bclass,b);
    }
    return blockSize;  
 }
 
+/* GetBandWidth: return band width vector for given transform */
+static IntVec GetBandWidth(XFInfo *xfinfo, const int b, IntVec blockSize)
+{
+   IntVec bandWidth = NULL;
+   int i,s;
+   
+   AdaptXForm *xform         = xfinfo->outXForm;
+   IntVec *xformBandWidth    = xfinfo->xformBandWidth;
+   IntVec *mllrMeanBandWidth = xfinfo->mllrMeanBandWidth;
+   IntVec *mllrCovBandWidth  = xfinfo->mllrCovBandWidth;
+   IntVec *cmllrBandWidth    = xfinfo->cmllrBandWidth;
+   
+   /* stream index */
+   s = xform->bclass->stream[b];
+   
+   if (xformBandWidth[s] != NULL) {
+      bandWidth = xformBandWidth[s];
+   } 
+   else {
+      switch(xform->xformSet->xkind) {
+      case MLLRMEAN:
+         bandWidth = mllrMeanBandWidth[s];
+         break;
+      case MLLRCOV:
+         bandWidth = mllrCovBandWidth[s];
+         break;
+      case CMLLR:
+         bandWidth = cmllrBandWidth[s];
+         break;
+      default:
+         break;
+      }
+   }
+   if (bandWidth == NULL) {
+      bandWidth = CreateIntVec(xform->mem,IntVecSize(blockSize));
+      for (i=1; i<=IntVecSize(blockSize); i++)
+         bandWidth[i] = blockSize[i];
+   }
+
+   return bandWidth;  
+}
+
 /*------------------------------------------------------------------------*/
 /*                      Internal Structure Support                        */
 /*------------------------------------------------------------------------*/
@@ -636,29 +1120,34 @@ static MInfo *CreateMInfo(MemHeap *x, Mi
       xf = xf->parentXForm;
    }
    if (adaptMean) {
-      mi->mean = CreateVector(x,size);
+      mi->mean = CreateSVector(x,size);
       CopyVector(mp->mean,mi->mean);
-   } else 
+   } 
+   else 
       mi->mean = NULL;
    if (adaptCov) {
       switch(mp->ckind){
       case DIAGC:
       case INVDIAGC:
-         mi->cov.var = CreateVector(x,size);
+         mi->cov.var = CreateSVector(x,size);
          CopyVector(mp->cov.var,mi->cov.var);
          mi->gConst = mp->gConst;
+         mi->ckind  = mp->ckind;
          break;
       default:
-         HError(999,"AccMixPDFStats: bad ckind %d",mp->ckind);
+         HError(999,"CreateMInfo: bad ckind %d",mp->ckind);
       }
-   } else {
+   } 
+   else {
       switch(mp->ckind){
       case DIAGC:
       case INVDIAGC:
          mi->cov.var = NULL;
+         mi->gConst = 0.0;
+         mi->ckind = NULLC;
          break;
       default:
-         HError(999,"AccMixPDFStats: bad ckind %d",mp->ckind);
+         HError(999,"CreateMInfo: bad ckind %d",mp->ckind);
       }
    }
    return mi;
@@ -760,7 +1249,7 @@ static void UpdateMInfo(HMMSet *hset, Ad
                   mi = GetMInfo(mp);
                   if ((adaptMean) && (mi->mean == NULL)) {
 		     size = VectorSize(mp->mean);
-                     mi->mean = CreateVector(hset->hmem,size);
+                     mi->mean = CreateSVector(hset->hmem,size);
                      CopyVector(mp->mean,mi->mean);
                      nMInfo++;
                   } 
@@ -770,9 +1259,10 @@ static void UpdateMInfo(HMMSet *hset, Ad
                      case INVDIAGC:
                         if (mi->cov.var == NULL) {
 			   size = VectorSize(mp->mean);
-                           mi->cov.var = CreateVector(hset->hmem,size);
+                           mi->cov.var = CreateSVector(hset->hmem,size);
                            CopyVector(mp->cov.var,mi->cov.var);
                            mi->gConst = mp->gConst;
+                           mi->ckind  = mp->ckind; 
                         }
                         break;
                      default:
@@ -805,7 +1295,7 @@ static XFormInfo *CreateXFormInfo(MemHea
    return info;
 }
 
-static void AttachXFormInfo(HMMSet *hset)
+void AttachXFormInfo(HMMSet *hset)
 {
    HMMScanState hss;
    MixPDF *mp;
@@ -883,7 +1373,8 @@ static void SetAInfo(HMMSet *hset, Adapt
                      ((XFormInfo *)mp->info)->paInfo = ai = (AInfo *)New(&infoStack,sizeof(AInfo));
                   else ((XFormInfo *)mp->info)->aInfo = ai = (AInfo *)New(&infoStack,sizeof(AInfo));
                   nAInfo++;
-               } else if (nlevel>1) { 
+               } 
+               else if (nlevel>1) { 
                   /* go the end of the chain and add adaptation info, but not at the first level */
                   /* a fix to tidy memory at this stage is required */
                   while (ai->next != NULL) ai=ai->next;
@@ -895,7 +1386,8 @@ static void SetAInfo(HMMSet *hset, Adapt
          }
          xf = xf->parentXForm;
       }
-   } else { /* This may be called during a reset so set all the ai's to NULL */
+   }
+   else { /* This may be called during a reset so set all the ai's to NULL */
       HMMScanState hss;
       NewHMMScan(hset,&hss);
       do {
@@ -921,179 +1413,178 @@ static void ResetComp(MixPDF *mp)
 
    mi = GetMInfo(mp); 
    if ( mi != NULL) { /* Initial model parameters have been stored */
+      /* copy original mean */
       if (mi->mean != NULL) CopyVector(mi->mean,mp->mean);
-      switch (mp->ckind) {
+      
+      if (mi->cov.var != NULL) {
+         /* transformed variance is stored in FULLC form */
+         if (mp->ckind==FULLC)
+            mp->cov.var = (SVector) GetHook(mp->cov.inv);
+                  
+         /* copy original var */
+         switch (mi->ckind) {
       case DIAGC:
       case INVDIAGC:
-         if (mi->cov.var != NULL) {
+         case FULLC:
             CopyVector(mi->cov.var,mp->cov.var);
             mp->gConst = mi->gConst;
-         }
+            mp->ckind  = mi->ckind;
          break;
       default:
-         HError(999,"ResetComp: bad ckind %d",mp->ckind);
+            HError(999,"ResetComp: bad ckind %d",mi->ckind);
+         }
       }
    } 
 }
 
-static TriMat *CreateBlockTriMat(MemHeap *x, IntVec blockSize)
+static DTriMat *CreateBlockTriMat(MemHeap *x, IntVec blockSize)
 {
-  TriMat *tm;
-  int nblock, bsize, b, *i;
+   DTriMat *tm;
+   int nblock, bsize, b;
+   long *i;
   
   nblock = IntVecSize(blockSize);
-  tm = (TriMat *)New(x,sizeof(TriMat)*(nblock+1));  
-  i = (int *)tm; *i = nblock;
+   tm = (DTriMat *)New(x,sizeof(DTriMat)*(nblock+1));  
+   i = (long *) tm; *i = (long) nblock;
   for (b=1;b<=nblock;b++) {
     bsize = blockSize[b];
-    tm[b] = CreateTriMat(x, bsize); 
-    ZeroTriMat(tm[b]);
+      tm[b] = CreateDTriMat(x, bsize); 
+      ZeroDTriMat(tm[b]);
   }
   return(tm);
 }
 
-static void ZeroBlockTriMat(TriMat *bTriMat)
+static void ZeroBlockTriMat(DTriMat *bTriMat)
 {
-  int *nblock,b;
+  int b;
+  long *nblock;
 
-  nblock = (int *)bTriMat;
+  nblock = (long *) bTriMat;
   for (b=1; b<=*nblock; b++)
-      ZeroTriMat(bTriMat[b]);  
+     ZeroDTriMat(bTriMat[b]);
 }
 
-static void ZeroBaseTriMat(TriMat *bTriMat)
+static void ZeroBaseTriMat(DTriMat *bTriMat)
 {
   int i;
-  int *vsize;
-  TriMat tm;
+   long *vsize;
+   DTriMat tm;
  
-  vsize = (int *)bTriMat;
+   vsize = (long *) bTriMat;
   for (i=1;i<=*vsize;i++) {
     tm = bTriMat[i];
-    ZeroTriMat(tm);
+      ZeroDTriMat(tm);
   }  
 }
 
-static void CreateBaseTriMat(MemHeap *x, MixPDF *mp, AdaptXForm *xform, int class)
+static void CreateBaseTriMat(XFInfo *xfinfo, MemHeap *x, MixPDF *mp, int class)
 {
-  TriMat *tm;
+   DTriMat *tm;
   int vsize = VectorSize(mp->mean);
-  IntVec blockSize = GetBlockSize(xform,class);
+   IntVec blockSize = GetBlockSize(xfinfo,class);
   RegAcc *regAcc, *ra;
   MixPDF *me;
   BaseClass *bclass;
   ILink i;
-  int j, cntj, *vsp, b, bsize;
+   int j, cntj, b, bsize;
+   long *vsp;
+   AdaptXForm *xform = xfinfo->outXForm;
 
   regAcc = GetRegAcc(mp);
-  if (xform->info->accBTriMat) { 
+   if (vsize>0 && xform->info->accBTriMat) { 
+      /* create BaseTriMat and attach it to RegAcc */
     regAcc->bVector =  CreateDVector(x,vsize);
     ZeroDVector(regAcc->bVector);
-    regAcc->obsVec =  CreateVector(x,vsize);
-    ZeroVector(regAcc->obsVec);
     regAcc->bDiagMat = CreateBlockTriMat(x,blockSize); 
     ZeroBlockTriMat(regAcc->bDiagMat);
-    tm = (TriMat *)New(x,sizeof(TriMat)*(vsize+1));
-    vsp = (int *)tm; *vsp = vsize;
+      tm = (DTriMat *)New(x,sizeof(DTriMat)*(vsize+1));
+      vsp = (long *) tm; *vsp = (long) vsize;
     for (b=1,cntj=1;b<=IntVecSize(blockSize);b++) {
       bsize = blockSize[b];
       for (j=1;j<=bsize;j++,cntj++) {
-	tm[cntj] =  CreateTriMat(x, bsize);  
-	ZeroTriMat(tm[cntj]);
+            tm[cntj] =  CreateDTriMat(x, bsize);  
+            ZeroDTriMat(tm[cntj]);
       }
     }
     regAcc->bTriMat = tm;    
-  } else regAcc->bTriMat = NULL; 
 
+      /* link BaseTriMat to models in the same class */
   bclass = xform->bclass;
   for (i=bclass->ilist[class]; i!=NULL; i=i->next) { 
-    if (xform->info->accBTriMat) {
       me = ((MixtureElem *)i->item)->mpdf;
       if( me != mp ) {
         ra = GetRegAcc(me);
         ra->bVector = regAcc->bVector;
         ra->bDiagMat = regAcc->bDiagMat;
         ra->bTriMat = regAcc->bTriMat;
-        ra->obsVec = regAcc->obsVec;
       }
-    } else regAcc->bTriMat = NULL;
+      }
   }      
 }
 
-void SetBaseAccsTime(int t)
+void SetBaseAccsTime(XFInfo *xfinfo, const int t)
 {
-   baseTriMatTime = t;
+   xfinfo->baseTriMatTime = t;
 }
 
 
 void UpdateAccCache(double Lr, Vector svec, MixPDF *mp)
 {
    AccCache *paac;
-   TriMat m;
-   int vsize = VectorSize(svec);
+   DTriMat m;
+   int vsize = VectorSize(mp->mean);
    Vector covar;
-   int i, j, bl, bstart, nblock, bsize; 
+   int i, j, bstart, bsize;
+   long bl, nblock;
 
    paac = GetPAAccCache(mp);    
-   if ( paac != NULL ) {
-      /* This needs to be altered so that it does not rely on a non-zero first element */
-      if ( paac->bTriMat[1][1][1] == 0 ) {
-	nblock = (int)(paac->bTriMat[0]);
+   if (paac==NULL) return;
+   if ((paac->bTriMat!=NULL) && (paac->bVector[1]==0.0) && (svec!=NULL)) {
+      nblock = (long)(paac->bTriMat[0]);
 	for (bl=1,bstart=0;bl<=nblock;bl++) {
 	  m = paac->bTriMat[bl];
-	  bsize = TriMatSize(m);
+         bsize = DTriMatSize(m);
 	  for (i=1;i<=bsize;i++) { /* Fill the accumulate stores */
 	    for (j=1; j<=i; j++)
 		m[i][j] = svec[i+bstart] * svec[j+bstart];
 	  }
 	  bstart += bsize;
 	}
-      }
       covar = mp->cov.var;
       for (i=1;i<=vsize;i++) {
          if (mp->ckind==INVDIAGC)
-            paac->bVector[i] += covar[i]*Lr;
+           paac->bVector[i] += Lr * (double) covar[i];
          else
-            paac->bVector[i] += Lr/covar[i];
+           paac->bVector[i] += Lr / (double) covar[i];
       }
    }
 }
 
-void UpdateBaseAccs(Vector svec)
+void UpdateBaseAccs(XFInfo *xfinfo, Vector svec, const int t, RegAcc *regAcc)
 {
-   int i,j,b,k, bsize, nblock, bl;
+   int i,j,k,b,bsize;
+   long nblock, bl;
    int cnt, cnti, cntj;
-   TriMat tm, m;
+   DTriMat tm, m;
    RegAcc *ra;
    DVector acc;
-   Vector ovec;
    BaseClass *bclass;
    MixPDF *mp;
+   AdaptXForm *outXForm = xfinfo->outXForm;
    
+   /* store statistics */
+   if (t != xfinfo->baseTriMatTime) {
    bclass = outXForm->bclass;
+#pragma omp parallel for private(mp,ra,acc,nblock,bl,cnti,m,bsize,i,tm,j,k)
    for (b=1;b<=bclass->numClasses;b++) {
       mp = ((MixtureElem *)(bclass->ilist[b])->item)->mpdf;
       ra = GetRegAcc(mp);
-      if ((ra->bTriMat != NULL) && (ra->bVector[1]>0)) {    
+         if ((ra->bTriMat!=NULL) && (ra->bVector[1]>0.0)) {    
          acc = ra->bVector;
-         nblock = (int)(ra->bDiagMat[0]);
-
-         /* generate the outer-product */
-         /* moved to here for speed with large numbers of baseclasses */
-         ovec = ra->obsVec;
-         for (bl=1, cnt=1; bl<=nblock;bl++){
-            bsize = TriMatSize(ra->bDiagMat[bl]);
-            m = ra->bDiagMat[bl];
-            for (i=1, cnti=cnt; i<=bsize; i++,cnti++) { /* Fill the outer product */
-               for (j=1,cntj=cnt; j<=i; j++,cntj++)
-                  m[i][j] = ovec[cnti]*ovec[cntj];
-            }
-            cnt +=bsize;
-         }
-
+            nblock = (long)(ra->bDiagMat[0]);
     for (bl=1,cnti=1;bl<=nblock;bl++) {
       m = ra->bDiagMat[bl];
-      bsize = TriMatSize(m);
+               bsize = DTriMatSize(m);
       for (i=1;i<=bsize;i++,cnti++) { /* Fill the accumulate stores */
         tm = ra->bTriMat[cnti];
         for (j=1; j<=bsize; j++)
@@ -1103,40 +1594,50 @@ void UpdateBaseAccs(Vector svec)
          }
          ZeroDVector(ra->bVector);
       }
-      /* now update the observation cache */
-      if (svec != NULL) {
-         for (i=1;i<=VectorSize(svec);i++)
-            ra->obsVec[i] = svec[i];
-      }
    }
 }
 
+   if (regAcc==NULL) return;
+   if ((regAcc->bTriMat!=NULL) && (regAcc->bVector[1]==0.0) && (svec!=NULL)) {
+      nblock = (long)(regAcc->bDiagMat[0]);
+      for (bl=1,cnt=1; bl<=nblock; bl++) {
+         bsize = DTriMatSize(regAcc->bDiagMat[bl]);
+         m = regAcc->bDiagMat[bl];
+         for (i=1,cnti=cnt; i<=bsize; i++,cnti++) {
+            for (j=1,cntj=cnt; j<=i; j++,cntj++)
+               m[i][j] = svec[cnti]*svec[cntj];
+         }
+         cnt +=bsize;
+      }
+   }
+}
 
-void UpdateBaseAccsWithPaac(void)
+void UpdateBaseAccsWithPaac(XFInfo *xfinfo, const int t)
 {
-   int i,j,k, b, bsize, nblock, bl;
+   int i,j,k,b,bsize;
+   long nblock, bl;
    int cnti;
-   TriMat tm, m;
+   DTriMat tm, m;
    RegAcc *ra;
    DVector acc;
    BaseClass *bclass;
    MixPDF *mp;
    AccCache *paac;
+   AdaptXForm *outXForm = xfinfo->outXForm;
 
+   /* store statistics */
+   if (t != xfinfo->baseTriMatTime) {
    bclass = outXForm->bclass;
-
-   for (b=1;b<=bclass->numClasses;b++) {
+      for (b=bclass->numClasses;b>0;b--) {
       mp = ((MixtureElem *)(bclass->ilist[b])->item)->mpdf;
+         paac = ((XFormInfo *)mp->info)->paac;
       ra = GetRegAcc(mp);
-
-      if ( ra->bTriMat != NULL) {
-        for (paac = headac; paac!= NULL; paac=paac->next) { 
-          if ( (paac->baseclass == b)&& (paac->bVector[1]>0) ){
+         if ((ra->bTriMat!=NULL) && (paac->bVector[1]>0.0)) {
             acc = paac->bVector;
-            nblock = (int)(ra->bDiagMat[0]);
+            nblock = (long)(ra->bDiagMat[0]);
             for (bl=1,cnti=1;bl<=nblock;bl++) {
               m = paac->bTriMat[bl];
-              bsize = TriMatSize(m);
+               bsize = DTriMatSize(m);
               for (i=1;i<=bsize;i++,cnti++) { /* Fill the accumulate stores */
                 tm = ra->bTriMat[cnti];
                 for (j=1; j<=bsize; j++)
@@ -1148,16 +1649,16 @@ void UpdateBaseAccsWithPaac(void)
         }
       }
    }  
-}
 
-void ResetAccCache(void)
+void ResetAccCache(XFInfo *xfinfo, const int t)
 {
    AccCache *ac;
  
-   if ( headac != NULL) {
-      for (ac = headac; ac!= NULL; ac=ac->next) {
+   if (t != xfinfo->baseTriMatTime) {
+      if (xfinfo->headac != NULL) {
+         for (ac=xfinfo->headac; ac!=NULL; ac=ac->next) {
         ZeroDVector(ac->bVector);
-        ZeroBlockTriMat(ac->bTriMat);
+         }
       }
    }
 }
@@ -1176,59 +1677,65 @@ static Boolean XFormModCovar(AdaptXForm 
   return isModified;
 }
 
-static void AccBaseTriMat(HMMSet *hset, double Lr, Vector svec, MixPDF *mp, int t)
+static void AccBaseTriMat(XFInfo *xfinfo, double Lr, Vector svec, MixPDF *mp, int t)
 {
    int vsize, i;
-   /* TriMat m; */
    Vector covar;
    RegAcc *regAcc;
    Boolean resetMixPDF = FALSE;
+   AdaptXForm *xform = xfinfo->outXForm;
+   HMMSet *hset;
   
+   if (xform != NULL) {
+      hset = xform->hset;
    if (((hset->parentXForm == NULL) && (hset->curXForm == NULL) ) || (hset->parentXForm == hset->curXForm))  {
       /* There's nothing to be done as model set the same */
       resetMixPDF = FALSE;
-   } else if (hset->parentXForm == NULL) {
+      }
+      else if (hset->parentXForm == NULL) {
       /* xform to be built on original parameters */
       /* reset the models if the inputXForm alters the variances */
-      if(covarChanged){
+         if(xfinfo->covarChanged){
 	      ResetComp(mp);
          resetMixPDF = TRUE;
       }
-   } else {
+      }
+      else {
       /* xform to be built on a parent xform */
-      if (covarPChanged || covarChanged){
-         ApplyCompXForm(mp,hset->parentXForm);
+         if (xfinfo->covarPChanged || xfinfo->covarChanged){
+            ApplyCompXForm(mp,hset->parentXForm,FALSE);
          resetMixPDF = TRUE;
       }
    }
+   }
    
    regAcc = GetRegAcc(mp);
    covar = mp->cov.var;
-   vsize = VectorSize(svec);
+   vsize = VectorSize(mp->mean);
 
-   if (t != baseTriMatTime) {
      /* Check to see whether this is the very first frame */
-     if (headac == NULL ) 
-       UpdateBaseAccs(svec);
+   if (xfinfo->headac==NULL) 
+      UpdateBaseAccs(xfinfo,svec,t,regAcc);
      else  {
-       UpdateBaseAccsWithPaac(); 
-       ResetAccCache();   
-     }
-     SetBaseAccsTime(t);
+      UpdateBaseAccsWithPaac(xfinfo,t); 
+      ResetAccCache(xfinfo,t);   
    }
+   SetBaseAccsTime(xfinfo,t);
 
-   if  (headac == NULL) {    
+   if  (xfinfo->headac==NULL) {    
      for (i=1;i<=vsize;i++) {
        if (mp->ckind==INVDIAGC)
-	 regAcc->bVector[i] += covar[i]*Lr;
+            regAcc->bVector[i] += Lr * (double) covar[i];
        else
-	 regAcc->bVector[i] += Lr/covar[i];
+            regAcc->bVector[i] += Lr / (double) covar[i];
      }
-   } else
+   } 
+   else  
      UpdateAccCache( Lr, svec, mp);
 
    if (resetMixPDF) {
-     ApplyCompXForm(mp,hset->curXForm);
+      hset = xform->hset;
+      ApplyCompXForm(mp,hset->curXForm,FALSE);
    }
 }
 
@@ -1238,25 +1745,32 @@ static RegAcc *CreateRegAcc(MemHeap *x, 
   int vsize = VectorSize(mp->mean);
   
   regAcc = (RegAcc *)New(x,sizeof(RegAcc));
-  regAcc->occ = 0;
+   regAcc->occ = 0.0;
   if (xform->info->accSum) {
-    regAcc->spSum = CreateVector(x,vsize);
-    ZeroVector(regAcc->spSum);
-  } else regAcc->spSum = NULL;
+      regAcc->spSum = CreateDVector(x,vsize);
+      ZeroDVector(regAcc->spSum);
+   } 
+   else regAcc->spSum = NULL;
   if (xform->info->accSumSq) {
-    regAcc->spSumSq = CreateVector(x,vsize);
-    ZeroVector(regAcc->spSumSq);
-  } else regAcc->spSumSq = NULL;
+      regAcc->spSumSq = CreateDVector(x,vsize);
+      ZeroDVector(regAcc->spSumSq);
+   } 
+   else regAcc->spSumSq = NULL;
+
   regAcc->bTriMat = NULL;   
+   regAcc->bDiagMat = NULL;
+   regAcc->bVector = NULL;   
+
   return regAcc;
 }
 
-static void AttachRegAccs(HMMSet *hset, AdaptXForm *xform)
+static void AttachRegAccs(HMMSet *hset, XFInfo *xfinfo)
 {  
   MixPDF *mp = NULL;
   int nRegAcc=0, b;
   BaseClass *bclass;
   ILink i;
+   AdaptXForm *xform = xfinfo->outXForm;
 
   /* RegAccs stored on the Info structure */
   if (!hset->attXFormInfo) AttachXFormInfo(hset);
@@ -1267,8 +1781,9 @@ static void AttachRegAccs(HMMSet *hset, 
       ((XFormInfo *)(mp->info))->regAcc = (RegAcc *)CreateRegAcc(hset->hmem,mp,xform);
       nRegAcc++;   
     }
+
     /* Use last component of the baseclass to access baseclass stats */
-    CreateBaseTriMat(hset->hmem,mp,xform,b); 
+      CreateBaseTriMat(xfinfo,hset->hmem,mp,b); 
   }
 
   if (trace&T_ACC) printf("Attached %d RegAcc structures\n",nRegAcc);
@@ -1277,17 +1792,22 @@ static void AttachRegAccs(HMMSet *hset, 
 
 /* --------------- handling the AccStruct structure ------------------ */
 
-static AccStruct *CreateAccStruct(MemHeap *x, AdaptXForm *xform, 
-				  int vsize, IntVec blockSize)
+static AccStruct *CreateAccStruct(MemHeap *x, XFInfo *xfinfo, int vsize, 
+                                  IntVec blockSize, IntVec bandWidth)
 {
   AccStruct *accs;
   int dim,i,cnti;
   int b,bsize; 
 
+   Boolean useBias = xfinfo->useBias;
+   AdaptXForm *xform = xfinfo->outXForm;
+
   accs = (AccStruct *)New(x,sizeof(AccStruct));
-  accs->occ = 0;
+   accs->occ = 0.0;
   accs->dim = vsize;
+   accs->useBias = useBias;
   accs->blockSize = blockSize;
+   accs->bandWidth = bandWidth;
   accs->K = NULL;
   accs->G = NULL;
   accs->D = NULL;
@@ -1332,14 +1852,16 @@ static AccStruct *CreateAccStruct(MemHea
           accs->G[i] = CreateDMatrix(x,vsize,vsize);
           ZeroDMatrix(accs->G[i]);
        }
-    } else {
+      } 
+      else {
        for (b=1,cnti=1;b<=IntVecSize(blockSize);b++) {
           bsize = blockSize[b];
           for (i=1;i<=bsize;i++,cnti++) {
              if ((staticSemiTied) && (b>1)){ 
                 /* link all accumulates into one */
                 accs->G[cnti] = accs->G[i];
-             } else {
+               } 
+               else {
                 accs->G[cnti] = CreateDMatrix(x,bsize,bsize);
                 ZeroDMatrix(accs->G[cnti]);
              }
@@ -1379,13 +1900,13 @@ static void SetSemiTiedAvCov(HMMSet *hse
 {
    HMMScanState hss;
    StateInfo *si   ;
-   StreamElem *ste;
+   StreamInfo *sti;
    MixPDF *mp;
    STriMat inv;
    DVector mean;
    DMatrix *mat, *smat, cov;
-   DVector *svec;
-   double occAcc, occ, tmp; 
+   DVector *svec,occAcc;
+   double occ, tmp;
    int k,kk,s,S;
    MuAcc *ma;
    VaAcc *va;
@@ -1396,36 +1917,47 @@ static void SetSemiTiedAvCov(HMMSet *hse
    mat = (DMatrix *)New(&gstack,(S+1)*sizeof(DMatrix));
    smat = (DMatrix *)New(&gstack,(S+1)*sizeof(DMatrix));
    svec = (DVector *)New(&gstack,(S+1)*sizeof(DVector));
+   occAcc = CreateDVector(&gstack, S);
    avCov = (TriMat *)New(hset->hmem,(S+1)*sizeof(TriMat));
+
    for (s=1;s<=S;s++) {
-      if (strmProj) vsize = hset->vecSize;
-      else vsize = hset->swidth[s];
+      if (strmProj) 
+         vsize = hset->vecSize;
+      else 
+         vsize = hset->swidth[s];
+           
       mat[s] = CreateDMatrix(&gstack,vsize,vsize);
       smat[s] = CreateDMatrix(&gstack,vsize,vsize);
       svec[s] = CreateDVector(&gstack,vsize);
-      /* create on HMMSet memory heap */
-      avCov[s] = CreateTriMat(hset->hmem,vsize);
+      avCov[s] = CreateTriMat(hset->hmem,vsize);  /* create on HMMSet memory heap */
       ZeroDMatrix(mat[s]);
    }
+   ZeroDVector(occAcc);
+   
    NewHMMScan(hset,&hss);
-   occAcc = 0.0;
    while(GoNextState(&hss,FALSE)) {
       si = hss.si;
       while (GoNextStream(&hss,TRUE)) {
          s = hss.s;
-         if (strmProj) vsize = hset->vecSize;
-         else vsize = hset->swidth[s];
          cov = smat[s]; ZeroDMatrix(cov);
          mean = svec[s]; ZeroDVector(mean);
-         ste = hss.ste; 
+         sti = hss.sti;
          occ = 0;
          for (m=1; m<= hss.M; m++) {
-            mp = ste->spdf.cpdf[m].mpdf;
+            mp = sti->spdf.cpdf[m].mpdf;
+            if (strmProj) 
+               vsize = hset->vecSize;
+            else 
+               vsize = VectorSize(mp->mean);
+               
+            if (vsize==hset->swidth[s]) {  /* MSD check */
             ma = (MuAcc *)GetHook(mp->mean);
             va = (VaAcc *)GetHook(mp->cov.var);
+               if (ma==NULL || va==NULL)
+                  HError(9999,"SetSemiTiedAvCov: mean/variance accumulators are NULL");
             if (fabs(ma->occ-va->occ) > 0.1)
                HError(999,"State-clustered systems only for semitied updates");
-            if (va->occ > 0) {
+               if (va->occ > 0.0) {
                inv = va->cov.inv;
                occ += va->occ;
                for (k=1;k<=vsize;k++) { 
@@ -1435,15 +1967,16 @@ static void SetSemiTiedAvCov(HMMSet *hse
                }
             }
          }
+         }
          /* accumulate in */
-         if (occ > 0) {
-            for (k=1;k<=vsize;k++) { 
+         if (occ > 0.0) {
+            for (k=1; k<=DVectorSize(mean); k++) {
                tmp = mean[k]/occ;
                for (kk=1;kk<=k;kk++) 
                   mat[s][k][kk] += cov[k][kk] - tmp*mean[kk];
             }
          }
-         occAcc += occ;
+         occAcc[s] += occ;
       }
    }
    EndHMMScan(&hss);
@@ -1454,7 +1987,7 @@ static void SetSemiTiedAvCov(HMMSet *hse
       else vsize = hset->swidth[s];
       for (k=1;k<=vsize;k++)
          for (kk=1;kk<=k;kk++)
-            avCov[s][k][kk] = mat[s][k][kk]/occAcc;
+            avCov[s][k][kk] = mat[s][k][kk]/occAcc[s];
    }
    Dispose(&gstack,mat);
 }
@@ -1486,7 +2019,7 @@ static void FixSemiTiedStats(HMMSet *hse
                      fix the statistics to be zero-mean out-product 
                   */
                   va = (VaAcc *) GetHook(mp->cov.var);
-                  if (va->occ>0) {
+                  if (va->occ>0.0) {
                      ma = (MuAcc *) GetHook(mp->mean);
                      inv = va->cov.inv;
                      mu = ma->mu;
@@ -1507,113 +2041,212 @@ static void FixSemiTiedStats(HMMSet *hse
 /*                       Regression Tree Parsing                          */
 /*------------------------------------------------------------------------*/
 
-static float SetNodeOcc(RegNode *node, BaseClass *bclass)
+static double SetNodeOcc (RegNode *node, BaseClass *bclass)
 {
-   int c;
+   int c, b, stream, vsize;
    ILink i;
    MixPDF *mp=NULL;
-   int dim,b;
+   double occ;
 
-   node->nodeOcc = 0;
+   node->nodeOcc = 0.0;
    if (node->numChild>0) {
       for (c=1;c<=node->numChild;c++) {
-         /* Check dimensionality of children is consistent */
-         node->nodeOcc += SetNodeOcc(node->child[c],bclass);
-         dim = (node->child[c])->vsize;
-         if (node->vsize>0) {
-            if (dim != node->vsize)
-               HError(999,"Inconsistent dimensions in baseclasses (%d %d)",dim,node->vsize);
-         } else 
-            node->vsize = dim;
+         /* Check vector sizes of child nodes are consistent */
+         occ = SetNodeOcc(node->child[c], bclass);
+         stream = (node->child[c])->stream;
+         vsize  = (node->child[c])->vsize;
+         
+         /* check consistency of stream and vector size */
+         if ( ((node->stream>-1) && (stream != node->stream)) || 
+              ((node->vsize >-1) && (vsize  != node->vsize )) )
+            node->valid = FALSE;
+         else {
+            node->stream = stream;
+            node->vsize  = vsize;
+            node->nodeOcc += occ;
       }
-   } else {
+      }
+   } 
+   else {
       for (b=1;b<=IntVecSize(node->baseClasses);b++) {
+         node->stream = bclass->stream[node->baseClasses[b]];
          for (i=bclass->ilist[node->baseClasses[b]]; i!=NULL; i=i->next) {
             mp = ((MixtureElem *)i->item)->mpdf;
-            node->nodeOcc += GetRegAcc(mp)->occ;
+
+            /* Baseclass definition ensures that vector sizes are correct within a baseclass */
+            vsize = VectorSize(mp->mean);
+            if (node->vsize>-1) {
+               if (vsize != node->vsize)
+                  HError(999,"Inconsistent vector size in baseclasses (%d %d)", vsize, node->vsize);
          }
-         /* Baseclass definition ensures that dimensions are correct within a baseclass */
-         dim = VectorSize(mp->mean);
-         if (node->vsize>0) {
-            if (dim != node->vsize)
-               HError(999,"Inconsistent dimensions in baseclasses (%d %d)",dim,node->vsize);
-         } else 
-            node->vsize = dim;
+            else
+                node->vsize = vsize;
+
+            node->nodeOcc += (GetRegAcc(mp))->occ;
       }
    }
+   }
+
    return node->nodeOcc;
 }
 
-static Boolean ParseNode(RegNode *node, AdaptXForm *xform, 
-			 RegTree *rtree, IntVec classes)
+
+static void SearchLeafNodes (RegNode *node, IntVec classes)
+{
+   int b,c;
+   
+   if (node->numChild>0) { /* Not a terminal node */
+     for (c=1;c<=node->numChild;c++)
+       SearchLeafNodes(node->child[c], classes);
+   } 
+   else { /* Mark baseclasses for adaptation */
+     for (b=1;b<=IntVecSize(node->baseClasses);b++) 
+       classes[node->baseClasses[b]] = 1;
+   }
+}
+
+
+static Boolean ParseNode (XFInfo *xfinfo, RegNode *node,  
+                          RegTree *rtree, IntVec classes, int xfindex)
 {
-   int b,c,size;
+   int b,c,size,parentxfindex=0;
    Boolean genXForm;
    IntVec lclasses;
 
-   void GenXForm(RegNode *node, AdaptXForm *xform, IntVec classes);  
+   Boolean GenXForm(RegNode *node, XFInfo *xfinfo, IntVec classes, int xfindex);
 
    genXForm = FALSE;
-   if (trace&T_TRE) printf("Node %d (%f)\n",node->nodeIndex,node->nodeOcc);
-   if (node->nodeOcc > rtree->thresh) {
+   if (trace&T_TRE) printf("Node %d (stream=%d, vsize=%d, occ=%f)\n",
+                           node->nodeIndex,node->stream,node->vsize,node->nodeOcc);
+
+   if(useSMAPcriterion){
+
+     if (node->nodeOcc > rtree->thresh[node->stream]) {
+       size = IntVecSize(classes);
+       lclasses = CreateIntVec(&gstack,size); /* temporal */
+       ZeroIntVec(lclasses);
+       SearchLeafNodes(node, lclasses);
+       if (trace&T_TRE) 
+         printf("Prior Transform index: %d\n",xfindex);
+       if(GenXForm(node,xfinfo,lclasses,xfindex)){
+         parentxfindex = xfinfo->outXForm->xformSet->numXForms;
+       }
+       FreeIntVec(&gstack,lclasses);
+     } 
+     if (node->numChild>0) { /* Not a terminal node */
+       for (c=1;c<=node->numChild;c++)
+         ParseNode(xfinfo, node->child[c], rtree, classes, parentxfindex);
+     } 
+     genXForm = TRUE;
+
+   }else{
+
+     if (node->nodeOcc > rtree->thresh[node->stream]) {
       size = IntVecSize(classes);
       lclasses = CreateIntVec(&gstack,IntVecSize(classes));
       ZeroIntVec(lclasses);
       if (node->numChild>0) { /* Not a terminal node */
          for (c=1;c<=node->numChild;c++)
-            if (ParseNode(node->child[c], xform, rtree, lclasses)) genXForm = TRUE;
+           if (ParseNode(xfinfo, node->child[c], rtree, lclasses, xfindex)) genXForm = TRUE;
          /* any of the children need a xform generate it */
-         if (genXForm) GenXForm(node,xform,lclasses);
-      } else { /* Generate xform for this node */
+         if (genXForm) GenXForm(node,xfinfo,lclasses,xfindex);
+       } 
+       else { /* Generate xform for this node */
          for (b=1;b<=IntVecSize(node->baseClasses);b++) lclasses[node->baseClasses[b]] = 1;
-         GenXForm(node,xform,lclasses);
+         GenXForm(node,xfinfo,lclasses,xfindex);
       }
       FreeIntVec(&gstack,lclasses);
       genXForm = FALSE;
-   } else {
+     } 
+     else {
       if (node->numChild>0) { /* Not a terminal node */
          for (c=1;c<=node->numChild;c++)
-            ParseNode(node->child[c], xform, rtree, classes);
-      } else { /* Mark baseclasses for adaptation */
+           ParseNode(xfinfo, node->child[c], rtree, classes, xfindex);
+       } 
+       else { /* Mark baseclasses for adaptation */
          for (b=1;b<=IntVecSize(node->baseClasses);b++) classes[node->baseClasses[b]] = 1;
       }
       genXForm = TRUE;
    }
+   }
+
    return genXForm;
 }
 
-static Boolean ParseTree(RegTree *rtree, AdaptXForm *xform)
+static void SearchOutputXforms(AdaptXForm *xform)
+{
+
+  int i, b, numxforms=0;
+  Boolean USEXFORM = FALSE;
+  LinXForm **outxforms;
+  IntVec outassign=NULL;
+
+  outxforms = (LinXForm **)New(xform->mem,(xform->bclass->numClasses+1)*sizeof(LinXForm *));
+   if (HardAssign(xform)) {
+     outassign = CreateIntVec(xform->mem,xform->bclass->numClasses);
+     ZeroIntVec(outassign);
+   }
+   else 
+      HError(999,"Not currently supported");
+
+  for (i=1;i<=xform->xformSet->numXForms;i++) {
+    USEXFORM = FALSE;
+    for (b=1;b<=xform->bclass->numClasses;b++) {
+      if (HardAssign(xform)){
+        if(xform->xformWgts.assign[b] == i)
+          USEXFORM = TRUE;
+      }
+      else 
+        HError(999,"Not currently supported");
+    }
+    if(USEXFORM){
+      numxforms++;
+      outxforms[numxforms] = CopyLinXForm(xform->mem,xform->xformSet->xforms[i]); 
+      for (b=1;b<=xform->bclass->numClasses;b++) {
+        if (HardAssign(xform)){
+          if(xform->xformWgts.assign[b] == i)
+            outassign[b] = numxforms;
+        }
+        else 
+          HError(999,"Not currently supported");
+      }
+    }
+  }
+  
+  CopyIntVec(outassign, xform->xformWgts.assign);
+  xform->xformSet->numXForms = numxforms;
+  xform->xformSet->xforms = NULL;
+  xform->xformSet->xforms = outxforms;
+  
+}
+
+static Boolean ParseTree (XFInfo *xfinfo)
 {
-   int c;
    IntVec classes;
-   float occ;
+   double occ,minthresh;
+   
+   AdaptXForm *xform = xfinfo->outXForm;
+   RegTree *rtree = xform->rtree;
 
    /* First set the correct threshold for this tree */
-   rtree->thresh = GetSplitThresh(xform);
+   minthresh = GetSplitThresh(xfinfo,rtree->thresh);
    occ = SetNodeOcc(rtree->root, rtree->bclass);
-   if (!(rtree->valid)) { /* multiple streams being used */
-      /* the total number of observations will be given by the roots child */
-      /* should be approximately the same for all children */
-      occ = rtree->root->child[1]->nodeOcc;
-   }
-   if (occ<rtree->thresh) /* not enough data to generate transforms */
+
+   if (occ<minthresh) /* not enough data to generate transforms */
       return FALSE;
    /* reset the number of transforms */
    xform->xformSet->numXForms = 0;
    if (xform->xformSet->xkind == SEMIT) 
       HError(999,"No support for semi-tied transforms with regression class trees");
    classes = CreateIntVec(&gstack,rtree->bclass->numClasses);
-   if (rtree->valid) { /* dimensionality of all transforms the same */
-      ZeroIntVec(classes);
-      ParseNode(rtree->root, xform, rtree, classes);
-   } else {
-      for (c=1;c<=rtree->root->numChild;c++) {
+
          ZeroIntVec(classes);
-         ParseNode(rtree->root->child[c], xform, rtree, classes);
-      }
-   }
+   ParseNode(xfinfo, rtree->root, rtree, classes, 0);
    FreeIntVec(&gstack,classes);
 
+   if(useSMAPcriterion && (!SaveAllSMAPXForms))
+     SearchOutputXforms(xform);
+
    if (xform->xformSet->numXForms == 0) return FALSE;
    else return TRUE;
 }
@@ -1650,9 +2283,13 @@ static void AccCMLLRBaseStats(MixPDF *mp
   RegAcc *ra;
   int i,j,k;
   int cnti,b,bsize;
-  TriMat tm;
+   DTriMat tm;
  
   ra = GetRegAcc(mp);
+
+   if (ra->bTriMat==NULL)
+      return;
+
   for (b=1,cnti=1;b<=IntVecSize(accs->blockSize);b++) {
     bsize = accs->blockSize[b];
     for (i=1;i<=bsize;i++,cnti++) {
@@ -1664,20 +2301,25 @@ static void AccCMLLRBaseStats(MixPDF *mp
       }
     }
   }
+   
+   return;
 }
  
+/* AccCMLLRPDFStats: accumulate pdf-dependent statistics to estimate CMLLR transform */
 static void AccCMLLRPDFStats(MixPDF *mp,  AccStruct *accs)
 {
   RegAcc *ra;
   int i,j;
-  float icov=0.0,scale;
+   double icov=0.0,scale;
   int cnt,cnti,cntj,b,bsize;
+   Boolean useBias = accs->useBias;
   Vector mean;
   Covariance cov;
  
   ra = GetRegAcc(mp);
   mean = mp->mean;
   cov = mp->cov;
+   
   for (b=1,cnti=1,cnt=1;b<=IntVecSize(accs->blockSize);b++) {
     bsize = accs->blockSize[b];
     for (i=1;i<=bsize;i++,cnti++) {
@@ -1686,10 +2328,10 @@ static void AccCMLLRPDFStats(MixPDF *mp,
         icov = cov.var[cnti];
         break;
       case DIAGC:
-        icov = 1/cov.var[cnti];
+            icov = 1.0/cov.var[cnti];
         break;
       default:
-        HError(999,"AccMixPDFStats: bad ckind %d",mp->ckind);
+            HError(999,"AccCMLLRPDFStats: bad ckind %d",mp->ckind);
       }
       scale = ra->occ * icov;
       for (j=1,cntj=cnt;j<=bsize;j++,cntj++) {
@@ -1710,8 +2352,9 @@ static void AccMLLRPDFStats(MixPDF *mp, 
 {
    RegAcc *ra;
    int i,j,k;
-   float icov=0.0,scale;
+   double icov=0.0,scale;
    int cnt,cnti,cntj,cntk,b,bsize;
+   Boolean useBias = accs->useBias;
    Vector mean;
    Covariance cov;
 
@@ -1726,10 +2369,10 @@ static void AccMLLRPDFStats(MixPDF *mp, 
             icov = cov.var[cnti]; 
             break;
          case DIAGC:
-            icov = 1/cov.var[cnti]; 
+            icov = 1.0/cov.var[cnti]; 
             break;
          default:
-            HError(999,"AccMixPDFStats: bad ckind %d",mp->ckind);
+            HError(999,"AccMLLRPDFStats: bad ckind %d",mp->ckind);
          }
          scale = ra->occ * icov;
          for (j=1,cntj=cnt;j<=bsize;j++,cntj++) {
@@ -1755,7 +2398,7 @@ static void AccMLLRCOVPDFStats(MixPDF *m
 {
   RegAcc *ra;
   int i,j,k;
-  float icov=0.0,scale, c1, c2, c3;
+   double icov=0.0,scale, c1, c2, c3;
   int cnt,cnti,cntj,cntk,b,bsize;
   Vector mean;
   Covariance cov;
@@ -1774,7 +2417,7 @@ static void AccMLLRCOVPDFStats(MixPDF *m
 	icov = 1/cov.var[cnti]; 
 	break;
       default:
-	HError(999,"AccMixPDFStats: bad ckind %d",mp->ckind);
+            HError(999,"AccMLLRCOVPDFStats: bad ckind %d",mp->ckind);
       }
       scale = ra->occ * icov;
       for (j=1,cntj=cnt;j<=bsize;j++,cntj++) {
@@ -1799,12 +2442,14 @@ static void AccMixPDFStats(HMMSet *hset,
     accs->occ += ra->occ;
     if (((hset->parentXForm == NULL) && (hset->curXForm == NULL) ) || (hset->parentXForm == hset->curXForm))  {
       /* There's nothing to be done as model set the same */
-    } else if (hset->parentXForm == NULL) { 
+      } 
+      else if (hset->parentXForm == NULL) { 
       /* xform to be built on original parameters */
       ResetComp(mp);
-    } else {
+      } 
+      else {
       /* xform to be built on a parent xform */
-      ApplyCompXForm(mp,hset->parentXForm);
+         ApplyCompXForm(mp,hset->parentXForm,FALSE);
     }
     switch (accs->xkind) {
     case MLLRMEAN:
@@ -1834,6 +2479,7 @@ static void AccBaseClassStats(MixPDF *mp
      Accumulate the statistics for the base classes. The 
      parent transforms have been already sorted.
   */
+   
   switch (accs->xkind) {
   case MLLRCOV:
   case CMLLR:
@@ -1845,8 +2491,7 @@ static void AccBaseClassStats(MixPDF *mp
   }
 }
 
-static void AccNodeStats(RegNode *node, AccStruct *accs, 
-			 AdaptXForm *xform, IntVec classes)
+static void AccNodeStats(RegNode *node, AccStruct *accs, AdaptXForm *xform, IntVec classes)
 {
   BaseClass *bclass;
   ILink i;
@@ -1857,7 +2501,8 @@ static void AccNodeStats(RegNode *node, 
   if (node->numChild>0) {
     for (c=1;c<=node->numChild;c++)
       AccNodeStats(node->child[c],accs,xform,classes);
-  } else {
+   } 
+   else {
     bclass = xform->bclass;
     for (b=1;b<=IntVecSize(node->baseClasses);b++) {
       for (i=bclass->ilist[node->baseClasses[b]]; i!=NULL; i=i->next) {
@@ -1865,9 +2510,66 @@ static void AccNodeStats(RegNode *node, 
 	AccMixPDFStats(xform->hset,mp,accs);
       }
       /* Use last component of the baseclass to access baseclass stats */
-      if( AccAdaptBaseTriMat(xform) )  AccBaseClassStats(mp,accs);
+         if (AccAdaptBaseTriMat(xform))  
+            AccBaseClassStats(mp,accs);
+      }
+   }
+}
+
+/* Add SMAP Prior to the accumulates */ 
+static void AddXFPrior(AccStruct *accs, AdaptXForm *xform, int xfindex)
+{
+   int i,j;
+   int cnt,cnti,b,bsize;
+   Boolean useBias = accs->useBias;
+   LinXForm *pxf;
+   XFormSet *xformSet;
+
+   xformSet = xform->xformSet;
+   pxf = xformSet->xforms[xfindex]; 
+   if(IntVecSize(accs->blockSize) != IntVecSize(pxf->blockSize)){
+     HError(999,"AddXFPrior (%d) does not match block number for transform (%d)",
+        IntVecSize(accs->blockSize),IntVecSize(pxf->blockSize));
+   }
+   if(accs->dim != pxf->vecSize){
+     HError(999,"AddXFPrior (%d) does not match vector size for transform (%d)",
+        accs->dim,pxf->vecSize);
+   }
+
+   for (b=1,cnti=1,cnt=1; b<=IntVecSize(accs->blockSize); b++) {
+      bsize = accs->blockSize[b];
+      if(bsize != pxf->blockSize[b]){
+         HError(999,"AddXFPrior (%d) does not match block size for transform (%d)",
+            accs->blockSize[b],pxf->blockSize[b]);
+      }
+      for (i=1; i<=bsize; i++,cnti++) {
+         for (j=1; j<=bsize; j++) {
+            accs->K[cnti][j] += pxf->xform[b][i][j]*sigmascale;
+            accs->G[cnti][j][j] += sigmascale;
+         }
+         if (useBias) {
+            accs->K[cnti][bsize+1] += pxf->bias[cnti]*sigmascale;
+            accs->G[cnti][bsize+1][bsize+1] += sigmascale;
+         }
     }
+      cnt += bsize;
+   }
+}
+
+/* Add Piror to the statistics Currently MLLRMEAN and CMLLR are supported */
+static void AddPrior(AccStruct *accs, AdaptXForm *xform, int xfindex)
+{
+  
+   switch (accs->xkind) {
+   case MLLRMEAN:
+   case CMLLR:
+     AddXFPrior(accs,xform,xfindex);
+     break;
+   default :
+     HError(999,"Transform kind not currently supported");
+     break;
   }
+
 }
 
 /* Feature-Space adaptation */
@@ -1875,48 +2577,52 @@ static void FixDet(LinXForm *xf)
 {
    int ind,nblock;
    double scale, bdet;
-   float det;
+   double det;
  
    nblock = IntVecSize(xf->blockSize);
    if ( nblock == xf->vecSize) {   
-      det=0;
+      det=0.0;
       for (ind=1;ind<=xf->vecSize;ind++) {
          scale = xf->xform[ind][1][1];
          det += log(scale*scale);
       }
-      xf->det = det;
-   } else {   
-      det=0; 
+      xf->det = (float) det;
+   } 
+   else {   
+      det=0.0; 
       for (ind=1;ind<=nblock;ind++) {
          bdet = MatDet(xf->xform[ind]);
          det += 2*log(fabs(bdet));
       }
-      xf->det = det;
+      xf->det = (float) det;
    }
 }
 /*------------------------------------------------------------------------*/
 /*     Accummulator Cache for application of parent XForms                */
 /*------------------------------------------------------------------------*/
-static AccCache  *CreateAccCache(IntVec size,  int b)
+static AccCache *CreateAccCache(XFInfo *xfinfo, const int b)
 {
    AccCache *ac;
+   IntVec size;
    int vsize, bl;
 
+   size = GetBlockSize(xfinfo,b),
+   
    vsize = 0;
    for (bl=1;bl<=IntVecSize(size);bl++) vsize += size[bl];
    
-   ac = (AccCache *)New(&acccaStack,sizeof(AccCache));
+   ac = (AccCache *)New(&xfinfo->acccaStack,sizeof(AccCache));
    ac->baseclass = b;
-   ac->bVector  = CreateDVector(&acccaStack,vsize);
+   ac->bVector  = CreateDVector(&xfinfo->acccaStack,vsize); 
    ZeroDVector(ac->bVector);
-   ac->bTriMat = CreateBlockTriMat(&acccaStack,size);
+   ac->bTriMat = CreateBlockTriMat(&xfinfo->acccaStack,size);    
    ZeroBlockTriMat(ac->bTriMat);
-   ac->next = headac;
-   headac = ac;
+   ac->next = xfinfo->headac;
+   xfinfo->headac = ac;
    return(ac);
 }
 
-static void SetAccCache(AdaptXForm *xform)
+static void SetAccCache(XFInfo *xfinfo)
 {
    MixPDF *mp;
    BaseClass *bclass;
@@ -1930,12 +2636,15 @@ static void SetAccCache(AdaptXForm *xfor
    XFormSet  *xformSet;
    HMMSet *hset;
    
+   AdaptXForm *xform = xfinfo->outXForm;
+   
    if ((xform != NULL) && (AccAdaptBaseTriMat(xform))) {
       hset = xform->hset;
       if (hset->parentXForm != NULL) {
         xform->parentXForm = hset->parentXForm;
         xform->parentXForm->nUse++;
-      } else
+      } 
+      else
         xform->parentXForm = NULL;    
 
       nxflevel = 1; 
@@ -1982,7 +2691,7 @@ static void SetAccCache(AdaptXForm *xfor
                if (nxflevel > 0) {
                   if (ind > 0) { /* support no transform has been generated */
                     if ( ac[ind] == NULL )  {
-                      ac[ind] = CreateAccCache(GetBlockSize(xform,b), b);
+                        ac[ind] = CreateAccCache(xfinfo,b);
                       nCache++;
                     }
                   }
@@ -2002,7 +2711,7 @@ static void SetAccCache(AdaptXForm *xfor
 /*      Observation Cache for application of feature-space transform      */
 /*------------------------------------------------------------------------*/
 
-static ObsCache *CreateObsCache(MemHeap *heap, ObsCache **headoc, int size)
+static ObsCache *CreateObsCache(MemHeap *heap, ObsCache **headoc, const int size)
 {
    ObsCache  *oc;
 
@@ -2019,13 +2728,15 @@ static ObsCache *CreateObsCache(MemHeap 
 }
   
 
-static void SetObsCache(AdaptXForm *xform, Boolean parent)
+static void SetObsCache(XFInfo *xfinfo, AdaptXForm *xform, Boolean parent)
 {
    MixPDF *mp;
    BaseClass *bclass;
-   int b, size, nxflevel = 0, nxfcomb = 1, numXf = 0, nxf, ind, nCache = 0;
+   int b, size, s;
    ILink i;
    ObsCache **headoc, **oc = NULL;
+   int nxflevel = 0, nxfcomb = 1, numXf = 0, nxf, ind;
+   int nCache = 0;
    AInfo *ai;
    AdaptXForm *xf;
    XFormSet *xformSet;
@@ -2034,16 +2745,16 @@ static void SetObsCache(AdaptXForm *xfor
    if (xform != NULL) {
 
     if (parent) {
-      ResetHeap(&pobcaStack);
-      heap = &pobcaStack;
-      headpoc = NULL;
-      headoc = &headpoc;
+        ResetHeap(&xfinfo->pobcaStack);
+        heap = &xfinfo->pobcaStack;
+        xfinfo->headpoc = NULL;
+        headoc = &(xfinfo->headpoc);
     }
     else {
-      ResetHeap(&bobcaStack);
-      heap = &bobcaStack;
-      headboc = NULL;
-      headoc = &headboc;
+        ResetHeap(&xfinfo->bobcaStack);
+        heap = &xfinfo->bobcaStack;
+        xfinfo->headboc = NULL;
+        headoc = &(xfinfo->headboc);
     }
 
     xf = xform;
@@ -2065,6 +2776,7 @@ static void SetObsCache(AdaptXForm *xfor
        
     bclass = xform->bclass;
     for (b = 1; b <= bclass->numClasses; b++) {
+         s = bclass->stream[b];
       for (i=bclass->ilist[b]; i!=NULL; i=i->next) {
    mp = ((MixtureElem *)i->item)->mpdf;
    if (nxflevel  == 0) {
@@ -2072,7 +2784,8 @@ static void SetObsCache(AdaptXForm *xfor
        ((XFormInfo *)mp->info)->paoc = NULL;
      }
      else ((XFormInfo *)mp->info)->oc = NULL;
-   } else {
+            } 
+            else {
      if (parent) ai = GetPAInfo(mp);
      else  ai = GetAInfo(mp);
 
@@ -2093,7 +2806,7 @@ static void SetObsCache(AdaptXForm *xfor
      }   
      if (nxflevel > 0) {
        if (ind > 0) { /* support no transform has been generated */
-         size = VectorSize(mp->mean);
+                     size = xform->hset->swidth[s];
          if ( oc[ind] == NULL )  {
       oc[ind] = CreateObsCache(heap, headoc, size);
       nCache++;
@@ -2101,7 +2814,6 @@ static void SetObsCache(AdaptXForm *xfor
        }
        if (parent) ((XFormInfo *)mp->info)->paoc = oc[ind];
        else ((XFormInfo *)mp->info)->oc = oc[ind];
-                 
      }
    }
       } 
@@ -2115,32 +2827,36 @@ static void SetObsCache(AdaptXForm *xfor
 
 static void UpdateObsCache( ObsCache *oc, Vector svec, LogFloat det, int t)  
 {
+   int i;
 
    if (oc != NULL ) {  
       if (t != oc->time) {
          oc->time = t;
-         CopyVector(svec, oc->obs);
+         for (i=1; i<=VectorSize(oc->obs); i++)
+            oc->obs[i] = (i<=VectorSize(svec)) ? svec[i] : ReturnIgnoreValue();
          oc->det = det;
       } 
    }
 }
 
-void ResetObsCache(void)
+void ResetObsCache(XFInfo *xfinfo)
 {
    ObsCache *oc;
       
-   if ( headboc != NULL) {
-     for (oc = headboc; oc!= NULL; oc=oc->next) {
+   if(xfinfo != NULL){
+      if (xfinfo->headboc!=NULL) {
+         for (oc=xfinfo->headboc; oc!= NULL; oc=oc->next) {
        oc->time = -1;
        ZeroVector(oc->obs);
-       oc->det = 0;
+            oc->det = 0.0;
      }
    }
-   if ( headpoc != NULL) {
-     for (oc = headpoc; oc!= NULL; oc=oc->next) {
+      if (xfinfo->headpoc!=NULL) {
+         for (oc=xfinfo->headpoc; oc!= NULL; oc=oc->next) {
        oc->time = -1;
        ZeroVector(oc->obs);
-       oc->det = 0;
+            oc->det = 0.0;
+         }
      }
    }
 }
@@ -2149,28 +2865,29 @@ void ResetObsCache(void)
 /*                          Adaptation Application                         */
 /*------------------------------------------------------------------------*/
 
+/* ApplyXForm2Vector: apply xform to a given vector (mean' = A*mean+b) */
 static void ApplyXForm2Vector(LinXForm *linXForm, Vector mean)
 {  
    Vector vec, bias;
-   int size,b,bsize;
+   int b,bsize;
    Matrix A;
-   float tmp;
+   double tmp;
    int i,j;
    int cnt,cnti,cntj;
 
    /* Check dimensions */
-   size = linXForm->vecSize;
+   const int size = linXForm->vecSize;
    if (size != VectorSize(mean))
       HError(999,"Transform dimension (%d) does not match mean dimension (%d)",
              size,VectorSize(mean));
    vec = CreateVector(&gstack,size);
-   CopyVector(mean,vec); ZeroVector(mean);
+   CopyVector(mean,vec); /* ZeroVector(mean); */
    /* Transform mean */
    for (b=1,cnti=1,cnt=1;b<=IntVecSize(linXForm->blockSize);b++) {
       bsize = linXForm->blockSize[b];
       A = linXForm->xform[b];
       for (i=1;i<=bsize;i++,cnti++) {
-         tmp = 0;
+         tmp = 0.0;
          for (j=1,cntj=cnt;j<=bsize;j++,cntj++)
             tmp += A[i][j] * vec[cntj];
          mean[cnti] = tmp;
@@ -2186,19 +2903,105 @@ static void ApplyXForm2Vector(LinXForm *
    FreeVector(&gstack,vec);
 }
 
-static void ApplyXForm2TriMat(LinXForm *linXForm, TriMat t, Matrix m)
+/* ApplyCMLLRXForm2Vector: apply CMLLR XForm to mean vector (mean' = A^{-1}*(mean-b)) */
+static void ApplyCMLLRXForm2Vector(LinXForm *linXForm, Vector mean)
 {  
-   int size,b,bsize;
-   Matrix A,mat;
-   float tmp;
-   int i,j,k;
-   int cnt,cnti,cntj,cntk;
+   Vector vec, bias;
+   int b,bsize;
+   Matrix A;
+   double tmp;
+   int i,j;
+   int cnt,cnti,cntj;
 
    /* Check dimensions */
-   size = linXForm->vecSize;
-   if (size != TriMatSize(t))
-      HError(999,"Transform dimension (%d) does not match matrix dimension (%d)",
-             size,TriMatSize(t));
+   const int size = linXForm->vecSize;
+   if (size != VectorSize(mean))
+      HError(999,"Transform dimension (%d) does not match mean dimension (%d)",
+             size,VectorSize(mean));
+   vec = CreateVector(&gstack,size);
+   CopyVector(mean,vec); ZeroVector(mean);
+
+   /* First apply bias (if required) */
+   bias = linXForm->bias;
+   if (bias != NULL) {
+      for (i=1;i<=size;i++)
+         vec[i] -= bias[i];
+   }
+
+   /* Transform mean */
+   for (b=1,cnti=1,cnt=1;b<=IntVecSize(linXForm->blockSize);b++) {
+      bsize = linXForm->blockSize[b];
+      A = CreateMatrix(&gstack, bsize, bsize);
+      MatInvert(linXForm->xform[b], A);
+      for (i=1;i<=bsize;i++,cnti++) {
+         tmp = 0.0;
+         for (j=1,cntj=cnt;j<=bsize;j++,cntj++)
+            tmp += A[i][j] * vec[cntj];
+         mean[cnti] = tmp;
+      }
+      cnt += bsize;
+      FreeMatrix(&gstack, A);
+   }
+   
+   FreeVector(&gstack,vec);
+}
+
+/* ApplyXForm2Cov: apply XForm to a given covariance matrix (cov' = A'*cov*A) */
+static void ApplyXForm2Cov(LinXForm *linXForm, Covariance *cov, CovKind ckind)
+{
+   int b,bsize;
+   Matrix A,A1,A2,mat;
+   int i,j;
+   int cnt,cnti,cntj;
+
+   /* Check dimensions */
+   const int size = TriMatSize(cov->inv);
+   if (size != linXForm->vecSize)
+      HError(999,"ApplyXForm2Cov: Transform dimension (%d) does not match covariance matrix dimension (%d)",
+             linXForm->vecSize,size);
+   
+   /* prepare matrices */
+   mat = CreateMatrix(&gstack,size,size);
+   A1  = CreateMatrix(&gstack,size,size); ZeroMatrix(A1);
+   A2  = CreateMatrix(&gstack,size,size); ZeroMatrix(A2);
+   
+   /* copy inverse covariance to mat */
+   Tri2Mat(cov->inv,mat);
+    
+   /* copy transformation matrices to A1 and A2 */
+   for (b=1,cnti=1,cnt=1;b<=IntVecSize(linXForm->blockSize);b++) {
+      bsize = linXForm->blockSize[b];
+      A = linXForm->xform[b];
+      for (i=1;i<=bsize;i++,cnti++)
+         for (j=1,cntj=cnt;j<=bsize;j++,cntj++)
+            A1[cntj][cnti] = A2[cnti][cntj] = A[i][j];
+      cnt += bsize;
+   }
+      
+   /* compute A1*mat*A2 */
+   MatrixMult(A1, mat, mat);
+   MatrixMult(mat, A2, mat);
+
+   /* copy transformed covariance to cov->inv */
+   Mat2Tri(mat, cov->inv);
+   
+   FreeMatrix(&gstack,mat);
+}
+
+/* ApplyXForm2TriMat: Apply XForm to a given triangular matrix (m = A*t) */ 
+static void ApplyXForm2TriMat (LinXForm *linXForm, TriMat t, Matrix m)
+{
+   int size,b,bsize;
+   Matrix A,mat;
+   float tmp;
+   int i,j,k;
+   int cnt,cnti,cntj,cntk;
+
+   /* Check dimensions */
+   size = linXForm->vecSize;
+   if (size != TriMatSize(t))
+      HError(999,"Transform dimension (%d) does not match matrix dimension (%d)",
+             size,TriMatSize(t));
    mat = CreateMatrix(&gstack,size,size);
    Tri2Mat(t,mat); 
    /* Transform mean */
@@ -2247,7 +3050,57 @@ static void DiagApplyMat2TXForm(LinXForm
    if (linXForm->bias != NULL) HError(999,"Assumes there is no bias in transform");  
 }
 
-/* Feature-Space adaptation */
+/* ConvFullCov: store diag covariance in full covariance form */
+static void ConvFullCov (HMMSet *hset, MixPDF *mp)
+{
+   int i,j,vsize;
+   SVector var;
+   STriMat inv;
+   MInfo *mi;
+   
+   mi = GetMInfo(mp);
+   var = mp->cov.var;
+   vsize = VectorSize(var);
+   
+   /* create full cov matrix and hook var and inv each other */
+   if(mi == NULL) {
+      inv = CreateSTriMat(hset->hmem, vsize);
+      SetHook(inv, var);
+   }
+   else if ((inv=GetHook(mi->cov.var))==NULL) {
+      inv = CreateSTriMat(hset->hmem,vsize);
+      SetHook(mi->cov.var,inv);
+      SetHook(inv,var);
+   }
+
+   switch(mp->ckind) {
+   case DIAGC:
+      for (i=1; i<=vsize; i++) {
+         for (j=1; j<i; j++)
+            inv[i][j] = 0.0;
+         inv[i][i] = 1.0/var[i];
+      }
+      mp->cov.inv = inv;
+      mp->ckind   = FULLC;
+      break;
+   case INVDIAGC:
+      for (i=1; i<=vsize; i++) {
+         for (j=1; j<i; j++)
+            inv[i][j] = 0.0;
+         inv[i][i] = var[i];
+      }
+      mp->cov.inv = inv;
+      mp->ckind   = FULLC;
+      break;
+   case FULLC:
+   default:
+      break;
+   }
+   
+   return;
+}
+      
+/* CompFXForm: Feature-Space adaptation */
 static Vector CompFXForm(MixPDF *mp, Vector svec, AdaptXForm *xform, AInfo *ai, LogFloat *det)
 {
   Vector vec;
@@ -2256,10 +3109,15 @@ static Vector CompFXForm(MixPDF *mp, Vec
 
   if (ai->next != NULL) { /* There's a parent transform */
     vec = CompFXForm(mp,svec,xform->parentXForm,ai->next,det);
-  } else {
-     *det = 0;
+   } 
+   else {
+      *det = 0.0;
      vec = svec;
   }
+   
+   if (mp->ckind==FULLC)
+      return svec;
+   
   /* Check the kind of the adaptation */
   if ((xform->akind != BASE) && (xform->akind != TREE))
     HError(999,"Only BASE and TREE adaptation currently supported");
@@ -2281,25 +3139,28 @@ static Vector CompFXForm(MixPDF *mp, Vec
       /* nothing is done */
       break;
     } /* No other options currently supported */
-  } else {
+   } 
+   else {
     /* no transforms equates to an identity transform */
     svec = vec;
   }
   return svec;
 }
 
-/* Model space adaptation */
-static void CompXForm(MixPDF *mp, AdaptXForm *xform, AInfo *ai)
+/* CompXForm: Model space adaptation */
+static void CompXForm(MixPDF *mp, AdaptXForm *xform, AInfo *ai, Boolean full)
 {
   XFormSet *xformSet;
-  int numXf, i;
-  int size = VectorSize(mp->mean);
-  Vector cov = CreateVector(&gstack,size);    
+   int numXf, i, size;
+   Vector var;
 
-  if (ai->next != NULL) { /* There's a parent transform */
-    CompXForm(mp,xform->parentXForm,ai->next);
-  } else { /* set up model parameters for adptation */
+   if (ai->next != NULL) { /* There are parent transforms */
+      CompXForm(mp,xform->parentXForm,ai->next,full);
+   } 
+   else { /* set up model parameters for adptation */
     ResetComp(mp);
+      if (full)
+         ConvFullCov(xform->hset, mp);
   }
   /* Check the kind of the adaptation */
   if ((xform->akind != BASE) && (xform->akind != TREE))
@@ -2313,6 +3174,13 @@ static void CompXForm(MixPDF *mp, AdaptX
       ApplyXForm2Vector(xformSet->xforms[numXf],mp->mean);
       break;
     case MLLRCOV:
+         if (full) {  
+            /* store transformed variance in full covariance form */
+            ApplyXForm2Cov(xformSet->xforms[numXf],&mp->cov,mp->ckind);
+            /* mp->gConst -= xformSet->xforms[numXf]->det; */
+            FixFullGConst(mp,-CovDet(mp->cov.inv));
+         }
+         else
       ApplyXForm2Vector(xformSet->xforms[numXf],mp->mean);
       break;
     case MLLRVAR:    
@@ -2322,30 +3190,45 @@ static void CompXForm(MixPDF *mp, AdaptX
         FixDiagGConst(mp);
         break;
       case INVDIAGC:    
+            size = VectorSize(mp->mean);
+            var  = CreateVector(&gstack,size);
+            /* inv var -> var */
         for (i=1;i<=size;i++)
-          cov[i] = 1/mp->cov.var[i];
-        ApplyXForm2Vector(xformSet->xforms[numXf], cov);
+               var[i] = 1.0/mp->cov.var[i];
+            /* apply xform to var */
+            ApplyXForm2Vector(xformSet->xforms[numXf], var);
+            /* store transformed var in inv var form */
         for (i=1;i<=size;i++)
-           mp->cov.var[i] = 1/cov[i];
+               mp->cov.var[i] = 1.0/var[i];
+            /* fix gConst */
         FixInvDiagGConst(mp);
+            FreeVector(&gstack, var);
         break;
       default:
         HError(999,"CompXForm: bad ckind %d",mp->ckind);
       }
       break;
+      case SEMIT:
+      case CMLLR:
+         if (full) { 
+            ApplyXForm2Cov(xformSet->xforms[numXf],&mp->cov,mp->ckind);
+            /* FixFullGConst(mp,-CovDet(mp->cov.inv)); */
+            mp->gConst -= xformSet->xforms[numXf]->det;
+            ApplyCMLLRXForm2Vector(xformSet->xforms[numXf],mp->mean);
+         }
+         break;
     default:
       /* nothing is done */
       break;
     } /* No other options currently supported */
   } 
-  FreeVector(&gstack, cov);
 }
 
 /*------------------------------------------------------------------------*/
 /*                 Transform Initialisation and Estimation                */
 /*------------------------------------------------------------------------*/
 
-static LinXForm *CreateLinXForm(MemHeap *x,int vsize,IntVec blockSize)
+static LinXForm *CreateLinXForm(MemHeap *x,int vsize,IntVec blockSize,Boolean useBias)
 {
    LinXForm *xf;
    int b,bsize,size;
@@ -2364,12 +3247,13 @@ static LinXForm *CreateLinXForm(MemHeap 
       size += bsize;
    }
    if (size != vsize)
-      HError(999,"Incompatible xform sizes %d and %d (block)",vsize,size);
+      HError(999,"Incompatable xform sizes %d and %d (block)",vsize,size);
    if (useBias) xf->bias = CreateSVector(x,size);
    else xf->bias = NULL;
    return xf;
 }
 
+/* EstMLLRDiagCovXForm: estimate MLLR diagonal variance transform */
 static void EstMLLRDiagCovXForm(AccStruct *accs, LinXForm *xf, LinXForm *dxf)
 {
    int b, cnti,dim, bsize;
@@ -2390,7 +3274,7 @@ static void EstMLLRDiagCovXForm(AccStruc
          for (i=1;i<=bsize;i++,cnti++) {
             tmu = 0; tvar = 0;
             ZeroDVector(tvec);
-            Tri2DMat(accs->G[cnti],G);
+            DTri2DMat(accs->G[cnti],G);
             for (j=1;j<=bsize;j++) {
                tmu += A[i][j] * accs->K[cnti][j];
                for (k=1;k<=bsize;k++)
@@ -2412,7 +3296,8 @@ static void EstMLLRDiagCovXForm(AccStruc
             dxf->xform[cnti][1][1] =  (accs->D[cnti] - 2*tmu + tvar)/accs->occ;
          }
          FreeDVector(&gstack,tvec);
-      } else {
+      } 
+      else {
          bsize = accs->blockSize[b];         
          for (i=1;i<=bsize;i++,cnti++) {
             dxf->xform[cnti][1][1] = 1.0;
@@ -2421,10 +3306,75 @@ static void EstMLLRDiagCovXForm(AccStruc
    }
 }
 
-static void EstMLLRMeanXForm(AccStruct *accs, LinXForm *xf)
+/* InvertG: invert matrix G (band or full structure) */
+static void InvertG (DMatrix G, DMatrix invG, const int c, const int bsize, const int bandw, const Boolean uBias)
 {
-   DMatrix invG,u,v;
+   DMatrix inv, u, v;
    DVector w;
+   int i,j,cnti,cntj,st,en,dim,size;
+
+   if (bandw+1<bsize) {
+      /* matrix size */
+      for (st=c-bandw; st<1; st++);
+      for (en=c+bandw; en>bsize; en--);
+      dim  = (uBias) ? bsize+1 : bsize;
+      size = (uBias) ? en-st+2 : en-st+1; 
+
+      /* matrices for inversion */
+      w   = CreateDVector(&gstack,size);
+      u   = CreateDMatrix(&gstack,size,size);
+      v   = CreateDMatrix(&gstack,size,size);
+      inv = CreateDMatrix(&gstack,size,size);
+
+      /* shrink G */
+      ZeroDMatrix(inv);
+      for (i=cnti=1; i<=dim; i++) {
+         if ((st<=i && i<=en) || (uBias && i==dim)) {
+            for (j=cntj=1; j<=dim; j++) {
+               if ((st<=j && j<=en) || (uBias && j==dim)) {
+                  inv[cnti][cntj] = G[i][j];
+                  cntj++;
+               }
+            }
+            cnti++;
+         }
+      }
+
+      /* inversion */
+      InvSVD(inv,u,w,v,inv);
+
+      /* store inv matrix to invG */
+      ZeroDMatrix(invG);
+      for (i=cnti=1; i<=dim; i++) {
+         if ((st<=i && i<=en) || (uBias && i==dim)) {
+            for (j=cntj=1; j<=dim; j++) {
+               if ((st<=j && j<=en) || (uBias && j==dim)) {
+                  invG[i][j] = inv[cnti][cntj];
+                  cntj++;
+               }
+            }
+            cnti++;
+         }
+      }
+   }
+   else {
+      /* matrices for inversion */
+      dim  = (uBias) ? bsize+1 : bsize;
+      w = CreateDVector(&gstack,dim);
+      u = CreateDMatrix(&gstack,dim,dim);
+      v = CreateDMatrix(&gstack,dim,dim);
+      InvSVD(G,u,w,v,invG);
+   }
+
+   FreeDVector(&gstack,w);
+
+   return;
+}
+
+/* EstMLLRMeanXForm: estimate MLLR mean transform */
+static void EstMLLRMeanXForm(AccStruct *accs, LinXForm *xf)
+{
+   DMatrix invG;
    SMatrix A;
    SVector bias;
    int i,j,k,dim;
@@ -2439,20 +3389,17 @@ static void EstMLLRMeanXForm(AccStruct *
          bsize = accs->blockSize[b];
          if (uBias) dim = bsize+1;
          else dim = bsize;
-         /* set up the matrices for the inversion */
+         /* set up the matrices for the inversion and the transforms to be estimated */
          invG = CreateDMatrix(&gstack,dim,dim);
-         u = CreateDMatrix(&gstack, dim, dim);
-         v = CreateDMatrix(&gstack, dim, dim);
-         w = CreateDVector(&gstack, dim);
-         /* and the transforms to be estimated */
          A = xf->xform[b]; 
          ZeroMatrix(A); 
          for (i=1;i<=bsize;i++,cnti++) {
             Tri2DMat(accs->G[cnti],invG);
-            InvSVD(invG, u, w, v, invG);
-            for (j=1;j<=bsize;j++)
+            InvertG(invG, invG, i, bsize, accs->bandWidth[b], uBias);
+            for (j=1; j<=bsize; j++) {
                for (k=1;k<=dim;k++)
                   A[i][j] += invG[j][k] * accs->K[cnti][k];
+            }
             if (uBias) {
                bias[cnti]=0;
                for (k=1;k<=dim;k++)
@@ -2460,7 +3407,8 @@ static void EstMLLRMeanXForm(AccStruct *
             }
          }
          FreeDMatrix(&gstack,invG);
-      } else {
+      } 
+      else {
          bsize = accs->blockSize[b];         
          A = xf->xform[b]; 
          ZeroMatrix(A); 
@@ -2492,23 +3440,23 @@ static double GetAlpha(DMatrix invgmat,D
     for (j=1;j<=bsize;j++)
       tvec[i] += cofact[j]*invgmat[i][j];
   /* Now set up the quadratic equation */
-  a=0;b=0;c=-occ;
+   a=0.0;b=0.0;c=-occ;
   for (i=1;i<=bsize;i++) {
     a += tvec[i]*cofact[i];
     b += tvec[i] * kmat[i];
   }
   if(bsize != dim)  b += tvec[dim] * kmat[dim];
   /* Must by definition be real */
-  tmp = (b*b-4*a*c);
-  if (tmp<0) {
+   tmp = (b*b-4.0*a*c);
+   if (tmp<0.0) {
     HError(-1,"WARNING: accumulates incorrect (%f < 0) - resetting",tmp);
-    tmp=0;
+      tmp=0.0;
   }
   
   tmp = sqrt(tmp);
   /* Now get the possible values of alpha */
-  alpha1 = (-b+tmp)/(2*a);
-  alpha2 = (-b-tmp)/(2*a);
+   alpha1 = (-b+tmp)/(2.0*a);
+   alpha2 = (-b-tmp)/(2.0*a);
   like1 = GetAlphaLike(a,b,c,alpha1);
   like2 = GetAlphaLike(a,b,c,alpha2);
  
@@ -2565,7 +3513,8 @@ static double GetSemiTiedLike(AccStruct 
             loglike += accs->G[cnt][k][k];
       }      
       loglike = -loglike/2;
-   } else {
+   } 
+   else {
       for (b=1,cnt=1;b<=nblocks;b++) {
          bsize = accs->blockSize[b];
          A = xf->xform[b];
@@ -2626,7 +3575,8 @@ static void InitCMLLRXForm(AccStruct *ac
 	lG[1][1] = accs->G[cnti][i][i]; lG[1][2] = accs->G[cnti][dim][i];
 	lG[2][1] = lG[1][2]; lG[2][2] = accs->G[cnti][dim][dim];
 	lK[1] = accs->K[cnti][i]; lK[2] = accs->K[cnti][dim];
-      } else {
+         } 
+         else {
 	lG[1][1] = accs->G[cnti][i][i];
 	lK[1] = accs->K[cnti][i];
       }
@@ -2653,7 +3603,8 @@ static void InitCMLLRXForm(AccStruct *ac
 		 i,b,likeNew/accs->occ,likeOld/accs->occ);
 	W[cnti] = iW[1];
 	if (uBias) bias[cnti] = iW[2];
-      } else {
+            } 
+            else {
 	W[cnti] = tW[1];
 	if (uBias) bias[cnti] = tW[2];
       }
@@ -2665,8 +3616,7 @@ static void InitCMLLRXForm(AccStruct *ac
 
 static void EstCMLLRXForm(AccStruct *accs, LinXForm *xf)
 {
-  DMatrix *InvG,invG,u,v;
-  DVector w;
+   DMatrix *InvG,invG;
   DMatrix A;
   DVector bias;
   int i,j,k,dim;
@@ -2682,7 +3632,8 @@ static void EstCMLLRXForm(AccStruct *acc
   if (xf->bias == NULL) {
      uBias = FALSE;
      bias = NULL;
-  } else {
+   }
+   else {
      uBias = TRUE;
      bias = CreateDVector(&gstack,xf->vecSize);
   } 
@@ -2696,10 +3648,6 @@ static void EstCMLLRXForm(AccStruct *acc
     cofact = CreateDVector(&gstack,bsize);
     if (uBias) dim = bsize+1;
     else dim = bsize;
-    /* set up the matrices for the inversion */
-    u = CreateDMatrix(&gstack, dim, dim);
-    v = CreateDMatrix(&gstack, dim, dim);
-    w = CreateDVector(&gstack, dim);
     /* and the transforms to be estimated */
     A = CreateDMatrix(&gstack, bsize,bsize);
     W = CreateDVector(&gstack,dim);
@@ -2709,8 +3657,8 @@ static void EstCMLLRXForm(AccStruct *acc
     for (i=1,cnti=cnt;i<=bsize;i++,cnti++) {
       A[i][i] = iniA[cnti];   
       InvG[cnti] = CreateDMatrix(&gstack,dim,dim);
-      Tri2DMat(accs->G[cnti],InvG[cnti]);
-      InvSVD(InvG[cnti], u, w, v, InvG[cnti]);
+         DTri2DMat(accs->G[cnti],InvG[cnti]);
+         InvertG(InvG[cnti], InvG[cnti], i, bsize, accs->bandWidth[b], uBias);
     }
     for (iter=1;iter<=maxXFormIter;iter++) {
       ZeroDVector(iniW);
@@ -2734,6 +3682,8 @@ static void EstCMLLRXForm(AccStruct *acc
         }      
         likeNew = GetRowLike(accs->G[cnti],accs->K[cnti],cofact,accs->occ,W);
         likeOld = GetRowLike(accs->G[cnti],accs->K[cnti],cofact,accs->occ,iniW);
+            if (trace&T_XFM)
+               printf("Iteration %d (row %d): Old=%e, New=%e (diff=%e)\n",iter,cnti,likeOld,likeNew,likeNew-likeOld);
         if (likeNew>likeOld) {
            det = 0; 
            for (j=1;j<=bsize;j++) {
@@ -2744,8 +3694,9 @@ static void EstCMLLRXForm(AccStruct *acc
               bias[cnti] = 0;
               bias[cnti] += W[dim];
            }
-	 } else {
-            if (likeOld/likeNew>1.00001) /* put a threshold on this! */
+            } 
+            else {
+               if (trace&T_XFM && (likeOld/likeNew>1.00001)) /* put a threshold on this! */
 	      printf("  Not updating transform (Block: %d Row: %d Iter: %d (%f %f))\n",
 		     b,i,iter,likeNew/accs->occ,likeOld/accs->occ);
 	 }
@@ -2777,7 +3728,7 @@ static void AccMixPDFSemiTiedStats(HMMSe
    STriMat inv;
 
    va = (VaAcc *) GetHook(mp->cov.var);
-   if (va->occ>0) {
+   if (va->occ>0.0) {
       strm = mp->stream;
       inv = va->cov.inv;
       if (strmProj) {
@@ -2791,13 +3742,14 @@ static void AccMixPDFSemiTiedStats(HMMSe
          for (s=1,cnti=1;s<strm;s++) cnti += hset->swidth[s];
          for (i=1;i<=hset->swidth[strm];i++,cnti++) {
             if (mp->ckind == INVDIAGC) ivar=mp->cov.var[i];
-            else ivar = 1/mp->cov.var[i];
+            else ivar = 1.0/mp->cov.var[i];
             G = accs->G[cnti]; 
             for (k=1;k<=hset->vecSize;k++) 
                for (kk=1;kk<=k;kk++) 
                   G[k][kk] += ivar*inv[k][kk];
          }
-      } else {
+      } 
+      else {
          /* the G accumulates may have been tied ... */
          if (staticSemiTied) accs->occ += va->occ * IntVecSize(accs->blockSize);
          else accs->occ += va->occ;
@@ -2809,7 +3761,7 @@ static void AccMixPDFSemiTiedStats(HMMSe
             */
             for (i=1;i<=bsize-numNuisanceDim;i++,cnti++) {
                if (mp->ckind == INVDIAGC) ivar=mp->cov.var[cnti];
-               else ivar = 1/mp->cov.var[cnti];
+               else ivar = 1.0/mp->cov.var[cnti];
                G = accs->G[cnti]; 
                for (k=1;k<=bsize;k++) 
                   for (kk=1;kk<=k;kk++) 
@@ -2898,8 +3850,8 @@ static void InitSemiTiedFR(AdaptXForm *x
          }
       }
       /* can either order by ranking .. or ident */
-      if (!initNuisanceFRIdent) A[i][max] = 1;
-      fisherRatio[max] = -i;
+      if (!initNuisanceFRIdent) A[i][max] = 1.0;
+      fisherRatio[max] = (double) -i;
    }
    for (i=1;i<=size;i++) fisherRatio[i] = -fisherRatio[i];
    if (initNuisanceFRIdent) {
@@ -2915,7 +3867,6 @@ static void InitSemiTiedFR(AdaptXForm *x
    }
    if (trace & T_FRS) {
       ShowDVector("Selection Order",fisherRatio,size);
-      /* ShowMatrix("Initial",A,size,size); */
    }
    xf->det=0;
    FreeDVector(&gstack,withinCov);
@@ -2959,7 +3910,7 @@ static void UpdateSemiTiedAccs(AdaptXFor
       for (i=vsize-numNuisanceDim+1;i<=vsize;i++) {
          /* mp is the last component of this baseclass */
          if (mp->ckind == INVDIAGC) ivar=mp->cov.var[i];
-         else ivar = 1/mp->cov.var[i];
+         else ivar = 1.0/mp->cov.var[i];
          /* scale the inverse to reflect counts */
          ivar *= accs->occ;
          G = accs->G[i];
@@ -3004,7 +3955,7 @@ static void InitSemiTiedVars(AdaptXForm 
             }
             if (mp->ckind == INVDIAGC) 
                for (j=size-numNuisanceDim+1;j<=size;j++)
-                  mp->cov.var[j] = 1/mp->cov.var[j];
+                  mp->cov.var[j] = 1.0/mp->cov.var[j];
          }
       }
    }
@@ -3056,7 +4007,7 @@ static double UpdateSemiTiedVars(HMMSet 
                   }
                   if (mp->ckind == INVDIAGC) 
                      for (j=1;j<=hset->swidth[strm];j++)
-                        mp->cov.var[j] = 1/mp->cov.var[j];
+                        mp->cov.var[j] = 1.0/mp->cov.var[j];
                   if (mp->ckind == INVDIAGC) {
                      for (j=1;j<=hset->swidth[strm];j++)
                         logdet += va->occ * log(mp->cov.var[j]);
@@ -3082,7 +4033,7 @@ static double UpdateSemiTiedVars(HMMSet 
                   }
                   if (mp->ckind == INVDIAGC) 
                      for (j=1;j<=size;j++)
-                        mp->cov.var[j] = 1/mp->cov.var[j];
+                        mp->cov.var[j] = 1.0/mp->cov.var[j];
                   /* get the information for the likelihood calculation */
                   if (mp->ckind == INVDIAGC) {
                      for (j=1;j<=size;j++)
@@ -3133,30 +4084,32 @@ static double InitSemiTiedDet(BaseClass 
    return logdet/2;
 }
 
-
 static void UpdateSemiTiedMeans(HMMSet *hset, LinXForm *xf, BaseClass *bclass, IntVec classes, Vector totMean)
 {
-   int b,j,size,s,strm,cnt;
+   int b,j,size,vsize,s,strm,cnt;
    ILink i;
    MixPDF *mp = NULL;
-   Vector vec,tvec;
+   Vector vec=NULL,tvec;
    MuAcc *ma;
 
    size = xf->vecSize; 
-   vec = CreateVector(&gstack,size);
    if (numNuisanceDim > 0) {
       tvec = CreateVector(&gstack,size);
       CopyVector(totMean,tvec);
       ApplyXForm2Vector(xf,tvec);
-   } else {
+   } 
+   else {
       tvec = NULL;
    }
+   
    for (b=1;b<=bclass->numClasses;b++) {
       if (classes[b] == 1) {
          for (i=bclass->ilist[b]; i!=NULL; i=i->next) {
             mp = ((MixtureElem *)i->item)->mpdf;
             ma = (MuAcc *) GetHook(mp->mean);
-            if (ma->occ>0) {
+            if (ma->occ>0.0) {
+               vsize = VectorSize(mp->mean);
+               vec = CreateVector(&gstack,vsize);
                CopyVector(ma->mu,vec);
                ApplyXForm2Vector(xf,vec);
                if (strmProj) {
@@ -3164,8 +4117,9 @@ static void UpdateSemiTiedMeans(HMMSet *
                   for (s=1,cnt=1;s<strm;s++)  cnt += hset->swidth[s];
                   for (j=1;j<=hset->swidth[strm];j++,cnt++) 
                      mp->mean[j] = vec[cnt]/ma->occ;
-               } else {
-                  for (j=1;j<=size-numNuisanceDim;j++)
+               } 
+               else {
+                  for (j=1;j<=vsize-numNuisanceDim;j++)
                      mp->mean[j] = vec[j]/ma->occ;
                }
                /* update the global "tied" means */
@@ -3173,11 +4127,11 @@ static void UpdateSemiTiedMeans(HMMSet *
                   for (j=size-numNuisanceDim+1;j<=size;j++)
                      mp->mean[j] = tvec[j];
                }
+               FreeVector(&gstack,vec);
             }
          }
       }
    }
-   FreeVector(&gstack,vec);
 }
 
 static void GetSemiTiedTotCov(AdaptXForm *xform, IntVec classes, TriMat totCov, Vector totMean)
@@ -3237,7 +4191,7 @@ static void GetSemiTiedTotCov(AdaptXForm
    FreeDMatrix(&gstack,mat);
 }
 
-static void UpdateSemiTiedVFloor(HMMSet *hset, LinXForm *xf, TriMat avCov, SVector vFloor)
+static void UpdateSemiTiedVFloor (HMMSet *hset, LinXForm *xf, TriMat avCov, SVector vFloor, const int s)
 {
    Matrix mat;
    int size,i;
@@ -3247,9 +4201,9 @@ static void UpdateSemiTiedVFloor(HMMSet 
       mat = CreateMatrix(&gstack,size,size);
       ApplyXForm2TriMat(xf,avCov,mat);
       DiagApplyMat2TXForm(xf,mat,vFloor);
-      for (i=1;i<=size;i++) vFloor[i] *= semiTiedFloorScale;
-      FreeMatrix (&gstack, mat);
-   } else
+      for (i=1;i<=size;i++) vFloor[i] *= semiTiedFloorScale[s];
+   } 
+   else
       ZeroVector(vFloor);
 }
 
@@ -3294,10 +4248,9 @@ void UpdateHLDAModel(HMMSet *hset)
    hset->projSize = 0;
 }
 
-
 static void UpdateSemiTiedXForm(AccStruct *accs, LinXForm *xf, LinXForm *ixf)
 {
-   DMatrix invG,u,v;
+   DMatrix invG;
    DMatrix *InvG;
    DVector w;
    DMatrix A;
@@ -3317,37 +4270,36 @@ static void UpdateSemiTiedXForm(AccStruc
      dim = bsize;
      cofact = CreateDVector(&gstack,bsize);
      ZeroDVector(cofact); 
-     /* set up the matrices for the inversion */
-     u = CreateDMatrix(&gstack, dim, dim);
-     v = CreateDMatrix(&gstack, dim, dim);
-     w = CreateDVector(&gstack, dim);
-     /* and the transforms to be estimated */
+      /* set up the transforms to be estimated */
      A = CreateDMatrix(&gstack,bsize,bsize);
      ZeroDMatrix(A); 
      if (ixf == NULL) {
         /* initialise with the diagonal transform */
         for (i=1,cnti=cnt;i<=bsize;i++, cnti++) {
            A[i][i] = sqrt(accs->G[cnti][i][i]/accs->occ); 
-           A[i][i] = 1/A[i][i];
+            A[i][i] = 1.0/A[i][i];
            InvG[cnti] = CreateDMatrix(&gstack,dim,dim);
            Tri2DMat(accs->G[cnti],InvG[cnti]);
-           InvSVD(InvG[cnti], u, w, v, InvG[cnti]);
+            InvertG(InvG[cnti], InvG[cnti], i, bsize, accs->bandWidth[b], FALSE);
         }
-     } else {
+      } 
+      else {
         for (i=1,cnti=cnt;i<=bsize;i++, cnti++) {
            InvG[cnti] = CreateDMatrix(&gstack,dim,dim);
            Tri2DMat(accs->G[cnti],InvG[cnti]);
-           InvSVD(InvG[cnti], u, w, v, InvG[cnti]);
+            InvertG(InvG[cnti], InvG[cnti], i, bsize, accs->bandWidth[b], FALSE);
            for (j=1;j<=bsize;j++)
               A[i][j] = ixf->xform[b][i][j];
         }
      }
+      w = CreateDVector(&gstack,dim);
      W = CreateDVector(&gstack,dim);
      iniW = CreateDVector(&gstack,dim);
      for (iter=1;iter<=maxXFormIter;iter++) {
        ZeroDVector(iniW);
        for (i=1,cnti=cnt;i<=bsize;i++,cnti++) {
-         for (j=1;j<=bsize;j++)      iniW[j] = A[i][j];
+            for (j=1;j<=bsize;j++)
+               iniW[j] = A[i][j];
          invG = InvG[cnti];    
          det = DMatCofact(A,i,cofact);     
          beta = 0;
@@ -3356,6 +4308,9 @@ static void UpdateSemiTiedXForm(AccStruc
                beta += cofact[j]*invG[j][k]*cofact[k];
          }
          beta = sqrt(accs->occ/beta);
+            if (isnan(beta)) {
+                HError(-9999,"UpdateSemiTiedXForm: beta becomes NaN, possibly too few adaptation data");
+            }
          ZeroDVector(W);
          for(j=1;j<=bsize;j++){
             for(k=1;k<=bsize;k++)
@@ -3365,11 +4320,17 @@ static void UpdateSemiTiedXForm(AccStruc
          ZeroDVector(w);
          likeNew = GetRowLike(accs->G[cnti],w,cofact,accs->occ,W);
          likeOld = GetRowLike(accs->G[cnti],w,cofact,accs->occ,iniW);
-         /* printf("Iteration %d (row %d): ",iter,cnt); */
+            if (trace&T_XFM)
+               printf("Iteration %d (row %d): Old=%e, New=%e (diff=%e)\n",iter,cnti,likeOld,likeNew,likeNew-likeOld);
          if (likeNew>likeOld) {
-           for(j=1;j<=bsize;j++)  A[i][j] = W[j];
-         } else {
-            if (likeOld/likeNew>1.00001) /* put a threshold on this! */
+               det = 0;
+               for(j=1;j<=bsize;j++){
+                  A[i][j] = W[j];
+                  det += W[j]*cofact[j];
+               }
+            } 
+            else {
+               if (trace&T_XFM && (likeOld/likeNew>1.00001)) /* put a threshold on this! */
                printf("  Not updating transform (Block: %d Row: %d Iter: %d (%f %f))\n",
 		      b,i,iter,likeNew/accs->occ,likeOld/accs->occ);
 	 }
@@ -3389,16 +4350,30 @@ static void UpdateSemiTiedXForm(AccStruc
 
 static void CheckSemiTiedOptions(AdaptXForm *xform, AccStruct *accs)
 {
-   int b,bsize;
+   int s,b,bsize;
+   Boolean msd;
+
+   /* MSD flag */
+   for (s=1,msd=FALSE; s<=xform->hset->swidth[0]; s++) {
+      if (xform->hset->msdflag[s]!=0) {
+         msd = TRUE;
+         break;
+      }
+   }
 
    if (strmProj) { /* confirm that strmProj valid */
       if (xform->bclass->numClasses != 1)
          HError(999,"Can only have strmProj with global transform");
       if (xform->hset->swidth[0] == 1) 
          HError(999,"strmProj with a single stream is not valid");
-   } else if (numNuisanceDim>0) { /* check the nuisance dimension options */
+      if (msd)
+         HError(999,"strmProj with MSD HMM is not valid");
+   } 
+   else if (numNuisanceDim>0) { /* check the nuisance dimension options */
       if (xform->hset->swidth[0] != 1)
          HError(999,"Can only have Nuisance Dimensions with single streams");
+      if (msd)
+         HError(999,"Can only have Nuisance Dimensions with non-MSD HMMs");
    }
 
    if (semiTied2InputXForm) {
@@ -3440,7 +4415,8 @@ static void EstSemiTXForm(AdaptXForm *xf
    CheckSemiTiedOptions(xform,accs);
    if (strmProj) { 
       size =  hset->vecSize;
-   } else 
+   } 
+   else
       size = accs->dim;
    
    ixf = NULL;
@@ -3448,8 +4424,10 @@ static void EstSemiTXForm(AdaptXForm *xf
    streams = CreateIntVec(&gstack,hset->swidth[0]);
    totCov = CreateTriMat(&gstack,size);
    totMean = CreateVector(&gstack,size);
+   
    if (strmProj) stream = 1;
    else stream = GetXFormStream(xform,classes,streams);
+   
    /* handle initialisation for HLDA */
    /* get the global covariance matrix */
    GetSemiTiedTotCov(xform,classes,totCov,totMean);
@@ -3465,19 +4443,22 @@ static void EstSemiTXForm(AdaptXForm *xf
             */               
             if ((xform->bclass->numClasses>1) && (hset->semiTied != NULL)) {
                printf("WARNINING: using total baseclass variance, not average state variance\n");
-               UpdateSemiTiedVFloor(hset,xf,totCov,vFloor);
+               UpdateSemiTiedVFloor(hset,xf,totCov,vFloor,stream);
             } else
-               UpdateSemiTiedVFloor(hset,xf,avCov[stream],vFloor);
+               UpdateSemiTiedVFloor(hset,xf,avCov[stream],vFloor,stream);
          }
          else 
             ZeroVector(vFloor);
          logdet = UpdateSemiTiedVars(hset,xf,xform->bclass,classes,vFloor,totCov);         
-      } else {
+      } 
+      else {
          InitSemiTiedVars(xform,classes,totCov);
          logdet = InitSemiTiedDet(xform->bclass,classes);
       }
-   } else 
+   } 
+   else
       logdet = InitSemiTiedDet(xform->bclass,classes);
+   
    for (iter=1;iter<=maxSemiTiedIter;iter++) {
       UpdateSemiTiedAccs(xform,accs,classes,totCov);
       if (staticSemiTied) tocc = accs->occ/(IntVecSize(accs->blockSize));
@@ -3487,8 +4468,11 @@ static void EstSemiTXForm(AdaptXForm *xf
          printf("Initial LogLikelihood = %f\n",logdet/tocc);
          UpdateSemiTiedXForm(accs, xf, ixf);
       }
-      else UpdateSemiTiedXForm(accs, xf, xf);
+      else 
+         UpdateSemiTiedXForm(accs, xf, xf);
+         
       printf("Iteration %d\n",iter); fflush(stdout);
+      
       if (stream>0) {
          /* 
             if there are multiple baseclases and a semitied transform already being used
@@ -3496,11 +4480,12 @@ static void EstSemiTXForm(AdaptXForm *xf
          */               
          if ((xform->bclass->numClasses>1) && (hset->semiTied != NULL)) {
             printf("WARNINING: using total baseclass variance, not average state variance\n");
-            UpdateSemiTiedVFloor(hset,xf,totCov,vFloor);
+            UpdateSemiTiedVFloor(hset,xf,totCov,vFloor,stream);
          } else
-            UpdateSemiTiedVFloor(hset,xf,avCov[stream],vFloor);
+            UpdateSemiTiedVFloor(hset,xf,avCov[stream],vFloor,stream);
       } else 
          ZeroVector(vFloor);
+
       logdet = UpdateSemiTiedVars(hset,xf,xform->bclass,classes,vFloor,totCov);
       logdet += GetSemiTiedLike(accs,xf);
       printf("  LogLikelihood = %f\n",logdet/tocc);
@@ -3505,16 +4490,17 @@ static void EstSemiTXForm(AdaptXForm *xf
       logdet += GetSemiTiedLike(accs,xf);
       printf("  LogLikelihood = %f\n",logdet/tocc);
    }
+   
    /* Tidy Stats */
    xf->vFloor = vFloor;
    UpdateSemiTiedMeans(hset,xf,xform->bclass,classes,totMean);
    FreeIntVec(&gstack,streams);
 }
 
-
+/* EstMLLRCovXForm: estimate MLLR covariance transform */
 static void EstMLLRCovXForm(AccStruct *accs, LinXForm *xf)
 {
-  DMatrix invG,u,v;
+   DMatrix invG;
   DMatrix *InvG;
   DVector w;
   DMatrix A;
@@ -3534,22 +4520,19 @@ static void EstMLLRCovXForm(AccStruct *a
      dim = bsize;
      cofact = CreateDVector(&gstack,bsize);
      ZeroDVector(cofact); 
-     /* set up the matrices for the inversion */
-     u = CreateDMatrix(&gstack, dim, dim);
-     v = CreateDMatrix(&gstack, dim, dim);
-     w = CreateDVector(&gstack, dim);
-     /* and the transforms to be estimated */
+      /* set up the transforms to be estimated */
      A = CreateDMatrix(&gstack,bsize,bsize);
      ZeroDMatrix(A); 
+      w = CreateDVector(&gstack,dim);
      W = CreateDVector(&gstack,dim);
      iniW = CreateDVector(&gstack,dim);
      /* initialise with the diagonal transform */
      for (i=1,cnti=cnt;i<=bsize;i++, cnti++) {
         A[i][i] = sqrt(accs->G[cnti][i][i]/accs->occ); 
-        A[i][i] = 1/A[i][i];
+         A[i][i] = 1.0/A[i][i];
         InvG[cnti] = CreateDMatrix(&gstack,dim,dim);
-        Tri2DMat(accs->G[cnti],InvG[cnti]);
-        InvSVD(InvG[cnti], u, w, v, InvG[cnti]);
+         DTri2DMat(accs->G[cnti],InvG[cnti]);
+         InvertG(InvG[cnti], InvG[cnti], i, bsize, accs->bandWidth[b], FALSE);
      }
      for (iter=1;iter<=maxXFormIter;iter++) {
        ZeroDVector(iniW);
@@ -3563,6 +4546,9 @@ static void EstMLLRCovXForm(AccStruct *a
                beta += cofact[j]*invG[j][k]*cofact[k];
          }
          beta = sqrt(accs->occ/beta);
+            if (isnan(beta)) {
+                HError(-9999,"EstMLLRCovXForm: beta becomes NaN, possibly too few adaptation data");
+            }
          ZeroDVector(W);
          for(j=1;j<=bsize;j++){
             for(k=1;k<=bsize;k++)
@@ -3572,11 +4558,17 @@ static void EstMLLRCovXForm(AccStruct *a
          ZeroDVector(w);
          likeNew = GetRowLike(accs->G[cnti],w,cofact,accs->occ,W);
          likeOld = GetRowLike(accs->G[cnti],w,cofact,accs->occ,iniW);
-         /* printf("Iteration %d (row %d): ",iter,cnt); */
+            if (trace&T_XFM) 
+               printf("Iteration %d (row %d): Old=%e, New=%e (diff=%e)\n",iter,cnti,likeOld,likeNew,likeNew-likeOld);
          if (likeNew>likeOld) {
-           for(j=1;j<=bsize;j++)  A[i][j] = W[j];
-         } else {
-            if (likeOld/likeNew>1.00001) /* put a threshold on this! */
+               det = 0;
+               for(j=1;j<=bsize;j++){
+                  A[i][j] = W[j];
+                  det += W[j]*cofact[j];
+               }
+            } 
+            else {
+               if (trace&T_XFM && (likeOld/likeNew>1.00001)) /* put a threshold on this! */
                printf("  Not updating transform (Block: %d Row: %d Iter: %d (%f %f))\n",
 		      b,i,iter,likeNew/accs->occ,likeOld/accs->occ);
 	 }
@@ -3594,17 +4586,21 @@ static void EstMLLRCovXForm(AccStruct *a
    Dispose(&gstack,InvG);
 }
 
-static void EstXForm(AccStruct *accs, AdaptXForm *xform, IntVec classes)
+static void EstXForm(AccStruct *accs, XFInfo *xfinfo, IntVec classes)
 {
   XFormSet *xformSet;
   LinXForm *xf, *dxf;
   IntVec diagBlockSize;
   int i;
   
+   AdaptXForm *xform = xfinfo->outXForm; 
+   AdaptXForm *diagCovXForm = xfinfo->diagCovXForm;
+  
   xformSet = xform->xformSet;
-  xformSet->numXForms++;
+   (xformSet->numXForms)++;
   xf = xformSet->xforms[xformSet->numXForms] 
-    = CreateLinXForm(xform->mem,accs->dim,accs->blockSize);
+      = CreateLinXForm(xform->mem,accs->dim,accs->blockSize,accs->useBias); 
+
   switch (accs->xkind) {
   case MLLRMEAN:    
     EstMLLRMeanXForm(accs, xf);
@@ -3614,7 +4610,7 @@ static void EstXForm(AccStruct *accs, Ad
       xformSet = diagCovXForm->xformSet;
       xformSet->numXForms++;
       dxf = xformSet->xforms[xformSet->numXForms] 
-	= CreateLinXForm(xform->mem,accs->dim,diagBlockSize);
+             = CreateLinXForm(xform->mem,accs->dim,diagBlockSize,FALSE);
       dxf->bias = NULL;
       EstMLLRDiagCovXForm(accs,xf,dxf);
       FixDet(dxf);
@@ -3637,25 +4633,35 @@ static void EstXForm(AccStruct *accs, Ad
     printf("Estimated XForm %d using %f observations\n",xformSet->numXForms,accs->occ);
 }
 
-void GenXForm(RegNode *node, AdaptXForm *xform, IntVec classes)
+Boolean GenXForm(RegNode *node, XFInfo *xfinfo, IntVec classes, int xfindex)
 {
    AccStruct *accs;
    int class=1,b;
+   IntVec blockSize,bandWidth;
+   
+   AdaptXForm *xform = xfinfo->outXForm;
+   AdaptXForm *diagCovXForm = xfinfo->diagCovXForm;
   
+   if (node->valid && node->vsize>0) {
    /* First get dimension of data associated with this set of transforms */
    if (trace&T_TRE) {
-      printf("Using node %d (%f) to adapt baseclasses: \n",node->nodeIndex,node->nodeOcc);
+         printf("Using node %d (occ=%f, stream=%d, vsize=%d) to adapt baseclasses: \n",
+                node->nodeIndex, node->nodeOcc, node->stream, node->vsize);
       for (b=1;b<=IntVecSize(classes);b++)
          if (classes[b] == 1) printf(" %d",b);
       printf("\n");
    }
    while (classes[class] == 0) class++;
+      blockSize = GetBlockSize(xfinfo,class);
+      bandWidth = GetBandWidth(xfinfo,class,blockSize);      
    if (strmProj)
-      accs = CreateAccStruct(&gstack,xform,xform->hset->vecSize,GetBlockSize(xform,class));
+         accs = CreateAccStruct(&gstack,xfinfo,xform->hset->vecSize,blockSize,bandWidth);
    else 
-      accs = CreateAccStruct(&gstack,xform,node->vsize,GetBlockSize(xform,class));
+         accs = CreateAccStruct(&gstack,xfinfo,node->vsize,blockSize,bandWidth);
    AccNodeStats(node,accs,xform,classes);
-   EstXForm(accs,xform,classes);
+      if(xfindex>0)
+         AddPrior(accs,xform, xfindex);
+      EstXForm(accs,xfinfo,classes);
    for (b=1;b<=IntVecSize(classes);b++)
       if (classes[b] == 1) {
 	if (HardAssign(xform)) {
@@ -3666,16 +4672,26 @@ void GenXForm(RegNode *node, AdaptXForm 
          else 
             HError(999,"Not currently supported");
       }
+      
    Dispose(&gstack,accs);
+      return TRUE;
+   }else{
+      return FALSE;
+   }
 }
 
-static Boolean GenClassXForm(BaseClass *bclass, AdaptXForm *xform)
+static Boolean GenClassXForm(XFInfo *xfinfo)
 {
   AccStruct *accs;
-  int b;
+   int s,b;
+   float thresh[SMAX];
   ILink i;
   MixPDF *mp = NULL;
-  IntVec classes;
+   IntVec classes,blockSize,bandWidth;
+   
+   AdaptXForm *xform = xfinfo->outXForm;
+   BaseClass *bclass = xform->bclass;
+   AdaptXForm *diagCovXForm = xfinfo->diagCovXForm;
 
   /* reset the number of transforms */
   xform->xformSet->numXForms = 0;
@@ -3692,34 +4708,114 @@ static Boolean GenClassXForm(BaseClass *
   }
   classes = CreateIntVec(&gstack,bclass->numClasses);
   for (b=1;b<=bclass->numClasses;b++) {
+      if (GetBaseClassVSize(bclass,b)>0) {
      ZeroIntVec(classes); classes[b] = 1;
     /* Accumulate structure regenerated each time as this will handle
        streams of different sizes simply */
+         blockSize = GetBlockSize(xfinfo,b);
+         bandWidth = GetBandWidth(xfinfo,b,blockSize);
      if (strmProj)
-        accs = CreateAccStruct(&gstack,xform,xform->hset->vecSize,GetBlockSize(xform,b));
+            accs = CreateAccStruct(&gstack,xfinfo,xform->hset->vecSize,blockSize,bandWidth);
      else     
-        accs = CreateAccStruct(&gstack,xform,GetVecSizeClass(bclass,b), GetBlockSize(xform,b));
+            accs = CreateAccStruct(&gstack,xfinfo,GetBaseClassVSize(bclass,b),blockSize,bandWidth);
     for (i=bclass->ilist[b]; i!=NULL; i=i->next) {
       mp = ((MixtureElem *)i->item)->mpdf;
       AccMixPDFStats(xform->hset,mp,accs);
     }
     /* Use last component of the baseclass to access baseclass stats */
     if (AccAdaptBaseTriMat(xform))  AccBaseClassStats(mp,accs);
-    if ((xform->xformSet->xkind == SEMIT) || (accs->occ > GetSplitThresh(xform))) {
-      EstXForm(accs,xform,classes);
+   
+         /* get threshold for this base class */
+         s = bclass->stream[b];
+         GetSplitThresh(xfinfo,thresh);
+         
+         printf("Class %d (stream=%d, vsize=%d", b, s, accs->dim);
+         if (xform->xformSet->xkind!=SEMIT)
+            printf(",occ=%f)\n", accs->occ);
+         else
+            printf(")\n"); 
+   
+         if ((accs->dim>0) && ((xform->xformSet->xkind==SEMIT) || (accs->occ > thresh[s]))) {
+            EstXForm(accs,xfinfo,classes);
       xform->xformWgts.assign[b] = xform->xformSet->numXForms;
       if (mllrDiagCov) 
 	diagCovXForm->xformWgts.assign[b] = diagCovXForm->xformSet->numXForms;
-    } else {
+         } 
+         else {
        xform->xformWgts.assign[b] = 0;
     }
     Dispose(&gstack,accs);
   }
+   }
   return TRUE;
 }
 
+InputXForm *AdaptXForm2InputXForm (HMMSet *hset, AdaptXForm *xform)
+{
+   InputXForm *ixform;
+   int s,i,j,cnt,hldasize;
+   char mac[MAXSTRLEN], num[MAXSTRLEN];
+   LabId id;
+   MLink m;
+   SVector v;
+   SMatrix mat;
+   
+   if (xform->bclass->numClasses != 1)
+      HError(999,"Can only use Stream Projections with single base classes");
+   ixform = (InputXForm *)New(hset->hmem,sizeof(InputXForm));
+   ixform->xformName = CopyString(hset->hmem,xform->xformName);
+   ixform->mmfIdMask = xform->bclass->mmfIdMask;
+   ixform->fname = NULL;
+   ixform->pkind = xform->hset->pkind;
+   ixform->preQual = FALSE;
+   ixform->xform = xform->xformSet->xforms[1];
+   if ((numNuisanceDim > 0) || (hset->projSize>0)) { /* adjust size to remove HLDA */
+      if (numNuisanceDim>0) hldasize = hset->vecSize-numNuisanceDim;
+      else hldasize = hset->vecSize-hset->projSize;
+      mat = CreateSMatrix(hset->hmem,hldasize,hset->vecSize);
+      for (i=1; i<=hldasize; i++)
+         for (j=1; j<=hset->vecSize; j++)
+            mat[i][j] = ixform->xform->xform[1][i][j];
+      ixform->xform->xform[1] = mat;
+   }
+   /*
+      Update the HMMSet vFloor and then zero xf vFloor. For input
+      xforms the HMMSet vFloor always  used.
+   */
+   if ((numNuisanceDim > 0) || (hset->projSize>0)) {
+      strcpy(mac,"varFloor1");
+      id = GetLabId(mac,FALSE);
+      if (id != NULL  && (m=FindMacroName(hset,'v',id)) != NULL){
+         /* found the varFloor to update */
+         if (numNuisanceDim>0) hldasize = hset->vecSize-numNuisanceDim;
+         else hldasize = hset->vecSize-hset->projSize;
+         v = CreateSVector(hset->hmem,hldasize);
+         for (i=1; i<=hldasize; i++)
+            v[i] = ixform->xform->vFloor[i];
+         m->structure = v;
+      }
+   } 
+   else {
+      for (s=1,cnt=1; s<=hset->swidth[0]; s++) {
+         strcpy(mac,"varFloor");
+         sprintf(num,"%d",s); strcat(mac,num);
+         id = GetLabId(mac,FALSE);
+         if (id != NULL  && (m=FindMacroName(hset,'v',id)) != NULL){
+            /* found the varFloor to update */
+            v = (SVector)m->structure;
+            for (i=1; i<=hset->swidth[s]; i++,cnt++)
+               v[i] = ixform->xform->vFloor[cnt];
+         }
+      }
+   }
+   ixform->xform->vFloor = NULL;
+   ixform->nUse = 0;
+
+   return ixform;
+}
+
 /* The transform generated from this can be applied to a model set */
-static AdaptXForm *CreateBaseAdaptXForm(HMMSet *hset, char *xformName)
+static AdaptXForm *CreateBaseAdaptXForm(HMMSet *hset, XFInfo *xfinfo, char *xformName)
 {
    AdaptXForm *xform;
    XFormAccInfo *info;
@@ -3727,8 +4823,10 @@ static AdaptXForm *CreateBaseAdaptXForm(
    int b;
    char buf[MAXSTRLEN];
 
+   XFormKind xKind = xfinfo->outXKind;
+
    xform = (AdaptXForm *)New(hset->hmem,sizeof(AdaptXForm));
-   xform->xformName = xformName;
+   xform->xformName = CopyString(hset->hmem,xformName);
    xform->mem = hset->hmem;
    xform->hset = hset;
    xform->nUse = 0;
@@ -3740,14 +4838,14 @@ static AdaptXForm *CreateBaseAdaptXForm(
    xformSet->nUse = 0;
    /* setup default values from config variables */
    xformSet->xkind = xKind; 
-   xform->akind = GetAdaptKind(xform);
+   xform->akind = GetAdaptKind(xfinfo);
    /* Now sort out the correct set of baseclasses */
    switch (xform->akind) {
    case BASE:
-      xform->bclass = GetBaseClass(hset,xform);
+      xform->bclass = GetBaseClass(hset,xfinfo);
       break;
    case TREE:
-      xform->rtree = GetRegTree(hset,xform);
+      xform->rtree = GetRegTree(hset,xfinfo);
       xform->bclass = xform->rtree->bclass;
       break;
    default:
@@ -3761,11 +4859,17 @@ static AdaptXForm *CreateBaseAdaptXForm(
    if (HardAssign(xform)) {
       xform->xformWgts.assign = CreateIntVec(hset->hmem,xform->bclass->numClasses);
       for (b=1;b<=xform->bclass->numClasses;b++) xform->xformWgts.assign[b] = 0;
-   } else 
+   } 
+   else 
       HError(999,"Not currently supported");
    /* create space for maximum number of transforms */
+   if(useSMAPcriterion){
+      xformSet->xforms = 
+         (LinXForm **)New(hset->hmem,(xform->rtree->numNodes+xform->rtree->numTNodes+1)*sizeof(LinXForm *));
+   }else{
    xformSet->xforms = 
       (LinXForm **)New(hset->hmem,(xform->bclass->numClasses+1)*sizeof(LinXForm *));
+   }
    /* setup the xform accumulation information */
    xform->info = info = (XFormAccInfo *)New(hset->hmem,sizeof(XFormAccInfo));
    info->accSum = AccAdaptMean(xform);
@@ -3774,8 +4878,10 @@ static AdaptXForm *CreateBaseAdaptXForm(
    if (hset->parentXForm != NULL) {
       xform->parentXForm = hset->parentXForm;
       xform->parentXForm->nUse++;
-   } else 
+   } 
+   else 
       xform->parentXForm = NULL;     
+   
    return xform;
 } 
 
@@ -3783,32 +4889,6 @@ static AdaptXForm *CreateBaseAdaptXForm(
 /*                  Manipulation of Adaptation Transforms                 */
 /*------------------------------------------------------------------------*/
 
-/* Product between two given matrices */
-static void MatrixMult(Matrix m1, Matrix m2, Matrix m)
-{  
-   float tempElem;
-   int i,j,k;
-   Matrix mat;
-
-   mat = CreateMatrix(&gstack,NumRows(m1),NumCols(m2));
-   if (NumCols(m1)==NumRows(m2)){
-      for (i=1;i<=NumRows(m);i++){
-         for (j=1;j<=NumCols(m);j++){
-            tempElem=0.0;
-            for (k=1;k<=NumCols(m1);k++){
-               tempElem+=m1[i][k]*m2[k][j];
-            }
-            mat[i][j]=tempElem;
-         }
-      }
-      CopyMatrix(mat,m);
-   }
-   else {
-      HError(999,"HMath: MatrixMult: Matrices not the same size!\n");
-   }
-   FreeMatrix(&gstack,mat);
-}
-
 static Boolean CompBlockSizes(IntVec blocks1, IntVec blocks2)
 {
    int nblock1, nblock2;
@@ -3820,8 +4900,10 @@ static Boolean CompBlockSizes(IntVec blo
       for (i=1;i<=nblock1;i++) 
          if (blocks1[i] != blocks2[i])
             return FALSE;
-   } else 
+   } 
+   else 
       return(FALSE);
+   
    return (TRUE);
 }
 
@@ -3848,7 +4930,8 @@ static void MultCovMeanLinXForms(LinXFor
          MatrixMult(mat,xf2->xform[bl],res);
          if (mllrCov2CMLLR) {
             CopyMatrix(res,xf2->xform[bl]);
-         } else {
+         } 
+         else {
             MatrixMult(res,imat,xf2->xform[bl]);
          }
          if (xf2->bias != NULL) {
@@ -3861,7 +4944,8 @@ static void MultCovMeanLinXForms(LinXFor
       }
       if (xf2->bias != NULL) 
          CopyVector(bres,xf2->bias);
-   } else {
+   } 
+   else {
       HError(999,"Not currently supported");
    }
    FreeVector(&gstack,bres);
@@ -3934,7 +5018,8 @@ static void SwapXForm(HMMSet *hset, Adap
             HError(999,"General transform swapping not currently supported\n");
          }
       }
-   } else {
+   } 
+   else {
       if (trace&T_SWP) {
          printf("Inappropriate combination  of  baseclasses %s %s\n",
                 xform->bclass->fname,paxform->bclass->fname);
@@ -3949,12 +5034,15 @@ static void SwapXForm(HMMSet *hset, Adap
 
 /* ---------------- Accumulation Control Functions ---------------------- */
 
-void AccAdaptFrame(HMMSet *hset, double Lr, Vector svec, MixPDF *mp, int t)
+void AccAdaptFrame(XFInfo *xfinfo, double Lr, Vector svec, MixPDF *mp, int t)
 {
    RegAcc *ra;
    int i, vsize;
 
-   vsize = VectorSize(svec);
+   vsize = VectorSize(mp->mean);
+   if (vsize!=SpaceOrder(svec))  /* check MSD */
+      return;
+      
    ra = GetRegAcc(mp);
    ra->occ += Lr;
    if (ra->spSum != NULL)
@@ -3964,7 +5052,7 @@ void AccAdaptFrame(HMMSet *hset, double 
       for (i=1;i<=vsize;i++)
          ra->spSumSq[i] += Lr*svec[i]*svec[i];
    if (ra->bTriMat != NULL) 
-      AccBaseTriMat(hset,Lr,svec,mp,t);
+      AccBaseTriMat(xfinfo,Lr,svec,mp,t);
 }
 
 void ZeroAdaptAccs(HMMSet *hset, AdaptXForm *xform)
@@ -3981,9 +5069,9 @@ void ZeroAdaptAccs(HMMSet *hset, AdaptXF
          for (i=bclass->ilist[b]; i!=NULL; i=i->next) {
             mp = ((MixtureElem *)i->item)->mpdf;
             ra = GetRegAcc(mp);
-            ra->occ = 0;
-            if (ra->spSum != NULL) ZeroVector(ra->spSum);
-            if (ra->spSumSq != NULL) ZeroVector(ra->spSumSq);
+            ra->occ = 0.0;
+            if (ra->spSum != NULL) ZeroDVector(ra->spSum);
+            if (ra->spSumSq != NULL) ZeroDVector(ra->spSumSq);
          }
          /* Use last component of the baseclass to access baseclass stats */
          if (ra->bTriMat != NULL) ZeroBaseTriMat(ra->bTriMat);
@@ -3993,49 +5081,63 @@ void ZeroAdaptAccs(HMMSet *hset, AdaptXF
 
 /* ---------------- Applying Transform Functions ------------------------ */
 
-void SetXForm(HMMSet *hset, AdaptXForm *xform)
+/* EXPORT->SetXForm: set current xform for given hset */
+void SetXForm(HMMSet *hset, XFInfo *xfinfo, AdaptXForm *xform)
 {
    if (!(CompareXFormInfo(hset->curXForm, xform))) {
       SetAInfo(hset,xform,FALSE);
    } 
-   SetObsCache(xform,FALSE);  
+   SetObsCache(xfinfo,xform,FALSE);
    if (storeMInfo) {
       if (hset->attMInfo) {
          if (!CompareMInfo(hset,xform))
             UpdateMInfo(hset,xform);
-      } else {
+      } 
+      else {
          SetMInfo(hset,xform);
       }
    }
    /* set the flag whether input transform changes covariance or not */
-   covarChanged = XFormModCovar(xform);
+   xfinfo->covarChanged = XFormModCovar(xform);
    hset->curXForm = xform;
 }
 
-void SetParentXForm(HMMSet *hset, AdaptXForm *xform)
+/* EXPORT->SetParentXForm: set parent xform for given hset */
+void SetParentXForm(HMMSet *hset, XFInfo *xfinfo, AdaptXForm *xform)
 {
    if (!(CompareXFormInfo(hset->parentXForm, xform))) {
       SetAInfo(hset,xform,TRUE);
    }
-   SetObsCache(xform, TRUE);
+   SetObsCache(xfinfo, xform, TRUE);
    if (storeMInfo) {
       if (hset->attMInfo) {
          if (!CompareMInfo(hset,xform))
             UpdateMInfo(hset,xform);
-      } else {
+      } 
+      else {
          SetMInfo(hset,xform);
       }
    }
    /* set the flag whether parent transform changes covariance or not */
-   covarPChanged = XFormModCovar(xform);
+   xfinfo->covarPChanged = XFormModCovar(xform);
    hset->parentXForm = xform;
-   SetAccCache(outXForm);
 }
 
-void ApplyCompXForm(MixPDF *mp, AdaptXForm *xform)
+/* EXPORT->ApplyCompXForm: apply component-specific xform to MixPDF */
+void ApplyCompXForm(MixPDF *mp, AdaptXForm *xform, Boolean full)
 {
    AInfo *ai = NULL;
    HMMSet *hset;
+   AdaptXForm *ax;
+
+   /* Store covariance matrices in full covariance form or not */
+   if (full) {      
+      for (ax=xform,full=FALSE; (ax!=NULL) && (full==FALSE); ax=ax->parentXForm) {
+         full |= ((ax->xformSet->xkind==MLLRCOV) 
+               || (ax->xformSet->xkind==CMLLR) 
+               || (ax->xformSet->xkind==SEMIT));
+      }
+   }
 
    if (xform != NULL) {
       hset = xform->hset;
@@ -4045,23 +5147,28 @@ void ApplyCompXForm(MixPDF *mp, AdaptXFo
          ai = GetAInfo(mp);
       else if (xform == hset->parentXForm) {
          ai = GetPAInfo(mp);
-      } else 
+      } 
+      else 
          HError(999,"Can only apply parent and current transform");
-      CompXForm(mp,xform,ai);
+      CompXForm(mp,xform,ai,full);
    }
 }
 
-Vector ApplyCompFXForm(MixPDF *mp, Vector svec, AdaptXForm *xform, LogFloat *det, int t)
+/* EXPORT->ApplyCompFXForm: apply component-specific xform to given observation */
+Vector ApplyCompFXForm(MixPDF *mp, Vector svec, AdaptXForm *xform, LogFloat *det, const int t)
 {
   AInfo *ai = NULL;
   ObsCache *oc = NULL;
   Vector vec;
   HMMSet *hset;
+   int vSize;
 
-  if (xform == NULL) {
+   vSize=VectorSize(mp->mean);
+   if (xform==NULL || SpaceOrder(svec)==0 || SpaceOrder(svec)!=vSize) {
      *det = 0;
      return svec;
-  }  else {
+   }  
+   else {
     hset = xform->hset;
     if (mp->info == NULL)
       HError(999,"No adaptation information for component");
@@ -4072,14 +5179,15 @@ Vector ApplyCompFXForm(MixPDF *mp, Vecto
     else if (xform == hset->parentXForm) {
       ai = GetPAInfo(mp);
       oc = GetPAObsCache(mp);
-    } else 
+      } 
+      else 
       HError(999,"Can only apply parent and current transform");
 
-    *det = 0; 
+      *det = 0.0;
     if ( oc != NULL ) {
       if (oc->time != t ) {
-	vec = CreateVector(&gstack,VectorSize(svec));
-	CopyVector(svec,vec);
+            vec = CreateVector(&gstack,vSize);
+            CopyRVector(svec,vec,vSize);
         CompFXForm(mp,vec,xform,ai,det);
         UpdateObsCache(oc, vec, *det,t);  
 	FreeVector(&gstack,vec); 
@@ -4088,37 +5196,55 @@ Vector ApplyCompFXForm(MixPDF *mp, Vecto
       vec = oc->obs;
       *det = oc->det;
       return vec;
-    } else {
-       *det = 0;
+      } 
+      else {
+         *det = 0.0;
        return svec;
     }
   }
 }
 
-void ApplyHMMSetXForm(HMMSet *hset, AdaptXForm *xform)
+/* EXPORT->ApplyHMMSetXForm: apply given xform to hset */
+void ApplyHMMSetXForm(HMMSet *hset, AdaptXForm *xform, Boolean full)
 {
   HMMScanState hss;
+   AdaptXForm *ax;
   int nAdpt=0;
 
+   /* Store covariance matrices in full covariance form or not */
+   if (full) {      
+      for (ax=xform,full=FALSE; (ax!=NULL) && (full==FALSE); ax=ax->parentXForm) {
+         full |= ((ax->xformSet->xkind==MLLRCOV) 
+               || (ax->xformSet->xkind==CMLLR) 
+               || (ax->xformSet->xkind==SEMIT));
+      }
+   }
+
   /* Only created XForm and parent Xform strutures */
   if ((xform != hset->curXForm) && (xform != hset->parentXForm))
     HError(999,"Can only apply parent and current transform");
+      
   NewHMMScan(hset,&hss);
   do {
     while (GoNextState(&hss,TRUE)) {
       while (GoNextStream(&hss,TRUE)) {            
 	if (hss.isCont)                     /* PLAINHS or SHAREDHS */
 	  while (GoNextMix(&hss,TRUE)) {
-	    ApplyCompXForm(hss.mp,xform);
+                  ApplyCompXForm(hss.mp,xform,full);
 	    nAdpt++;
 	  }
       }
     }
   } while (GoNextHMM(&hss));
   EndHMMScan(&hss);
+   
+   if (full)
+      hset->ckind = FULLC;
+      
   if (trace&T_ADT) printf("Adapted %d components\n",nAdpt);
 }
 
+/* EXPORT->ResetXFormHMMSet: reset applied xform */
 void ResetXFormHMMSet(HMMSet *hset)
 {
    HMMScanState hss;
@@ -4135,8 +5261,10 @@ void ResetXFormHMMSet(HMMSet *hset)
       }
    } while (GoNextHMM(&hss));
    EndHMMScan(&hss);
-}
 
+   if (hset->ckind==FULLC)
+      hset->ckind = DIAGC;
+}
 
 /* ---------------  Transform Copying Functions  ----------------------- */
 
@@ -4154,8 +5282,10 @@ LinXForm *CopyLinXForm(MemHeap *x, LinXF
    if (xf->bias != NULL) {
       nxf->bias = CreateSVector(x,xf->vecSize);
       CopyVector(xf->bias,nxf->bias);
-   } else
+   } 
+   else
       nxf->bias = NULL;
+
    if (xf->vFloor != NULL) {
       nxf->vFloor = CreateSVector(x,VectorSize(xf->vFloor));
       CopyVector(xf->vFloor,nxf->vFloor);
@@ -4159,7 +5289,8 @@ LinXForm *CopyLinXForm(MemHeap *x, LinXF
    if (xf->vFloor != NULL) {
       nxf->vFloor = CreateSVector(x,VectorSize(xf->vFloor));
       CopyVector(xf->vFloor,nxf->vFloor);
-   } else
+   }
+   else
       nxf->vFloor = NULL;
    nxf->xform = (Matrix *)New(x,(IntVecSize(xf->blockSize)+1)*sizeof(Matrix));
    for (bl=1;bl<=IntVecSize(xf->blockSize);bl++) {
@@ -4212,7 +5343,8 @@ AdaptXForm *CopyAdaptXForm(MemHeap *x, A
    if (HardAssign(xform)) {
       nxform->xformWgts.assign = CreateIntVec(x,IntVecSize(xform->xformWgts.assign));
       CopyIntVec(xform->xformWgts.assign,nxform->xformWgts.assign);
-   } else {
+   } 
+   else {
       HError(999,"Not currently supported");
    }
    
@@ -4221,101 +5353,39 @@ AdaptXForm *CopyAdaptXForm(MemHeap *x, A
 
 /* ---------------  Transform Estimation Functions ----------------------- */
 
-AdaptXForm *CreateAdaptXForm(HMMSet *hset, char *xformName)
+AdaptXForm *CreateAdaptXForm(HMMSet *hset, XFInfo *xfinfo, char *xformName)
 {
-   AdaptXForm *xform;
+   AdaptXForm *xform,*diagCovXForm;
 
    /* The macroname is not defined at this stage, to avoid
       over-writing the old version */
-   xform = CreateBaseAdaptXForm(hset,xformName);
+   xfinfo->outXForm = xform = CreateBaseAdaptXForm(hset,xfinfo,xformName);
    if (mllrDiagCov) { /* additional code for efficient diag Cov */     
-     diagCovXForm = CreateBaseAdaptXForm(hset,xformName);
+      xfinfo->diagCovXForm = diagCovXForm = CreateBaseAdaptXForm(hset,xfinfo,xformName);
      /* fix the parent xform and attributes */
      if (xform->parentXForm != NULL) xform->parentXForm->nUse--;
      diagCovXForm->parentXForm = xform;
      diagCovXForm->xformSet->xkind = MLLRVAR;
      diagCovXForm->info = xform->info;
    }
-   if (!hset->attRegAccs) AttachRegAccs(hset,xform);
-   outXForm = xform;
+   if (!hset->attRegAccs) AttachRegAccs(hset,xfinfo);
+   xfinfo->outXForm = xform;
    return xform;
 }
 
-InputXForm *AdaptXForm2InputXForm(HMMSet *hset, AdaptXForm *xform)
-{
-   InputXForm *ixform;
-   int s,i,j,cnt,hldasize;
-   char mac[256], num[10];
-   LabId id;
-   MLink m;
-   SVector v;
-   SMatrix mat;
-
-   if (xform->bclass->numClasses != 1)
-      HError(999,"Can only use Stream Projections with single base classes");
-   ixform = (InputXForm *)New(hset->hmem,sizeof(InputXForm));
-   ixform->xformName = xform->xformName;
-   ixform->mmfIdMask = xform->bclass->mmfIdMask;
-   ixform->fname = NULL;
-   ixform->pkind = xform->hset->pkind;
-   ixform->preQual = FALSE;
-   ixform->xform = xform->xformSet->xforms[1];
-   if ((numNuisanceDim > 0) || (hset->projSize>0)) { /* adjust size to remove HLDA */
-      if (numNuisanceDim>0) hldasize = hset->vecSize-numNuisanceDim;
-      else hldasize = hset->vecSize-hset->projSize;
-      mat = CreateSMatrix(hset->hmem,hldasize,hset->vecSize);
-      for (i=1;i<=hldasize;i++)
-         for (j=1;j<=hset->vecSize;j++)
-            mat[i][j] = ixform->xform->xform[1][i][j];
-      ixform->xform->xform[1] = mat;
-   } 
-   /* 
-      Update the HMMSet vFloor and then zero xf vFloor. For input
-      xforms the HMMSet vFloor always  used.
-   */
-   if ((numNuisanceDim > 0) || (hset->projSize>0)) {
-      strcpy(mac,"varFloor1");
-      id = GetLabId(mac,FALSE);
-      if (id != NULL  && (m=FindMacroName(hset,'v',id)) != NULL){
-         /* found the varFloor to update */
-         if (numNuisanceDim>0) hldasize = hset->vecSize-numNuisanceDim;
-         else hldasize = hset->vecSize-hset->projSize;
-         v = CreateSVector(hset->hmem,hldasize);
-         for (i=1;i<=hldasize;i++) 
-            v[i] = ixform->xform->vFloor[i];
-         m->structure = v;
-      }
-   } else {
-      for (s=1,cnt=1;s<=hset->swidth[0];s++) {
-         strcpy(mac,"varFloor");
-         sprintf(num,"%d",s); strcat(mac,num);
-         id = GetLabId(mac,FALSE);
-         if (id != NULL  && (m=FindMacroName(hset,'v',id)) != NULL){
-            /* found the varFloor to update */
-            v = (SVector)m->structure;
-            for (i=1;i<=hset->swidth[s];i++,cnt++) 
-               v[i] = ixform->xform->vFloor[cnt];
-         }
-      }
-   }
-   ixform->xform->vFloor = NULL;
-   ixform->nUse = 0;
-
-   return ixform;
-}
-
-Boolean GenAdaptXForm(HMMSet *hset, AdaptXForm* xform)
+Boolean GenAdaptXForm(HMMSet *hset, XFInfo *xfinfo)
 {
    AdaptKind akind;
    Boolean genXForm = FALSE;
+   AdaptXForm *xform = xfinfo->outXForm;
 
    akind = xform->akind;
    switch(akind) {
    case TREE: 
-      genXForm = ParseTree(xform->rtree,xform);
+      genXForm = ParseTree(xfinfo);
       break;
    case BASE:
-      genXForm = GenClassXForm(xform->bclass,xform);
+      genXForm = GenClassXForm(xfinfo);
       break;
    default:
       HError(999,"Only TREE and BASE adaptation kinds currently supported");
@@ -4325,19 +5395,21 @@ Boolean GenAdaptXForm(HMMSet *hset, Adap
    return genXForm;
 }
 
-void TidyBaseAccs()
+void TidyBaseAccs(XFInfo *xfinfo)
 {
-   SetBaseAccsTime(-1);
-   if (headac == NULL )
-      UpdateBaseAccs(NULL);
+   SetBaseAccsTime(xfinfo,-2);
+   if (xfinfo->headac==NULL)
+      UpdateBaseAccs(xfinfo,NULL,-1,NULL);
    else { 
-      UpdateBaseAccsWithPaac();
-      ResetAccCache();
+      UpdateBaseAccsWithPaac(xfinfo,-1);
+      ResetAccCache(xfinfo,-1);
    }
 }
 
-AdaptXForm *GetMLLRDiagCov(AdaptXForm *xform)
+AdaptXForm *GetMLLRDiagCov(XFInfo *xfinfo, AdaptXForm *xform)
 {
+   AdaptXForm *diagCovXForm = xfinfo->diagCovXForm;
+   
    if (diagCovXForm == NULL)
       return xform;
    else 
@@ -4355,12 +5427,9 @@ Boolean UpdateSpkrStats(HMMSet *hset, XF
    char newMn[MAXSTRLEN];
    char spkr[MAXSTRLEN];
    char paspkr[MAXSTRLEN];
-   static char coutspkr[MAXSTRLEN];
-   static char cinspkr[MAXSTRLEN];
-   static char cpaspkr[MAXSTRLEN];
-   static int nspkr = 0;
    Boolean resetHMMSet = FALSE, maskMatch;
    Boolean spkrChange = FALSE;
+   int s;
 
    if (!((hset->hsKind == PLAINHS) || (hset->hsKind == SHAREDHS))
        && (xfinfo->useOutXForm || xfinfo->useInXForm || xfinfo->usePaXForm )) {
@@ -4371,31 +5440,32 @@ Boolean UpdateSpkrStats(HMMSet *hset, XF
       maskMatch = MaskMatch(xfinfo->outSpkrPat,spkr,datafn);
       if ((!maskMatch) && (datafn != NULL))
          HError(999,"Output xform mask %s does not match filename %s",xfinfo->outSpkrPat,datafn);
-      if ((datafn == NULL) || ((coutspkr!=NULL) && strcmp(spkr,coutspkr))) {
+      if ((datafn == NULL) || (strcmp(spkr,xfinfo->coutspkr))) {
          /* end of current speaker, so complete his/her transform */
-         if (nspkr>0) { /* nothing to generate if first speaker */
+         if (xfinfo->nspkr>0) { /* nothing to generate if first speaker */
             if (trace&T_SXF)
-               printf("Generating transform %s (%i)\n",coutspkr,nspkr);
+               printf("Generating transform %s (%i)\n",xfinfo->coutspkr,xfinfo->nspkr);
             /* Tidy the statistics of the last frame */
-            SetBaseAccsTime(-1);
-            if (headac == NULL )
-               UpdateBaseAccs(NULL);
+            SetBaseAccsTime(xfinfo,-2);
+            if (xfinfo->headac==NULL)
+               UpdateBaseAccs(xfinfo,NULL,-1,NULL);
             else { 
-               UpdateBaseAccsWithPaac();
-               ResetAccCache();
+               UpdateBaseAccsWithPaac(xfinfo,-1);
+               ResetAccCache(xfinfo,-1);
             }
             /* Generate the new transform */
-            MakeFN(coutspkr,NULL,xfinfo->outXFormExt,newMn);
-            xfinfo->outXForm = CreateAdaptXForm(hset, newMn);
-            GenAdaptXForm(hset,xfinfo->outXForm);
-	    if (mllrDiagCov) xfinfo->outXForm = diagCovXForm;
+            MakeFN(xfinfo->coutspkr,NULL,xfinfo->outXFormExt, newMn);
+            xfinfo->outXForm = CreateAdaptXForm(hset, xfinfo, newMn);
+            GenAdaptXForm(hset,xfinfo);
+            if (mllrDiagCov) xfinfo->outXForm = xfinfo->diagCovXForm;
             /* After generating a transform need to reset parameters */
             resetHMMSet = TRUE;
             if (keepXFormDistinct) {  /* Output individual transform */
-               MakeFN(coutspkr,xfinfo->outXFormDir,xfinfo->outXFormExt,newFn);
+               MakeFN(xfinfo->coutspkr,xfinfo->outXFormDir,xfinfo->outXFormExt,newFn);
                SaveOneXForm(hset,xfinfo->outXForm,newFn,xfinfo->saveBinary);
-            } else { /* Create macro from the masked speaker name and extension */
-               MakeFN(coutspkr,NULL,xfinfo->outXFormExt,newMn);
+            } 
+            else { /* Create macro from the masked speaker name and extension */
+               MakeFN(xfinfo->coutspkr,NULL,xfinfo->outXFormExt,newMn);
                CreateXFormMacro(hset,xfinfo->outXForm,newMn);
             }
             if (saveSpkrModels) { 
@@ -4404,128 +5474,175 @@ Boolean UpdateSpkrStats(HMMSet *hset, XF
                   including extension is used to distinguish models.
                   First set the adaptation up.
                */
-               SetXForm(hset,xfinfo->outXForm);
-               ApplyHMMSetXForm(hset, xfinfo->outXForm);	   
+               SetXForm(hset,xfinfo,xfinfo->outXForm);
+               ApplyHMMSetXForm(hset, xfinfo->outXForm, xfinfo->outFullC);
                ForceDiagC(hset);
                SaveHMMSet(hset,xfinfo->outXFormDir,newMn,newMn,xfinfo->saveBinary);
                ConvDiagC(hset,TRUE);
                /* remembering to reset the transform */
-               if (xfinfo->useInXForm) {
-		 SetXForm(hset,xfinfo->inXForm);
-               }else{
-		 SetXForm(hset,NULL);
-	       }
+               if (xfinfo->useInXForm) 
+                  SetXForm(hset,xfinfo,xfinfo->inXForm);
+               else
+                  SetXForm(hset,xfinfo,NULL);
             }
             spkrChange = TRUE;
             ZeroAdaptAccs(hset,xfinfo->outXForm);
-            if (xfinfo->usePaXForm && (datafn != NULL)) {
+            if ((xfinfo->usePaXForm || xfinfo->use_alPaXForm) && (datafn != NULL)) {
                maskMatch = MaskMatch(xfinfo->paSpkrPat,paspkr,datafn);
                if (!maskMatch)
                   HError(999,"Parent xform mask %s does not match filename %s",xfinfo->paSpkrPat,datafn);
                /* parent transform changed and not the last file? */
-               if (strcmp(paspkr,cpaspkr)) { 
-                  strcpy(cpaspkr,paspkr);
-                  MakeFN(cpaspkr,xfinfo->paXFormDir,xfinfo->paXFormExt,newFn);
-                  MakeFN(cpaspkr,NULL,xfinfo->paXFormExt,newMn);
+               if (strcmp(paspkr,xfinfo->cpaspkr)) { 
+                  strcpy(xfinfo->cpaspkr,paspkr);
+                  if (xfinfo->usePaXForm) {
+                     MakeFN(xfinfo->cpaspkr,xfinfo->paXFormDir,xfinfo->paXFormExt,newFn);
+                     MakeFN(xfinfo->cpaspkr,NULL,xfinfo->paXFormExt,newMn);
                   xfinfo->paXForm = LoadOneXForm(hset,newMn,newFn);
-                  SetParentXForm(hset,xfinfo->paXForm);
+                     SetParentXForm(hset,xfinfo,xfinfo->paXForm);
+                     SetAccCache(xfinfo);
+                  }
+                  if (xfinfo->al_hset!=NULL && xfinfo->use_alPaXForm) {
+                     MakeFN(xfinfo->cpaspkr,xfinfo->al_paXFormDir,xfinfo->al_paXFormExt,newFn);
+                     MakeFN(xfinfo->cpaspkr,NULL,xfinfo->al_paXFormExt,newMn);
+                     xfinfo->al_paXForm = LoadOneXForm(xfinfo->al_hset,newMn,newFn);
+                     SetParentXForm(xfinfo->al_hset,xfinfo,xfinfo->al_paXForm);
+                     SetAccCache(xfinfo);
+                  }
+                  else
+                     xfinfo->al_paXForm = xfinfo->paXForm;
                }
-            } else if (hset->semiTied != NULL) { /* model set uses a semitied transform */
-               if (xfinfo->paXForm == NULL) { /* semi-tied transform is for all files */
-                  xfinfo->paXForm = hset->semiTied;
-                  SetParentXForm(hset,xfinfo->paXForm);
                }
             }
-         } else if (xfinfo->usePaXForm) { /* set-up the initial parent transform information */
+         else if (xfinfo->usePaXForm || xfinfo->use_alPaXForm) { /* set-up the initial parent transform information */
             maskMatch = MaskMatch(xfinfo->paSpkrPat,paspkr,datafn);
             if (!maskMatch)
                HError(999,"Parent xform mask %s does not match filename %s",xfinfo->paSpkrPat,datafn);
-            strcpy(cpaspkr,paspkr);
-            MakeFN(cpaspkr,xfinfo->paXFormDir,xfinfo->paXFormExt,newFn);
-            MakeFN(cpaspkr,NULL,xfinfo->paXFormExt,newMn);
+            strcpy(xfinfo->cpaspkr,paspkr);
+            if (xfinfo->usePaXForm) {
+               MakeFN(xfinfo->cpaspkr,xfinfo->paXFormDir,xfinfo->paXFormExt,newFn);
+               MakeFN(xfinfo->cpaspkr,NULL,xfinfo->paXFormExt,newMn);
             xfinfo->paXForm = LoadOneXForm(hset,newMn,newFn);
-            SetParentXForm(hset,xfinfo->paXForm);
-         } else if (hset->semiTied != NULL) { /* model set uses a semitied transform */
-            if (xfinfo->paXForm == NULL) { /* semi-tied transform is for all files */
-               xfinfo->paXForm = hset->semiTied;
-               SetParentXForm(hset,xfinfo->paXForm);
+               SetParentXForm(hset,xfinfo,xfinfo->paXForm);
+               SetAccCache(xfinfo);
             }
+            if (xfinfo->al_hset!=NULL && xfinfo->use_alPaXForm) {
+               MakeFN(xfinfo->cpaspkr,xfinfo->al_paXFormDir,xfinfo->al_paXFormExt,newFn);
+               MakeFN(xfinfo->cpaspkr,NULL,xfinfo->al_paXFormExt,newMn);
+               xfinfo->al_paXForm = LoadOneXForm(xfinfo->al_hset,newMn,newFn);
+               SetParentXForm(xfinfo->al_hset,xfinfo,xfinfo->al_paXForm);
+               SetAccCache(xfinfo);
          }
-         nspkr++;
-         strcpy(coutspkr,spkr);      
-      } else if (xfinfo->usePaXForm) { 
+            else
+               xfinfo->al_paXForm = xfinfo->paXForm;
+         }
+         
+         if (datafn!=NULL) {
+            xfinfo->nspkr++;
+            strcpy(xfinfo->coutspkr,spkr);
+         }      
+      } 
+      else if (xfinfo->usePaXForm || xfinfo->use_alPaXForm) { 
          /* check to see whether the parent transform changes */
          /* this should not happen */
          MaskMatch(xfinfo->paSpkrPat,paspkr,datafn);
-         if (strcmp(paspkr,cpaspkr)) 
+         if (strcmp(paspkr,xfinfo->cpaspkr)) 
             HError(999,"Changing parent transform out of sync with output transform (%s %s)",
-                   paspkr,cpaspkr);
+                   paspkr,xfinfo->cpaspkr);
+      }
       }
-   } else if (xfinfo->usePaXForm && (datafn != NULL)) {
+   else if ((xfinfo->usePaXForm || xfinfo->use_alPaXForm) && (datafn != NULL)) {
       /* Parent transform specified with no output transform */
       maskMatch = MaskMatch(xfinfo->paSpkrPat,paspkr,datafn);
       if (!maskMatch)
          HError(999,"Parent xform mask %s does not match filename %s",xfinfo->paSpkrPat,datafn);
       /* parent transform changed and not the last file? */
-      if (strcmp(paspkr,cpaspkr)) { 
-         strcpy(cpaspkr,paspkr);
-         MakeFN(cpaspkr,xfinfo->paXFormDir,xfinfo->paXFormExt,newFn);
-         MakeFN(cpaspkr,NULL,xfinfo->paXFormExt,newMn);
+      if (strcmp(paspkr,xfinfo->cpaspkr)) { 
+         strcpy(xfinfo->cpaspkr,paspkr);
+         if (xfinfo->usePaXForm) {  /* parent xform for hset */
+            MakeFN(xfinfo->cpaspkr,xfinfo->paXFormDir,xfinfo->paXFormExt,newFn);
+            MakeFN(xfinfo->cpaspkr,NULL,xfinfo->paXFormExt,newMn);
          xfinfo->paXForm = LoadOneXForm(hset,newMn,newFn);
-         SetParentXForm(hset,xfinfo->paXForm);
+            SetParentXForm(hset,xfinfo,xfinfo->paXForm);
+            SetAccCache(xfinfo);
       }
-      spkrChange=TRUE;
-   } else if (hset->semiTied != NULL) { /* model set uses a semitied transform */
+         else if (hset->semiTied != NULL) { /* model set uses a semitied transform */
       if (xfinfo->paXForm == NULL) { /* semi-tied transform is for all files */
          xfinfo->paXForm = hset->semiTied;
-         SetParentXForm(hset,xfinfo->paXForm);
+               SetParentXForm(hset,xfinfo,xfinfo->paXForm);
+               SetAccCache(xfinfo);
       }
+         }
+         if (xfinfo->al_hset!=NULL) {
+            if (xfinfo->use_alPaXForm) {  /* parent xform for al_hset */
+               MakeFN(xfinfo->cpaspkr,xfinfo->al_paXFormDir,xfinfo->al_paXFormExt,newFn);
+               MakeFN(xfinfo->cpaspkr,NULL,xfinfo->al_paXFormExt,newMn);
+               xfinfo->al_paXForm = LoadOneXForm(xfinfo->al_hset,newMn,newFn);
+               SetParentXForm(xfinfo->al_hset,xfinfo,xfinfo->al_paXForm);
+               SetAccCache(xfinfo);
+            }
+            else if (xfinfo->al_hset->semiTied != NULL) { /* model set uses a semitied transform */
+               if (xfinfo->al_paXForm == NULL) { /* semi-tied transform is for all files */
+                  xfinfo->al_paXForm = xfinfo->al_hset->semiTied;
+                  SetParentXForm(xfinfo->al_hset,xfinfo,xfinfo->al_paXForm);
+                  SetAccCache(xfinfo);
+               }
+            }
+         }
+         else 
+            xfinfo->al_paXForm = xfinfo->paXForm;
+
       spkrChange=TRUE;
-   } else 
-      spkrChange=TRUE;
+      }
+   } 
 
    /* Second: handle input transform */
-   if (xfinfo->useInXForm  && (datafn != NULL)) {
+   if ((xfinfo->useInXForm || xfinfo->use_alInXForm) && (datafn != NULL)) {
       maskMatch = MaskMatch(xfinfo->inSpkrPat,spkr,datafn);
       if (!maskMatch)
          HError(999,"Input xform mask %s does not match filename %s",xfinfo->inSpkrPat,datafn);
       /* if a transform has been changed the input transform must be 
          reapplied */
-      if (((cinspkr!=NULL) && strcmp(spkr,cinspkr)) || (resetHMMSet)) {
+      if (strcmp(spkr,xfinfo->cinspkr) || resetHMMSet) {
          if (trace&T_SXF)
             printf("Using input transform %s\n",spkr);
-         strcpy(cinspkr,spkr);      
-         MakeFN(cinspkr,NULL,xfinfo->inXFormExt,newMn);
+         strcpy(xfinfo->cinspkr,spkr);      
+         if (xfinfo->useInXForm) {  /* input xform for hset */
+            MakeFN(xfinfo->cinspkr,NULL,xfinfo->inXFormExt,newMn);
          xfinfo->inXForm = LoadOneXForm(hset,newMn,NULL);
-         SetXForm(hset,xfinfo->inXForm);
-         ApplyHMMSetXForm(hset,xfinfo->inXForm);
-         if (xfinfo->al_hset != NULL) {
-            MakeFN(cinspkr,xfinfo->alXFormDir,xfinfo->alXFormExt,newFn);
-            MakeFN(cinspkr,NULL,xfinfo->alXFormExt,newMn);
+            SetXForm(hset,xfinfo,xfinfo->inXForm);
+            ApplyHMMSetXForm(hset,xfinfo->inXForm,xfinfo->inFullC);
+         }
+         if (xfinfo->al_hset!=NULL && xfinfo->use_alInXForm) {  /* input xform for al_hset */
+            MakeFN(xfinfo->cinspkr,xfinfo->al_inXFormDir,xfinfo->al_inXFormExt,newFn);
+            MakeFN(xfinfo->cinspkr,NULL,xfinfo->al_inXFormExt,newMn);
             xfinfo->al_inXForm = LoadOneXForm(xfinfo->al_hset,newMn,newFn);
-            SetXForm(xfinfo->al_hset,xfinfo->al_inXForm);
-            ApplyHMMSetXForm(xfinfo->al_hset,xfinfo->al_inXForm);
-         } else {
+            SetXForm(xfinfo->al_hset,xfinfo,xfinfo->al_inXForm);
+            ApplyHMMSetXForm(xfinfo->al_hset,xfinfo->al_inXForm,FALSE);
+         } 
+         else 
             xfinfo->al_inXForm = xfinfo->inXForm;
+
+         spkrChange = TRUE;
          }
       }
-   } else if (resetHMMSet && (xfinfo->usePaXForm || (xfinfo->inXForm != NULL) || saveSpkrModels)) { 
+   else if (resetHMMSet && (xfinfo->usePaXForm || (xfinfo->inXForm != NULL) || saveSpkrModels)) { 
       /* 
          Reset model parameters as transform generated using 
          a parent transform - it is possible to be more efficient 
          if the nature of the transform is also considered 
       */
       ResetXFormHMMSet(hset);
-   } else { /* handle the fact that alignment and update HMMSet may use semi-tied transforms */
+   }
+   else { /* handle the fact that alignment and update HMMSet may use semi-tied transforms */
       if ((xfinfo->inXForm == NULL) && (xfinfo->al_inXForm == NULL)) { /* semi-tied transform is for all files */
          if (hset->semiTied != NULL) { /* model set uses a semitied transform */
             xfinfo->inXForm = hset->semiTied;
-            SetXForm(hset,xfinfo->inXForm);
+            SetXForm(hset,xfinfo,xfinfo->inXForm);
          }
          if (xfinfo->al_hset != NULL) {
             if (xfinfo->al_hset->semiTied != NULL) { /* alignment model set uses a semitied transform */
                xfinfo->al_inXForm = xfinfo->al_hset->semiTied;
-               SetXForm(xfinfo->al_hset,xfinfo->al_inXForm);
+               SetXForm(xfinfo->al_hset,xfinfo,xfinfo->al_inXForm);
             }
          } else {
             xfinfo->al_inXForm = xfinfo->inXForm;
@@ -4538,12 +5656,21 @@ Boolean UpdateSpkrStats(HMMSet *hset, XF
       if (!keepXFormDistinct) {
          if (xfinfo->xformTMF == NULL) {
             MakeFN("TMF",xfinfo->outXFormDir,NULL,newFn);
-            SaveAllXForms(hset,newFn,xfinfo->saveBinary);
-         } else 
+         } 
+         else {
             MakeFN(xfinfo->xformTMF,xfinfo->outXFormDir,NULL,newFn);
+         }
             SaveAllXForms(hset,newFn,xfinfo->saveBinary);
       }
+      
+      /* reset static variables for speaker name */
+      for (s=0; s<MAXSTRLEN; s++){
+         xfinfo->coutspkr[s] = '\0';
+         xfinfo->cpaspkr[s] = '\0';
+         xfinfo->cinspkr[s] = '\0';
+      }
    }
+
    return spkrChange;
 }
 
@@ -4556,9 +5683,11 @@ void UpdateSemiTiedModels(HMMSet *hset, 
    if (semiTiedMacro == NULL) {
       if (numNuisanceDim > 0) newMn = "HLDA";
       else newMn = "SEMITIED";
-   } else newMn = semiTiedMacro;
-   xfinfo->outXForm = CreateAdaptXForm(hset, newMn);
-   GenAdaptXForm(hset,xfinfo->outXForm);
+   } 
+   else 
+      newMn = semiTiedMacro;
+   xfinfo->outXForm = CreateAdaptXForm(hset, xfinfo, newMn);
+   GenAdaptXForm(hset,xfinfo);
    CreateXFormMacro(hset,xfinfo->outXForm,newMn);
    MakeFN(newMn,xfinfo->outXFormDir,xfinfo->outXFormExt,newFn);
    if ((strmProj) || (semiTied2InputXForm)) {
@@ -4567,7 +5696,8 @@ void UpdateSemiTiedModels(HMMSet *hset, 
       hset->xf = ixform;
       if (numNuisanceDim>0) UpdateHLDAModel(hset);
       SaveInputXForm(hset,ixform,newFn,saveSemiTiedBinary);
-   } else {
+   } 
+   else {
       hset->projSize = numNuisanceDim;
       hset->semiTied = xfinfo->outXForm;
       SaveOneXForm(hset,xfinfo->outXForm,newFn,saveSemiTiedBinary);
@@ -4594,4 +5724,51 @@ void UpdateProjectModels(HMMSet *hset, c
    /* gconsts fixed in main script */
 }
 
+/* ApplyMapXForm: apply mapped xform to MixPDF */
+void ApplyMapXForm(MixPDF * mp, MixPDF * mp_map, AdaptXForm * xform, Boolean full)
+{
+   AInfo *ai = NULL;
+   HMMSet *hset;
+   AdaptXForm *ax;
+
+   /* Store covariance matrices in full covariance form or not */
+   if (full)
+      for (ax = xform, full = FALSE; (ax != NULL) && (full == FALSE); ax = ax->parentXForm)
+         full |= ((ax->xformSet->xkind == MLLRCOV) || (ax->xformSet->xkind == CMLLR) || (ax->xformSet->xkind == SEMIT));
+
+   if (xform != NULL) {
+      hset = xform->hset;
+      if (mp_map->info == NULL)
+         HError(999, "ApplyMapXForm: No adaptation information for component");
+      if (xform == hset->curXForm)      /* use adapt information from current Xform */
+         ai = GetAInfo(mp_map);
+      else if (xform == hset->parentXForm)
+         ai = GetPAInfo(mp_map);
+      else
+         HError(999, "ApplyMapXForm: Can only apply parent and current transform");
+      CompXForm(mp, xform, ai, full);
+   }
+}
+
+LinXForm* GetRelateXForm(HMMSet *hset, MixPDF *mp, XFormKind xkind)
+{
+   AInfo *ai = NULL;
+   AdaptXForm *xform;
+   int numXf;
+
+   xform = hset->curXForm;
+   ai = GetAInfo(mp);
+
+   while(ai) {
+      if(xform->xformSet->xkind == xkind) {
+         numXf = xform->xformWgts.assign[ai->baseClass];
+         return xform->xformSet->xforms[numXf];
+      }
+      ai = ai->next;
+      xform = xform->parentXForm;
+   }
+
+  return NULL;
+}
 
+/* ------------------------ End of HAdapt.c ------------------------ */
diff -pbBEwurNa --ignore-matching-lines='.*vc_id.*' HTK-3.4.1/HTKLib/HAdapt.h HTS-2.2_for_HTK-3.4.1/HTKLib/HAdapt.h
--- HTK-3.4.1/HTKLib/HAdapt.h	2009-03-11 19:07:40.000000000 +0900
+++ HTS-2.2_for_HTK-3.4.1/HTKLib/HAdapt.h	2011-06-16 13:15:50.000000000 +0900
@@ -28,6 +28,54 @@
 /*         File: HAdapt.h      Adaptation Library module       */
 /* ----------------------------------------------------------- */
 
+/*  *** THIS IS A MODIFIED VERSION OF HTK ***                        */
+/* ----------------------------------------------------------------- */
+/*           The HMM-Based Speech Synthesis System (HTS)             */
+/*           developed by HTS Working Group                          */
+/*           http://hts.sp.nitech.ac.jp/                             */
+/* ----------------------------------------------------------------- */
+/*                                                                   */
+/*  Copyright (c) 2001-2011  Nagoya Institute of Technology          */
+/*                           Department of Computer Science          */
+/*                                                                   */
+/*                2001-2008  Tokyo Institute of Technology           */
+/*                           Interdisciplinary Graduate School of    */
+/*                           Science and Engineering                 */
+/*                                                                   */
+/*                2008-2009  University of Edinburgh                 */
+/*                           Centre for Speech Technology Research   */
+/*                                                                   */
+/* All rights reserved.                                              */
+/*                                                                   */
+/* Redistribution and use in source and binary forms, with or        */
+/* without modification, are permitted provided that the following   */
+/* conditions are met:                                               */
+/*                                                                   */
+/* - Redistributions of source code must retain the above copyright  */
+/*   notice, this list of conditions and the following disclaimer.   */
+/* - Redistributions in binary form must reproduce the above         */
+/*   copyright notice, this list of conditions and the following     */
+/*   disclaimer in the documentation and/or other materials provided */
+/*   with the distribution.                                          */
+/* - Neither the name of the HTS working group nor the names of its  */
+/*   contributors may be used to endorse or promote products derived */
+/*   from this software without specific prior written permission.   */
+/*                                                                   */
+/* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND            */
+/* CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,       */
+/* INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF          */
+/* MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE          */
+/* DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS */
+/* BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,          */
+/* EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED   */
+/* TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,     */
+/* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON */
+/* ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,   */
+/* OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY    */
+/* OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE           */
+/* POSSIBILITY OF SUCH DAMAGE.                                       */
+/* ----------------------------------------------------------------- */
+
 #ifndef _HADAPT_H_
 #define _HADAPT_H_
 
@@ -35,6 +83,22 @@
 extern "C" {
 #endif
 
+/* observation cache to save rotated observations */
+typedef struct _ObsCache{
+   int time;
+   Vector obs;
+   float det;
+   struct _ObsCache *next;
+} ObsCache;
+
+/* acc cache to save accumulators related to parent XForm */
+typedef struct _AccCache{
+   int     baseclass;
+   DVector bVector;
+   DTriMat *bTriMat;
+   struct _AccCache *next;
+} AccCache;  
+
 typedef struct {
   char *outSpkrPat;
   char *inSpkrPat;
@@ -42,42 +106,122 @@ typedef struct {
   char *outXFormExt;
   char *inXFormExt;
   char *paXFormExt;
-  char *alXFormExt;
+   char *al_inXFormExt;
+   char *al_paXFormExt;
   char *outXFormDir;
   char *paXFormDir;
-  char *alXFormDir;
+   char *al_inXFormDir;
+   char *al_paXFormDir;
   Boolean useOutXForm;
   Boolean useInXForm;
   Boolean usePaXForm;
+   Boolean use_alInXForm;
+   Boolean use_alPaXForm;
+   Boolean outFullC;
+   Boolean inFullC;
   char *xformTMF;
   Boolean saveBinary;
   AdaptXForm *inXForm;
   AdaptXForm *outXForm;
   AdaptXForm *paXForm;
+   AdaptXForm *diagCovXForm;
   HMMSet *al_hset;
   AdaptXForm *al_inXForm;
+   AdaptXForm *al_paXForm;
+   
+   /* Transform Kind to be created */
+   XFormKind outXKind;  
+   
+   /* whether a bias is to be estimated for the xform */
+   Boolean useBias;
+   
+   /* split threshold definitions for each stream for each xform kind */
+   Vector xformSplitThresh;
+   Vector mllrMeanSplitThresh;
+   Vector mllrCovSplitThresh;
+   Vector cmllrSplitThresh;
+
+   /* adaptation kind  definitions for each xform kind */
+   AdaptKind xformAdaptKind;
+   AdaptKind mllrMeanAdaptKind;
+   AdaptKind mllrCovAdaptKind;
+   AdaptKind cmllrAdaptKind;
+
+   /* regression tree definitions for each xform kind */
+   char *xformRegTree;
+   char *mllrMeanRegTree;
+   char *mllrCovRegTree;
+   char *cmllrRegTree;
+
+   /* baseclass definitions for each xform kind */
+   char *xformBaseClass;
+   char *mllrMeanBaseClass;
+   char *mllrCovBaseClass;
+   char *cmllrBaseClass;
+
+   /* block size definitions for each xform kind for each stream */
+   IntVec xformBlockSize[SMAX];
+   IntVec mllrMeanBlockSize[SMAX];
+   IntVec mllrCovBlockSize[SMAX];
+   IntVec cmllrBlockSize[SMAX];
+
+   /* band width definitions for each xform kind for each stream */
+   IntVec xformBandWidth[SMAX];
+   IntVec mllrMeanBandWidth[SMAX];
+   IntVec mllrCovBandWidth[SMAX];
+   IntVec cmllrBandWidth[SMAX];
+
+   /* number of nuisance dimensions for HLDA transform estimation */
+   int numNuisanceDim;
+   
+   char coutspkr[MAXSTRLEN];
+   char cinspkr[MAXSTRLEN];
+   char cpaspkr[MAXSTRLEN];
+   int nspkr;
+   
+   /* current time when this changes accumulate complete stats */
+   /* -1 indicates that this is the first frame of a new file */
+   int baseTriMatTime;
+
+   ObsCache *headboc;
+   ObsCache *headpoc;
+   AccCache *headac;
+
+   MemHeap bobcaStack; /* base obscache */
+   MemHeap pobcaStack; /* parent obscache */
+   MemHeap acccaStack;			
+
+   /* specifies whether the transforms change the model variances */
+   Boolean covarChanged;
+   Boolean covarPChanged;
 } XFInfo;
 
 /* -------------------- Initialisation Functions -------------------------- */
 
-void InitAdapt(XFInfo *xfinfo);
+void InitAdapt(XFInfo *xfinfo_hmm, XFInfo *xfinfo_dur);
 /*
    Initialise configuration parameters
 */
 
-AdaptXForm *GetMLLRDiagCov(AdaptXForm *xform);
+void ResetAdapt (XFInfo *xfinfo_hmm, XFInfo *xfinfo_dur);
+/*
+   Reset adaptation module 
+*/
+
+AdaptXForm *GetMLLRDiagCov(XFInfo *xfinfo, AdaptXForm *xform);
+void CheckAdaptSetUp (HMMSet *hset, XFInfo *xfinfo);
 
 /* ---------------- Accumulation Control Functions ------------------------ */
 
-void SetBaseAccsTime(int t);
-void TidyBaseAccs();
+void SetBaseAccsTime(XFInfo *xfinfo, const int t);
+void TidyBaseAccs(XFInfo *xfinfo);
 /*
   Modifies the internal time of current frames. Is used to ensure that
   last frame is correctly added in using UpdateBaseTriMat
 */
 
 
-void AccAdaptFrame(HMMSet *hset, double Lr, Vector svec, MixPDF *mp, int t);
+void AccAdaptFrame(XFInfo *xfinfo, double Lr, Vector svec, MixPDF *mp, int t);
 /* 
    Accumulate frame stats into specific mixture comp transformed using parent
 */
@@ -89,14 +233,14 @@ void ZeroAdaptAccs(HMMSet *hset, AdaptXF
 
 /* ---------------- Applying Transform Functions ------------------------ */
 
-void SetXForm(HMMSet *hset, AdaptXForm *xform);
+void SetXForm(HMMSet *hset, XFInfo *xfinfo, AdaptXForm *xform);
 /*
   Set the current transform to xform. This must be executed
   prior to applying any adaptation transforms. Setting xform 
   to NULL turns off the input transformation.
 */
 
-void SetParentXForm(HMMSet *hset, AdaptXForm *xform);
+void SetParentXForm(HMMSet *hset, XFInfo *xfinfo, AdaptXForm *xform);
 /*
   Set the parent transform to xform. If this is not set the
   default functionality is to build a transform on top of
@@ -105,12 +249,12 @@ void SetParentXForm(HMMSet *hset, AdaptX
   space.
 */
 
-void ApplyHMMSetXForm(HMMSet *hset, AdaptXForm* xform);
+void ApplyHMMSetXForm(HMMSet *hset, AdaptXForm* xform, Boolean full);
 /*
   Apply current transform (and parents) to complete model set.
 */
 
-void ApplyCompXForm(MixPDF *mp, AdaptXForm* xform);
+void ApplyCompXForm(MixPDF *mp, AdaptXForm* xform, Boolean full);
 /*
   Apply current transform (and parents) to a component.
 */
@@ -122,7 +266,7 @@ Vector ApplyCompFXForm(MixPDF *mp, Vecto
   IMPORTANT: Do not alter the values of the returned vector
 */
 
-void ResetObsCache(void);
+void ResetObsCache(XFInfo *xfinfo);
 
 void ResetXFormHMMSet(HMMSet *hset);
 /*
@@ -151,13 +295,13 @@ AdaptXForm *CopyAdaptXForm(MemHeap *x, A
 
 /* ---------------  Transform Estimation Functions ----------------------- */
 
-AdaptXForm *CreateAdaptXForm(HMMSet *hset, char* xformName);
+AdaptXForm *CreateAdaptXForm(HMMSet *hset, XFInfo *xfinfo, char *xformName);
 /*
   Creates a new output transform. xformName will eventually
   be used as the macroname for the transform.
 */
 
-Boolean GenAdaptXForm(HMMSet *hset, AdaptXForm* xform);
+Boolean GenAdaptXForm(HMMSet *hset, XFInfo *xfinfo);
 /*
   Estimate the transform using the information and regression
   trees specified in the configuration files. Returns FALSE
@@ -188,6 +332,11 @@ void UpdateProjectModels(HMMSet *hset, c
   Applies the projection to the HMMSet and stores transforms etc.
 */
 
+/* for AX command in HHEd */
+void AttachXFormInfo(HMMSet *hset);
+void ApplyMapXForm(MixPDF *mp, MixPDF *mp_map, AdaptXForm *xform, Boolean full);
+
+LinXForm* GetRelateXForm(HMMSet *hset, MixPDF *mp, XFormKind xkind);
 
 #ifdef __cplusplus
 }
@@ -195,4 +344,4 @@ void UpdateProjectModels(HMMSet *hset, c
 
 #endif  /* _HADAPT_H_ */
 
-/* ---------------------------- END HAdapt.h ------------------------------ */
+/* ------------------------ End of HAdapt.h ------------------------ */
diff -pbBEwurNa --ignore-matching-lines='.*vc_id.*' HTK-3.4.1/HTKLib/HArc.c HTS-2.2_for_HTK-3.4.1/HTKLib/HArc.c
--- HTK-3.4.1/HTKLib/HArc.c	2009-03-13 03:41:53.000000000 +0900
+++ HTS-2.2_for_HTK-3.4.1/HTKLib/HArc.c	2011-06-16 13:18:28.000000000 +0900
@@ -26,8 +26,53 @@
 /*         File: HArc.c   Forward Backward routines        */
 /* ----------------------------------------------------------- */
 
+/*  *** THIS IS A MODIFIED VERSION OF HTK ***                        */
+/* ----------------------------------------------------------------- */
+/*           The HMM-Based Speech Synthesis System (HTS)             */
+/*           developed by HTS Working Group                          */
+/*           http://hts.sp.nitech.ac.jp/                             */
+/* ----------------------------------------------------------------- */
+/*                                                                   */
+/*  Copyright (c) 2001-2011  Nagoya Institute of Technology          */
+/*                           Department of Computer Science          */
+/*                                                                   */
+/*                2001-2008  Tokyo Institute of Technology           */
+/*                           Interdisciplinary Graduate School of    */
+/*                           Science and Engineering                 */
+/*                                                                   */
+/* All rights reserved.                                              */
+/*                                                                   */
+/* Redistribution and use in source and binary forms, with or        */
+/* without modification, are permitted provided that the following   */
+/* conditions are met:                                               */
+/*                                                                   */
+/* - Redistributions of source code must retain the above copyright  */
+/*   notice, this list of conditions and the following disclaimer.   */
+/* - Redistributions in binary form must reproduce the above         */
+/*   copyright notice, this list of conditions and the following     */
+/*   disclaimer in the documentation and/or other materials provided */
+/*   with the distribution.                                          */
+/* - Neither the name of the HTS working group nor the names of its  */
+/*   contributors may be used to endorse or promote products derived */
+/*   from this software without specific prior written permission.   */
+/*                                                                   */
+/* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND            */
+/* CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,       */
+/* INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF          */
+/* MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE          */
+/* DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS */
+/* BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,          */
+/* EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED   */
+/* TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,     */
+/* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON */
+/* ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,   */
+/* OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY    */
+/* OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE           */
+/* POSSIBILITY OF SUCH DAMAGE.                                       */
+/* ----------------------------------------------------------------- */
+
 char *arc_version = "!HVER!HArc:   3.4.1 [CUED 12/03/09]";
-char *arc_vc_id = "$Id: HArc.c,v 1.1.1.1 2006/10/11 09:54:57 jal58 Exp $";
+char *arc_vc_id = "$Id: HArc.c,v 1.11 2011/06/16 04:18:28 uratec Exp $";
 
 
 /*
@@ -210,8 +255,8 @@ HArc *CreateArc(MemHeap *mem, Lattice *l
 
 void PrintArc(FILE *f, HArc *a){
    ArcTrans *at;
-   fprintf(f, "Arc{ id=%d, pos=%d, parentLarc=0x%x, t_start=%f, t_end=%f",
-           a->id, a->pos, (int)a->parentLarc, (float)a->t_start, (float)a->t_end);
+   fprintf(f, "Arc{ id=%d, pos=%d, parentLarc=0x%lx, t_start=%f, t_end=%f",
+           a->id, a->pos, (long)a->parentLarc, (float)a->t_start, (float)a->t_end);
    if(a->prec && a->t_end > a->prec->t_end){
       printf("(>%f by %E)\n", (float)a->prec->t_end, (float)(a->t_end - a->prec->t_end));
       if(a->t_end + 0.0 == a->prec->t_end){ printf("****\n"); }
@@ -282,7 +327,7 @@ void SortArcs( ArcInfo *aInfo )
    for ( al = arclist ; al != ale ; ++al )
       {
          (*al)->prec = prec ; prec = *al ; 
-         (*al)->foll = *(al+1) ; 
+         (*al)->foll = (al+1 != ale) ? *(al+1) : NULL; 
          (*al)->id = id++ ;
       }
 
@@ -455,7 +500,7 @@ void ArcFromLat(ArcInfo *aInfo, HMMSet *
                ac->alphat=ac->alphat1=NULL;ac->betaPlus=NULL;ac->otprob=NULL;
             } else {
                int j,s,SS,S = hset->swidth[0]; /* probably just 1. */
-	       StreamElem *ste;
+               StreamInfo *sti;
 
 	       SS=(S==1)?1:S+1;
                ac->SP=FALSE;
@@ -468,13 +513,14 @@ void ArcFromLat(ArcInfo *aInfo, HMMSet *
 		  ac->otprob[t] = ((float***)New(aInfo->mem,(ac->Nq-2)*sizeof(float **)))-2;
 		  for(j=2;j<ac->Nq;j++){
                      ac->otprob[t][j] = (float**)New(aInfo->mem,SS*sizeof(float*)); /*2..Nq-1*/
-		     ste = ac->hmm->svec[j].info->pdf+1;
+                     sti = ac->hmm->svec[j].info->pdf[1].info;
 		     if (S==1) {
 		        ac->otprob[t][j][0] = NULL;
 		     } else {
 		        ac->otprob[t][j][0] = (float*)New(aInfo->mem,sizeof(float));
 			ac->otprob[t][j][0][0] = LZERO;
-			for (s=1;s<=S;s++,ste++)
+			for (s=1;s<=S;s++) {
+                          sti = ac->hmm->svec[j].info->pdf[s].info;
 			  ac->otprob[t][j][s] = NULL;
 		     }
                   }
@@ -482,6 +528,7 @@ void ArcFromLat(ArcInfo *aInfo, HMMSet *
             }
          }
       }
+      }
       for(arc=aInfo->start;arc;arc=arc->foll)  if(arc->calcArc) arc->ac = arc->calcArc->ac;
 
 
@@ -565,7 +612,7 @@ Boolean LatInLat(Lattice *numLat, Lattic
 
 
 
-/* ------------------------------------ Initialisation ------------------------------------ */
+/* ------------------------------------ Initialisation & Reset ------------------------------------ */
 
 /* EXPORT->InitArc: initialise configuration parameters */
 void InitArc(void)
@@ -583,3 +630,10 @@ void InitArc(void)
    }
 }
 
+/* EXPORT->ResetArc: reset arc module */
+void ResetArc (void)
+{
+   return;
+}
+
+/* ------------------------ End of HArc.c -------------------------- */
diff -pbBEwurNa --ignore-matching-lines='.*vc_id.*' HTK-3.4.1/HTKLib/HArc.h HTS-2.2_for_HTK-3.4.1/HTKLib/HArc.h
--- HTK-3.4.1/HTKLib/HArc.h	2009-03-13 03:42:02.000000000 +0900
+++ HTS-2.2_for_HTK-3.4.1/HTKLib/HArc.h	2011-06-16 13:18:28.000000000 +0900
@@ -28,6 +28,51 @@
 /*         An alternative kind of lattice format used there.   */
 /* ----------------------------------------------------------- */
 
+/*  *** THIS IS A MODIFIED VERSION OF HTK ***                        */
+/* ----------------------------------------------------------------- */
+/*           The HMM-Based Speech Synthesis System (HTS)             */
+/*           developed by HTS Working Group                          */
+/*           http://hts.sp.nitech.ac.jp/                             */
+/* ----------------------------------------------------------------- */
+/*                                                                   */
+/*  Copyright (c) 2001-2011  Nagoya Institute of Technology          */
+/*                           Department of Computer Science          */
+/*                                                                   */
+/*                2001-2008  Tokyo Institute of Technology           */
+/*                           Interdisciplinary Graduate School of    */
+/*                           Science and Engineering                 */
+/*                                                                   */
+/* All rights reserved.                                              */
+/*                                                                   */
+/* Redistribution and use in source and binary forms, with or        */
+/* without modification, are permitted provided that the following   */
+/* conditions are met:                                               */
+/*                                                                   */
+/* - Redistributions of source code must retain the above copyright  */
+/*   notice, this list of conditions and the following disclaimer.   */
+/* - Redistributions in binary form must reproduce the above         */
+/*   copyright notice, this list of conditions and the following     */
+/*   disclaimer in the documentation and/or other materials provided */
+/*   with the distribution.                                          */
+/* - Neither the name of the HTS working group nor the names of its  */
+/*   contributors may be used to endorse or promote products derived */
+/*   from this software without specific prior written permission.   */
+/*                                                                   */
+/* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND            */
+/* CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,       */
+/* INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF          */
+/* MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE          */
+/* DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS */
+/* BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,          */
+/* EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED   */
+/* TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,     */
+/* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON */
+/* ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,   */
+/* OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY    */
+/* OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE           */
+/* POSSIBILITY OF SUCH DAMAGE.                                       */
+/* ----------------------------------------------------------------- */
+
 /* !HVER!HArc:   3.4.1 [CUED 12/03/09] */
 
 
@@ -206,8 +251,6 @@ int TimeToNFrames(float time, ArcInfo *a
    as the first and last frames of the phone).
  */
 
-/* ------------------------- End of Arc.h --------------------------- */
-
 void AttachMPEInfo(ArcInfo *aInfo); /* attaches the "mpe" fields  */
 
 Boolean LatInLat(Lattice *numLat, Lattice *denLat);
@@ -216,3 +259,6 @@ Boolean LatInLat(Lattice *numLat, Lattic
 #define EndOfWord(a) (a->pos == a->parentLarc->nAlign-1)
 
 void InitArc(void);
+void ResetArc(void);
+
+/* ------------------------ End of Arc.h --------------------------- */
diff -pbBEwurNa --ignore-matching-lines='.*vc_id.*' HTK-3.4.1/HTKLib/HAudio.c HTS-2.2_for_HTK-3.4.1/HTKLib/HAudio.c
--- HTK-3.4.1/HTKLib/HAudio.c	2009-03-13 03:42:11.000000000 +0900
+++ HTS-2.2_for_HTK-3.4.1/HTKLib/HAudio.c	2011-06-16 13:18:28.000000000 +0900
@@ -19,8 +19,53 @@
 /*      File: HAudio.c: Audio Input/Output Interface           */
 /* ----------------------------------------------------------- */
 
+/*  *** THIS IS A MODIFIED VERSION OF HTK ***                        */
+/* ----------------------------------------------------------------- */
+/*           The HMM-Based Speech Synthesis System (HTS)             */
+/*           developed by HTS Working Group                          */
+/*           http://hts.sp.nitech.ac.jp/                             */
+/* ----------------------------------------------------------------- */
+/*                                                                   */
+/*  Copyright (c) 2001-2011  Nagoya Institute of Technology          */
+/*                           Department of Computer Science          */
+/*                                                                   */
+/*                2001-2008  Tokyo Institute of Technology           */
+/*                           Interdisciplinary Graduate School of    */
+/*                           Science and Engineering                 */
+/*                                                                   */
+/* All rights reserved.                                              */
+/*                                                                   */
+/* Redistribution and use in source and binary forms, with or        */
+/* without modification, are permitted provided that the following   */
+/* conditions are met:                                               */
+/*                                                                   */
+/* - Redistributions of source code must retain the above copyright  */
+/*   notice, this list of conditions and the following disclaimer.   */
+/* - Redistributions in binary form must reproduce the above         */
+/*   copyright notice, this list of conditions and the following     */
+/*   disclaimer in the documentation and/or other materials provided */
+/*   with the distribution.                                          */
+/* - Neither the name of the HTS working group nor the names of its  */
+/*   contributors may be used to endorse or promote products derived */
+/*   from this software without specific prior written permission.   */
+/*                                                                   */
+/* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND            */
+/* CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,       */
+/* INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF          */
+/* MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE          */
+/* DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS */
+/* BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,          */
+/* EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED   */
+/* TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,     */
+/* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON */
+/* ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,   */
+/* OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY    */
+/* OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE           */
+/* POSSIBILITY OF SUCH DAMAGE.                                       */
+/* ----------------------------------------------------------------- */
+
 char *haudio_version = "!HVER!HAudio:   3.4.1 [CUED 12/03/09]";
-char *haudio_vc_id = "$Id: HAudio.c,v 1.1.1.1 2006/10/11 09:54:57 jal58 Exp $";
+char *haudio_vc_id = "$Id: HAudio.c,v 1.9 2011/06/16 04:18:28 uratec Exp $";
 
 #include "HShell.h"        /* HTK Libraries */
 #include "HMem.h"
@@ -347,7 +392,11 @@ static Boolean IsVAXOrder(void)
    px = &x;
    pc = (unsigned char *) px;
    *pc = 1; *(pc+1) = 0;         /* store bytes 1 0 */
-   return x==1;          /* does it read back as 1? */
+
+   if (x==1)          /* does it read back as 1? */
+      return TRUE;
+   else 
+      return FALSE;
 }
 #endif
 
@@ -1889,6 +1938,12 @@ void InitAudio(void)
 #endif
 }
 
+/* EXPORT->ResetAudio: reset audio module */
+void ResetAudio(void)
+{
+   return;   /* do nothing */
+}
+
 /* --------------------------- Status Handling ------------------- */
 
 static char * aiStatMap[] = { "AI_CLEARED","AI_WAITSIG",
@@ -2362,4 +2417,4 @@ int SamplesToPlay(AudioOut a)
    return OutSamples(a);
 }
 
-/* ------------------------ End of HAudio.c ------------------------- */
+/* ------------------------ End of HAudio.c ------------------------ */
diff -pbBEwurNa --ignore-matching-lines='.*vc_id.*' HTK-3.4.1/HTKLib/HAudio.h HTS-2.2_for_HTK-3.4.1/HTKLib/HAudio.h
--- HTK-3.4.1/HTKLib/HAudio.h	2009-03-13 03:42:22.000000000 +0900
+++ HTS-2.2_for_HTK-3.4.1/HTKLib/HAudio.h	2011-06-16 13:18:28.000000000 +0900
@@ -19,6 +19,51 @@
 /*         File: HAudio.h:   Audio Input/Output                */
 /* ----------------------------------------------------------- */
 
+/*  *** THIS IS A MODIFIED VERSION OF HTK ***                        */
+/* ----------------------------------------------------------------- */
+/*           The HMM-Based Speech Synthesis System (HTS)             */
+/*           developed by HTS Working Group                          */
+/*           http://hts.sp.nitech.ac.jp/                             */
+/* ----------------------------------------------------------------- */
+/*                                                                   */
+/*  Copyright (c) 2001-2011  Nagoya Institute of Technology          */
+/*                           Department of Computer Science          */
+/*                                                                   */
+/*                2001-2008  Tokyo Institute of Technology           */
+/*                           Interdisciplinary Graduate School of    */
+/*                           Science and Engineering                 */
+/*                                                                   */
+/* All rights reserved.                                              */
+/*                                                                   */
+/* Redistribution and use in source and binary forms, with or        */
+/* without modification, are permitted provided that the following   */
+/* conditions are met:                                               */
+/*                                                                   */
+/* - Redistributions of source code must retain the above copyright  */
+/*   notice, this list of conditions and the following disclaimer.   */
+/* - Redistributions in binary form must reproduce the above         */
+/*   copyright notice, this list of conditions and the following     */
+/*   disclaimer in the documentation and/or other materials provided */
+/*   with the distribution.                                          */
+/* - Neither the name of the HTS working group nor the names of its  */
+/*   contributors may be used to endorse or promote products derived */
+/*   from this software without specific prior written permission.   */
+/*                                                                   */
+/* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND            */
+/* CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,       */
+/* INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF          */
+/* MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE          */
+/* DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS */
+/* BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,          */
+/* EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED   */
+/* TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,     */
+/* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON */
+/* ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,   */
+/* OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY    */
+/* OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE           */
+/* POSSIBILITY OF SUCH DAMAGE.                                       */
+/* ----------------------------------------------------------------- */
+
 /* !HVER!HAudio:   3.4.1 [CUED 12/03/09] */
 
 #ifndef _HAUDIO_H_
@@ -57,6 +102,10 @@ void InitAudio(void);
    Initialise audio module
 */
 
+void ResetAudio(void);
+/*
+   Reset audio module
+*/
 
 AudioIn OpenAudioInput(MemHeap *x, HTime *sampPeriod, 
                        HTime winDur, HTime frPeriod);
@@ -198,4 +247,4 @@ int SamplesToPlay(AudioOut a);
 
 #endif  /* _HAUDIO_H_ */
 
-/* ------------------------ End of HAudio.h ----------------------- */
+/* ------------------------ End of HAudio.h ------------------------ */
diff -pbBEwurNa --ignore-matching-lines='.*vc_id.*' HTK-3.4.1/HTKLib/HDict.c HTS-2.2_for_HTK-3.4.1/HTKLib/HDict.c
--- HTK-3.4.1/HTKLib/HDict.c	2009-03-13 03:42:30.000000000 +0900
+++ HTS-2.2_for_HTK-3.4.1/HTKLib/HDict.c	2011-06-16 13:18:28.000000000 +0900
@@ -19,8 +19,53 @@
 /*         File: HDict.c  Dictionary Storage                   */
 /* ----------------------------------------------------------- */
 
+/*  *** THIS IS A MODIFIED VERSION OF HTK ***                        */
+/* ----------------------------------------------------------------- */
+/*           The HMM-Based Speech Synthesis System (HTS)             */
+/*           developed by HTS Working Group                          */
+/*           http://hts.sp.nitech.ac.jp/                             */
+/* ----------------------------------------------------------------- */
+/*                                                                   */
+/*  Copyright (c) 2001-2011  Nagoya Institute of Technology          */
+/*                           Department of Computer Science          */
+/*                                                                   */
+/*                2001-2008  Tokyo Institute of Technology           */
+/*                           Interdisciplinary Graduate School of    */
+/*                           Science and Engineering                 */
+/*                                                                   */
+/* All rights reserved.                                              */
+/*                                                                   */
+/* Redistribution and use in source and binary forms, with or        */
+/* without modification, are permitted provided that the following   */
+/* conditions are met:                                               */
+/*                                                                   */
+/* - Redistributions of source code must retain the above copyright  */
+/*   notice, this list of conditions and the following disclaimer.   */
+/* - Redistributions in binary form must reproduce the above         */
+/*   copyright notice, this list of conditions and the following     */
+/*   disclaimer in the documentation and/or other materials provided */
+/*   with the distribution.                                          */
+/* - Neither the name of the HTS working group nor the names of its  */
+/*   contributors may be used to endorse or promote products derived */
+/*   from this software without specific prior written permission.   */
+/*                                                                   */
+/* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND            */
+/* CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,       */
+/* INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF          */
+/* MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE          */
+/* DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS */
+/* BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,          */
+/* EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED   */
+/* TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,     */
+/* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON */
+/* ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,   */
+/* OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY    */
+/* OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE           */
+/* POSSIBILITY OF SUCH DAMAGE.                                       */
+/* ----------------------------------------------------------------- */
+
 char *hdict_version = "!HVER!HDict:   3.4.1 [CUED 12/03/09]";
-char *hdict_vc_id = "$Id: HDict.c,v 1.1.1.1 2006/10/11 09:54:57 jal58 Exp $";
+char *hdict_vc_id = "$Id: HDict.c,v 1.9 2011/06/16 04:18:28 uratec Exp $";
 
 #include "HShell.h"
 #include "HMem.h"
@@ -53,12 +98,18 @@ void InitDict(void)
    }
 }
 
+/* EXPORT->ResetDict: reset module */
+void ResetDict(void)
+{
+   return;   /* do nothing */
+}
+
 /* ----------- Vocab Hash Table Routines  ---------------------- */
 
 /* VocabHash: return a hash value for given Word LabId */
 static int VocabHash(LabId name)
 {
-   return (int) (((unsigned) name)%VHASHSIZE);
+   return (int) (((unsigned long) name)%VHASHSIZE);
 }
 
 /* NewWord: Add a new word wordName to voc */
@@ -426,4 +477,4 @@ ReturnStatus WriteDict(char *dictFn, Voc
    return(SUCCESS);
 }
 
-/* ------------------------ End of HDict.c ----------------------- */
+/* ------------------------ End of HDict.c ------------------------- */
diff -pbBEwurNa --ignore-matching-lines='.*vc_id.*' HTK-3.4.1/HTKLib/HDict.h HTS-2.2_for_HTK-3.4.1/HTKLib/HDict.h
--- HTK-3.4.1/HTKLib/HDict.h	2009-03-13 03:42:41.000000000 +0900
+++ HTS-2.2_for_HTK-3.4.1/HTKLib/HDict.h	2011-06-16 13:18:28.000000000 +0900
@@ -19,6 +19,51 @@
 /*         File: HDict.h  Dictionary Storage                   */
 /* ----------------------------------------------------------- */
 
+/*  *** THIS IS A MODIFIED VERSION OF HTK ***                        */
+/* ----------------------------------------------------------------- */
+/*           The HMM-Based Speech Synthesis System (HTS)             */
+/*           developed by HTS Working Group                          */
+/*           http://hts.sp.nitech.ac.jp/                             */
+/* ----------------------------------------------------------------- */
+/*                                                                   */
+/*  Copyright (c) 2001-2011  Nagoya Institute of Technology          */
+/*                           Department of Computer Science          */
+/*                                                                   */
+/*                2001-2008  Tokyo Institute of Technology           */
+/*                           Interdisciplinary Graduate School of    */
+/*                           Science and Engineering                 */
+/*                                                                   */
+/* All rights reserved.                                              */
+/*                                                                   */
+/* Redistribution and use in source and binary forms, with or        */
+/* without modification, are permitted provided that the following   */
+/* conditions are met:                                               */
+/*                                                                   */
+/* - Redistributions of source code must retain the above copyright  */
+/*   notice, this list of conditions and the following disclaimer.   */
+/* - Redistributions in binary form must reproduce the above         */
+/*   copyright notice, this list of conditions and the following     */
+/*   disclaimer in the documentation and/or other materials provided */
+/*   with the distribution.                                          */
+/* - Neither the name of the HTS working group nor the names of its  */
+/*   contributors may be used to endorse or promote products derived */
+/*   from this software without specific prior written permission.   */
+/*                                                                   */
+/* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND            */
+/* CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,       */
+/* INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF          */
+/* MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE          */
+/* DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS */
+/* BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,          */
+/* EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED   */
+/* TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,     */
+/* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON */
+/* ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,   */
+/* OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY    */
+/* OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE           */
+/* POSSIBILITY OF SUCH DAMAGE.                                       */
+/* ----------------------------------------------------------------- */
+
 /* !HVER!HDict:   3.4.1 [CUED 12/03/09] */
 
 #ifndef _HDICT_H_
@@ -77,6 +122,11 @@ void InitDict(void);
    Initialise the HDict module 
 */
 
+void ResetDict(void);
+/* 
+   Rest module 
+*/
+
 void InitVocab(Vocab *voc);
 /* 
    Initialise a Vocab data structure - must be called before
@@ -158,5 +208,4 @@ void DelPron(Vocab *voc, Word word, Pron
 
 #endif  /* _HDICT_H_ */
 
-/* ------------------------ End of HDict.h ----------------------- */
-
+/* ------------------------ End of HDict.h ------------------------- */
diff -pbBEwurNa --ignore-matching-lines='.*vc_id.*' HTK-3.4.1/HTKLib/HExactMPE.c HTS-2.2_for_HTK-3.4.1/HTKLib/HExactMPE.c
--- HTK-3.4.1/HTKLib/HExactMPE.c	2009-03-13 03:42:49.000000000 +0900
+++ HTS-2.2_for_HTK-3.4.1/HTKLib/HExactMPE.c	2011-06-16 13:18:28.000000000 +0900
@@ -27,8 +27,53 @@
 /*         File: HExactMPE.c   Discriminative training         */
 /* ----------------------------------------------------------- */
 
+/*  *** THIS IS A MODIFIED VERSION OF HTK ***                        */
+/* ----------------------------------------------------------------- */
+/*           The HMM-Based Speech Synthesis System (HTS)             */
+/*           developed by HTS Working Group                          */
+/*           http://hts.sp.nitech.ac.jp/                             */
+/* ----------------------------------------------------------------- */
+/*                                                                   */
+/*  Copyright (c) 2001-2011  Nagoya Institute of Technology          */
+/*                           Department of Computer Science          */
+/*                                                                   */
+/*                2001-2008  Tokyo Institute of Technology           */
+/*                           Interdisciplinary Graduate School of    */
+/*                           Science and Engineering                 */
+/*                                                                   */
+/* All rights reserved.                                              */
+/*                                                                   */
+/* Redistribution and use in source and binary forms, with or        */
+/* without modification, are permitted provided that the following   */
+/* conditions are met:                                               */
+/*                                                                   */
+/* - Redistributions of source code must retain the above copyright  */
+/*   notice, this list of conditions and the following disclaimer.   */
+/* - Redistributions in binary form must reproduce the above         */
+/*   copyright notice, this list of conditions and the following     */
+/*   disclaimer in the documentation and/or other materials provided */
+/*   with the distribution.                                          */
+/* - Neither the name of the HTS working group nor the names of its  */
+/*   contributors may be used to endorse or promote products derived */
+/*   from this software without specific prior written permission.   */
+/*                                                                   */
+/* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND            */
+/* CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,       */
+/* INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF          */
+/* MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE          */
+/* DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS */
+/* BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,          */
+/* EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED   */
+/* TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,     */
+/* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON */
+/* ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,   */
+/* OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY    */
+/* OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE           */
+/* POSSIBILITY OF SUCH DAMAGE.                                       */
+/* ----------------------------------------------------------------- */
+
 char *hexactmpe_version = "!HVER!HExactMPE:   3.4.1 [CUED 12/03/09]";
-char *hexactmpe_vc_id = "$Id: HExactMPE.c,v 1.1.1.1 2006/10/11 09:54:57 jal58 Exp $";
+char *hexactmpe_vc_id = "$Id: HExactMPE.c,v 1.13 2011/06/16 04:18:28 uratec Exp $";
 
 /*
     Performs forward/backward alignment
@@ -107,8 +152,12 @@ static int debug_bestcorr = 1000;
 
 
 
-Boolean IsNonSilArc(LArc *larc){ /*returns TRUE if this word is non SENT_START etc. */
-  return (larc->nAlign>1 || (larc->nAlign==1 && !IsSilence(larc->lAlign[0].label->name)));
+Boolean IsNonSilArc(LArc *larc) /*returns TRUE if this word is non SENT_START etc. */
+{
+   if (larc->nAlign>1 || (larc->nAlign==1 && !IsSilence(larc->lAlign[0].label->name))) 
+      return TRUE;
+   else
+      return FALSE;
 }
 int GetNumPhones(LArc *larc){ /*returns num phones in a word...*/
   if(!Quinphone){
@@ -122,14 +171,19 @@ int GetNumPhones(LArc *larc){ /*returns 
     return i;
   }
 }
-Boolean NonSil_and_Quinphone_IsStartPhone(LArc *larc, int i){
+Boolean NonSil_and_Quinphone_IsStartPhone(LArc *larc, int i)
+{
   if(!Quinphone){ 
-    return (i < larc->nAlign-1 || !IsSilence(larc->lAlign[larc->nAlign-1].label->name)); /* not end phone or end phone is non-sil. */
+      if (i < larc->nAlign-1 || !IsSilence(larc->lAlign[larc->nAlign-1].label->name)) /* not end phone or end phone is non-sil. */
+         return TRUE;
+      else
+         return FALSE;
   }
   else{
-    return (i % 3 == 0 && i != larc->nAlign-1); /* assuming each has 3 states and a terminal sil/sp [This could be wrong later, but just for simplicity
-						   do it this way now.....]*/
-    
+      if (i % 3 == 0 && i != larc->nAlign-1) /* assuming each has 3 states and a terminal sil/sp [This could be wrong later, but just for simplicity do it this way now.....]*/
+         return TRUE;
+      else 
+         return FALSE;
   }
 }
 
@@ -241,7 +295,8 @@ Boolean GetBestCorrectness /*step correc
   if(_BestCorr) *_BestCorr = BestCorr;             /* final correctness */
   if(_BestCorrPart) *_BestCorrPart = BestCorrPart; /*contribution from this phone. */
   if(_bestj) *_bestj = bestj;                     /* sausage pos of best contribution */
-  return(bestj!=-1);
+  if(bestj!=-1) return TRUE;
+  else return FALSE;
 }
 float DoCorrectness(FBLatInfo *fbInfo, MemHeap *mem, ArcInfo *ai, float prune, 
                     int beamN/*phones on either side...*/,
@@ -268,7 +323,7 @@ float DoCorrectness(FBLatInfo *fbInfo, M
     if(locc > prune){   /* ... if above prune threshold then attach the 'cn' structure */
       if(!PhoneMEE && StartOfWord(a)/*expands to a->pos==0*/){  /* This is the MWE case. Create a cn structure for the first phone of the word. */
 	LArc *la = a->parentLarc; 
-	int iword = (int)/*from LabId*/ la->end->word->wordName;
+	int iword = (int)((long)/*from LabId*/ la->end->word->wordName);
 	int id = (a->calcArc ? a->calcArc->id : a->id);
 	HArc *b,*lastArc; int x;
 
@@ -278,7 +333,7 @@ float DoCorrectness(FBLatInfo *fbInfo, M
 	a->mpe->cn = cn;
 	cn->me_start = a;
 	cn->iphone = iword;
-	cn->IsSilence = IsSilence(a->phone->name); /* First arc of word is sil->silence word. */
+	cn->IsSilence = (Boolean) IsSilence(a->phone->name); /* First arc of word is sil->silence word. */
 	cn->follTrans=cn->precTrans=NULL;
 	cn->scaled_aclike = fbInfo->aInfo->ac[id].aclike * latProbScale;
 	
@@ -320,7 +375,7 @@ float DoCorrectness(FBLatInfo *fbInfo, M
 	a->mpe->cn = cn;
 	cn->me_start = a;
 	cn->iphone = iphone;
-	cn->IsSilence = IsSilence(a->phone->name);
+	cn->IsSilence = (Boolean) IsSilence(a->phone->name);
 	cn->follTrans=cn->precTrans=NULL;
 
 	/* Following code is the general case, for quinphones as well as triphones. */
@@ -661,7 +716,7 @@ void DoExactCorrectness(FBLatInfo *fbInf
     w=0;
     for(node=lat->lnodes+0; node->foll; node=node->foll->end)
       if(node->foll->nAlign > 1 ||  (node->foll->nAlign==1 && ! IsSilence(node->foll->lAlign[0].label->name))) /* a word [ not sil. ]...*/
-	iwords[w++][0] = (int)node->foll->end->word->wordName; /* word is at the node at the end of the arc. */
+	iwords[w++][0] = (int)((long)node->foll->end->word->wordName); /* word is at the node at the end of the arc. */
 	 
     for(larc=lat->larcs,a=0;a<lat->na;larc++,a++){   
       if(IsNonSilArc(larc)){  /* Is a word [not sil]*/
@@ -811,7 +866,7 @@ void DoExactCorrectness(FBLatInfo *fbInf
 #endif /* SUPPORT_EXACT_CORRECTNESS */
 
 
-/* ------------------------------------ Initialisation ------------------------------------ */
+/* ------------------------------------ Initialisation & Reset ------------------------------------ */
 
 /* EXPORT->InitExactMPE: initialise configuration parameters */ 
 void InitExactMPE(void)
@@ -841,5 +896,10 @@ void InitExactMPE(void)
 
 }
 
+/* EXPORT->ResetExactMPE: reset module */
+void ResetExactMPE (void)
+{
+   return;  /* do nothing */
+}
 
-
+/* ------------------------ End of HExactMPE.c --------------------- */
diff -pbBEwurNa --ignore-matching-lines='.*vc_id.*' HTK-3.4.1/HTKLib/HExactMPE.h HTS-2.2_for_HTK-3.4.1/HTKLib/HExactMPE.h
--- HTK-3.4.1/HTKLib/HExactMPE.h	2009-03-13 03:42:57.000000000 +0900
+++ HTS-2.2_for_HTK-3.4.1/HTKLib/HExactMPE.h	2011-06-16 13:18:28.000000000 +0900
@@ -27,6 +27,51 @@
 /*         File: HExactMPE.h   MPE implementation (exact)      */
 /* ----------------------------------------------------------- */
 
+/*  *** THIS IS A MODIFIED VERSION OF HTK ***                        */
+/* ----------------------------------------------------------------- */
+/*           The HMM-Based Speech Synthesis System (HTS)             */
+/*           developed by HTS Working Group                          */
+/*           http://hts.sp.nitech.ac.jp/                             */
+/* ----------------------------------------------------------------- */
+/*                                                                   */
+/*  Copyright (c) 2001-2011  Nagoya Institute of Technology          */
+/*                           Department of Computer Science          */
+/*                                                                   */
+/*                2001-2008  Tokyo Institute of Technology           */
+/*                           Interdisciplinary Graduate School of    */
+/*                           Science and Engineering                 */
+/*                                                                   */
+/* All rights reserved.                                              */
+/*                                                                   */
+/* Redistribution and use in source and binary forms, with or        */
+/* without modification, are permitted provided that the following   */
+/* conditions are met:                                               */
+/*                                                                   */
+/* - Redistributions of source code must retain the above copyright  */
+/*   notice, this list of conditions and the following disclaimer.   */
+/* - Redistributions in binary form must reproduce the above         */
+/*   copyright notice, this list of conditions and the following     */
+/*   disclaimer in the documentation and/or other materials provided */
+/*   with the distribution.                                          */
+/* - Neither the name of the HTS working group nor the names of its  */
+/*   contributors may be used to endorse or promote products derived */
+/*   from this software without specific prior written permission.   */
+/*                                                                   */
+/* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND            */
+/* CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,       */
+/* INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF          */
+/* MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE          */
+/* DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS */
+/* BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,          */
+/* EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED   */
+/* TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,     */
+/* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON */
+/* ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,   */
+/* OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY    */
+/* OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE           */
+/* POSSIBILITY OF SUCH DAMAGE.                                       */
+/* ----------------------------------------------------------------- */
+
 /* !HVER!HExactMPE:   3.4.1 [CUED 12/03/09] */
 
 
@@ -40,8 +85,10 @@
 
 void InitExactMPE(void); /* set configs. */
 
+void ResetExactMPE(void); 
 
 #ifdef SUPPORT_EXACT_CORRECTNESS
 void DoExactCorrectness(FBLatInfo *fbInfo, Lattice *lat);   
 #endif
 
+/* ------------------------ End of HExtractMPE.h ------------------- */
diff -pbBEwurNa --ignore-matching-lines='.*vc_id.*' HTK-3.4.1/HTKLib/HFB.c HTS-2.2_for_HTK-3.4.1/HTKLib/HFB.c
--- HTK-3.4.1/HTKLib/HFB.c	2009-03-13 03:43:06.000000000 +0900
+++ HTS-2.2_for_HTK-3.4.1/HTKLib/HFB.c	2011-06-16 13:18:28.000000000 +0900
@@ -32,8 +32,53 @@
 /*         File: HFB.c: Forward Backward routines module       */
 /* ----------------------------------------------------------- */
 
+/*  *** THIS IS A MODIFIED VERSION OF HTK ***                        */
+/* ----------------------------------------------------------------- */
+/*           The HMM-Based Speech Synthesis System (HTS)             */
+/*           developed by HTS Working Group                          */
+/*           http://hts.sp.nitech.ac.jp/                             */
+/* ----------------------------------------------------------------- */
+/*                                                                   */
+/*  Copyright (c) 2001-2011  Nagoya Institute of Technology          */
+/*                           Department of Computer Science          */
+/*                                                                   */
+/*                2001-2008  Tokyo Institute of Technology           */
+/*                           Interdisciplinary Graduate School of    */
+/*                           Science and Engineering                 */
+/*                                                                   */
+/* All rights reserved.                                              */
+/*                                                                   */
+/* Redistribution and use in source and binary forms, with or        */
+/* without modification, are permitted provided that the following   */
+/* conditions are met:                                               */
+/*                                                                   */
+/* - Redistributions of source code must retain the above copyright  */
+/*   notice, this list of conditions and the following disclaimer.   */
+/* - Redistributions in binary form must reproduce the above         */
+/*   copyright notice, this list of conditions and the following     */
+/*   disclaimer in the documentation and/or other materials provided */
+/*   with the distribution.                                          */
+/* - Neither the name of the HTS working group nor the names of its  */
+/*   contributors may be used to endorse or promote products derived */
+/*   from this software without specific prior written permission.   */
+/*                                                                   */
+/* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND            */
+/* CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,       */
+/* INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF          */
+/* MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE          */
+/* DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS */
+/* BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,          */
+/* EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED   */
+/* TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,     */
+/* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON */
+/* ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,   */
+/* OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY    */
+/* OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE           */
+/* POSSIBILITY OF SUCH DAMAGE.                                       */
+/* ----------------------------------------------------------------- */
+
 char *hfb_version = "!HVER!HFB:   3.4.1 [CUED 12/03/09]";
-char *hfb_vc_id = "$Id: HFB.c,v 1.1.1.1 2006/10/11 09:54:57 jal58 Exp $";
+char *hfb_vc_id = "$Id: HFB.c,v 1.51 2011/06/16 04:18:28 uratec Exp $";
 
 #include "HShell.h"     /* HMM ToolKit Modules */
 #include "HMem.h"
@@ -63,13 +108,15 @@ char *hfb_vc_id = "$Id: HFB.c,v 1.1.1.1 
 #define T_OUT   0200    /* Output Probabilities */
 #define T_UPD   0400    /* Model updates */
 #define T_TMX  01000    /* Tied Mixture Usage */
-#define T_TIM  02000    /* Time elapsed in FBFile */
+#define T_TIM  02000    /* Time elapsed in FBUtt */
 
 static int trace         =  0;
 static int skipstartInit = -1;
 static int skipendInit   = -1;
 static Boolean alCompLevel = FALSE;   /* align model at component level */
 
+extern Boolean keepOccm; /* keep mixture occ (used in parameter generation) */
+
 static ConfParam *cParm[MAXGLOBS];      /* config parameters */
 static int nParm = 0;
 
@@ -84,6 +131,12 @@ static struct { 
 
 static Boolean pde = FALSE;  /* partial distance elimination */
 static Boolean sharedMix = FALSE; /* true if shared mixtures */
+static Boolean sharedStream = FALSE; /* true if shared streams */
+
+static Boolean semiMarkov = FALSE;  /* HMM or HSMM */
+static int maxstdDevCoef = 10;      /* max duration */
+static int minDur = 5;              /* min duration */
+static MemHeap dprobStack;
 
 /* ------------------------- Min HMM Duration -------------------------- */
 
@@ -176,18 +229,18 @@ static WtAcc *CreateWtAcc(MemHeap *x, in
    WtAcc *wa;
    
    wa = (WtAcc *) New(x,sizeof(WtAcc));
-   wa->c = CreateVector(x,nMix);
+   wa->c = CreateSVector(x,nMix);
    ZeroVector(wa->c);
    wa->occ = 0.0;
    wa->time = -1; wa->prob = NULL;
    return wa;
 }
 
-/* AttachTrAccs: attach transition accumulators to hset */
+/* AttachWtTrAccs: attach weight and transition accumulators to hset */
 static void AttachWtTrAccs(HMMSet *hset, MemHeap *x)
 {
    HMMScanState hss;
-   StreamElem *ste;
+   StreamInfo *sti;
    HLink hmm;
   
    NewHMMScan(hset,&hss);
@@ -200,15 +253,48 @@ static void AttachWtTrAccs(HMMSet *hset,
       }
       while (GoNextState(&hss,TRUE)) {
          while (GoNextStream(&hss,TRUE)) {
-            ste = hss.ste;
-            ste->hook = CreateWtAcc(x,hss.M);
+            sti = hss.sti;
+            sti->hook = CreateWtAcc(x,hss.M);
+         }
+      }
+   } while (GoNextHMM(&hss));
+   EndHMMScan(&hss);
+}
+
+/* -------------------- HMM -> HSMM conversion --------------------- */
+
+static void FixTransHSMM (HMMSet *hset)
+{
+   int i,j;
+   HMMScanState hss;
+   LogDouble sum;
+   SMatrix tr;
+   
+   /* fix trans prob */
+   NewHMMScan(hset,&hss);
+   do {
+      if (!IsSeenV(hss.hmm->transP)) {
+         tr = hss.hmm->transP;
+         for (i=1; i<=hss.N; i++) {
+            if (tr[i][i]>LSMALL) {
+               sum = LZERO;
+               for (j=1; j<=hss.N; j++)  
+                  if (j!=i && tr[i][j]>LSMALL)
+                     sum = LAdd(sum,tr[i][j]);
+               for (j=1; j<=hss.N; j++)
+                  tr[i][j] = (tr[i][j]>LSMALL) ? tr[i][j]-sum : LZERO;
+               tr[i][i] = LZERO;
+            }
          }
+         TouchV(hss.hmm->transP);
       }
    } while (GoNextHMM(&hss));
    EndHMMScan(&hss);
 }
 
 /* -------------------------- Initialisation ----------------------- */
+
+/* EXPORT->InitFB: initialise FB module */
 void InitFB(void)
 {
    int m;
@@ -218,12 +304,17 @@ void InitFB(void)
 
    Register(hfb_version,hfb_vc_id);
 
+   /* setup the local memory management */
+   CreateHeap(&dprobStack,"duration prob store", MSTAK, 1, 1.0, 50000, 500000);
+   
    for (m = 0; m < 2; ++m) {
       nParm = GetConfig(m==0 ? "HFWDBKWD" : "HFB", TRUE, cParm, MAXGLOBS);
       if (nParm>0){
          if (GetConfInt(cParm,nParm,"TRACE",&i)) trace = i;
          if (GetConfInt(cParm,nParm,"HSKIPSTART",&i)) skipstartInit = i;
          if (GetConfInt(cParm,nParm,"HSKIPEND",&i)) skipendInit = i;
+         if (GetConfInt(cParm,nParm,"MAXSTDDEVCOEF",&i)) maxstdDevCoef = i;
+         if (GetConfInt(cParm,nParm,"MINDUR",&i)) minDur = i;
          if (GetConfFlt(cParm,nParm,"PRUNEINIT", &d)) pruneSetting.pruneInit = d;
          if (GetConfFlt(cParm,nParm,"PRUNEINC", &d)) pruneSetting.pruneInc = d;
          if (GetConfFlt(cParm,nParm,"PRUNELIM", &d)) pruneSetting.pruneLim = d;
@@ -234,23 +325,32 @@ void InitFB(void)
    }
 }
 
-/* Allow tools to enable top-level tracing in HFB. Only here for historical reasons */
+/* EXPORT->ResetFB: reset FB module */
+void ResetFB(void)
+{
+   ResetHeap(&dprobStack);
+   return;   /* do nothing */
+}
+
+/* EXPORT->SetTraceFB: Allow tools to enable top-level tracing in HFB. Only here for historical reasons */
 void SetTraceFB(void)
 {
    trace |= T_TOP;
 }
 
 
-/* Initialise the forward backward memory stacks and make initialisations  */
-void InitialiseForBack(FBInfo *fbInfo, MemHeap *x, HMMSet *hset, UPDSet uset, 
-                       LogDouble pruneInit, LogDouble pruneInc, 
-                       LogDouble pruneLim, float minFrwdP)
+/* EXPORT->InitialiseForBack: IniInitialise the forward backward memory stacks and make initialisations  */
+void InitialiseForBack(FBInfo *fbInfo, MemHeap *x, HMMSet *hset, UPDSet uFlags_hmm, HMMSet *dset, UPDSet uFlags_dur, 
+                       LogDouble pruneInit, LogDouble pruneInc, LogDouble pruneLim, 
+                       float minFrwdP, Boolean useAlign, Boolean genDur)
 {
    int s;
    AlphaBeta *ab;
   
-   fbInfo->uFlags = uset;
+   fbInfo->uFlags_hmm = uFlags_hmm;
+   fbInfo->uFlags_dur = uFlags_dur;
    fbInfo->up_hset = fbInfo->al_hset = hset;
+   fbInfo->up_dset = fbInfo->al_dset = dset;
    fbInfo->twoModels = FALSE;
    fbInfo->hsKind = hset->hsKind;
    /* Accumulators attached using AttachAccs() in HERest are overwritten
@@ -261,6 +361,9 @@ void InitialiseForBack(FBInfo *fbInfo, M
    fbInfo->maxM = MaxMixInSet(hset);
    fbInfo->skipstart = skipstartInit;
    fbInfo->skipend   = skipendInit;
+   fbInfo->useAlign = useAlign;
+   fbInfo->inXForm_hmm = fbInfo->al_inXForm_hmm = fbInfo->paXForm_hmm = NULL;
+   fbInfo->inXForm_dur = fbInfo->al_inXForm_dur = fbInfo->paXForm_dur = NULL;
    for (s=1;s<=hset->swidth[0];s++)
       fbInfo->maxMixInS[s] = MaxMixInSetS(hset, s);
    fbInfo->ab = (AlphaBeta *) New(x, sizeof(AlphaBeta));
@@ -279,27 +382,49 @@ void InitialiseForBack(FBInfo *fbInfo, M
       if (pruneSetting.pruneInc != 0.0)
          printf("Pruning-On[%.1f %.1f %.1f]\n", pruneSetting.pruneInit, 
                 pruneSetting.pruneInc, pruneSetting.pruneLim);
+      else if (fbInfo->useAlign)
+         printf("Pruning-On[Alignment]\n");
       else
          printf("Pruning-On[%.1f]\n", pruneSetting.pruneInit);
    else
       printf("Pruning-Off\n");
    if (hset->numSharedMix > 0)
       sharedMix = TRUE;
+   if (hset->numSharedStreams > 0)
+      sharedStream = TRUE;
+   if (dset!=NULL) {
+      if ((dset->hsKind!=PLAINHS) && (dset->hsKind!=SHAREDHS))
+         HError(7392,"InitialiseForBack: Model kind not supported for duration models");
+      if (MaxMixInSet(dset)>1)
+         HError(9999,"InitialiseForBack: Only single Gaussian is supported for duration models");
+      for (s=1; s<=dset->swidth[0]; s++)
+         if (dset->swidth[s]!=1)
+            HError(9999,"InitialiseForBack: Stream width must be 1");
+      if (!genDur) {
+         FixTransHSMM(hset);
+         semiMarkov = TRUE;
+      }
+      AttachWtTrAccs(dset,x);
+   }
    if (pde) {
       if (sharedMix)
 	 HError(7399,"PDE is not compatible with shared mixtures");
       printf("Partial Distance Elimination on\n");
    }
+   
+   return;
 }
 
 /* Use a different model set for alignment */
-void UseAlignHMMSet(FBInfo* fbInfo, MemHeap* x, HMMSet *al_hset)
+void UseAlignHMMSet(FBInfo* fbInfo, MemHeap* x, HMMSet *al_hset, HMMSet *al_dset)
 {
    int s,S;
 
    /* First check 2-model mode allowed for current up_hset */
    if ((fbInfo->hsKind != PLAINHS) && (fbInfo->hsKind != SHAREDHS))
       HError(7392,"Model kind not supported for fixed alignments");
+
+   if (al_hset!=NULL) {
    if (al_hset->hsKind != fbInfo->hsKind)
       HRError(7392,"Different kinds in alignment and update HMM sets!");
    /* check stream compatibility */
@@ -310,9 +435,9 @@ void UseAlignHMMSet(FBInfo* fbInfo, MemH
       if (al_hset->swidth[s] != fbInfo->up_hset->swidth[s]) 
          HError(7392,"Stream %d widths differ in alignment and update HMM sets!",s);
    /* check update flags */
-   if (fbInfo->uFlags&UPTRANS) {
+      if (fbInfo->uFlags_hmm&UPTRANS) {
       HRError(7392,"Don't update transitions on a 2-model alignment"); 
-      fbInfo->uFlags = fbInfo->uFlags & ~UPTRANS;
+         fbInfo->uFlags_hmm = (UPDSet) (fbInfo->uFlags_hmm & ~UPTRANS);
    }
    /* check input Xforms */
    if ((al_hset->xf!=NULL) && (al_hset->xf != fbInfo->up_hset->xf))
@@ -321,14 +446,43 @@ void UseAlignHMMSet(FBInfo* fbInfo, MemH
    /* update the global alignment set features */
    fbInfo->hsKind = al_hset->hsKind;      
    fbInfo->maxM = MaxMixInSet(al_hset);
+       
    /* dummy accs to accomodate minDir */
    AttachWtTrAccs(al_hset, x);
    SetMinDurs(al_hset);
+         
    /* precomps */
    if ( al_hset->hsKind == SHAREDHS)
       AttachPreComps(al_hset,al_hset->hmem);
     
+      if (semiMarkov)
+         FixTransHSMM(al_hset);
+      
    fbInfo->al_hset = al_hset;  
+   }
+
+   if (fbInfo->up_dset!=NULL && al_dset!=NULL) {
+      S = al_dset->swidth[0];
+      if (S != fbInfo->up_dset->swidth[0])
+         HError(7392,"UseAlignHMMSet: Different num streams in alignment and update duration model sets!");
+      for (s=1; s<=S; s++) 
+         if (al_dset->swidth[s] != fbInfo->up_dset->swidth[s]) 
+            HError(7392,"UseAlignHMMSet: Stream %d widths differ in alignment and update duration model sets!",s);
+      if ((al_dset->hsKind!=PLAINHS) && (al_dset->hsKind!=SHAREDHS))
+         HError(7392,"UseAlignHMMSet: Model kind not supported for duration models");
+      if (MaxMixInSet(al_dset)>1)
+         HError(9999,"UseAlignHMMSet: Only single Gaussian is supported for duration models");
+      /* check input Xforms */
+      if ((al_dset->xf!=NULL) && (al_dset->xf != fbInfo->up_dset->xf))
+         HError(7392,"UseAlignHMMSet: Inconsistent input transforms for align duration model set");
+            
+      if (fbInfo->uFlags_dur&(UPMEANS|UPVARS)) {
+         HRError(7392,"UseAlignHMMSet: Don't update duration models on a 2-model alignment"); 
+         fbInfo->uFlags_dur = (UPDSet) 0;
+      }
+      AttachWtTrAccs(al_dset, x);
+      fbInfo->al_dset = al_dset;
+   }
    fbInfo->twoModels = TRUE;
 }
 
@@ -363,7 +517,6 @@ static void CreateTraceOcc(AlphaBeta *ab
    int q;
    Vector *occa;
 
-   printf("\n");
    ab->occa=(Vector *)New(&ab->abMem, utt->Q*sizeof(Vector));
    occa = ab->occa;
    --occa;
@@ -396,18 +549,22 @@ static void TraceOcc(AlphaBeta *ab, UttI
 }
 
 /* SetOcct: set the global occupation count for given hmm */
-static void SetOcct(HLink hmm, int q, Vector occt, Vector *occa,
-                    DVector aqt, DVector bqt, DVector bq1t, LogDouble pr)
+static void SetOcct(HLink hmm, int q, Vector occt, Vector *occa, int *maxDur,
+                    DVector *aqt, DVector *bqt, DVector *bq1t, LogDouble pr)
 {
-   int i,N;
-   double x;
+   int i,N,d;
+   double x,y;
    Vector occaq;
    
    N=hmm->numStates;
+   y=0.0;
    for (i=1;i<=N;i++) {
-      x = aqt[i]+bqt[i];
-      if (i==1 && bq1t != NULL && hmm->transP[1][N] > LSMALL)
-         x = LAdd(x,aqt[1]+bq1t[1]+hmm->transP[1][N]);
+      x = LZERO;
+      for (d=1; d<=maxDur[i]; d++)
+         if (aqt[i][d]>LSMALL && bqt[i][d]>LSMALL)
+            x = LAdd(x,aqt[i][d]+bqt[i][d]);
+      if (i==1 && bq1t != NULL && ApplyDAEM(hmm->transP[1][N]) > LSMALL)
+	 x = LAdd(x,aqt[1][1]+bq1t[1][1]+ApplyDAEM(hmm->transP[1][N]));
       x -= pr;
       occt[i] = (x>MINEARG) ? exp(x) : 0.0;
    }
@@ -421,7 +578,10 @@ static void SetOcct(HLink hmm, int q, Ve
 /* NonSkipRegion: returns true if t is not in the skip region */
 static Boolean NonSkipRegion(int skipstart, int skipend, int t)
 {
-   return skipstart<1 || t<skipstart || t>skipend;
+   if (skipstart<1 || t<skipstart || t>skipend)
+      return TRUE;
+   else
+      return FALSE;
 }
 
 /* PrLog: print a log value */
@@ -442,12 +602,12 @@ void GetInputObs( UttInfo *utt, int t, H
 {
 
    if (utt->twoDataFiles)
-      ReadAsTable(utt->pbuf2,t-1,&(utt->ot2));
-   ReadAsTable(utt->pbuf,t-1,&(utt->ot));
+      ReadAsTable(utt->pbuf2,t-1,&(utt->o2[t]));
+   ReadAsTable(utt->pbuf,t-1,&(utt->o[t]));
 
    if (hsKind == TIEDHS)
       if (utt->twoDataFiles)
-         ReadAsTable(utt->pbuf,t-1,&(utt->ot2));
+         ReadAsTable(utt->pbuf,t-1,&(utt->o2[t]));
 
 }
 
@@ -458,9 +618,9 @@ void GetInputObs( UttInfo *utt, int t, H
 /* CheckPruning: record peak alpha.beta product and position */
 static void CheckPruning(AlphaBeta *ab, int t, int skipstart, int skipend)
 {
-   int i,q,Nq,bestq,besti,margin;
+   int i,q,Nq,bestq,besti,margin,d,*maxDur;
    PruneInfo *p;
-   DVector aq,bq;
+   DVector *aq,*bq;
    HLink hmm;
    LogDouble lx,maxL;
 
@@ -470,8 +630,13 @@ static void CheckPruning(AlphaBeta *ab, 
    for (q=p->qLo[t];q<=p->qHi[t];q++){
       hmm = ab->al_qList[q]; Nq = hmm->numStates;   
       aq = ab->alphat[q]; bq=ab->beta[t][q];
+      maxDur = ab->maxDur[q];
       for (i=2;i<Nq;i++){
-         if ((lx=aq[i]+bq[i])>maxL){
+         lx = LZERO;
+         for (d=1; d<=maxDur[i]; d++)
+            if (aq[i][d]>LSMALL && bq[i][d]>LSMALL)
+               lx = LAdd(lx,aq[i][d]+bq[i][d]);
+         if (lx>maxL){
             bestq = q; besti = i; maxL=lx;
          }
       }
@@ -513,21 +678,35 @@ static int CreateInsts(FBInfo *fbInfo, A
    TrAcc *ta;
    LabId  *qIds;
    short *qDms;
-   HLink *al_qList, *up_qList;
+   HLink *al_qList=NULL, *up_qList=NULL, *al_dList=NULL, *up_dList=NULL;
    HMMSet *al_hset, *up_hset;
+   HMMSet *al_dset, *up_dset;
 
    al_hset=fbInfo->al_hset; up_hset=fbInfo->up_hset;
-   /* init logical hmm list */
+   al_dset=fbInfo->al_dset; up_dset=fbInfo->up_dset;
+
+   /* init logical hmm & dur model list */
    up_qList=(HLink *)New(&ab->abMem, Q*sizeof(HLink)); 
    --up_qList;
+   if (up_dset!=NULL) {
+      up_dList=(HLink *)New(&ab->abMem, Q*sizeof(HLink)); 
+      --up_dList;
+   }
 
    /* 2-model re-estimation update models */
    if (fbInfo->twoModels) {
       al_qList=(HLink *)New(&ab->abMem, Q*sizeof(HLink));
       --al_qList;
+      if (al_dset!=NULL) {
+         al_dList=(HLink *)New(&ab->abMem, Q*sizeof(HLink));
+         --al_dList;
+      }
    }
-   else /* use same list for update and align */
+   else {
+      /* use same list for update and align */
       al_qList = up_qList;
+      al_dList = up_dList;
+   }
 
    qIds = (LabId *)New(&ab->abMem, Q*sizeof(LabId));
    --qIds;
@@ -540,11 +719,22 @@ static int CreateInsts(FBInfo *fbInfo, A
       if((macroName=FindMacroName(al_hset,'l',lab->labid))==NULL)
          HError(7321,"CreateInsts: Unknown label %s",lab->labid->name);
       al_qList[q] = (HLink)macroName->structure;
+      if (al_dset!=NULL) {
+         if ((macroName=FindMacroName(al_dset,'l',lab->labid))==NULL)
+            HError(7321,"CreateInsts: Unknown label %s",lab->labid->name);
+         al_dList[q] = (HLink)macroName->structure;
+      }
+
       /* 2-model re-estimation update models */
       if (fbInfo->twoModels){ 
          if((macroName=FindMacroName(up_hset,'l',lab->labid))==NULL)
             HError(2321,"CreateInsts: Unknown update label %s",lab->labid->name);
          up_qList[q] = (HLink)macroName->structure;
+         if (up_dset!=NULL) {
+            if ((macroName=FindMacroName(up_dset,'l',lab->labid))==NULL)
+               HError(2321,"CreateInsts: Unknown update label %s",lab->labid->name);
+            up_dList[q] = (HLink)macroName->structure;
+         }
          /* need equal num states */
          if ((al_qList[q])->numStates != (up_qList[q])->numStates)
             HError(999,"Num states differ in align and update models (%d %d)",
@@ -567,6 +757,8 @@ static int CreateInsts(FBInfo *fbInfo, A
    /* store in struct*/
    ab->al_qList = al_qList; 
    ab->up_qList = up_qList;
+   ab->al_dList = al_dList;
+   ab->up_dList = up_dList;
    ab->qIds  = qIds;
    ab->qDms  = qDms;
 
@@ -574,21 +766,31 @@ static int CreateInsts(FBInfo *fbInfo, A
 }
 
 /* CreateAlpha: allocate alpha columns */
-static void CreateAlpha(AlphaBeta *ab, HMMSet *hset, int Q)
+static void CreateAlpha(AlphaBeta *ab, HMMSet *hset, int Q, int T)
 {
-
-   int q;
-   DVector *alphat, *alphat1;
+   int q,Nq,i;
+   DVector **alphat, **alphat1;
  
    /* Create Storage Space - two columns */
-   alphat = (DVector *)New(&ab->abMem, Q*sizeof(DVector));
+   alphat = (DVector **)New(&ab->abMem, Q*sizeof(DVector *));
    --alphat;
-   for (q=1;q<=Q;q++)
-       alphat[q] = CreateDVector(&ab->abMem, (ab->al_qList[q])->numStates);
-   alphat1=(DVector *)New(&ab->abMem, Q*sizeof(DVector));
+   for (q=1;q<=Q;q++) {
+      Nq = (ab->al_qList[q])->numStates;
+      alphat[q] = (DVector *)New(&ab->abMem, Nq*sizeof(DVector));
+      --alphat[q];
+      for (i=1; i<=Nq; i++)
+         alphat[q][i] = CreateDVector(&ab->abMem, ab->maxDur[q][i]);
+   }
+
+   alphat1=(DVector **)New(&ab->abMem, Q*sizeof(DVector *));
    --alphat1;
-   for (q=1;q<=Q;q++)
-       alphat1[q] = CreateDVector(&ab->abMem, (ab->al_qList[q])->numStates);
+   for (q=1;q<=Q;q++) {
+      Nq = (ab->al_qList[q])->numStates;
+      alphat1[q] = (DVector *)New(&ab->abMem, Nq*sizeof(DVector));
+      --alphat1[q];
+      for (i=1; i<=Nq; i++)
+         alphat1[q][i] = CreateDVector(&ab->abMem, ab->maxDur[q][i]);
+   }
 
    ab->occt = CreateVector(&ab->abMem,MaxStatesInSet(hset));
    ab->alphat  = alphat;
@@ -600,15 +802,17 @@ static void CreateAlpha(AlphaBeta *ab, H
 static void ZeroAlpha(AlphaBeta *ab, int qlo, int qhi)
 {
    HLink hmm;
-   int Nq,j,q;
-   DVector aq;
+   int Nq,j,q,d,maxDur;
+   DVector aqj;
    
    for (q=qlo;q<=qhi;q++) {   
       hmm = ab->al_qList[q]; 
       Nq = hmm->numStates; 
-      aq = ab->alphat[q];
-      for (j=1;j<=Nq;j++)
-         aq[j] = LZERO;
+      for (j=1; j<=Nq; j++) {
+         aqj = ab->alphat[q][j];  maxDur = ab->maxDur[q][j];
+         for (d=1; d<=maxDur; d++)
+            aqj[d] = LZERO;
+      }
    }
 }
 
@@ -616,11 +820,12 @@ static void ZeroAlpha(AlphaBeta *ab, int
 static void InitAlpha(AlphaBeta *ab, int *start, int *end, 
                       int Q, int skipstart, int skipend)
 {
-   int i,j,Nq,eq,q;
+   int i,j,Nq,eq,q,d,*maxDur;
    PruneInfo *p;
    HLink hmm;
-   DVector aq;
+   DVector *aq;
    float ***outprob;
+   SVector *durprob;
    LogDouble x,a,a1N=0.0;
    
    p = ab->pInfo;
@@ -628,21 +833,25 @@ static void InitAlpha(AlphaBeta *ab, int
    for (q=1; q<=eq; q++){
       hmm = ab->al_qList[q]; Nq = hmm->numStates;
       aq = ab->alphat[q];
-      aq[1] = (q==1)?0.0:ab->alphat[q-1][1]+a1N;
+      durprob = ab->durprob[q];
+      maxDur  = ab->maxDur [q];
+      aq[1][1] = (q==1) ? 0.0 : ab->alphat[q-1][1][1]+a1N;
       if((outprob = ab->otprob[1][q]) == NULL)
          HError(7322,"InitAlpha: Outprob NULL in model %d in InitAlpha",q);
       for (j=2;j<Nq;j++) {
-         a = hmm->transP[1][j];
-         aq[j] = (a>LSMALL)?aq[1]+a+outprob[j][0][0]:LZERO;
+	 a = ApplyDAEM(hmm->transP[1][j]);
+         aq[j][1] = (a>LSMALL) ? aq[1][1]+a+outprob[j][0][0] : LZERO;
+         for (d=2; d<=maxDur[j]; d++)
+            aq[j][d] = LZERO;
       }
       x = LZERO;
       for (i=2;i<Nq;i++) {
-         a = hmm->transP[i][Nq];
+	 a = ApplyDAEM(hmm->transP[i][Nq]);
          if (a>LSMALL)
-            x = LAdd(x,aq[i]+a);
+            x = LAdd(x,aq[i][1]+durprob[i][1]+a);
       }
-      aq[Nq] = x;
-      a1N = hmm->transP[1][Nq];
+      aq[Nq][1] = x;
+      a1N = ApplyDAEM(hmm->transP[1][Nq]);
    }
    ZeroAlpha(ab,eq+1,Q);
    if (trace&T_PRU && p->pruneThresh < NOPRUNE)
@@ -654,20 +863,20 @@ static void InitAlpha(AlphaBeta *ab, int
    time t, return LZERO if cannot do so */
 static LogDouble MaxModelProb(AlphaBeta *ab, int q, int t, int minq)
 {
-   DVector aq,bq,bq1;
+   DVector *aq,*bq,*bq1;
    LogDouble maxP,x;
-   int Nq1,Nq,i,qx,qx1;
+   int Nq1,Nq,d,i,qx,qx1,*maxDur;
    HLink hmm;
    
    if (q==1)
       maxP = LZERO;
    else {
       bq1 = ab->beta[t][q-1]; Nq1 = ab->al_qList[q-1]->numStates;
-      maxP = (bq1==NULL)?LZERO:ab->alphat[q-1][Nq1] + bq1[Nq1];
+      maxP = (bq1==NULL) ? LZERO : ab->alphat[q-1][Nq1][1] + bq1[Nq1][1];
       for (qx=q-1;qx>minq && ab->al_qList[qx]->transP[1][Nq1] > LSMALL;qx--){
          qx1 = qx-1;
          bq1 = ab->beta[t][qx1]; Nq1 = ab->al_qList[qx1]->numStates;
-         x=(bq1==NULL)?LZERO:ab->alphat[qx1][Nq1]+bq1[Nq1];
+         x = (bq1==NULL) ? LZERO : ab->alphat[qx1][Nq1][1]+bq1[Nq1][1];
          if (x > maxP) maxP = x;
       }
    }
@@ -675,8 +884,14 @@ static LogDouble MaxModelProb(AlphaBeta 
    bq=ab->beta[t][q];
    if (bq != NULL) {
       aq = ab->alphat[q]; 
-      for (i=1;i<Nq;i++)
-         if ((x=aq[i]+bq[i]) > maxP) maxP = x;
+      maxDur = ab->maxDur[q];
+      for (i=1;i<Nq;i++) {
+         x = LZERO;
+         for (d=1; d<=maxDur[i]; d++)
+            if (aq[i][d]>LSMALL && bq[i][d]>LSMALL)
+               x = LAdd(x,aq[i][d]+bq[i][d]);
+         if (x > maxP) maxP = x;
+      }
    }
    return maxP;
 }
@@ -686,10 +901,11 @@ static LogDouble MaxModelProb(AlphaBeta 
 static void StepAlpha(AlphaBeta *ab, int t, int *start, int *end, 
                       int Q, int T, LogDouble pr, int skipstart, int skipend)
 {
-   DVector aq,laq,*tmp, *alphat,*alphat1;
+   DVector *aq,*laq,**tmp, **alphat,**alphat1;
    PruneInfo *p;
    float ***outprob;
-   int sq,eq,i,j,q,Nq,lNq;
+   SVector *durprob;
+   int sq,eq,i,j,d,q,Nq,lNq,*maxDur;
    LogDouble x=0.0,y,a,a1N=0.0;
    HLink hmm;
    
@@ -703,19 +919,19 @@ static void StepAlpha(AlphaBeta *ab, int
    while (pr-MaxModelProb(ab,sq,t-1,sq)>pruneSetting.minFrwdP){
       ++sq;                /* raise start point */
       if (sq>p->qHi[t]) 
-         HError(7390,"StepAlpha: Alpha prune failed sq(%d) > qHi(%d)",sq,p->qHi[t]);
+         HError(7390,"StepAlpha: Alpha prune failed sq(%d) > qHi(%d) at time %d",sq,p->qHi[t],t);
    }
    if (sq<p->qLo[t])       /* start-point below beta beam so pull it back */
       sq = p->qLo[t];
    
-   eq = p->qHi[t-1]<Q?p->qHi[t-1]+1:p->qHi[t-1];
+   eq = (p->qHi[t-1]<Q) ? p->qHi[t-1]+1 : p->qHi[t-1];
    /* start end-point at top of beta beam at t-1  */
    /* JJO : + 1 to allow for state q-1[N] -> q[1] */
    /*       + 1 for each tee model following eq.  */
    while (pr-MaxModelProb(ab,eq,t-1,sq)>pruneSetting.minFrwdP){
       --eq;             /* lower end-point */
       if (eq<sq) 
-         HError(7390,"StepAlpha: Alpha prune failed eq(%d) < sq(%d)",eq,sq);
+         HError(7390,"StepAlpha: Alpha prune failed eq(%d) < sq(%d) at time %d",eq,sq,t);
    }
    while (eq<Q && ab->qDms[eq]==0) eq++;
    if (eq>p->qHi[t])  /* end point above beta beam so pull it back */
@@ -739,34 +955,47 @@ static void StepAlpha(AlphaBeta *ab, int
       lNq = Nq; hmm = ab->al_qList[q]; Nq = hmm->numStates; 
       aq = alphat[q]; 
       laq = alphat1[q];
+      durprob = ab->durprob[q];
+      maxDur  = ab->maxDur[q];
       if (laq == NULL)
          HError(7322,"StepAlpha: laq gone wrong!");
       if((outprob = ab->otprob[t][q]) == NULL)
          HError(7322,"StepAlpha: Outprob NULL at time %d model %d in StepAlpha",t,q);
       if (q==1)
-         aq[1] = LZERO;
+         aq[1][1] = LZERO;
       else{
-         aq[1] = alphat1[q-1][lNq];
+         aq[1][1] = alphat1[q-1][lNq][1];
          if (q>sq && a1N>LSMALL) /* tee Model */
-            aq[1] = LAdd(aq[1],alphat[q-1][1]+a1N);
+            aq[1][1] = LAdd(aq[1][1], alphat[q-1][1][1]+a1N);
       }
       for (j=2;j<Nq;j++) {
-         a = hmm->transP[1][j];
-         x = (a>LSMALL)?a+aq[1]:LZERO;
+	 a = ApplyDAEM(hmm->transP[1][j]);
+         x = (a>LSMALL) ? aq[1][1]+a : LZERO;
          for (i=2;i<Nq;i++){
-            a = hmm->transP[i][j]; y = laq[i];
-            if (a>LSMALL && y>LSMALL)
-               x = LAdd(x,y+a);
+	    a = ApplyDAEM(hmm->transP[i][j]);
+            if (a>LSMALL)
+               for (d=1; d<=maxDur[i]; d++) {
+                  y = laq[i][d];
+                  if (y>LSMALL)
+                     x = LAdd(x,y+durprob[i][d]+a);
+               }
          }
-         aq[j] = x + outprob[j][0][0];
+         aq[j][1] = x + outprob[j][0][0];
+
+         for (d=2; d<=maxDur[j]; d++)
+            aq[j][d] = laq[j][d-1] + outprob[j][0][0];
       }
       x = LZERO;
       for (i=2;i<Nq;i++){
-         a = hmm->transP[i][Nq]; y = aq[i];
-         if (a>LSMALL && y>LSMALL)
-            x = LAdd(x,y+a);
+	a = ApplyDAEM(hmm->transP[i][Nq]);
+         if (a>LSMALL)
+            for (d=1; d<=maxDur[i]; d++) {
+               y = aq[i][d];
+               if (y>LSMALL)
+                  x = LAdd(x,y+durprob[i][d]+a);
       }
-      aq[Nq] = x; a1N = hmm->transP[1][Nq];
+      }
+      aq[Nq][1] = x; a1N = ApplyDAEM(hmm->transP[1][Nq]);
    }
    if (eq<Q) ZeroAlpha(ab,eq+1,Q);
 
@@ -789,12 +1018,12 @@ static void CreateBeta(AlphaBeta *ab, in
 {
    int t;
    PruneInfo *p;
-   DVector **beta;
+   DVector ***beta;
 
    p = ab->pInfo;
    p->qHi = CreateShortVec(&ab->abMem, T); /* storage for min and max q vals */
    p->qLo = CreateShortVec(&ab->abMem, T);
-   beta=(DVector **)New(&ab->abMem, T*sizeof(DVector *));
+   beta=(DVector ***)New(&ab->abMem, T*sizeof(DVector **));
    --beta;
    for (t=1;t<=T;t++){
       beta[t] = NULL;
@@ -804,14 +1033,14 @@ static void CreateBeta(AlphaBeta *ab, in
 }
 
 /* CreateBetaQ: column of DVectors covering current beam */
-static DVector *CreateBetaQ(MemHeap *x, int qLo,int qHi,int Q)
+static DVector **CreateBetaQ (MemHeap *x, int qLo, int qHi, int Q)
 {
    int q;
-   DVector *v;
+   DVector **v;
 
    qLo--; qLo--;  if (qLo<1) qLo=1;
    qHi++;  if (qHi>Q) qHi=Q;
-   v = (DVector *)New(x, (qHi-qLo+1)*sizeof(DVector));
+   v = (DVector **)New(x, (qHi-qLo+1)*sizeof(DVector *));
    v -= qLo;
    for (q=qLo;q<=qHi;q++) v[q] = NULL;
    return(v);
@@ -847,12 +1076,16 @@ static float ****CreateOqprob(MemHeap *x
 }
 
 /* NewBetaVec: create prob vector size 1..N */
-static DVector NewBetaVec(MemHeap *x, int N)
+static DVector *NewBetaVec(MemHeap *x, int N, int *maxDur)
 {
-   DVector v;
+   int n;
+   DVector *v;
    
-   v=(DVector)New(x, N*sizeof(double));
+   v=(DVector *)New(x, N*sizeof(double));
    --v;
+   for (n=1; n<=N; n++)
+      v[n] = CreateDVector(x, maxDur[n]);
+
    return v;
 }
 
@@ -895,7 +1128,7 @@ static float * NewOtprobVec(MemHeap *x, 
 }
 
 /* ShStrP: Stream Outp calculation exploiting sharing */
-static float * ShStrP(HMMSet *hset, StreamElem *ste, Vector v, int t,
+static float * ShStrP(HMMSet *hset, StreamInfo *sti, Vector v, const int t, 
 		       AdaptXForm *xform, MemHeap *abmem)
 {
    WtAcc *wa;
@@ -904,16 +1137,16 @@ static float * ShStrP(HMMSet *hset, Stre
    float *outprobjs;
    int m,M;
    PreComp *pMix;
-   LogFloat det,x,mixp,wt;
+   LogFloat det,x,mixp,wt=0.0;
    Vector otvs;
    
-   wa = (WtAcc *)ste->hook;
+   wa = (WtAcc *)sti->hook;
    if (wa->time==t)           /* seen this state before */
       outprobjs = wa->prob;
    else {
-      M = ste->nMix;
+      M = sti->nMix;
       outprobjs = NewOtprobVec(abmem,M);
-      me = ste->spdf.cpdf+1;
+      me = sti->spdf.cpdf+1;
       if (M==1){                 /* Single Mix Case */
          mp = me->mpdf;
          pMix = (PreComp *)mp->hook;
@@ -926,6 +1159,7 @@ static float * ShStrP(HMMSet *hset, Stre
                pMix->prob = x; pMix->time = t;
             }
          }
+         x = ApplyDAEM(x);
       } else if (sharedMix) { /* Multiple Mixture Case - general case */
          x = LZERO;
          for (m=1;m<=M;m++,me++) {
@@ -942,6 +1176,9 @@ static float * ShStrP(HMMSet *hset, Stre
                      pMix->prob = mixp; pMix->time = t;
                   }
                }
+               mixp = ApplyDAEM(mixp);
+               wt   = ApplyDAEM(wt);
+               if (mixp>LSMALL && wt>LSMALL)
                x = LAdd(x,wt+mixp);
 	       outprobjs[m] = mixp;
             }
@@ -954,6 +1191,9 @@ static float * ShStrP(HMMSet *hset, Stre
                mp = me->mpdf;
 	       mixp = MOutP(ApplyCompFXForm(mp,v,xform,&det,t),mp);
 	       mixp += det;
+               mixp = ApplyDAEM(mixp);
+               wt   = ApplyDAEM(wt);
+               if (mixp>LSMALL && wt>LSMALL)
                x = LAdd(x,wt+mixp);
 	       outprobjs[m] = mixp;
             }
@@ -965,15 +1205,20 @@ static float * ShStrP(HMMSet *hset, Stre
 	 otvs = ApplyCompFXForm(mp,v,xform,&det,t);
 	 mixp = IDOutP(otvs,VectorSize(otvs),mp); /* INVDIAGC assumed */
 	 mixp += det;
+         mixp = ApplyDAEM(mixp);
+         wt   = ApplyDAEM(wt);
 	 x = wt+mixp;
 	 outprobjs[1] = mixp;
-	 for (m=2,me=ste->spdf.cpdf+2;m<=M;m++,me++) {
+	 for (m=2,me=sti->spdf.cpdf+2;m<=M;m++,me++) {
             wt = MixLogWeight(hset,me->weight);
 	    if (wt>LMINMIX){
 	       mp = me->mpdf;
 	       otvs = ApplyCompFXForm(mp,v,xform,&det,t);
 	       if (PDEMOutP(otvs,mp,&mixp,x-wt-det) == TRUE) {
 		  mixp += det;
+                  mixp = ApplyDAEM(mixp);
+                  wt   = ApplyDAEM(wt);
+                  if (mixp>LSMALL && wt>LSMALL)
 		  x = LAdd(x,wt+mixp);
 	       }
 	       outprobjs[m] = mixp; /* LZERO if PDEMOutP returns FALSE */
@@ -988,27 +1233,27 @@ static float * ShStrP(HMMSet *hset, Stre
 }
    
 /* Setotprob: allocate and calculate otprob matrix at time t */
-static void Setotprob(AlphaBeta *ab, FBInfo *fbInfo, ParmBuf pbuf, 
-                      Observation ot, int t, int S, int qHi, int qLo)
+static void Setotprob(AlphaBeta *ab, FBInfo *fbInfo, UttInfo *utt, int t, int S, int qHi, int qLo)
 {
    int q,j,Nq,s;
    float ***outprob, **outprobj, *****otprob;
+   StateInfo *si;
    StreamElem *ste;
+   StreamInfo *sti;
    HLink hmm;
    LogFloat sum;
    PruneInfo *p;
    int skipstart, skipend;
    HMMSet *hset;
-   Boolean seenState=FALSE;
+   Boolean seenStr=FALSE;
    
    hset = fbInfo->al_hset;
    skipstart = fbInfo->skipstart;
    skipend = fbInfo->skipend;
    p = ab->pInfo;
    otprob = ab->otprob;
-   ReadAsTable(pbuf,t-1,&ot);
    if (hset->hsKind == TIEDHS)
-      PrecomputeTMix(hset,&ot,pruneSetting.minFrwdP,0);
+      PrecomputeTMix(hset,&utt->o[t],pruneSetting.minFrwdP,0);
    if (trace&T_OUT && NonSkipRegion(skipstart,skipend,t)) 
       printf(" Output Probs at time %d\n",t);
    if (qLo>1) --qLo;
@@ -1021,29 +1266,31 @@ static void Setotprob(AlphaBeta *ab, FBI
          {
             outprob = otprob[t][q] = CreateOjsprob(&ab->abMem,Nq,S);
             for (j=2;j<Nq;j++){
-               ste=hmm->svec[j].info->pdf+1; sum = 0.0;
+               si=hmm->svec[j].info;
+               ste=si->pdf+1; sum = 0.0;
                outprobj = outprob[j];
                for (s=1;s<=S;s++,ste++){
+                  sti = ste->info;
                   switch (hset->hsKind){
                   case TIEDHS:  /* SOutP deals with tied mix calculation */
                   case DISCRETEHS:
                      if (S==1) {
                         outprobj[0] = NewOtprobVec(&ab->abMem,1);
-                        outprobj[0][0] = SOutP(hset,s,&ot,ste);
+                        outprobj[0][0] = SOutP(hset,s,&utt->o[t],sti);
                      } else {
                         outprobj[s] = NewOtprobVec(&ab->abMem,1);
-                        outprobj[s][0] = SOutP(hset,s,&ot,ste);
+                        outprobj[s][0] = SOutP(hset,s,&utt->o[t],sti);
                      }
 		     break;
     /* Check that PLAINHS is handled correctly this  way - efficient? */
                   case PLAINHS:  
                   case SHAREDHS: 
 		     if (S==1)
-		        outprobj[0] = ShStrP(hset,ste,ot.fv[s],t,fbInfo->al_inXForm,&ab->abMem);
+                        outprobj[0] = ShStrP(hset,sti,utt->o[t].fv[s],t,fbInfo->al_inXForm_hmm,&ab->abMem);
 		     else {
-                        if (((WtAcc *)ste->hook)->time==t) seenState=TRUE;
-                        else seenState=FALSE;
-		        outprobj[s] = ShStrP(hset,ste,ot.fv[s],t,fbInfo->al_inXForm,&ab->abMem);
+                        if (((WtAcc *)sti->hook)->time==t) seenStr=TRUE;
+                        else seenStr=FALSE;
+                        outprobj[s] = ShStrP(hset,sti,utt->o[t].fv[s],t,fbInfo->al_inXForm_hmm,&ab->abMem);
                      }
 		    break;
                   default:
@@ -1053,22 +1300,16 @@ static void Setotprob(AlphaBeta *ab, FBI
 		        outprobj[s] = NULL; 
                   }
                   if (S>1)
-		     sum += outprobj[s][0];
+                     sum += si->weights[s] * outprobj[s][0];
                }
                if (S>1){
-                  if (seenState) {
-                     outprobj[0][0] = sum/2;
-                  } else {
                      outprobj[0][0] = sum;
-                     for (s=1;s<=S;s++)
-                        outprobj[s][0] = sum - outprobj[s][0];
-                  }
                }
                if (trace&T_OUT && NonSkipRegion(skipstart,skipend,t)) {
                   printf(" %d. ",j); PrLog(outprobj[0][0]);
                   if (S>1){
                      printf("[ ");
-                     for (s=1;s<=S;s++) PrLog(outprobj[s][0]);
+                     for (s=1; s<=S; s++) PrLog(outprobj[0][0] - si->weights[s]*outprobj[s][0]);
                      printf("]");
                   }
                }
@@ -1079,12 +1320,109 @@ static void Setotprob(AlphaBeta *ab, FBI
    }
 }
 
+/* EXPORT->ResetDMMPreComps: reset all pre-calculated durprob matrices */
+void ResetDMMPreComps (HMMSet *dset)
+{
+   HMMScanState hss;
+   WtAcc *wa;
+   
+   /* reset dprob hooks */
+   NewHMMScan(dset,&hss);
+   while (GoNextStream(&hss,FALSE)) {
+      wa = (WtAcc *)hss.sti->hook;
+      SetHook(wa->c,NULL);
+   }
+   EndHMMScan(&hss);
+   
+   /* reset all dprob matrices */ 
+   ResetHeap(&dprobStack);
+}
+
+/* Setdurprob: allocate and calculate durprob matrix */
+static void Setdurprob(AlphaBeta *ab, FBInfo *fbInfo, UttInfo *utt)
+{
+   int q,j,Nq,d,maxDur;
+   double var=0.0;
+   float stw;
+   LogFloat det;
+   Vector dur;
+   SVector dprob;
+   StateInfo *si;
+   StreamInfo *sti;
+   MixPDF *mp;
+   WtAcc *wa;
+   
+   /* vector to be used to calculate duration prob */
+   dur = CreateVector(&gstack,1);
+   
+   /* duration prob and max # of durations */
+   ab->durprob = (SVector **) New(&ab->abMem,utt->Q*sizeof(SVector *));
+   ab->maxDur  = (int **)     New(&ab->abMem,utt->Q*sizeof(int *));
+   ab->durprob--;  ab->maxDur--;
+
+   for (q=1; q<=utt->Q; q++) {
+      Nq = ab->al_qList[q]->numStates;
+      ab->durprob[q] = (SVector *) New(&ab->abMem, Nq*sizeof(SVector));
+      ab->maxDur [q] = (int *)     New(&ab->abMem, Nq*sizeof(int));
+      ab->durprob[q]--;  ab->maxDur[q]--;
+      si = (semiMarkov) ? ab->al_dList[q]->svec[2].info : NULL;
+      
+      for (j=1; j<=Nq; j++) {
+         if (!semiMarkov || j==1 || j==Nq) {
+            ab->maxDur [q][j]    = 1;
+            ab->durprob[q][j]    = CreateSVector(&ab->abMem, 1);
+            ab->durprob[q][j][1] = 0.0;
+         }
+         else {
+            /* currently only single Gaussian is supported */
+            sti = ab->al_dList[q]->svec[2].info->pdf[j-1].info;
+            stw = ab->al_dList[q]->svec[2].info->weights[j-1];   /* stream weight */
+            wa = (WtAcc *)sti->hook;
+            if (GetHook(wa->c)==NULL) {
+               /* calculate max duration */
+               mp = sti->spdf.cpdf[1].mpdf;
+               ApplyCompXForm(mp, fbInfo->al_inXForm_dur, TRUE);  /* transform mp in full form */
+               switch(mp->ckind) {
+               case DIAGC:    var = mp->cov.var[1]; break;
+               case INVDIAGC: var = 1.0 / mp->cov.var[1]; break;
+               case FULLC:    var = 1.0 / mp->cov.inv[1][1]; break;
+               }
+               maxDur = (int)(mp->mean[1] + maxstdDevCoef*sqrt(var) + 0.5);
+               maxDur = (maxDur<minDur) ? minDur : maxDur;
+               ApplyCompXForm(mp, fbInfo->al_inXForm_dur, fbInfo->xfinfo_dur->inFullC);
+               
+               /* compute duration prob */
+               dprob  = CreateSVector(&dprobStack,maxDur);
+               for (d=1; d<=maxDur; d++) {
+                  dur[1] = (float)d;
+                  dprob[d] = MOutP(ApplyCompFXForm(mp,dur,fbInfo->al_inXForm_dur,&det,d),mp);
+                  dprob[d] += det;
+                  dprob[d] = ApplyDAEM(dprob[d]);
+               }
+               if (stw!=1.0) /* multiply stream weight */
+                  for (d=1; d<=maxDur; d++) dprob[d] *= stw;
+               SetHook(dprob,(Ptr)((long)(maxDur)));
+               SetHook(wa->c,dprob);
+            }
+            else {
+               dprob = (SVector) GetHook(wa->c);
+               maxDur = (int)((long)GetHook(dprob));
+            }
+            ab->maxDur [q][j] = maxDur;
+            ab->durprob[q][j] = dprob;
+         }
+      }
+   }
+   
+   FreeVector(&gstack,dur);
+}
+
 /* TraceAlphaBeta: print alpha/beta values at time t, also sum
          alpha/beta product across states at t-, t, and t+ */
 static void TraceAlphaBeta(AlphaBeta *ab, int t, int startq, int endq, LogDouble pr)
 {
-   int i,q,Nq;
-   DVector aqt,bqt;
+   int i,q,Nq,d,*maxDur;
+   DVector *aqt,*bqt;
    HLink hmm;
    double summ,sump,sum;
    
@@ -1095,15 +1433,26 @@ static void TraceAlphaBeta(AlphaBeta *ab
       printf("  Q%2d: %5s           alpha             beta\n",
              q,ab->qIds[q]->name);
       aqt = ab->alphat[q]; bqt = ab->beta[t][q];
+      maxDur = ab->maxDur[q];
       for (i=1;i<=Nq;i++){
-         printf("                "); PrLog(aqt[i]); 
-         printf("     ");        PrLog(bqt[i]);
+         for (d=1; d<=maxDur[i]; d++) {
+            if (!semiMarkov) {
+               printf("                "); PrLog(aqt[i][d]);
+               printf("     ");        PrLog(bqt[i][d]);
+            }
+            else { 
+               printf("   d%5d       ",d); PrLog(aqt[i][d]);
+               printf("     ");        PrLog(bqt[i][d]);
+            }
          printf("\n");
       }
-      summ = LAdd(summ,aqt[1]+bqt[1]);
+      }
+      summ = LAdd(summ,aqt[1][1]+bqt[1][1]);
       for (i=2;i<Nq;i++)
-         sum = LAdd(sum,aqt[i]+bqt[i]);
-      sump = LAdd(sump,aqt[Nq]+bqt[Nq]);
+         for (d=1; d<=maxDur[i]; d++)
+            if (aqt[i][d]>LSMALL && bqt[i][d]>LSMALL)
+               sum = LAdd(sum,aqt[i][d]+bqt[i][d]);
+      sump = LAdd(sump,aqt[Nq][1]+bqt[Nq][1]);
    }
    printf("  Sums of Products:  "); PrLog(summ-pr);
    printf("(-)   "); PrLog(sum-pr); 
@@ -1145,15 +1494,134 @@ static void SetBeamTaper(PruneInfo *p, s
 }
 
 
+/* SetAlign: set start and end frame according to given label */
+void SetAlign (long *st, long *en, short *qDms, const int Q, const int T)
+{
+   int q, i, mindur;
+
+   /* set segment boundaries which can be determined from given label */
+   st[1] = 1;
+   en[Q] = T;
+   for (q=1; q<=Q; q++) {
+      if (q>1 && st[q]<=0 && en[q-1]>0) st[q] = en[q-1]+1;
+      if (q<Q && en[q]<=0 && st[q+1]>0) en[q] = st[q+1]-1;
+
+      if (q>1 && st[q]>0 && en[q-1]>0 && st[q]-en[q-1]>1)
+         st[q] = en[q-1] = (st[q]+en[q-1])/2; 
+   }
+   
+   /* set segment boundaries which can be determined from given label and #HMM states */
+   /* set segment end and start frames */
+   for (q=Q-1; q>=1; q--) {
+      if (en[q]<=0)
+         en[q] = en[q+1]-qDms[q+1];
+   }
+   for (q=2; q<=Q; q++) {
+      if (st[q]<=0)
+         st[q] = st[q-1]+qDms[q-1];
+   }
+
+   /* check length of each segment and #HMM states */
+   for (q=1; q<=Q; q++) {
+      for (i=mindur=0; q+i<=Q; i++) {
+         mindur += qDms[q+i];
+         while (en[q+i]-st[q]+1<mindur) {
+            if (st[q]<=1 && en[q+i]>=T) 
+               HError(7399,"SetAlign: given data sequence is shorter than given sentence HMM");
+            if (st[q]>1)
+               st[q]--;
+            if (en[q+i]<T)
+               en[q+i]++;
+         }
+      }
+   }
+
+   /* check start and end */
+   for (q=2; q<=Q; q++) {
+      if (st[q]>en[q-1]+1)
+         HError(-7399,"SetAlign: start[%d]=%d is larger than end[%d]=%d", q, st[q], q-1, en[q-1]);
+   }
+}
+
+/* SetAlignBeam: set beam start and end points according to given model alignment */
+static void SetAlignBeam (AlphaBeta *ab, PruneInfo *p, UttInfo *utt)
+{
+   LabList *lablist;
+   LLink lab;
+   long *st, *en;
+   int t, q;
+   Boolean hasAlign = FALSE;
+
+   const int T = utt->T;
+   const int Q = utt->Q;
+
+   /* label list for current uttreance */
+   lablist = utt->tr->head;
+   
+   /* allocate start and end */ 
+   st = (long *) New(&ab->abMem, Q*sizeof(long));
+   en = (long *) New(&ab->abMem, Q*sizeof(long));
+   st--; en--;
+
+   /* get start and end time for q-th model according to given model alignment */
+   for (q=1; q<=Q; q++) {
+      lab = GetLabN(lablist,q);  /* q-th label */
+      /* read start and end time for current model */
+      st[q] = (long)lab->start/utt->tgtSampRate + 1;
+      en[q] = (long)lab->end  /utt->tgtSampRate;
+      
+      if (en[q]>T)
+         en[q] = T;
+         
+      if (!hasAlign && ( (st[q]>1 && st[q]<T) || (en[q]>1 && en[q]<T)))
+         hasAlign = TRUE;
+   }
+
+   if (hasAlign) {
+      /* arrange alignment */ 
+      SetAlign(st, en, ab->qDms, Q, T);
+      
+      /* set beam width (qLo and qHi) according to start and end time */
+      for (t=2; t<T; t++) {
+         /* set qHi */
+         for (q=p->qHi[t]; q>0; q--) {
+            if (st[q]<=t && t<=en[q]) 
+               break;
+         }
+         p->qHi[t] = q;
+
+         /* set qLo */
+         for (q=p->qLo[t]; q<=Q; q++) {
+            if (st[q]<=t && t<=en[q])
+               break;
+         }
+         p->qLo[t] = q;
+      }
+      
+      /* check qLo and qHi */
+      for (t=1; t<=T; t++) {
+         if (p->qLo[t]>p->qHi[t]) 
+            HError(7399,"SetAlignBeam: beam is irregal, qLo[%d]=%d > qHi[%d]=%d", t, p->qLo[t], t, p->qHi[t]); 
+      }
+   }
+
+   /* free start and end */
+   st++; en++;
+   Dispose(&ab->abMem, en);
+   Dispose(&ab->abMem, st);
+   
+   return;
+}
+
 /* SetBeta: allocate and calculate beta and otprob matrices */
 static LogDouble SetBeta(AlphaBeta *ab, FBInfo *fbInfo, UttInfo *utt)
 {
 
-   ParmBuf pbuf;
-   int i,j,t,q,Nq,lNq=0,q_at_gMax,startq,endq;
+   int i,j,t,q,Nq,lNq=0,q_at_gMax,startq,endq,d,*maxDur;
    int S, Q, T;
-   DVector bqt=NULL,bqt1,bq1t1,maxP, **beta;
+   DVector *bqt=NULL,*bqt1,*bq1t1,maxP,***beta;
    float ***outprob;
+   SVector *durprob;
    LogDouble x,y,gMax,lMax,a,a1N=0.0;
    HLink hmm;
    PruneInfo *p;
@@ -1163,7 +1631,7 @@ static LogDouble SetBeta(AlphaBeta *ab, 
    hset = fbInfo->al_hset;
    skipstart = fbInfo->skipstart;
    skipend = fbInfo->skipend;
-   pbuf=utt->pbuf;
+
    S=utt->S;
    Q=utt->Q;
    T=utt->T;
@@ -1174,24 +1642,28 @@ static LogDouble SetBeta(AlphaBeta *ab, 
   
    /* Last Column t = T */
    p->qHi[T] = Q; endq = p->qLo[T];
-   Setotprob(ab,fbInfo,pbuf,utt->ot,T,S,Q,endq);
+   Setotprob(ab,fbInfo,utt,T,S,Q,endq);
+   Setdurprob(ab,fbInfo,utt);
    beta[T] = CreateBetaQ(&ab->abMem,endq,Q,Q);
    gMax = LZERO;   q_at_gMax = 0;    /* max value of beta at time T */
    for (q=Q; q>=endq; q--){
       hmm = ab->al_qList[q]; Nq = hmm->numStates;
-      bqt = beta[T][q] = NewBetaVec(&ab->abMem,Nq);
-      bqt[Nq] = (q==Q)?0.0:beta[T][q+1][lNq]+a1N;
+      durprob = ab->durprob[q];
+      maxDur  = ab->maxDur[q];
+      bqt = beta[T][q] = NewBetaVec(&ab->abMem,Nq,maxDur);
+      bqt[Nq][1] = (q==Q) ? 0.0 : beta[T][q+1][lNq][1]+a1N;
       for (i=2;i<Nq;i++) 
-         bqt[i] = hmm->transP[i][Nq]+bqt[Nq];
+         for (d=1; d<=maxDur[i]; d++)
+	    bqt[i][d] = durprob[i][d] + ApplyDAEM(hmm->transP[i][Nq]) + bqt[Nq][1];
       outprob = ab->otprob[T][q];
       x = LZERO;
       for (j=2; j<Nq; j++){
-         a = hmm->transP[1][j]; y = bqt[j];
+	 a = ApplyDAEM(hmm->transP[1][j]); y = bqt[j][1];
          if (a>LSMALL && y > LSMALL)
             x = LAdd(x,a+outprob[j][0][0]+y);
       }
-      bqt[1] = x;
-      lNq = Nq; a1N = hmm->transP[1][Nq];
+      bqt[1][1] = x;
+      lNq = Nq; a1N = ApplyDAEM(hmm->transP[1][Nq]);
       if (x>gMax) {
          gMax = x; q_at_gMax = q;
       }
@@ -1212,44 +1684,58 @@ static LogDouble SetBeta(AlphaBeta *ab, 
       /*  unless this is outside the beam taper.     */
       /*  + 1 to allow for state q+1[1] -> q[N]      */
       /*  + 1 for each tee model preceding endq.     */
-      Setotprob(ab,fbInfo,pbuf,utt->ot,t,S,startq,endq);
+      Setotprob(ab,fbInfo,utt,t,S,startq,endq);
       beta[t] = CreateBetaQ(&ab->abMem,endq,startq,Q);
       for (q=startq;q>=endq;q--) {
          lMax = LZERO;                 /* max value of beta in model q */
          hmm = ab->al_qList[q]; 
          Nq = hmm->numStates;
-         bqt = beta[t][q] = NewBetaVec(&ab->abMem,Nq);
+         durprob = ab->durprob[q];
+         maxDur  = ab->maxDur[q];
+         bqt = beta[t][q] = NewBetaVec(&ab->abMem,Nq,maxDur);
          bqt1 = beta[t+1][q];
          bq1t1 = (q==Q)?NULL:beta[t+1][q+1];
          outprob = ab->otprob[t+1][q];
-         bqt[Nq] = (bq1t1==NULL)?LZERO:bq1t1[1];
+         bqt[Nq][1] = (bq1t1==NULL) ? LZERO : bq1t1[1][1];
          if (q<startq && a1N>LSMALL)
-            bqt[Nq]=LAdd(bqt[Nq],beta[t][q+1][lNq]+a1N);
+            bqt[Nq][1] = LAdd(bqt[Nq][1], beta[t][q+1][lNq][1]+a1N);
          for (i=Nq-1;i>1;i--){
-            x = hmm->transP[i][Nq] + bqt[Nq];
-            if (q>=p->qLo[t+1]&&q<=p->qHi[t+1])
+            for (d=1; d<=maxDur[i]; d++) {
+	       x = durprob[i][d] + ApplyDAEM(hmm->transP[i][Nq]) + bqt[Nq][1];
+               if (q>=p->qLo[t+1] && q<=p->qHi[t+1]) {
                for (j=2;j<Nq;j++) {
-                  a = hmm->transP[i][j]; y = bqt1[j];
+		     a = ApplyDAEM(hmm->transP[i][j]); y = bqt1[j][1];
                   if (a>LSMALL && y>LSMALL)
-                     x = LAdd(x,a+outprob[j][0][0]+y);
+                        x = LAdd(x,durprob[i][d]+a+outprob[j][0][0]+y);
+                  }
+                  if (d<maxDur[i] && bqt1[i][d+1]>LSMALL)
+                     x = LAdd(x,outprob[i][0][0]+bqt1[i][d+1]);
+               }
+               bqt[i][d] = x;
                }
-            bqt[i] = x;
+            /* compute lMax and gMax only if pruning is on */
+            if (p->pruneThresh < NOPRUNE) { 
+               x = LZERO;
+               for (d=1; d<=maxDur[i]; d++)
+                  if (bqt[i][d]>LSMALL)
+                     x = LAdd(x,bqt[i][d]);
             if (x>lMax) lMax = x;
             if (x>gMax) {
                gMax = x; q_at_gMax = q;
             }
          }
+         }
          outprob = ab->otprob[t][q];
          x = LZERO;
          for (j=2; j<Nq; j++){
-            a = hmm->transP[1][j];
-            y = bqt[j];
+	    a = ApplyDAEM(hmm->transP[1][j]);
+            y = bqt[j][1];
             if (a>LSMALL && y>LSMALL)
                x = LAdd(x,a+outprob[j][0][0]+y);
          }
-         bqt[1] = x;
+         bqt[1][1] = x;
          maxP[q] = lMax;
-         lNq = Nq; a1N = hmm->transP[1][Nq];
+         lNq = Nq; a1N = ApplyDAEM(hmm->transP[1][Nq]);
       }
       while (gMax-maxP[startq] > p->pruneThresh) {
          beta[t][startq] = NULL;
@@ -1277,7 +1763,7 @@ static LogDouble SetBeta(AlphaBeta *ab, 
    }
 
    /* Finally, set total prob pr */
-   utt->pr = bqt[1];
+   utt->pr = bqt[1][1];
 
    if (utt->pr <= LSMALL) {
       return LZERO;
@@ -1311,14 +1797,8 @@ static void CheckData(HMMSet *hset, char
    }
 }
 
-/* ResetStacks: Reset all stacks used by StepBack function */
-static void ResetStacks(AlphaBeta *ab)
-{
-   ResetHeap(&ab->abMem);
-}
-
 /* StepBack: Step utterance from T to 1 calculating Beta matrix*/
-static Boolean StepBack(FBInfo *fbInfo, UttInfo *utt, char * datafn)
+static Boolean StepBack(FBInfo *fbInfo, UttInfo *utt)
 {
    LogDouble lbeta;
    LogDouble pruneThresh;
@@ -1326,12 +1806,14 @@ static Boolean StepBack(FBInfo *fbInfo, 
    PruneInfo *p;
    int qt;
    
-   ResetObsCache();  
+   ResetObsCache(fbInfo->xfinfo_hmm);
+   if (fbInfo->xfinfo_dur != NULL)
+     ResetObsCache(fbInfo->xfinfo_dur);
    ab = fbInfo->ab;
    pruneThresh=pruneSetting.pruneInit;
    do
       {
-         ResetStacks(ab);
+         ResetHeap(&ab->abMem);
          InitPruneStats(ab);  
          p = fbInfo->ab->pInfo;
          p->pruneThresh = pruneThresh;
@@ -1339,11 +1821,13 @@ static Boolean StepBack(FBInfo *fbInfo, 
          if (qt>utt->T) {
             if (trace&T_TOP)
                printf(" Unable to traverse %d states in %d frames\n",qt,utt->T);
-            HError(-7324,"StepBack: File %s - bad data or over pruning\n",datafn);
+            HError(-7324,"StepBack: Bad data or over pruning\n");
             return FALSE;
          }
          CreateBeta(ab,utt->T);
          SetBeamTaper(p,ab->qDms,utt->Q,utt->T);
+         if (fbInfo->useAlign)
+            SetAlignBeam(ab, p, utt);
          CreateOtprob(ab,utt->T);
          lbeta=SetBeta(ab,fbInfo,utt);
          if (lbeta>LSMALL) break;
@@ -1351,7 +1835,7 @@ static Boolean StepBack(FBInfo *fbInfo, 
          if (pruneThresh>pruneSetting.pruneLim || pruneSetting.pruneInc==0.0) {
             if (trace&T_TOP)
                printf(" No path found in beta pass\n");
-            HError(-7324,"StepBack: File %s - bad data or over pruning\n",datafn);
+            HError(-7324,"StepBack: Bad data or over pruning\n");
             return FALSE;
          }
          if (trace&T_TOP) {
@@ -1369,12 +1853,13 @@ static Boolean StepBack(FBInfo *fbInfo, 
 
 /* UpTranParms: update the transition counters of given hmm */
 static void UpTranParms(FBInfo *fbInfo, HLink hmm, int t, int q,
-                        DVector aqt, DVector bqt, DVector bqt1, DVector bq1t, 
+                        DVector *aqt, DVector *bqt, DVector *bqt1, DVector *bq1t, 
                         LogDouble pr)
 {
-   int i,j,N;
+   int i,j,N,d,*maxDur;
    Vector ti,ai;
    float ***outprob,***outprob1;
+   SVector *durprob;
    double sum,x;
    TrAcc *ta;
    AlphaBeta *ab;
@@ -1383,28 +1868,44 @@ static void UpTranParms(FBInfo *fbInfo, 
    ab = fbInfo->ab;
    ta = (TrAcc *) GetHook(hmm->transP);
    outprob = ab->otprob[t][q]; 
+   durprob = ab->durprob[q];
+   maxDur  = ab->maxDur[q];
    if (bqt1!=NULL) outprob1 = ab->otprob[t+1][q];  /* Bug fix */
    else outprob1 = NULL;
-   for (i=1;i<N;i++)
-      ta->occ[i] += ab->occt[i];
    for (i=1;i<N;i++) {
       ti = ta->tran[i]; ai = hmm->transP[i];
       for (j=2;j<=N;j++) {
          if (i==1 && j<N) {                  /* entry transition */
-            x = aqt[1]+ai[j]+outprob[j][0][0]+bqt[j]-pr;
-            if (x>MINEARG) ti[j] += exp(x);
-         } else
+	    x = aqt[1][1]+ApplyDAEM(ai[j])+outprob[j][0][0]+bqt[j][1]-pr;
+         }
+         else {
             if (i>1 && j<N && bqt1!=NULL) {     /* internal transition */
-               x = aqt[i]+ai[j]+outprob1[j][0][0]+bqt1[j]-pr;
-               if (x>MINEARG) ti[j] += exp(x);
-            } else
+               x = LZERO;
+               for (d=1; d<=maxDur[i]; d++)
+                  if (aqt[i][d]>LSMALL)
+                     x = LAdd(x,aqt[i][d]+durprob[i][d]);
+               x += ApplyDAEM(ai[j])+outprob1[j][0][0]+bqt1[j][1]-pr;
+            }
+            else {
                if (i>1 && j==N) {                  /* exit transition */
-                  x = aqt[i]+ai[N]+bqt[N]-pr;
-                  if (x>MINEARG) ti[N] += exp(x);
+                  x = LZERO;
+                  for (d=1; d<=maxDur[i]; d++)
+                     if (aqt[i][d]>LSMALL)
+                        x = LAdd(x,aqt[i][d]+durprob[i][d]);
+                  x += ApplyDAEM(ai[N])+bqt[N][1]-pr;
+               }
+               else
+                  x = LZERO;
+	    }
+	 }
+         if (x>MINEARG) {
+            ti[j] += exp(x); ta->occ[i] += exp(x);
+         }
+         if (i==1 && j==N && ApplyDAEM(ai[N])>LSMALL && bq1t != NULL){ /* tee transition */
+	    x = aqt[1][1]+ApplyDAEM(ai[N])+bq1t[1][1]-pr;
+            if (x>MINEARG) {
+               ti[N] += exp(x); ta->occ[i] += exp(x);
                }
-         if (i==1 && j==N && ai[N]>LSMALL && bq1t != NULL){ /* tee transition */
-            x = aqt[1]+ai[N]+bq1t[1]-pr;
-            if (x>MINEARG) ti[N] += exp(x);
          }
       }
    }
@@ -1424,14 +1925,15 @@ static void UpTranParms(FBInfo *fbInfo, 
 
 /* UpMixParms: update mu/va accs of given hmm  */
 static void UpMixParms(FBInfo *fbInfo, int q, HLink hmm, HLink al_hmm,
-                       Observation ot, Observation ot2, 
-                       int t, DVector aqt, DVector aqt1, DVector bqt, int S,
+                       Observation *o, Observation *o2, 
+                       int t, DVector *aqt, DVector *aqt1, DVector *bqt, int S,
                        Boolean twoDataFiles, LogDouble pr)
 {
-   int i,s,j,k,kk,m=0,mx,M=0,N,vSize;
+   int i,s,j,k,kk,m=0,mx,M=0,N,vSize,order,d,*maxDur;
    Vector mu_jm,var,mean=NULL,invk,otvs;
    TMixRec *tmRec = NULL;
    float **outprob;
+   SVector *durprob;
    Matrix inv;
    LogFloat c_jm,a,prob=0.0;
    LogDouble x,initx = LZERO;
@@ -1440,7 +1942,9 @@ static void UpMixParms(FBInfo *fbInfo, i
    HMMSet *hset;
    HSetKind hsKind;
    AlphaBeta *ab;
+   StateInfo *si;
    StreamElem *ste, *al_ste=NULL;
+   StreamInfo *sti, *al_sti=NULL;
    MixtureElem *me;
    MixPDF *mp=NULL;
    MuAcc *ma;
@@ -1450,7 +1954,7 @@ static void UpMixParms(FBInfo *fbInfo, i
    float wght=0.0;
    /* variables for 2-model reestimation */
    Vector comp_prob=NULL;        /* array[1..M] of Component probability */
-   float norm=0.0;               /* total mixture prob */
+   float norm=0.0, stw;          /* total mixture prob */
    LogFloat det;
    AdaptXForm *inxform;
    Vector ovec=NULL;
@@ -1459,7 +1963,7 @@ static void UpMixParms(FBInfo *fbInfo, i
    hset   = fbInfo->up_hset;
    hsKind = fbInfo->hsKind;
 
-   if (trace&T_MIX && fbInfo->uFlags&UPMIXES && 
+   if (trace&T_MIX && fbInfo->uFlags_hmm&UPMIXES && 
        NonSkipRegion(fbInfo->skipstart,fbInfo->skipend,t)){
       printf("Mixture Weights at time %d, model Q%d %s\n",
              t,q,ab->qIds[q]->name);
@@ -1472,27 +1976,51 @@ static void UpMixParms(FBInfo *fbInfo, i
       ovec = CreateVector(&gstack,hset->vecSize);
       for (i=1,s=1;s<=S;s++)
          for (k=1;k<=hset->swidth[s];k++,i++)
-            ovec[i] = ot.fv[s][k];
+            ovec[i] = o[t].fv[s][k];
    }
 
    N = hmm->numStates;
+   maxDur = ab->maxDur[q];
+   durprob = ab->durprob[q];
+   
+   if (keepOccm) {
+      ab->occm[t][q] = (Vector **) New(&ab->abMem, N*sizeof(Vector *));
+      ab->occm[t][q]--;
+   }
+         
    for (j=2;j<N;j++) {
+      si = hmm->svec[j].info;
       if (fbInfo->maxM>1){
-         initx = hmm->transP[1][j] + aqt[1];
-         if (t>1)
+	 initx = ApplyDAEM(hmm->transP[1][j]) + aqt[1][1];
+         if (t>1) {
             for (i=2;i<N;i++){
-               a = hmm->transP[i][j];
+	       a = ApplyDAEM(hmm->transP[i][j]);
                if (a>LSMALL)
-                  initx = LAdd(initx,aqt1[i]+a);
+                  for (d=1; d<=maxDur[i]; d++)
+                     if (aqt1[i][d]>LSMALL)
+                        initx = LAdd(initx,aqt1[i][d]+durprob[i][d]+a);
+            }
+            initx += bqt[j][1];
+            for (d=2; d<=maxDur[j]; d++)
+               if (aqt1[j][d-1]>LSMALL && bqt[j][d]>LSMALL)
+                  initx = LAdd(initx,aqt1[j][d-1]+bqt[j][d]);
             }
-         initx += bqt[j] - pr;
+         else
+            initx += bqt[j][1];
+         initx -= pr;
       }
-      if (trace&T_MIX && fbInfo->uFlags&UPMIXES && 
+      if (trace&T_MIX && fbInfo->uFlags_hmm&UPMIXES && 
           NonSkipRegion(fbInfo->skipstart,fbInfo->skipend,t))
          printf("  State %d: ",j);
+      if (keepOccm) {
+         ab->occm[t][q][j] = (Vector *) New(&ab->abMem, S*sizeof(Vector));
+         ab->occm[t][q][j]--;
+      }
       ste = hmm->svec[j].info->pdf+1;
       outprob = ab->otprob[t][q][j];
       for (s=1;s<=S;s++,ste++){
+         sti = ste->info;
+         stw = (si->weights!=NULL) ? si->weights[s] : 1.0;
          /* Get observation vector for this state/stream */
          vSize = hset->swidth[s];
       
@@ -1508,41 +2036,50 @@ static void UpMixParms(FBInfo *fbInfo, i
             break;
          case PLAINHS:
          case SHAREDHS:
-            M = ste->nMix;
-            mmix = (M>1);
+            M = sti->nMix;
+            mmix = (M>1) ? TRUE : FALSE;
             break;
          }
          /* update weight occupation count */
-         wa = (WtAcc *) ste->hook; steSumLr = 0.0;
+         wa = (WtAcc *) sti->hook; steSumLr = 0.0;
 
-         if (fbInfo->twoModels) { /* component probs of update hmm */
+         if (keepOccm) {
+            ab->occm[t][q][j][s] = CreateVector(&ab->abMem, M);
+            ZeroVector(ab->occm[t][q][j][s]);
+         }
+         if (fbInfo->twoModels || stw!=1.0) { /* component probs of update hmm */
             norm = LZERO;
             for (mx=1; mx<=M; mx++) {
                if (alCompLevel) {
                   al_ste = al_hmm->svec[j].info->pdf+1;
-                  if (al_ste->nMix != M)
+                  al_sti = al_ste->info;
+                  if (al_sti->nMix != M)
                      HError(999,"Cannot align at the component level if number of components is different!");
                }
                if (alCompLevel) {
-                  me = al_ste->spdf.cpdf+mx;
+                  me = al_sti->spdf.cpdf+mx;
                } else {
-                  me = ste->spdf.cpdf+mx;
+                  me = sti->spdf.cpdf+mx;
                }
-	       inxform = fbInfo->inXForm;
+               inxform = fbInfo->inXForm_hmm;
                mp=me->mpdf;
                if (twoDataFiles){  
                   if (alCompLevel) {
-                     otvs = ApplyCompFXForm(mp,ot.fv[s],fbInfo->al_inXForm,&det,t);
+                     otvs = ApplyCompFXForm(mp,o2[t].fv[s],fbInfo->al_inXForm_hmm,&det,t);
                   }
                   else {
-                     otvs = ApplyCompFXForm(mp,ot2.fv[s],inxform,&det,t);
+                     otvs = ApplyCompFXForm(mp,o2[t].fv[s],inxform,&det,t);
                   }
-               } else {
-                  otvs = ApplyCompFXForm(mp,ot.fv[s],inxform,&det,t);
-               }
-               wght = MixLogWeight(hset,me->weight);
-               comp_prob[mx]=wght+MOutP(otvs,mp)+det;
-               norm = LAdd(norm,comp_prob[mx]);
+               } else if (fbInfo->twoModels) {
+                  otvs = ApplyCompFXForm(mp,o[t].fv[s],inxform,&det,t);
+               } else
+                  otvs = o[t].fv[s];
+               order = SpaceOrder(otvs);
+               wght = stw * ApplyDAEM(MixLogWeight(hset,me->weight));
+               prob = (fbInfo->twoModels) ? ApplyDAEM(MOutP(otvs,mp)+det) : ((S==1) ? outprob[0][mx] : outprob[s][mx]);
+               comp_prob[mx] = (!hset->msdflag[s] || (hset->msdflag[s] && order==VectorSize(mp->mean))) ? stw*prob : LZERO;  /* MSD check */
+               if (wght+comp_prob[mx]>LSMALL)
+                  norm = LAdd(norm,wght+comp_prob[mx]);
             }
          }
 
@@ -1551,46 +2088,60 @@ static void UpMixParms(FBInfo *fbInfo, i
             switch (hsKind){    /* Get wght and mpdf */
             case TIEDHS:
                m=tmRec->probs[mx].index;
-               wght=MixLogWeight(hset,ste->spdf.tpdf[m]);
+               wght=MixLogWeight(hset,sti->spdf.tpdf[m]);
                mp=tmRec->mixes[m];
                break;
             case DISCRETEHS:
                if (twoDataFiles)
-                  m=ot2.vq[s];
+                  m=o2[t].vq[s];
                else
-                  m=ot.vq[s];
+                  m=o[t].vq[s];
                wght = 0.0; /* This is the log-weight, just for consistency! */
                mp=NULL;
                break;
             case PLAINHS:
             case SHAREDHS:
                m = mx;
-               me = ste->spdf.cpdf+m;
+               me = sti->spdf.cpdf+m;
                wght = MixLogWeight(hset,me->weight);
                mp=me->mpdf;
+               if (hset->msdflag[s]) vSize = VectorSize(mp->mean);
                break;
             }
             if (wght>LMINMIX){
+              wght = ApplyDAEM(wght);
               /* compute mixture likelihood  */
-              if (!mmix || (hsKind==DISCRETEHS)) /* For DISCRETEHS calcs are*/
-                 x = aqt[j]+bqt[j]-pr;           /* same as single mix*/
-              else if (fbInfo->twoModels) {      /* note: only SHAREDHS or PLAINHS */
-                 x = comp_prob[m]+aqt[j]+bqt[j]-pr-norm;
+              if (!mmix || (hsKind==DISCRETEHS)) {/* For DISCRETEHS calcs are same as single mix*//* note: only SHAREDHS or PLAINHS */
+                  x = LZERO;
+                  for (d=1; d<=maxDur[j]; d++)
+                     if (aqt[j][d]>LSMALL && bqt[j][d]>LSMALL)
+                        x = LAdd(x,aqt[j][d]+bqt[j][d]);   /* same as single mix*/
+                  x -= pr;
+              }
+              else if (fbInfo->twoModels) {      
+                  c_jm = stw * wght;
+                  x = LZERO;
+                  for (d=1; d<=maxDur[j]; d++)
+                     if (aqt[j][d]>LSMALL && bqt[j][d]>LSMALL)
+                        x = LAdd(x,aqt[j][d]+bqt[j][d]);
+                  x += c_jm+comp_prob[m]-pr-norm;
               }
               else {
-                 c_jm=wght;
+                 c_jm = stw * wght;
                  x = initx+c_jm;
                  switch(hsKind) {
                  case TIEDHS :
                     tmp = tmRec->probs[mx].prob;
                     prob = (tmp>=MINLARG)?log(tmp)+tmRec->maxP:LZERO;
+                    prob = (prob>LSMALL) ? stw * prob : LZERO;
                     break;
                  case PLAINHS : 
                  case SHAREDHS:
-		    if (S==1)
-		       prob = outprob[0][mx];
+                    if (stw==1.0)
+                       prob = (S==1) ? outprob[0][mx] : outprob[s][mx];
 		    else
-		       prob = outprob[s][mx];
+                       prob = (S==1) ? stw * outprob[0][0] + comp_prob[mx] - norm
+                                     : stw * outprob[s][0] + comp_prob[mx] - norm;
                     break;
                  default:
                     x=LZERO;
@@ -1598,16 +2149,16 @@ static void UpMixParms(FBInfo *fbInfo, i
                  }
                  x += prob;
                  if (S>1)      /* adjust for parallel streams */
-                    x += outprob[s][0];
+                    x += outprob[0][0] - stw * outprob[s][0];
               }
               if (twoDataFiles){  /* switch to new data for mu & var est */
-                 otvs = ot2.fv[s];
+                 otvs = o2[t].fv[s];
               }
               if (-x<pruneSetting.minFrwdP) {
 		 if (twoDataFiles){  /* switch to new data for mu & var est */
-		   otvs = ApplyCompFXForm(mp,ot2.fv[s],fbInfo->paXForm,&det,t);
+                   otvs = ApplyCompFXForm(mp,o2[t].fv[s],fbInfo->paXForm_hmm,&det,t);
 		 } else {
-		   otvs = ApplyCompFXForm(mp,ot.fv[s],fbInfo->paXForm,&det,t);
+                   otvs = ApplyCompFXForm(mp,o[t].fv[s],fbInfo->paXForm_hmm,&det,t);
 		 }
                  Lr = exp(x);
                   /* More diagnostics */
@@ -1619,13 +2170,13 @@ static void UpMixParms(FBInfo *fbInfo, i
                   /* update occupation counts */
                   steSumLr += Lr;
                   /* update the adaptation statistic counts */
-                  if (fbInfo->uFlags&UPXFORM)
-                     AccAdaptFrame(hset, Lr, otvs, mp, t);
+                  if (fbInfo->uFlags_hmm&UPXFORM)
+                     AccAdaptFrame(fbInfo->xfinfo_hmm, Lr, otvs, mp, t);
                   /* 
                      update the semi-tied statistic counts
                      this accumulates "true" outer products to allow multiple streams
                   */ 
-                  if (fbInfo->uFlags&UPSEMIT) {
+                  if (fbInfo->uFlags_hmm&UPSEMIT) {
                      ma = (MuAcc *) GetHook(mp->mean);
                      va = (VaAcc *) GetHook(mp->cov.var);
                      ma->occ += Lr;
@@ -1660,9 +2211,9 @@ static void UpMixParms(FBInfo *fbInfo, i
                      }
                   } else {
                      /* update mean counts */
-                     if ((fbInfo->uFlags&UPMEANS) || (fbInfo->uFlags&UPVARS))
+                     if ((fbInfo->uFlags_hmm&UPMEANS) || (fbInfo->uFlags_hmm&UPVARS))
                         mean = mp->mean; 
-                     if ((fbInfo->uFlags&UPMEANS) && (fbInfo->uFlags&UPVARS)) {
+                     if ((fbInfo->uFlags_hmm&UPMEANS) && (fbInfo->uFlags_hmm&UPVARS)) {
                         ma = (MuAcc *) GetHook(mean);
                         va = (VaAcc *) GetHook(mp->cov.var);
                         ma->occ += Lr;
@@ -1690,14 +2241,14 @@ static void UpMixParms(FBInfo *fbInfo, i
                            }
                         }
                      }
-                     else if (fbInfo->uFlags&UPMEANS){
+                     else if (fbInfo->uFlags_hmm&UPMEANS){
                         ma = (MuAcc *) GetHook(mean);
                         mu_jm = ma->mu;
                         ma->occ += Lr;
                         for (k=1;k<=vSize;k++)     /* sum zero mean */
                            mu_jm[k] += (otvs[k]-mean[k])*Lr;
                      }
-                     else if (fbInfo->uFlags&UPVARS){
+                     else if (fbInfo->uFlags_hmm&UPVARS){
                         /* update covariance counts */
                         va = (VaAcc *) GetHook(mp->cov.var);
                         va->occ += Lr;
@@ -1721,20 +2272,23 @@ static void UpMixParms(FBInfo *fbInfo, i
                      }
                   }
                   /* update mixture weight counts */
-                  if (fbInfo->uFlags&UPMIXES) {
+                  if (fbInfo->uFlags_hmm&UPMIXES) {
                      wa->c[m] +=Lr;
                      if (trace&T_MIX && NonSkipRegion(fbInfo->skipstart,fbInfo->skipend,t))
                         printf("%3d. %7.2f",m,wa->c[m]);
                   }
+                  
+                  if (keepOccm)
+                     ab->occm[t][q][j][s][m] = Lr;
                }
             }
             if (twoDataFiles){ /* Switch back to old data for prob calc */
-               otvs = ot.fv[s];
+               otvs = o[t].fv[s];
             }    
          }
       
          wa->occ += steSumLr;
-         if (trace&T_MIX && mmix && fbInfo->uFlags&UPMIXES && 
+         if (trace&T_MIX && mmix && fbInfo->uFlags_hmm&UPMIXES && 
              NonSkipRegion(fbInfo->skipstart,fbInfo->skipend,t))
             printf("[%7.2f]\n",wa->occ);
       }
@@ -1743,6 +2297,202 @@ static void UpMixParms(FBInfo *fbInfo, i
    FreeVector(&gstack,comp_prob);
 }
 
+/* UpDurParms: update duration accs of given hmm */
+static void UpDurParms(FBInfo *fbInfo, UttInfo *utt, HLink hmm, const int t, const int q)
+{
+   int i,j,m,k,kk,vSize,d,*maxDur;
+   double Lr,zmean,zmean2,zmeanlr,steSumLr;
+   SVector *durprob;
+   LogDouble initx,x;
+   LogFloat det;
+   AlphaBeta *ab;
+   PruneInfo *p;
+   StreamInfo *sti;
+   MixPDF *mp;
+   Vector mean,var,mu_jm,invk,dur,xdur;
+   DVector *aqt,*aqt1,*bqt,*bqt1;
+   TriMat inv;
+   MuAcc *ma=NULL;
+   VaAcc *va=NULL;
+   WtAcc *wa=NULL;
+
+   const int T = utt->T;
+   const int N = hmm->numStates;
+   
+   ab   = fbInfo->ab;
+   p    = ab->pInfo;
+   aqt = ab->alphat[q];
+   bqt = ab->beta[t][q];
+   bqt1 = (t==T) ? NULL : ab->beta[t+1][q];
+   aqt1 = (t==1) ? NULL : ab->alphat1[q];
+            
+   maxDur  = ab->maxDur[q];
+   durprob = ab->durprob[q];
+   
+   dur  = CreateVector(&gstack,1);
+   xdur = CreateVector(&gstack,1);
+         
+   for (j=2; j<N; j++) {
+      sti = ab->up_dList[q]->svec[2].info->pdf[j-1].info;
+      wa = (WtAcc *) sti->hook; steSumLr = 0.0;
+
+      /* initial term */
+      if (!semiMarkov) {
+         /* HMM */
+	 initx = ApplyDAEM(hmm->transP[1][j]) + aqt[1][1];
+         if (t>1) {
+            for (i=2; i<N; i++)
+	       if (i!=j && ApplyDAEM(hmm->transP[i][j])>LSMALL && aqt1[i][1]>LSMALL)
+		  initx = LAdd(initx,aqt1[i][1]+ApplyDAEM(hmm->transP[i][j]));
+         }
+      }
+      else {
+         /* HSMM */
+	 initx = ApplyDAEM(hmm->transP[j][N])+bqt[N][1];
+         if (bqt1!=NULL)
+            for (i=2; i<N; i++)
+	       if (ApplyDAEM(hmm->transP[j][i])>LSMALL && bqt1[i][1]>LSMALL)
+		  initx = LAdd(initx,ApplyDAEM(hmm->transP[j][i])+ab->otprob[t+1][q][i][0][0]+bqt1[i][1]);
+      }
+
+      for (m=1; m<=sti->nMix; m++) {
+         /* accumulators */
+         mp = sti->spdf.cpdf[m].mpdf;
+         mean = mp->mean; vSize = VectorSize(mean);
+         if (fbInfo->uFlags_dur&UPMEANS) ma = (MuAcc *) GetHook(mean);
+         if (fbInfo->uFlags_dur&UPVARS)  va = (VaAcc *) GetHook(mp->cov.var);
+      
+         /* count statistics from t to t1 */
+         for (d=1; (!semiMarkov && t+d-1<=T) || (semiMarkov && d<=maxDur[j]); d++) {
+            /* acc statistics */
+            if (initx>LSMALL && (semiMarkov || (!semiMarkov && p->qLo[t+d-1]<=q && q<=p->qHi[t+d-1])) ) {
+               if (!semiMarkov) {
+                  /* HMM */
+                  initx += ab->otprob[t+d-1][q][j][0][0];
+                  if (d>1) 
+		     initx += ApplyDAEM(hmm->transP[j][j]);
+   
+                  x = ApplyDAEM(hmm->transP[j][N]);
+                  if (t+d-1<T) {
+                     x += (p->qLo[t+d]<=q+1 && q+1<=p->qHi[t+d]) ? ab->beta[t+d][q+1][1][1] : LZERO;
+                     if (p->qLo[t+d]<=q && q<=p->qHi[t+d]) {
+                        for (k=2; k<N; k++)
+			   if (k!=j && ApplyDAEM(hmm->transP[j][k])>LSMALL && ab->beta[t+d][q][k][1]>LSMALL)
+			      x = LAdd(x, ApplyDAEM(hmm->transP[j][k])+ab->otprob[t+d][q][k][0][0]+ab->beta[t+d][q][k][1]);
+                     }
+                  }
+               }
+               else {
+                  /* HSMM */
+                  x = aqt[j][d]+durprob[j][d]; 
+               }
+               x = initx+x-utt->pr;
+                        
+               /* update duration counts */
+               Lr = L2F(x);
+               if (Lr>0.0) {
+                  /* duration observation */
+                  dur[1] = (float)d;
+                  xdur = ApplyCompFXForm(mp,dur,fbInfo->paXForm_dur,&det,d);
+
+                  /* update the adaptation statistic counts */
+                  if (fbInfo->uFlags_dur&UPXFORM)
+                     AccAdaptFrame(fbInfo->xfinfo_dur,Lr,xdur,mp,d);
+                   
+                  /* acc statistics */
+                  if ((fbInfo->uFlags_dur&UPMEANS) && (fbInfo->uFlags_dur&UPVARS)) {
+                     ma->occ += Lr;
+                     va->occ += Lr;
+                     mu_jm = ma->mu;
+                     if ((mp->ckind==DIAGC)||(mp->ckind==INVDIAGC)){
+                        var = va->cov.var;
+                        for (k=1; k<=vSize; k++) {
+                           zmean=xdur[k]-mp->mean[k];
+                           zmeanlr=zmean*Lr;
+                           mu_jm[k] += zmeanlr;
+                           var[k] += zmean*zmeanlr;
+                        }
+                     }
+                     else {
+                        inv = va->cov.inv;
+                        for (k=1; k<=vSize; k++) {
+                           invk = inv[k];
+                           zmean=xdur[k]-mp->mean[k];
+                           zmeanlr=zmean*Lr;
+                           mu_jm[k] += zmeanlr;
+                           for (kk=1; kk<=k; kk++) {
+                              zmean2 = xdur[k]-mp->mean[kk];
+                              invk[kk] += zmean2*zmeanlr;
+                           }
+                        }
+                     }
+                  }
+                  else if (fbInfo->uFlags_dur&UPMEANS) {
+                     mu_jm = ma->mu;
+                     ma->occ += Lr;
+                     for (k=1; k<=vSize; k++)     /* sum zero mean */
+                        mu_jm[k] += (xdur[k]-mean[k])*Lr;
+                  }
+                  else if (fbInfo->uFlags_dur&UPVARS){
+                      va->occ += Lr;
+                      if ((mp->ckind==DIAGC)||(mp->ckind==INVDIAGC)) {
+                         var = va->cov.var;
+                         for (k=1; k<=vSize; k++) {
+                            zmean=xdur[k]-mean[k];
+                            var[k] += zmean*zmean*Lr;
+                         }
+                      }
+                  }
+                  /* update mixture weight counts */
+                  if (fbInfo->uFlags_dur&UPMIXES) {
+                     steSumLr += Lr;
+                     wa->c[m] +=Lr;
+                  }
+               }  
+            }
+            else 
+               break; 
+         }
+      }
+      wa->occ += steSumLr;
+   }
+   
+   FreeVector(&gstack,dur);
+}
+
+/* UpStateOcc: update state-level occupancy counts of given hmm */
+static void UpStateOcc(FBInfo *fbInfo, int q, HLink hmm, DVector *aqt, DVector *bqt, LogDouble pr)
+{
+   int i,N,d,*maxDur;
+   double x;
+   float occ,tmp;
+   SVector *durprob;
+   StateInfo *si;
+
+   N = hmm->numStates;
+   maxDur = fbInfo->ab->maxDur[q];
+   durprob = fbInfo->ab->durprob[q];
+   
+   for (i=2; i<N; i++) {
+      x = LZERO;
+      for (d=1; d<=maxDur[i]; d++)
+         if (aqt[i][d]>LSMALL && bqt[i][d]>LSMALL)
+            x = LAdd(x,aqt[i][d]+bqt[i][d]);
+      x -= pr;
+      occ = (x>MINEARG) ? exp(x) : 0.0;
+      
+      si = hmm->svec[i].info;
+      if (si->hook==NULL)
+         tmp = 0.0;
+      else
+         memcpy(&tmp,&(si->hook),sizeof(float));
+      tmp += occ;
+      memcpy(&(si->hook),&tmp,sizeof(float));
+   }
+   
+   return;
+}
+
 /* -------------------- Top Level of F-B Updating ---------------- */
 
 
@@ -1751,34 +2501,49 @@ static void UpMixParms(FBInfo *fbInfo, i
 
 static void StepForward(FBInfo *fbInfo, UttInfo *utt)
 {
-   int q,t,start,end,negs;
-   DVector aqt,aqt1,bqt,bqt1,bq1t;
+   int q,t,start,end;
+   long negs;
+   DVector *aqt,*aqt1,*bqt,*bqt1,*bq1t;
    HLink al_hmm, up_hmm;
    AlphaBeta *ab;
+   PruneInfo *p;
 
    /* reset the memory heap for alpha for a new utterance */
    /* ResetHeap(&(fbMemInfo.alphaStack)); */
   
    ab = fbInfo->ab;
-   CreateAlpha(ab,fbInfo->al_hset,utt->Q); /* al_hset may be idential to up_hset */
+   p = ab->pInfo;
+   CreateAlpha(ab,fbInfo->al_hset,utt->Q, utt->T); /* al_hset may be idential to up_hset */
    InitAlpha(ab,&start,&end,utt->Q,fbInfo->skipstart,fbInfo->skipend);
    ab->occa = NULL;
    if (trace&T_OCC) 
       CreateTraceOcc(ab,utt);
+   if (keepOccm) {  /* create occm for parameter generation */
+      ab->occm = (Vector ****) New (&ab->abMem, utt->T*sizeof(Vector ***));
+      ab->occm--;
+   }  
    for (q=1;q<=utt->Q;q++){             /* inc access counters */
+      /* hmms */
       up_hmm = ab->up_qList[q];
-      negs = (int)up_hmm->hook+1;
+      negs = (long)up_hmm->hook+1;
+      up_hmm->hook = (void *)negs;
+      
+      /* duration models */
+      if (fbInfo->up_dset!=NULL && fbInfo->uFlags_dur&(UPMEANS|UPVARS|UPMIXES)) {
+         up_hmm = ab->up_dList[q];
+         negs = (long)up_hmm->hook+1;
       up_hmm->hook = (void *)negs;
    }
+   }
 
-   ResetObsCache();
+   ResetObsCache(fbInfo->xfinfo_hmm);
+   if (fbInfo->xfinfo_dur != NULL)
+      ResetObsCache(fbInfo->xfinfo_dur);
 
    for (t=1;t<=utt->T;t++) {
 
-      GetInputObs(utt, t, fbInfo->hsKind);
-
       if (fbInfo->hsKind == TIEDHS)
-         PrecomputeTMix(fbInfo->al_hset,&(utt->ot),pruneSetting.minFrwdP,0);
+         PrecomputeTMix(fbInfo->al_hset,&(utt->o[t]),pruneSetting.minFrwdP,0);
 
       if (t>1)
          StepAlpha(ab,t,&start,&end,utt->Q,utt->T,utt->pr,
@@ -1787,6 +2552,13 @@ static void StepForward(FBInfo *fbInfo, 
       if (trace&T_ALF && NonSkipRegion(fbInfo->skipstart,fbInfo->skipend,t)) 
          TraceAlphaBeta(ab,t,start,end,utt->pr);
     
+      if (keepOccm) {
+         ab->occm[t] = (Vector ***) New(&ab->abMem, (end-start+1)*sizeof(Vector **));
+         ab->occm[t] -= start;
+         p->qLo[t] = start;  
+         p->qHi[t] = end;
+      }
+      
       for (q=start;q<=end;q++) { 
          /* increment accs for each active model */
          al_hmm = ab->al_qList[q];
@@ -1796,13 +2568,18 @@ static void StepForward(FBInfo *fbInfo, 
          bqt1 = (t==utt->T) ? NULL:ab->beta[t+1][q];
          aqt1 = (t==1)      ? NULL:ab->alphat1[q];
          bq1t = (q==utt->Q) ? NULL:ab->beta[t][q+1];
-         SetOcct(al_hmm,q,ab->occt,ab->occa,aqt,bqt,bq1t,utt->pr);
+         if (trace&T_OCC)
+            SetOcct(al_hmm,q,ab->occt,ab->occa,ab->maxDur[q],aqt,bqt,bq1t,utt->pr);
          /* accumulate the statistics */
-         if (fbInfo->uFlags&(UPMEANS|UPVARS|UPMIXES|UPXFORM))
-            UpMixParms(fbInfo,q,up_hmm,al_hmm,utt->ot,utt->ot2,t,aqt,aqt1,bqt,
+         if (fbInfo->uFlags_hmm&(UPMEANS|UPVARS|UPMIXES|UPXFORM) || keepOccm)
+            UpMixParms(fbInfo,q,up_hmm,al_hmm,utt->o,utt->o2,t,aqt,aqt1,bqt,
                        utt->S, utt->twoDataFiles, utt->pr);
-         if (fbInfo->uFlags&UPTRANS)
+         if (fbInfo->uFlags_hmm&UPTRANS)
             UpTranParms(fbInfo,up_hmm,t,q,aqt,bqt,bqt1,bq1t,utt->pr);
+         if (fbInfo->uFlags_dur&(UPMEANS|UPVARS|UPMIXES|UPXFORM))
+            UpDurParms(fbInfo,utt,al_hmm,t,q);
+         if (fbInfo->up_hset->numSharedStreams>0)
+            UpStateOcc(fbInfo,q,up_hmm,aqt,bqt,utt->pr);
       }
       if (trace&T_OCC && NonSkipRegion(fbInfo->skipstart,fbInfo->skipend,t)) 
          TraceOcc(ab,utt,t);
@@ -1814,7 +2591,7 @@ void LoadLabs(UttInfo *utt, FileFormat l
               char *labDir, char *labExt)
 {
 
-   char labfn[255],buf1[255],buf2[255];
+   char labfn[MAXSTRLEN], buf1[MAXSTRLEN], buf2[MAXSTRLEN];
 
    /* reset the heap for a new transcription */
    ResetHeap(&utt->transStack);
@@ -1869,23 +2646,26 @@ void LoadData(HMMSet *hset, UttInfo *utt
       GetBufferInfo(utt->pbuf2,&info2);
       CheckData(hset,datafn2,&info2,utt->twoDataFiles);
       T2 = ObsInBuffer(utt->pbuf2);
+      utt->tgtSampRate2 = info2.tgtSampRate;
    }else
       CheckData(hset,datafn,&info,utt->twoDataFiles);
+
    utt->T = ObsInBuffer(utt->pbuf);
+   utt->tgtSampRate = info.tgtSampRate;
    if (utt->twoDataFiles && (utt->T != T2))
       HError(7326,"HFB: Paired training files must be same length for single pass retraining");
   
   
 }
 
-/* Initialise the observation structures within UttInfo */
+/* EXPORT -> InitUttObservations: Initialise the observation structures within UttInfo */
 void InitUttObservations(UttInfo *utt, HMMSet *al_hset, 
                          char * datafn, int * maxMixInS)
 {
 
    BufferInfo info, info2;
    Boolean eSep;
-   int s, i;
+   int s, t;
 
    if (utt->twoDataFiles)
       if(SetChannel("HPARM1")<SUCCESS)
@@ -1899,33 +2679,71 @@ void InitUttObservations(UttInfo *utt, H
    }
   
    SetStreamWidths(info.tgtPK,info.tgtVecSize,al_hset->swidth,&eSep);
-   utt->ot = MakeObservation(&gstack,al_hset->swidth,info.tgtPK,
-                             al_hset->hsKind==DISCRETEHS,eSep);
+   
+   /* prepare storage for observations */
+   utt->o  = (Observation *) New(&gstack, utt->T*sizeof(Observation));
+   utt->o--;
+   if (utt->twoDataFiles) {
+      utt->o2 = (Observation *) New(&gstack, utt->T*sizeof(Observation));
+      utt->o2--;
+   }
+   
+   for (t=1; t<=utt->T; t++) {
+      utt->o[t] = MakeObservation(&gstack,al_hset->swidth,info.tgtPK,
+                                  ((al_hset->hsKind==DISCRETEHS) ? TRUE:FALSE),eSep);
    if (utt->twoDataFiles)
-       utt->ot2 = MakeObservation(&gstack,al_hset->swidth,info2.tgtPK,
-                                  al_hset->hsKind==DISCRETEHS,eSep);
+         utt->o2[t] = MakeObservation(&gstack,al_hset->swidth,info2.tgtPK,
+                                      ((al_hset->hsKind==DISCRETEHS) ? TRUE:FALSE),eSep);
+
+      /* load observation and store it to utt->o and utt->o2 */
+      GetInputObs(utt, t, al_hset->hsKind);
    
    if (al_hset->hsKind==DISCRETEHS){ 
-      for (i=0; i<utt->T; i++){
-         ReadAsTable(utt->pbuf,i,&utt->ot);
          for (s=1; s<=utt->S; s++){
-             if( (utt->ot.vq[s] < 1) || (utt->ot.vq[s] > maxMixInS[s]))
-                 HError(7350,"LoadFile: Discrete data value [ %d ] out of range in seam [ %d ] in file %s",
-                        utt->ot.vq[s],s,datafn);
+            if( (utt->o[t].vq[s] < 1) || (utt->o[t].vq[s] > maxMixInS[s]))
+               HError(7350,"LoadFile: Discrete data value [ %d ] out of range in stream [ %d ] in file %s",
+                      utt->o[t].vq[s],s,datafn);
          }
       }
    }
+}
+
+
+/* EXPORT -> ResetUttObservations: reset the observation structures within UttInfo */
+void ResetUttObservations (UttInfo *utt, HMMSet *al_hset)
+{
+   BufferInfo info, info2;
+   int t;
+   
+   /* load buffer informations */
+   GetBufferInfo(utt->pbuf,&info);
+   if (utt->twoDataFiles)
+      GetBufferInfo(utt->pbuf2,&info2);
    
+   /* reset each observation */
+   for (t=utt->T; t>0; t--) {
+      if (utt->twoDataFiles)
+         ResetObservation(&gstack,&utt->o2[t],al_hset->swidth,info2.tgtPK);
+      ResetObservation(&gstack,&utt->o[t],al_hset->swidth,info.tgtPK);
 }
 
+   /* reset observation storage */
+   if (utt->twoDataFiles) {
+      utt->o2++;
+      Dispose(&gstack, utt->o2);
+   }
+   utt->o++;
+   Dispose(&gstack, utt->o);
+}
 
-/* FBFile: apply forward-backward to given utterance */
-Boolean FBFile(FBInfo *fbInfo, UttInfo *utt, char * datafn)
+/* FBUtt: apply forward-backward to given utterance */
+Boolean FBUtt (FBInfo *fbInfo, UttInfo *utt)
 {
    Boolean success;
 
-   if ((success = StepBack(fbInfo,utt,datafn)))
+   if ((success = StepBack(fbInfo,utt)))
       StepForward(fbInfo,utt);
+
 #ifdef PDE_STATS
    PrintPDEstats();
 #endif
@@ -1930,12 +2748,7 @@ Boolean FBFile(FBInfo *fbInfo, UttInfo *
    PrintPDEstats();
 #endif
 
-   ResetStacks(fbInfo->ab);
-
    return success;
 }
 
-
-/* ----------------------------------------------------------- */
-/*                      END:  HFB.c                         */
-/* ----------------------------------------------------------- */
+/* ------------------------ End of HFB.c --------------------------- */
diff -pbBEwurNa --ignore-matching-lines='.*vc_id.*' HTK-3.4.1/HTKLib/HFB.h HTS-2.2_for_HTK-3.4.1/HTKLib/HFB.h
--- HTK-3.4.1/HTKLib/HFB.h	2009-03-13 03:43:17.000000000 +0900
+++ HTS-2.2_for_HTK-3.4.1/HTKLib/HFB.h	2011-06-16 13:18:29.000000000 +0900
@@ -19,6 +19,51 @@
 /*         File: HFB.h: Forward Backward routines module       */
 /* ----------------------------------------------------------- */
 
+/*  *** THIS IS A MODIFIED VERSION OF HTK ***                        */
+/* ----------------------------------------------------------------- */
+/*           The HMM-Based Speech Synthesis System (HTS)             */
+/*           developed by HTS Working Group                          */
+/*           http://hts.sp.nitech.ac.jp/                             */
+/* ----------------------------------------------------------------- */
+/*                                                                   */
+/*  Copyright (c) 2001-2011  Nagoya Institute of Technology          */
+/*                           Department of Computer Science          */
+/*                                                                   */
+/*                2001-2008  Tokyo Institute of Technology           */
+/*                           Interdisciplinary Graduate School of    */
+/*                           Science and Engineering                 */
+/*                                                                   */
+/* All rights reserved.                                              */
+/*                                                                   */
+/* Redistribution and use in source and binary forms, with or        */
+/* without modification, are permitted provided that the following   */
+/* conditions are met:                                               */
+/*                                                                   */
+/* - Redistributions of source code must retain the above copyright  */
+/*   notice, this list of conditions and the following disclaimer.   */
+/* - Redistributions in binary form must reproduce the above         */
+/*   copyright notice, this list of conditions and the following     */
+/*   disclaimer in the documentation and/or other materials provided */
+/*   with the distribution.                                          */
+/* - Neither the name of the HTS working group nor the names of its  */
+/*   contributors may be used to endorse or promote products derived */
+/*   from this software without specific prior written permission.   */
+/*                                                                   */
+/* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND            */
+/* CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,       */
+/* INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF          */
+/* MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE          */
+/* DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS */
+/* BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,          */
+/* EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED   */
+/* TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,     */
+/* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON */
+/* ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,   */
+/* OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY    */
+/* OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE           */
+/* POSSIBILITY OF SUCH DAMAGE.                                       */
+/* ----------------------------------------------------------------- */
+
 /* !HVER!HFB:   3.4.1 [CUED 12/03/09] */
 
 #ifndef _HFB_H_
@@ -46,8 +91,11 @@ typedef struct {
   ParmBuf pbuf;       /* parameter buffer */
   ParmBuf pbuf2;      /* a second parameter buffer (if required) */
 
-  Observation ot;      /* Observation at time t ... */
-  Observation ot2;     /* Cepstral Mean Normalised obervation, used in
+  HTime tgtSampRate;  /* frame rate */
+  HTime tgtSampRate2; /* second frame rate */
+    
+  Observation *o;      /* Observations */
+  Observation *o2;     /* Cepstral Mean Normalised obervation, used in
                                single pass re-training */
 
   LogDouble pr;        /* log prob of current utterance */
@@ -74,34 +122,51 @@ typedef struct {
   PruneInfo *pInfo;   /* pruning information */
   HLink *up_qList;    /* array[1..Q] of active HMM defs */
   HLink *al_qList;    /* array[1..Q] of active align HMM defs */
+  HLink *up_dList;    /* array[1..Q] of active dur model defs */
+  HLink *al_dList;    /* array[1..Q] of active align dur model defs */
+  MLink *qLink;       /* array[1..Q] of link to active HMM defs */
   LabId  *qIds;       /* array[1..Q] of logical HMM names (in qList) */
   short *qDms;        /* array[1..Q] of minimum model duration */
-  DVector *alphat;    /* array[1..Q][1..Nq] of prob */
-  DVector *alphat1;   /* alpha[t-1] */
-  DVector **beta;     /* array[1..T][1..Q][1..Nq] of prob */
+  DVector **alphat;   /* array[1..Q][1..Nq] of prob */
+  DVector **alphat1;  /* alpha[t-1] */
+  DVector ***beta;    /* array[1..T][1..Q][1..Nq] of prob */
   float *****otprob;  /* array[1..T][1..Q][2..Nq-1][0..S][0..M] of prob */
+  SVector **durprob;  /* array[1..Q][2..Nq-1][1..maxDur] of state dur prob */
+  int **maxDur;       /* array[1..Q][1..Nq] of max state duration */
   LogDouble pr;       /* log prob of current utterance */
   Vector occt;        /* occ probs for current time t */
   Vector *occa;       /* array[1..Q][1..Nq] of occ probs (trace only) */
+  Vector ****occm;    /* array[1..T][1..Q][1..Nq][1..S][1..M] of occ probs (param gen only) */
 
 } AlphaBeta;
 
 /* structure storing the model set and a pointer to it's alpha-beta pass structure */
 typedef struct {
   Boolean twoModels;  /* Enable two model reestimation */
+  Boolean useAlign;   /* Using model alignment */
   HMMSet *up_hset;    /* set of HMMs to be re-estimated */
   HMMSet *al_hset;    /* HMMs to use for alignment */
                       /* these are equal unless 2 model reest */
+  HMMSet *up_dset;    /* set of duration models to be estimated */
+  HMMSet *al_dset;    /* duration models to use for alignment */
+                      /* these are equal unless 2 model reest */
   HSetKind hsKind;    /* kind of the alignment HMM system */
-  UPDSet uFlags;      /* parameter update flags */
+  UPDSet uFlags_hmm;  /* parameter update flags for HMMs */
+  UPDSet uFlags_dur;  /* parameter update flags for duration models */
   int skipstart;      /* Skipover region - debugging only */
   int skipend;
   int maxM;           /* maximum number of mixtures in hmmset */
   int maxMixInS[SMAX];/* array[1..swidth[0]] of max mixes */
   AlphaBeta *ab;      /* Alpha-beta structure for this model */
-  AdaptXForm *inXForm;/* current input transform (if any) */
-  AdaptXForm *al_inXForm;/* current input transform for al_hset (if any) */
-  AdaptXForm *paXForm;/* current parent transform (if any) */
+
+  XFInfo *xfinfo_hmm;         /* xform info for hmmset */
+  XFInfo *xfinfo_dur;         /* xform info for dmset */
+  AdaptXForm *inXForm_hmm;    /* current input transform for HMMs (if any) */
+  AdaptXForm *inXForm_dur;    /* current input transform for duration models (if any) */
+  AdaptXForm *al_inXForm_hmm; /* current input transform for al_hset (if any) */
+  AdaptXForm *al_inXForm_dur; /* current input transform for al_dset (if any) */
+  AdaptXForm *paXForm_hmm;    /* current parent transform for HMMs (if any) */
+  AdaptXForm *paXForm_dur;    /* current parent transform for duration models (if any) */
 } FBInfo;
 
 
@@ -110,16 +175,19 @@ typedef struct {
 /* Initialise HFB module */
 void InitFB(void) ;
 
+/* Reset HFB module */
+void ResetFB(void);
+
 /* Allow tools to enable top-level tracing in HFB. Only here for historical reasons */
 void SetTraceFB(void);
 
 /* Initialise the forward backward memory stacks etc */
-void InitialiseForBack(FBInfo *fbInfo, MemHeap *x, HMMSet *set, UPDSet uset, 
-                       LogDouble pruneInit, LogDouble pruneInc, 
-                       LogDouble pruneLim, float minFrwdP);
+void InitialiseForBack(FBInfo *fbInfo, MemHeap *x, HMMSet *hset, UPDSet uFlags_hmm, HMMSet *dset, UPDSet uFlags_dur,
+                       LogDouble pruneInit, LogDouble pruneInc, LogDouble pruneLim, 
+                       float minFrwdP, Boolean useAlign, Boolean genDur);
 
 /* Use a different model set for alignment */
-void UseAlignHMMSet(FBInfo* fbInfo, MemHeap* x, HMMSet *al_hset);
+void UseAlignHMMSet(FBInfo* fbInfo, MemHeap* x, HMMSet *al_hset, HMMSet *al_dset);
 
 /* Initialise the utterance Information */
 void InitUttInfo(UttInfo *utt, Boolean twoFiles );
@@ -139,14 +207,25 @@ void LoadData(HMMSet *hset, UttInfo *utt
 void InitUttObservations(UttInfo *utt, HMMSet *hset,
 			 char * datafn, int * maxmixInS);
 
-/* FBFile: apply forward-backward to given utterance */
-Boolean FBFile(FBInfo *fbInfo, UttInfo *utt, char * datafn);
+/* reset the observation structures within UttInfo */ 
+void ResetUttObservations (UttInfo *utt, HMMSet *hset);
+
+/* reset all pre-calculated duration prob matrices */
+void ResetDMMPreComps (HMMSet *dset);
+
+/* FBUtt: apply forward-backward to given utterance */
+Boolean FBUtt(FBInfo *fbInfo, UttInfo *utt);
 
 /* PrLog: print a log value */
 void PrLog(LogDouble x);
 
+/* SetAlign: set start and end frame according to given label */
+void SetAlign (long *st, long *en, short *qDms, const int Q, const int T);
+
 #ifdef __cplusplus
 }
 #endif
 
 #endif  /* _HFB_H_ */
+
+/* ------------------------ End of HHB.h --------------------------- */
diff -pbBEwurNa --ignore-matching-lines='.*vc_id.*' HTK-3.4.1/HTKLib/HFBLat.c HTS-2.2_for_HTK-3.4.1/HTKLib/HFBLat.c
--- HTK-3.4.1/HTKLib/HFBLat.c	2009-03-13 03:43:28.000000000 +0900
+++ HTS-2.2_for_HTK-3.4.1/HTKLib/HFBLat.c	2011-06-16 13:18:29.000000000 +0900
@@ -27,8 +27,53 @@
 /*         File: HFBLat.c   Lattice Forward Backward routines  */
 /* ----------------------------------------------------------- */
 
+/*  *** THIS IS A MODIFIED VERSION OF HTK ***                        */
+/* ----------------------------------------------------------------- */
+/*           The HMM-Based Speech Synthesis System (HTS)             */
+/*           developed by HTS Working Group                          */
+/*           http://hts.sp.nitech.ac.jp/                             */
+/* ----------------------------------------------------------------- */
+/*                                                                   */
+/*  Copyright (c) 2001-2011  Nagoya Institute of Technology          */
+/*                           Department of Computer Science          */
+/*                                                                   */
+/*                2001-2008  Tokyo Institute of Technology           */
+/*                           Interdisciplinary Graduate School of    */
+/*                           Science and Engineering                 */
+/*                                                                   */
+/* All rights reserved.                                              */
+/*                                                                   */
+/* Redistribution and use in source and binary forms, with or        */
+/* without modification, are permitted provided that the following   */
+/* conditions are met:                                               */
+/*                                                                   */
+/* - Redistributions of source code must retain the above copyright  */
+/*   notice, this list of conditions and the following disclaimer.   */
+/* - Redistributions in binary form must reproduce the above         */
+/*   copyright notice, this list of conditions and the following     */
+/*   disclaimer in the documentation and/or other materials provided */
+/*   with the distribution.                                          */
+/* - Neither the name of the HTS working group nor the names of its  */
+/*   contributors may be used to endorse or promote products derived */
+/*   from this software without specific prior written permission.   */
+/*                                                                   */
+/* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND            */
+/* CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,       */
+/* INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF          */
+/* MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE          */
+/* DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS */
+/* BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,          */
+/* EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED   */
+/* TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,     */
+/* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON */
+/* ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,   */
+/* OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY    */
+/* OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE           */
+/* POSSIBILITY OF SUCH DAMAGE.                                       */
+/* ----------------------------------------------------------------- */
+
 char *hfblat_version = "!HVER!HFBLat:   3.4.1 [CUED 12/03/09]";
-char *hfblat_vc_id = "$Id: HFBLat.c,v 1.1.1.1 2006/10/11 09:54:57 jal58 Exp $";
+char *hfblat_vc_id = "$Id: HFBLat.c,v 1.18 2011/06/16 04:18:29 uratec Exp $";
 
 /*
   Performs forward/backward alignment
@@ -171,7 +216,7 @@ int GetNoContextPhone(LabId phone, int *
 
    if(PhoneMEEUseContext){
       if(Quinphone) HError(1, "Quinphone not compatible with context phones...");
-      return (int) phone;
+      return (int) ((long)phone);
    }
    strcpy(buf,lab);
 #ifdef SUPPORT_QUINPHONE
@@ -210,7 +255,7 @@ int GetNoContextPhone(LabId phone, int *
    /* Want to return an integer identifier for the string.  Put the string into an integer
       if it is <4 chars long, otherwise call GetLabId.  Calling GetLabId too much can be
       inefficient so I use this approach instead for short phones. */
-   if(len > sizeof(int)) return (int) GetLabId(tmp, TRUE);
+   if(len > sizeof(int)) return (int) ((long)GetLabId(tmp, TRUE));
    else return ans;
 }
 
@@ -231,7 +276,7 @@ static void SetCorrectness(FBLatInfo *fb
    int larcid;
    CorrectArcList **correctArc;
    correctArc=New(&fbInfo->tempStack, sizeof(CorrectArcList*)*(fbInfo->T+1));
-   ResetObsCache();
+   ResetObsCache(fbInfo->xfinfo);
    if(!numLat) HError(-1, "MEE mode and no numLat provided.  FBLat needs to be given both lattices in this mode.");
    for(t=1;t<=fbInfo->T;t++)    correctArc[t]  = NULL;
 
@@ -252,7 +297,7 @@ static void SetCorrectness(FBLatInfo *fb
                {
                   LabId label = numLat->larcs[larcid].lAlign[seg].label; 
                   if(!PhoneMEEUseContext) i_label = GetNoContextPhone(label,&quinphone_nstates,&quinphone_state,NULL,NULL); 
-                  else i_label = (int)label; /* Use address of LabId. */
+                  else i_label = (int)((long)label); /* Use address of LabId. */
                }
 
                end_time = start_time + numLat->larcs[larcid].lAlign[seg].dur;
@@ -301,7 +346,7 @@ static void SetCorrectness(FBLatInfo *fb
 #endif
             ca = New(&fbInfo->tempStack, sizeof(CorrectArc));
             ca->start = i_start; ca->end = i_end; 
-            ca->i_label = (int)numLat->larcs[larcid].end->word->wordName;
+            ca->i_label = (int)((long)numLat->larcs[larcid].end->word->wordName);
 
             for(i=i_start;i<=i_end;i++){
                CorrectArcList *cal = New(&fbInfo->tempStack, sizeof(CorrectArcList));
@@ -331,7 +376,7 @@ static void SetCorrectness(FBLatInfo *fb
                /*get phone start&end times.*/
                i_start=a->t_start;i_end=a->t_end;
                if(!PhoneMEEUseContext)  iphone = GetNoContextPhone(phone,&quinphone_nstates,&quinphone_state, a, &i_end);
-               else iphone = (int)phone;
+               else iphone = (int)((long)phone);
 #ifdef SUPPORT_QUINPHONE
                if(Quinphone && quinphone_nstates>1 && quinphone_state > 2){ ZeroCorrectness = TRUE; }
 #endif
@@ -395,12 +440,12 @@ static void SetCorrectness(FBLatInfo *fb
                   for(i=i_start;i<=i_end;i++){ /*look for all the ref. phones in this time interval.*/
                      for(cal = correctArc[i];cal;cal=cal->t){
                         float proportion;
-                        int otherWord; 
+                        long otherWord; 
                         currBegin = cal->h->start; currEnd=cal->h->end;
                         otherWord = cal->h->i_label; /*is actually the (int)LabId in this case.*/
                         proportion =
                            (float)(MIN(i_end,currEnd)-MAX(i_start,currBegin)+1)/ ((float)(currEnd-currBegin+1)); 
-                        if(otherWord == (int)word)
+                        if(otherWord == (long)word)
                            /*Work out how much overlap we have with the correct phone*/
                            /* ref length div by overlap length */
                            currCorrect = MAX(currCorrect, InsCorrectness + proportion*(-InsCorrectness+1));
@@ -522,7 +567,7 @@ static void SetCorrectnessAsError(FBLatI
    int larcid;
    CorrectArcList **correctArc;
    correctArc=New(&fbInfo->tempStack, sizeof(CorrectArcList*)*(fbInfo->T+1));
-   ResetObsCache();
+   ResetObsCache(fbInfo->xfinfo);
    if(!numLat) HError(-1, "MEE mode and no numLat provided.  FBLat needs to be given both lattices in this mode.");
    for(t=1;t<=fbInfo->T;t++)    correctArc[t]  = NULL;
 
@@ -543,7 +588,7 @@ static void SetCorrectnessAsError(FBLatI
                {
                   LabId label = numLat->larcs[larcid].lAlign[seg].label; 
                   if(!PhoneMEEUseContext) i_label = GetNoContextPhone(label,&quinphone_nstates,&quinphone_state,NULL,NULL); 
-                  else i_label = (int)label; /* Use address of LabId. */
+                  else i_label = (int)((long)label); /* Use address of LabId. */
 
 		  is_nonsil = (int) ! IsSilence(label->name);
                }
@@ -594,7 +639,7 @@ static void SetCorrectnessAsError(FBLatI
 #endif
             ca = New(&fbInfo->tempStack, sizeof(CorrectArc));
             ca->start = i_start; ca->end = i_end; 
-            ca->i_label = (int)numLat->larcs[larcid].end->word->wordName;
+            ca->i_label = (int)((long)numLat->larcs[larcid].end->word->wordName);
 
             for(i=i_start;i<=i_end;i++){
                CorrectArcList *cal = New(&fbInfo->tempStack, sizeof(CorrectArcList));
@@ -618,18 +663,18 @@ static void SetCorrectnessAsError(FBLatI
                LabId phone = a->phone;
                int iphone; /*as ints..*/
                int i_start, i_end;
-               float currCorrect; /*-1 is the min correctness (for wrong phones).*/
+               float currCorrect=-1; /*-1 is the min correctness (for wrong phones).*/
                
                /*get phone start&end times.*/
                i_start=a->t_start;i_end=a->t_end;
                if(!PhoneMEEUseContext)  iphone = GetNoContextPhone(phone,&quinphone_nstates,&quinphone_state, a, &i_end);
-               else iphone = (int)phone;
+               else iphone = (int)((long)phone);
 #ifdef SUPPORT_QUINPHONE
                if(Quinphone && quinphone_nstates>1 && quinphone_state > 2){ ZeroCorrectness = TRUE; }
 #endif
                if(!ZeroCorrectness){ /* ZeroCorrectness is true for non-start models in quinphone case */
 		 int compute_count = 100; /* Limit computation... */
-		 currCorrect = GetLowestNegError(i_start, i_end, i_start, 0, 0, correctArc, iphone, &compute_count, IsSilence(phone->name));
+                 currCorrect = GetLowestNegError(i_start, i_end, i_start, 0, 0, correctArc, iphone, &compute_count, (Boolean)IsSilence(phone->name));
 	       }
          
                if( /* IsSilence(phone->name) || */ ZeroCorrectness) /* If for some reason we arent counting this phone... relates to quinphones,
@@ -764,7 +809,7 @@ static float * NewOtprobVec(MemHeap *x, 
 
 
 /* ShStrP: Stream Outp calculation exploiting sharing */
-static float * ShStrP(Vector v, int t, StreamElem *ste, AdaptXForm *xform, MemHeap *amem)
+static float *ShStrP (Vector v, int t, StreamInfo *sti, AdaptXForm *xform, MemHeap *amem)
 {
    WtAcc *wa;
    MixtureElem *me;
@@ -774,13 +819,13 @@ static float * ShStrP(Vector v, int t, S
    PreComp *pMix;
    LogFloat det,x,mixp;
    
-   wa = (WtAcc *)ste->hook;
+   wa = (WtAcc *)sti->hook;
    if (wa->time==t)           /* seen this state before */
       outprobjs = wa->prob;
    else {
-      M = ste->nMix;
+      M = sti->nMix;
       outprobjs = NewOtprobVec(amem,M);
-      me = ste->spdf.cpdf+1;
+      me = sti->spdf.cpdf+1;
       if (M==1){                 /* Single Mix Case */
          mp = me->mpdf;
          pMix = (PreComp *)mp->hook;
@@ -819,11 +864,11 @@ static float * ShStrP(Vector v, int t, S
    
 
 /* Setotprob: allocate and calculate otprob matrix at time t */
-static void Setotprob(int t)
+static void Setotprob (const int t)
 {
    int q,j,Nq,s;
    float ***outprob;
-   StreamElem *ste;
+   StreamInfo *sti;
    HLink hmm;
    LogFloat sum;
    float local_probscale;
@@ -843,28 +888,27 @@ static void Setotprob(int t)
          outprob = ac->otprob[t];
       
          for (j=2;j<Nq;j++){
-            ste=hmm->svec[j].info->pdf+1; sum = 0.0;
-
-
-            for (s=1;s<=fbInfo->S;s++,ste++){
+            sum = 0.0;
+            for (s=1; s<=fbInfo->S; s++) {
+               sti=hmm->svec[j].info->pdf[s].info;
                switch (fbInfo->hsKind){
                case TIEDHS:	 /* SOutP deals with tied mix calculation */
                case DISCRETEHS:
                   if (fbInfo->S==1) {
                      outprob[j][0] = NewOtprobVec(fbInfo->aInfo->mem,1);
-                     outprob[j][0][0] = SOutP(fbInfo->hset,s,&fbInfo->al_ot, ste);
+                     outprob[j][0][0] = SOutP(fbInfo->hset,s,&fbInfo->al_ot, sti);
                   } else {
                      outprob[j][s] = NewOtprobVec(fbInfo->aInfo->mem,1);
-                     outprob[j][s][0] = SOutP(fbInfo->hset,s,&fbInfo->al_ot, ste);
+                     outprob[j][s][0] = SOutP(fbInfo->hset,s,&fbInfo->al_ot, sti);
                   }
 		  break;
-               case PLAINHS: /* x = SOutP(fbInfo->hset,s,&ot,ste);    break; commented out by dp10006 since
+               case PLAINHS: /* x = SOutP(fbInfo->hset,s,&ot,sti);    break; commented out by dp10006 since
                                 sharing is needed in any case for lattices. */
                case SHAREDHS:
 		  if (fbInfo->S==1)
-		     outprob[j][0] = ShStrP(fbInfo->al_ot.fv[s],t+StartTime,ste,fbInfo->inXForm,fbInfo->aInfo->mem);
+		     outprob[j][0] = ShStrP(fbInfo->al_ot.fv[s],t+StartTime,sti,fbInfo->inXForm,fbInfo->aInfo->mem);
 		  else
-		     outprob[j][s] = ShStrP(fbInfo->al_ot.fv[s],t+StartTime,ste,fbInfo->inXForm,fbInfo->aInfo->mem);
+		     outprob[j][s] = ShStrP(fbInfo->al_ot.fv[s],t+StartTime,sti,fbInfo->inXForm,fbInfo->aInfo->mem);
 		  break;
                default:       HError(1, "Unknown hset kind.");
                }
@@ -885,7 +929,8 @@ static void Setotprob(int t)
    }
 }
 
-void SetModelBetaPlus(int t, int q){
+void SetModelBetaPlus (const int t, const int q)
+{
    double x=LZERO;
    Acoustic *ac = fbInfo->aInfo->ac+q;
    HLink hmm = ac->hmm;
@@ -922,7 +967,7 @@ static void SetBetaPlus()
    /* 
       Columns T-1 -> 1.
    */
-   ResetObsCache();  
+   ResetObsCache(fbInfo->xfinfo);  
    for (t=fbInfo->T;t>=1;t--) {
       Setotprob(t);
       for (q=fbInfo->aInfo->qHi[t];q>=fbInfo->aInfo->qLo[t];q--) { /*MAX(qHi[t],qLo[t]) because of the case for tee models where qHi[t]=qLo[t]-1 .*/
@@ -971,7 +1016,7 @@ static void UpTranParms(int t, int q){ 
    TrAcc *ta,*tammi=NULL;   
    Acoustic *ac = fbInfo->aInfo->ac+q;
    HLink hmm = ac->hmm;
-   float x=0,mee_acc_scale = fbInfo->AccScale*(fbInfo->MPE?ac->mpe_occscale:1), abs_mee_acc_scale = fabs(mee_acc_scale);   
+   float x=0.0,mee_acc_scale = fbInfo->AccScale*(fbInfo->MPE?ac->mpe_occscale:1), abs_mee_acc_scale = fabs(mee_acc_scale);   
    DVector aqt = ac->alphat,
       bqtPlus = ac->betaPlus[t],
       bqt1Plus = (t<ac->t_end ? ac->betaPlus[t+1] : NULL);
@@ -1071,7 +1116,7 @@ void DoAllMixUpdates(int t){
    LogFloat det;
 
    float zmean,zmeanlr;
-   MuAcc *ma,*mammi;
+   MuAcc *ma,*mammi=NULL;
    VaAcc *va,*vammi;
    int local_accindx;
   
@@ -1103,7 +1148,7 @@ void DoAllMixUpdates(int t){
              up_otvs = ApplyCompFXForm(mp,fbInfo->al_ot.fv[s],fbInfo->paXForm,&det,t);
          } 
          if (fbInfo->uFlags&UPXFORM) 
-            AccAdaptFrame(fbInfo->hset,Lr, up_otvs, mp, t);   /* note: discriminative transform update needs to be investigated further */
+            AccAdaptFrame(fbInfo->xfinfo, Lr, up_otvs, mp, t);   /* note: discriminative transform update needs to be investigated further */
 
          /* -------------------- (c) Std Mixture updates --------------------*/
          if (fbInfo->uFlags&UPMEANS) { /* cant update vars but not means. */
@@ -1203,12 +1248,13 @@ static double UpMixParms(int q, HLink hm
    double Lr,steSumLr;
    float tmp;
    StreamElem *ste;
+   StreamInfo *sti;
    MixtureElem *me;
    MixPDF *mp=NULL;
    WtAcc *wa, *wammi=NULL;
    PreComp *pMix;
    Boolean mmix=FALSE;  /* TRUE if multiple mixture */
-   float wght=0;
+   float wght=0.0;
    float mee_acc_scale =   fbInfo->AccScale * (fbInfo->MPE? fbInfo->aInfo->ac[q].mpe_occscale: 1 ),
       abs_mee_acc_scale = fabs(mee_acc_scale); int local_accindx = (mee_acc_scale > 0 ? fbInfo->num_index : fbInfo->den_index);
 
@@ -1238,6 +1284,7 @@ static double UpMixParms(int q, HLink hm
       for (s=1;s<=fbInfo->S;s++,ste++){
          /* Get observation vector for this state/stream */
          vSize = fbInfo->hset->swidth[s];
+         sti = ste->info;
 
          switch (fbInfo->hsKind){
          case TIEDHS:		          /* if tied mixtures then we only */
@@ -1251,13 +1298,13 @@ static double UpMixParms(int q, HLink hm
             break;
          case PLAINHS:
          case SHAREDHS:
-            M = ste->nMix;
-            mmix = (M>1);
+            M = sti->nMix;
+            mmix = (M>1) ? TRUE : FALSE;
             break;
          }
        
-         wa = ((WtAcc*)ste->hook) + local_accindx;
-         if(DoingFourthAcc) wammi = ((WtAcc*)ste->hook) + add_index;   
+         wa = ((WtAcc*)sti->hook) + local_accindx;
+         if(DoingFourthAcc) wammi = ((WtAcc*)sti->hook) + add_index;   
          steSumLr = 0.0;      /*  zero stream occupation count */
        
        
@@ -1266,7 +1313,7 @@ static double UpMixParms(int q, HLink hm
             switch (fbInfo->hsKind){	/* Get wght and mpdf */
             case TIEDHS:
                m=tmRec->probs[mx].index;
-               wght=MixWeight(fbInfo->hset,ste->spdf.tpdf[m]);
+               wght=MixWeight(fbInfo->hset,sti->spdf.tpdf[m]);
                mp=tmRec->mixes[m];
                break;
             case DISCRETEHS:
@@ -1277,7 +1324,7 @@ static double UpMixParms(int q, HLink hm
             case PLAINHS:
             case SHAREDHS:
                m = mx;
-               me = ste->spdf.cpdf+m;
+               me = sti->spdf.cpdf+m;
                wght = MixWeight(fbInfo->hset,me->weight);
                mp=me->mpdf;
                break;
@@ -1352,10 +1399,10 @@ static double UpMixParms(int q, HLink hm
             }
          }
    
-         wa = ((WtAcc*)ste->hook) + local_accindx;
+         wa = ((WtAcc*)sti->hook) + local_accindx;
          wa->occ += steSumLr * abs_mee_acc_scale;
          if(DoingFourthAcc){   /* do 4th acc if MPE with MMI prior */            
-            wammi = ((WtAcc*)ste->hook) + add_index;
+            wammi = ((WtAcc*)sti->hook) + add_index;
             wammi->occ += steSumLr;
          }
       }
@@ -1385,11 +1432,13 @@ static void CheckData(char *fn, BufferIn
 /* StepForward: Step from 1 to T calc'ing Alpha columns and updating parms */
 static void StepForward()
 {
-   int q,t,negs;
+   int q,t;
+   long negs;
    DVector aqt,aqt1,bqt,bqt1,tmp;
    double occ, total_occ;
    HLink hmm, up_hmm;
-   ResetObsCache();
+
+   ResetObsCache(fbInfo->xfinfo);
    ZeroAlpha(1, fbInfo->Q); /*Zero the alphat column,*/
    for(q=1;q<=fbInfo->Q;q++){ /*And switch: now the alphat1 column is zero.*/
       Acoustic *ac = fbInfo->aInfo->ac + q;
@@ -1399,7 +1448,7 @@ static void StepForward()
   
    for (q=1;q<=fbInfo->Q;q++){  /* inc access counters */
       up_hmm = fbInfo->aInfo->ac[q].hmm;
-      negs = (int)up_hmm->hook+1;
+      negs = (long)up_hmm->hook+1;
       up_hmm->hook = (void *)negs;
    }
 
@@ -1453,7 +1502,7 @@ static void StepForward()
 
 
 
-static  char buf1[255];
+static  char buf1[MAXSTRLEN];
 static  Boolean eSep;
 
  
@@ -1534,7 +1583,7 @@ void FBLatFirstPass(FBLatInfo *_fbInfo, 
       printf(" Processing Data: %s\n", NameOf(datafn,buf1));
       fflush(stdout);
    }
-   MPE = fbInfo->MPE = (MPECorrLat!=NULL);
+   MPE = fbInfo->MPE = ((MPECorrLat!=NULL) ? TRUE:FALSE);
   
    ArcFromLat(fbInfo->aInfo, fbInfo->hset);
    if(MPE) AttachMPEInfo(fbInfo->aInfo);
@@ -1567,11 +1616,11 @@ void FBLatFirstPass(FBLatInfo *_fbInfo, 
       SetStreamWidths(fbInfo->al_info.tgtPK,fbInfo->al_info.tgtVecSize,fbInfo->hset->swidth,&eSep);
     
       fbInfo->al_ot = MakeObservation(&fbInfo->miscStack,fbInfo->hset->swidth,fbInfo->al_info.tgtPK,
-                                      fbInfo->hsKind==DISCRETEHS,eSep);
+                                      ((fbInfo->hsKind==DISCRETEHS) ? TRUE:FALSE),eSep);
 
       if (fbInfo->twoDataFiles){ /*todo, fix use of this. */
          fbInfo->up_ot = MakeObservation(&fbInfo->miscStack,fbInfo->hset->swidth,fbInfo->up_info.tgtPK,
-                                         fbInfo->hsKind==DISCRETEHS,eSep);
+                                         ((fbInfo->hsKind==DISCRETEHS) ? TRUE:FALSE),eSep);
       }
       fbInfo->firstTime = FALSE;
    }
@@ -1838,6 +1887,12 @@ void InitFBLat(void)
 
 
 
+/* EXPORT->ResetFBLat: reset module */
+void ResetFBLat (void)
+{
+   return;
+}
+
 /* EXPORT-> InitialiseFB Sets up heaps etc for Forward-Backwards */
 
 void InitialiseFBInfo(FBLatInfo *fbInfo,
@@ -1902,7 +1957,4 @@ void SetDoingFourthAcc(Boolean DO, int i
    add_index = indx;
 }
 
-
-/* --------------------------------- End HFBLat.c -------------------------------------- */
-
-
+/* ------------------------ End of HFBLat.c ------------------------ */
diff -pbBEwurNa --ignore-matching-lines='.*vc_id.*' HTK-3.4.1/HTKLib/HFBLat.h HTS-2.2_for_HTK-3.4.1/HTKLib/HFBLat.h
--- HTK-3.4.1/HTKLib/HFBLat.h	2009-03-13 03:43:38.000000000 +0900
+++ HTS-2.2_for_HTK-3.4.1/HTKLib/HFBLat.h	2011-06-16 13:18:29.000000000 +0900
@@ -27,11 +27,56 @@
 /*         File: HFBLat.h   Lattice Forward Backward routines  */
 /* ----------------------------------------------------------- */
 
+/*  *** THIS IS A MODIFIED VERSION OF HTK ***                        */
+/* ----------------------------------------------------------------- */
+/*           The HMM-Based Speech Synthesis System (HTS)             */
+/*           developed by HTS Working Group                          */
+/*           http://hts.sp.nitech.ac.jp/                             */
+/* ----------------------------------------------------------------- */
+/*                                                                   */
+/*  Copyright (c) 2001-2011  Nagoya Institute of Technology          */
+/*                           Department of Computer Science          */
+/*                                                                   */
+/*                2001-2008  Tokyo Institute of Technology           */
+/*                           Interdisciplinary Graduate School of    */
+/*                           Science and Engineering                 */
+/*                                                                   */
+/* All rights reserved.                                              */
+/*                                                                   */
+/* Redistribution and use in source and binary forms, with or        */
+/* without modification, are permitted provided that the following   */
+/* conditions are met:                                               */
+/*                                                                   */
+/* - Redistributions of source code must retain the above copyright  */
+/*   notice, this list of conditions and the following disclaimer.   */
+/* - Redistributions in binary form must reproduce the above         */
+/*   copyright notice, this list of conditions and the following     */
+/*   disclaimer in the documentation and/or other materials provided */
+/*   with the distribution.                                          */
+/* - Neither the name of the HTS working group nor the names of its  */
+/*   contributors may be used to endorse or promote products derived */
+/*   from this software without specific prior written permission.   */
+/*                                                                   */
+/* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND            */
+/* CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,       */
+/* INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF          */
+/* MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE          */
+/* DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS */
+/* BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,          */
+/* EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED   */
+/* TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,     */
+/* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON */
+/* ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,   */
+/* OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY    */
+/* OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE           */
+/* POSSIBILITY OF SUCH DAMAGE.                                       */
+/* ----------------------------------------------------------------- */
+
 /* !HVER!HNET:   3.4.1 [CUED 12/03/09] */
 
 
 /*
-   This module provides facilities to apply a HMM set to 
+   This module provides facilities to apply an HMM set to 
    forward-backward align a sequence of training files and
    collect statistics from each alignment.  The exact
    statistics to capture are defined by a set of flags and
@@ -86,6 +131,8 @@ typedef struct {
   float den_index; /*only for MPE. */ /*make sure set. */
 
   Boolean InUse; /* FALSE if stacks are cleared and lattices empty. */
+
+  XFInfo *xfinfo;
   AdaptXForm *inXForm;/* current input transform (if any) */
   AdaptXForm *paXForm;/* current parent transform (if any) */
   /* ... */
@@ -96,6 +143,8 @@ void InitFBLat(void);
    Initialise module and set configuration parameters. 
 */
 
+void ResetFBLat(void);
+
 void InitialiseFBInfo(FBLatInfo *fbInfo, HMMSet *hset, UPDSet uset, Boolean TwoDataFiles); 
 
 
@@ -126,9 +175,4 @@ void GetTimes(LArc *larc, int i, int *st
 /* EXPORT-> SetDoingFourthAcc: Indicate whether it is currently storing MMI statistics */
 void SetDoingFourthAcc(Boolean DO, int indx);
 
-/* ------------------------- End of HFBLat.h --------------------------- */
-
-
-
-
-
+/* ------------------------ End of HFBLat.h ------------------------ */
diff -pbBEwurNa --ignore-matching-lines='.*vc_id.*' HTK-3.4.1/HTKLib/HGen.c HTS-2.2_for_HTK-3.4.1/HTKLib/HGen.c
--- HTK-3.4.1/HTKLib/HGen.c	1970-01-01 09:00:00.000000000 +0900
+++ HTS-2.2_for_HTK-3.4.1/HTKLib/HGen.c	2011-06-16 13:27:17.000000000 +0900
@@ -0,0 +1,2059 @@
+/* ----------------------------------------------------------------- */
+/*           The HMM-Based Speech Synthesis System (HTS)             */
+/*           developed by HTS Working Group                          */
+/*           http://hts.sp.nitech.ac.jp/                             */
+/* ----------------------------------------------------------------- */
+/*                                                                   */
+/*  Copyright (c) 2001-2011  Nagoya Institute of Technology          */
+/*                           Department of Computer Science          */
+/*                                                                   */
+/*                2001-2008  Tokyo Institute of Technology           */
+/*                           Interdisciplinary Graduate School of    */
+/*                           Science and Engineering                 */
+/*                                                                   */
+/* All rights reserved.                                              */
+/*                                                                   */
+/* Redistribution and use in source and binary forms, with or        */
+/* without modification, are permitted provided that the following   */
+/* conditions are met:                                               */
+/*                                                                   */
+/* - Redistributions of source code must retain the above copyright  */
+/*   notice, this list of conditions and the following disclaimer.   */
+/* - Redistributions in binary form must reproduce the above         */
+/*   copyright notice, this list of conditions and the following     */
+/*   disclaimer in the documentation and/or other materials provided */
+/*   with the distribution.                                          */
+/* - Neither the name of the HTS working group nor the names of its  */
+/*   contributors may be used to endorse or promote products derived */
+/*   from this software without specific prior written permission.   */
+/*                                                                   */
+/* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND            */
+/* CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,       */
+/* INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF          */
+/* MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE          */
+/* DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS */
+/* BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,          */
+/* EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED   */
+/* TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,     */
+/* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON */
+/* ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,   */
+/* OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY    */
+/* OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE           */
+/* POSSIBILITY OF SUCH DAMAGE.                                       */
+/* ----------------------------------------------------------------- */
+/*         File: HGen.c: Generate parameter sequence from HMM        */
+/* ----------------------------------------------------------------- */
+
+char *hgen_version = "!HVER!HGen: 2.2 [NIT 07/07/11]";
+char *hgen_vc_id = "$Id: HGen.c,v 1.54 2011/06/16 04:27:17 uratec Exp $";
+
+#include "HShell.h"             /* HMM ToolKit Modules */
+#include "HMem.h"
+#include "HMath.h"
+#include "HSigP.h"
+#include "HAudio.h"
+#include "HWave.h"
+#include "HVQ.h"
+#include "HParm.h"
+#include "HLabel.h"
+#include "HModel.h"
+#include "HTrain.h"
+#include "HUtil.h"
+#include "HAdapt.h"
+#include "HFB.h"
+#include "HGen.h"
+#include "lbfgs.h"
+
+#define LBFGSMEM 7
+#define MAXWINLEN 30
+
+/* ------------------- Trace Information ------------------------------ */
+/* Trace Flags */
+#define T_TOP   0001            /* Top level tracing */
+#define T_MAT   0002            /* trace matrices */
+#define T_STA   0004            /* trace state sequence */
+#define T_GV    0010            /* trace gv param gen */
+
+static int trace = 0010;
+
+static ConfParam *cParm[MAXGLOBS];      /* config parameters */
+static int nParm = 0;
+
+static int maxEMIter = 20;      /* max iterations in the EM-based parameter generation */
+static double EMepsilon = 1.0E-4;       /* convergence factor for EM iteration */
+
+typedef enum { RNDTRANS = 1, RNDDUR = 2, RNDSPACE = 4, RNDMIX = 8, RNDPAR = 16 } RNDSet;
+static RNDSet rFlags = (RNDSet) 0;      /* random generation flag */
+static double rndParMean = 0.0; /* mean of Gaussian noise for random generation */
+static double rndParVar = 1.0;  /* variance of Gaussian noise for random generation */
+
+/* GV related variables */
+static Boolean useGV = FALSE;
+static IntVec useGVPst = NULL;  /* GV flag for each Pst */
+static int maxGVIter = 50;      /* max iterations in the speech parameter generation considering GV */
+static double GVepsilon = 1.0E-4;       /* convergence factor per dimension for GV iteration */
+static double minEucNorm = 1.0E-2;      /* minimum Euclid norm per dimension of a gradient vector */
+static double stepInit = 1.0;   /* initial step size */
+static double stepDec = 0.5;    /* step size deceleration factor */
+static double stepInc = 1.2;    /* step size acceleration factor */
+static double w1 = 1.0;         /* weight for HMM output prob. */
+static double w2 = 1.0;         /* weight for GV output prob. */
+static Boolean cdGV = FALSE;    /* use context-dependent GV */
+static Boolean logGV = FALSE;   /* use logarithmic GV */
+static double initweight = 1.0;
+
+typedef enum { STEEPEST = 0, NEWTON = 1, LBFGS = 2 } OptKind;
+#ifdef _HAS_FORTRAN
+static OptKind optKind = LBFGS; /* optimization method */
+#else
+static OptKind optKind = NEWTON;        /* optimization method */
+#endif                          /* _HAS_FORTRAN */
+
+static char gvDir[MAXFNAMELEN]; /* dir to look for GV defs */
+static char gvExt[MAXSTRLEN];   /* GV def file extension */
+static char gvMMF[MAXFNAMELEN]; /* GV MMF */
+static char gvLst[MAXFNAMELEN]; /* GV list */
+static char **gvOffmodel = NULL;        /* model names which are excluded to calculate GV */
+static HMMSet gvset;            /* GV set */
+static MemHeap gvStack;         /* Stack holds all GV related info */
+
+/* -------------------------- Initialisation ----------------------- */
+
+/* Str2OptKind: parse the string into the correct OptKind */
+static OptKind Str2OptKind(char *str)
+{
+   OptKind okind = STEEPEST;
+   if (!(strcmp(str, "STEEPEST")))
+      okind = STEEPEST;
+   else if (!(strcmp(str, "NEWTON")))
+      okind = NEWTON;
+   else if (!(strcmp(str, "LBFGS")))
+      okind = LBFGS;
+   else
+      HError(9999, "Str2OptKind: Unknown OptKind kind");
+
+#ifndef _HAS_FORTRAN
+   if (okind == LBFGS)
+      HError(9999, "Str2OptKind: LBFGS method requires FORTRAN compiler");
+#endif                          /* _HAS_FORTRAN */
+
+   return okind;
+}
+
+/* OptKind2Str: Return string representation of enum OptKind */
+static char *OptKind2Str(OptKind okind, char *buf)
+{
+   static char *okindmap[] = { "STEEPEST", "NEWTON", "LBFGS" };
+   return strcpy(buf, okindmap[okind]);
+}
+
+/* EXPORT->SetrFlags: set random generation flags */
+void SetrFlags(char *s)
+{
+   rFlags = (RNDSet) 0;
+   while (*s != '\0')
+      switch (*s++) {
+      case 't':
+         rFlags = (RNDSet) (rFlags + RNDTRANS);
+         break;
+      case 'd':
+         rFlags = (RNDSet) (rFlags + RNDDUR);
+         break;
+      case 's':
+         rFlags = (RNDSet) (rFlags + RNDSPACE);
+         break;
+      case 'm':
+         rFlags = (RNDSet) (rFlags + RNDMIX);
+         break;
+      case 'p':
+         rFlags = (RNDSet) (rFlags + RNDPAR);
+         break;
+      default:
+         HError(2320, "SetrFlags: Unknown random generation flag %c", *s);
+         break;
+      }
+}
+
+/* EXPORT->PrintrFlags: print random generation flags */
+void PrintrFlags(void)
+{
+   printf("HGen  ");
+
+   if (!rFlags)
+      printf("ML Generating: ");
+   if (!(rFlags & RNDTRANS))
+      printf("Transitions ");
+   if (!(rFlags & RNDDUR))
+      printf("Durations ");
+   if (!(rFlags & RNDSPACE))
+      printf("Spaces ");
+   if (!(rFlags & RNDMIX))
+      printf("Mixtures ");
+   if (!(rFlags & RNDPAR))
+      printf("Parameters ");
+   if (!rFlags)
+      printf("   ");
+
+   if (rFlags)
+      printf("Random Generating: ");
+   if (rFlags & RNDTRANS)
+      printf("Transitions ");
+   if (rFlags & RNDDUR)
+      printf("Durations ");
+   if (rFlags & RNDSPACE)
+      printf("Spaces ");
+   if (rFlags & RNDMIX)
+      printf("Mixtures ");
+   if (rFlags & RNDPAR)
+      printf("Parameters ");
+   printf("\n\n");
+}
+
+/* EXPORT->InitGen: initialise module */
+void InitGen(void)
+{
+   int i;
+   double d;
+   Boolean b;
+   char buf[MAXSTRLEN];
+
+   Register(hgen_version, hgen_vc_id);
+
+   nParm = GetConfig("HGEN", TRUE, cParm, MAXGLOBS);
+   if (nParm > 0) {
+      if (GetConfInt(cParm, nParm, "TRACE", &i))
+         trace = i;
+      if (GetConfInt(cParm, nParm, "MAXEMITER", &i))
+         maxEMIter = i;
+      if (GetConfFlt(cParm, nParm, "EMEPSILON", &d))
+         EMepsilon = d;
+      if (GetConfFlt(cParm, nParm, "RNDPARMEAN", &d))
+         rndParMean = d;
+      if (GetConfFlt(cParm, nParm, "RNDPARVAR", &d))
+         rndParVar = d;
+      if (GetConfBool(cParm, nParm, "USEGV", &b))
+         useGV = b;
+      if (GetConfBool(cParm, nParm, "CDGV", &b))
+         cdGV = b;
+      if (GetConfBool(cParm, nParm, "LOGGV", &b))
+         logGV = b;
+      if (GetConfInt(cParm, nParm, "MAXGVITER", &i))
+         maxGVIter = i;
+      if (GetConfFlt(cParm, nParm, "GVEPSILON", &d))
+         GVepsilon = d;
+      if (GetConfFlt(cParm, nParm, "MINEUCNORM", &d))
+         minEucNorm = d;
+      if (GetConfFlt(cParm, nParm, "STEPINIT", &d))
+         stepInit = d;
+      if (GetConfFlt(cParm, nParm, "STEPDEC", &d))
+         stepDec = d;
+      if (GetConfFlt(cParm, nParm, "STEPINC", &d))
+         stepInc = d;
+      if (GetConfFlt(cParm, nParm, "HMMWEIGHT", &d))
+         w1 = d;
+      if (GetConfFlt(cParm, nParm, "GVWEIGHT", &d))
+         w2 = d;
+      if (GetConfFlt(cParm, nParm, "GVINITWEIGHT", &d))
+         initweight = d;
+      if (GetConfStr(cParm, nParm, "OPTKIND", buf))
+         optKind = Str2OptKind(buf);
+      if (GetConfStr(cParm, nParm, "RNDFLAGS", buf))
+         SetrFlags(buf);
+      if (GetConfStr(cParm, nParm, "GVMODELMMF", buf))
+         strcpy(gvMMF, buf);
+      if (GetConfStr(cParm, nParm, "GVHMMLIST", buf))
+         strcpy(gvLst, buf);
+      if (GetConfStr(cParm, nParm, "GVMODELDIR", buf))
+         strcpy(gvDir, buf);
+      if (GetConfStr(cParm, nParm, "GVMODELEXT", buf))
+         strcpy(gvExt, buf);
+      if (GetConfStr(cParm, nParm, "GVOFFMODEL", buf))
+         gvOffmodel = ParseConfStrVec(&gstack, buf, TRUE);
+      if (GetConfStr(cParm, nParm, "USEGVPST", buf))
+         useGVPst = ParseConfIntVec(&gstack, buf, TRUE);
+   }
+
+   if (useGV) {
+      /* Stack for GV */
+      CreateHeap(&gvStack, "gvStore", MSTAK, 1, 1.0, 50000, 500000);
+
+      /* load GV set */
+      CreateHMMSet(&gvset, &gvStack, TRUE);
+      AddMMF(&gvset, gvMMF);
+      if (MakeHMMSet(&gvset, gvLst) < SUCCESS)
+         HError(9928, "InitGen: MakeHMMSet failed");
+      if (LoadHMMSet(&gvset, gvDir, gvExt) < SUCCESS)
+         HError(9928, "InitGen: LoadHMMSet failed");
+      ConvDiagC(&gvset, TRUE);
+      ConvLogWt(&gvset);
+
+      /* and echo status */
+      if (trace & T_TOP) {
+         printf("GV enabled\n");
+         printf(" %d Logical/%d Physical Models Loaded, VecSize=%d\n", gvset.numLogHMM, gvset.numPhyHMM, gvset.vecSize);
+      }
+
+      if (logGV && optKind == NEWTON)
+         HError(9999, "InitGen: Currently only STEEPEST and LBFGS supports log GV");
+   }
+
+   return;
+}
+
+/* EXPORT->ResetGen: reset module */
+void ResetGen(void)
+{
+   if (useGV)
+      ResetHeap(&gvStack);
+
+   return;
+}
+
+/* EXPORT->SetConfGen: set trace flag for this module */
+void SetTraceGen(void)
+{
+   trace |= T_TOP;
+}
+
+/* -------------------------- Window coefficients handling -------------------------- */
+
+/* InitWindow: Initialise and load window coefficients */
+static void InitWindow(MemHeap * x, PdfStream * pst)
+{
+   Source src;
+   int i, winlen;
+
+   /* Allocate array for window coefficients */
+   pst->win.width = (int **) New(x, pst->win.num * sizeof(int *));
+   for (i = 0; i < pst->win.num; i++)
+      pst->win.width[i] = (int *) New(x, 2 * sizeof(int));
+   pst->win.coef = (float **) New(x, pst->win.num * sizeof(float *));
+
+   /* Load window coefficients */
+   for (i = 0; i < pst->win.num; i++) {
+      if (InitSource(pst->win.fn[i], &src, NoFilter) < SUCCESS)
+         HError(2610, "InitWindow: Can't open file %s", pst->win.fn[i]);
+
+      /* Read window length */
+      ReadInt(&src, &winlen, 1, FALSE);
+      if (winlen < 0)
+         HError(9999, "InitWindow: Length of %d-th window (%d) is invalid", i + 1, winlen);
+      if (winlen > MAXWINLEN)
+         HError(9999, "InitWindow: Length of %d-th window (%d) exceeds maximum length (%d)", i + 1, winlen, MAXWINLEN);
+
+      /* Read window coefficients */
+      pst->win.coef[i] = (float *) New(x, winlen * sizeof(float));
+      ReadFloat(&src, pst->win.coef[i], winlen, FALSE);
+
+      /* Set pointer */
+      pst->win.coef[i] += winlen / 2;
+      pst->win.width[i][WLEFT] = -winlen / 2;
+      pst->win.width[i][WRIGHT] = winlen / 2;
+      if (winlen % 2 == 0)
+         pst->win.width[i][WRIGHT]--;
+
+      CloseSource(&src);
+   }
+
+   /* Set pst->width */
+   pst->win.maxw[WLEFT] = pst->win.maxw[WRIGHT] = 0;
+   for (i = 0; i < pst->win.num; i++) {
+      if (pst->win.maxw[WLEFT] > pst->win.width[i][WLEFT])
+         pst->win.maxw[WLEFT] = pst->win.width[i][WLEFT];
+      if (pst->win.maxw[WRIGHT] < pst->win.width[i][WRIGHT])
+         pst->win.maxw[WRIGHT] = pst->win.width[i][WRIGHT];
+   }
+   pst->width = (abs(pst->win.maxw[WLEFT]) > abs(pst->win.maxw[WRIGHT])) ? abs(pst->win.maxw[WLEFT]) : abs(pst->win.maxw[WRIGHT]);
+   pst->width = 2 * pst->width + 1;
+
+   /* calcurate max_L to determine size of band matrix */
+   if (pst->win.maxw[WLEFT] >= pst->win.maxw[WRIGHT])
+      pst->win.max_L = pst->win.maxw[WLEFT];
+   else
+      pst->win.max_L = pst->win.maxw[WRIGHT];
+
+   return;
+}
+
+/* -------------------------- PdfStream handling -------------------------- */
+
+/* CreatePdfStreams: create PdfStream in GenInfo */
+static void CreatePdfStreams(GenInfo * genInfo, Boolean training)
+{
+   int p, t, M;
+   PdfStream *pst;
+   MemHeap *x = genInfo->genMem;
+   int len;
+
+   for (p = 1; p <= genInfo->nPdfStream[0]; p++) {
+      /* p-th PdfStream */
+      pst = &(genInfo->pst[p]);
+
+      /* Load window file for p-th PdfStream */
+      InitWindow(x, pst);
+
+      /* full or diag covariance */
+      pst->fullCov = ((genInfo->hset->ckind == FULLC) || (useGV && (gvset.ckind == FULLC))) ? TRUE : FALSE;
+
+      if (training) {
+         len = genInfo->tframe;
+      } else {
+         len = pst->T;
+      }
+
+      /* prepare mean vector and inverse covariance matrix sequences */
+      pst->mseq = CreateMatrix(x, len, pst->vSize);     /* mean vectors */
+      pst->vseq = (Covariance *) New(x, len * sizeof(Covariance));      /* inverse covariance matrices */
+      pst->vseq--;
+
+      for (t = 1; t <= len; t++) {
+         if (pst->fullCov)
+            pst->vseq[t].inv = CreateSTriMat(x, pst->vSize);    /* inverse covariance (precision) matrices */
+         else
+            pst->vseq[t].var = CreateVector(x, pst->vSize);     /* inverse variances */
+      }
+
+      /* prepare vector and matrices for a set of linear equations */
+      M = (pst->fullCov) ? pst->order : 1;
+      if (training)
+         pst->C = CreateMatrix(x, len, pst->order * pst->win.num);      /* generated parameter sequence */
+      else
+         pst->C = CreateMatrix(x, len, pst->order);     /* generated parameter sequence */
+      pst->g = CreateDVector(x, M * len);       /* vector for forward and backward substitution and gradient */
+      pst->c = CreateDVector(x, M * len);       /* vector for generated parameter sequence */
+      pst->WUM = CreateDVector(x, M * len);     /* W'*U^{-1}*W */
+      pst->WUW = CreateDMatrix(x, M * len, M * pst->width);     /* W'*U^{-1}*M */
+
+      if (useGV) {
+         /* gv mean */
+         pst->gvmean = CreateVector(x, pst->vSize);
+         ZeroVector(pst->gvmean);
+
+         /* gv covariance */
+         if (gvset.ckind == FULLC) {
+            pst->gvcov.inv = CreateSTriMat(x, pst->vSize);
+            ZeroTriMat(pst->gvcov.inv);
+         } else {
+            pst->gvcov.var = CreateVector(x, pst->vSize);
+            ZeroVector(pst->gvcov.var);
+         }
+
+         /* gv flag */
+         pst->gvFlag = (Boolean *) New(x, genInfo->tframe * sizeof(Boolean));
+         pst->gvFlag--;
+
+         /* gv time counter */
+         pst->gvT = 0;
+      }
+   }
+
+   return;
+}
+
+/* ChkBoundary: check k-th dimension at absolute_t-th frame is on the boundary where switching MSD space */
+static Boolean ChkBoundary(PdfStream * pst, const int k, const int absolute_t, const int absolute_T)
+{
+   int j;
+
+   const int t = pst->t;        /* time counter in this PdfStream */
+   const int T = pst->T;        /* total frame in this PdfStream */
+   const int i = (k - 1) / pst->order;  /* window index for k-th dimension */
+
+   /* check */
+   for (j = pst->win.width[i][0]; j <= pst->win.width[i][1]; j++)
+      if (t + j < 1 || t + j > T || (pst->win.coef[i][j] != 0.0 && absolute_t + j >= 1 && absolute_t + j <= absolute_T && !pst->ContSpace[absolute_t + j]))
+         return TRUE;
+
+   return FALSE;
+}
+
+static void CountLenForSegs(GenInfo * genInfo, int start, int end)
+{
+   int i, j, d, t, p, stream;
+
+   for (p = 1; p <= genInfo->nPdfStream[0]; p++)
+      genInfo->pst[p].t = 0;
+
+   for (i = 1, t = 1; i <= genInfo->labseqlen; i++) {
+      for (j = 1; genInfo->sindex[i][j] != 0; j++) {
+         for (d = 0; d < genInfo->durations[i][j]; d++, t++) {
+            if (t < start)
+               continue;
+            if (t > end)
+               break;
+
+            for (p = stream = 1; p <= genInfo->nPdfStream[0]; stream += genInfo->nPdfStream[p++]) {
+               /* continuous space or not */
+               if (genInfo->pst[p].ContSpace[t])
+                  genInfo->pst[p].t++;
+            }
+         }
+      }
+   }
+
+   for (p = 1; p <= genInfo->nPdfStream[0]; p++) {
+      genInfo->pst[p].T = genInfo->pst[p].t;
+      assert(genInfo->pst[p].t <= genInfo->tframe);
+   }
+}
+
+/* SetupPdfStreams: setup PdfStreams for parameter generation */
+void SetupPdfStreams(GenInfo * genInfo, int start, int end)
+{
+   int i, j, k, l, d, t, p, s, stream, m, v, max;
+   float weight;
+   Boolean bound;
+   PdfStream *pst;
+   StateInfo *si;
+   MixPDF *mpdf;
+   Vector mseq_t, mnomial;
+   Covariance vseq_t;
+   LabId id;
+   MLink macro;
+
+   /* multinomial distribution for random generation */
+   mnomial = CreateVector(&gstack, genInfo->maxMixes);
+
+   /* absolute time */
+   const int T = genInfo->tframe;
+
+   if (start <= 0)
+      start = 1;
+   if (end <= 0 || end > genInfo->tframe)
+      end = genInfo->tframe;
+   CountLenForSegs(genInfo, start, end);
+
+   /* initialize time counter and statistics of each PdfStream */
+   for (p = stream = 1; p <= genInfo->nPdfStream[0]; stream += genInfo->nPdfStream[p++]) {
+      /* p-th PdfStream */
+      pst = &(genInfo->pst[p]);
+
+      /* initialize time counter, mseq, and vseq */
+      pst->origStart = 1;
+      pst->t = 1;
+      for (t = 1; t <= pst->T; t++) {
+         ZeroVector(pst->mseq[t]);
+         if (pst->fullCov)
+            ZeroTriMat(pst->vseq[t].inv);
+         else
+            ZeroVector(pst->vseq[t].var);
+      }
+
+      /* get gv mean and covariance */
+      if (useGV) {
+         if (!cdGV)
+            id = GetLabId("gv", TRUE);
+         else if (genInfo->stateAlign)
+            id = genInfo->label[1]->auxLab[1];
+         else
+            id = genInfo->label[1]->labid;
+         if ((macro = FindMacroName(&gvset, 'h', id)) != NULL) {
+            for (s = stream, v = 1; s < stream + genInfo->nPdfStream[p]; v += genInfo->hset->swidth[s++]) {
+               mpdf = ((HLink) macro->structure)->svec[2].info->pdf[p].info->spdf.cpdf[1].mpdf; /* currently only sigle-mixture GV pdf is supported */
+               for (k = 1; k <= VectorSize(mpdf->mean); k++) {
+                  /* gv mean */
+                  pst->gvmean[v + k - 1] = mpdf->mean[k];
+                  /* gv covariance */
+                  switch (mpdf->ckind) {        /* store inverse variance */
+                  case DIAGC:
+                     pst->gvcov.var[v + k - 1] = 1.0 / mpdf->cov.var[k];
+                     break;
+                  case INVDIAGC:
+                     pst->gvcov.var[v + k - 1] = mpdf->cov.var[k];
+                     break;
+                  case FULLC:
+                     /* diagonal elements */
+                     pst->gvcov.inv[v + k - 1][v + k - 1] = mpdf->cov.inv[k][k];
+                     /* off-diagonal elements */
+                     for (l = 1; l < k; l++)
+                        pst->gvcov.inv[v + k - 1][v + l - 1] = mpdf->cov.inv[k][l];
+                     break;
+                  default:
+                     HError(9999, "SetupPdfStreams: Only DIAGC, INVDIAGC, or FULLC is supported for GV Pdf.");
+                  }
+               }
+            }
+         } else
+            HError(9935, "Generator: Cannot find GV model %s in current list", id->name);
+      }
+   }
+
+   /* load mean and variance and set mseq and vseq */
+   for (i = 1, t = 1; i <= genInfo->labseqlen; i++) {
+      for (j = 1; genInfo->sindex[i][j] != 0; j++) {
+         si = genInfo->hmm[i]->svec[genInfo->sindex[i][j]].info;
+         for (d = 0; d < genInfo->durations[i][j]; d++, t++) {
+            for (p = stream = 1; p <= genInfo->nPdfStream[0]; stream += genInfo->nPdfStream[p++]) {
+               /* p-th PdfStream */
+               pst = &(genInfo->pst[p]);
+
+               if (pst->ContSpace[t] && t < start)
+                  pst->origStart++;
+               if (t < start)
+                  continue;
+               if (t > end)
+                  break;
+
+               /* continuous space or not */
+               if (pst->ContSpace[t]) {
+                  /* mean vector and covariance matrix at this frame */
+                  mseq_t = pst->mseq[pst->t];
+                  vseq_t = pst->vseq[pst->t];
+
+                  /* calculate mean_jp and cov_jp */
+                  for (s = stream, v = 1; s < stream + genInfo->nPdfStream[p]; v += genInfo->hset->swidth[s++]) {
+                     /* calculate total weight of continuous spaces */
+                     ZeroVector(mnomial);
+                     for (m = 1, max = 0, weight = LZERO; m <= si->pdf[s].info->nMix; m++) {
+                        mpdf = si->pdf[s].info->spdf.cpdf[m].mpdf;
+                        if (VectorSize(mpdf->mean) == genInfo->hset->swidth[s]) {
+                           /* use the best mixture only */
+                           if (si->pdf[s].info->spdf.cpdf[m].weight >= weight) {
+                              weight = si->pdf[s].info->spdf.cpdf[m].weight;
+                              max = m;
+                           }
+                           mnomial[m] = MixWeight(genInfo->hset, si->pdf[s].info->spdf.cpdf[m].weight);
+                        }
+                     }
+                     if (max == 0)
+                        HError(999, "SetupPdfStreams: no mix found");
+                     if (rFlags & RNDMIX)       /* randomly select one mixture component */
+                        max = MultiNomial(mnomial, si->pdf[s].info->nMix);
+
+                     /* set pdf streams */
+                     mpdf = si->pdf[s].info->spdf.cpdf[max].mpdf;
+                     for (k = 1; k <= genInfo->hset->swidth[s]; k++) {
+                        bound = ChkBoundary(pst, v + k - 1, t, T);
+                        if (pst->fullCov) {
+                           /* full case */
+                           switch (mpdf->ckind) {
+                           case DIAGC:
+                              mseq_t[v + k - 1] += (bound) ? 0.0 : 1.0 / mpdf->cov.var[k] * mpdf->mean[k];
+                              vseq_t.inv[v + k - 1][v + k - 1] += (bound) ? 0.0 : 1.0 / mpdf->cov.var[k];
+                              break;
+                           case INVDIAGC:
+                              mseq_t[v + k - 1] += (bound) ? 0.0 : mpdf->cov.var[k] * mpdf->mean[k];
+                              vseq_t.inv[v + k - 1][v + k - 1] += (bound) ? 0.0 : mpdf->cov.var[k];
+                              break;
+                           case FULLC:
+                              /* diagonal elements */
+                              mseq_t[v + k - 1] += (bound) ? 0.0 : mpdf->cov.inv[k][k] * mpdf->mean[k];
+                              vseq_t.inv[v + k - 1][v + k - 1] += (bound) ? 0.0 : mpdf->cov.inv[k][k];
+
+                              /* off-diagonal elements */
+                              for (l = 1; l < k; l++) {
+                                 mseq_t[v + k - 1] += (bound) ? 0.0 : mpdf->cov.inv[k][l] * mpdf->mean[l];
+                                 mseq_t[v + l - 1] += (bound) ? 0.0 : mpdf->cov.inv[k][l] * mpdf->mean[k];
+                                 vseq_t.inv[v + k - 1][v + l - 1] += (bound) ? 0.0 : mpdf->cov.inv[k][l];
+                              }
+                              break;
+                           default:
+                              HError(9999, "SetupPdfStreams: Only DIAGC, INVDIAGC or FULLC is supported.");
+                           }
+                        } else {
+                           switch (mpdf->ckind) {
+                           case DIAGC:
+                              mseq_t[v + k - 1] += (bound) ? 0.0 : 1.0 / mpdf->cov.var[k] * mpdf->mean[k];
+                              vseq_t.var[v + k - 1] += (bound) ? 0.0 : 1.0 / mpdf->cov.var[k];
+                              break;
+                           case INVDIAGC:
+                              mseq_t[v + k - 1] += (bound) ? 0.0 : mpdf->cov.var[k] * mpdf->mean[k];
+                              vseq_t.var[v + k - 1] += (bound) ? 0.0 : mpdf->cov.var[k];
+                              break;
+                           default:
+                              HError(9999, "SetupPdfStreams: Only DIAGC or INVDIAGC is supported.");
+                           }
+                        }
+                     }
+                  }
+
+                  /* set flag to exclude models in gvOffmodel from GV calculation */
+                  if (useGV) {
+                     char buf[MAXSTRLEN];
+                     strcpy(buf, genInfo->label[i]->labid->name);
+                     TriStrip(buf);
+                     for (k = 1, pst->gvFlag[pst->t] = TRUE; gvOffmodel != NULL && k <= gvOffmodel[0][0]; k++) {
+                        if (strcmp(buf, gvOffmodel[k]) == 0) {
+                           pst->gvFlag[pst->t] = FALSE;
+                           break;
+                        }
+                     }
+                     if (pst->gvFlag[pst->t])
+                        pst->gvT++;
+                  }
+
+                  /* update counter */
+                  pst->t++;
+               }
+            }
+         }
+      }
+   }
+
+   FreeVector(&gstack, mnomial);
+
+   return;
+}
+
+/* ----------------------- Sentence model initization/reset routines ----------------------- */
+
+/* GetStateIndex: get state index from name */
+static int GetStateIndex(LabId id)
+{
+   return (atoi(strrchr(id->name, '[') + 1));
+}
+
+/* SetStateSequence: set state sequence which maximize its state sequence prob */
+static void SetStateSequence(GenInfo * genInfo)
+{
+   int i, j, k, n, best;
+   LogFloat trans;
+   HLink hmm;
+   Label *label;
+   IntSet acyclic;
+   Vector mnomial;
+
+   /* set state sequence */
+   if (genInfo->stateAlign) {   /* state alignments are given */
+      for (i = 1, j = 0, n = 0; i <= CountLabs(genInfo->labseq->head); i++) {
+         /* get i-th label */
+         label = GetLabN(genInfo->labseq->head, i);
+
+         /* prepare an array to store state durations in the j-th model */
+         if (label->auxLab[1] != NULL) {
+            j++;
+            n = 0;
+         }
+
+         /* get state duration from the given label */
+         k = GetStateIndex(label->labid);
+         if (k <= 1 || k >= genInfo->hmm[j]->numStates)
+            HError(9999, "SetStateSequence: #state in the %d-th label is out of range", i);
+
+         /* set the n-th state in this model */
+         genInfo->sindex[j][++n] = k;
+      }
+   } else {                     /* state alignment is not given */
+      /* IntSet to detect acyclic graph */
+      acyclic = CreateSet(genInfo->maxStates);
+
+      /* transition probs for random generation */
+      mnomial = CreateVector(&gstack, genInfo->maxStates);
+
+      if (trace & T_STA)
+         printf(" State sequence:\n");
+
+      /* get state durations from given label sequence */
+      for (i = 1; i <= genInfo->labseqlen; i++) {
+         hmm = genInfo->hmm[i];
+         ClearSet(acyclic);
+
+         if (trace & T_STA)
+            printf("  %d-th model: %d", i, 1);
+
+         /* trace most likely state sequence in this model */
+         for (j = 1, n = 0; j != hmm->numStates; j = best) {
+            ZeroVector(mnomial);
+            for (k = 2, best = 1, trans = LZERO; k <= hmm->numStates; k++) {
+               if (k == j)
+                  continue;     /* exclude self-transition */
+               if (hmm->transP[j][k] > trans) { /* select ML one */
+                  trans = hmm->transP[j][k];
+                  best = k;
+               }
+               mnomial[k] = L2F(hmm->transP[j][k]);
+            }
+            if (rFlags & RNDTRANS) {    /* randomly select next state */
+               best = MultiNomial(mnomial, hmm->numStates);
+               trans = hmm->transP[j][best];
+            }
+
+            /* check acyclic transition */
+            if (!(rFlags & RNDTRANS) && IsMember(acyclic, best))
+               HError(9999, "SetStateSeuqnce: acyclic transition is detected.");
+            AddMember(acyclic, best);
+
+            if (trace & T_STA)
+               printf(" -> %3d (%1.2f)", best, L2F(trans));
+
+            /* set n-th state to best */
+            if (best != hmm->numStates)
+               genInfo->sindex[i][++n] = best;
+         }
+
+         if (trace & T_STA) {
+            printf("\n");
+            fflush(stdout);
+         }
+      }
+
+      /* free */
+      FreeVector(&gstack, mnomial);
+      FreeSet(acyclic);
+   }
+
+   return;
+}
+
+/* CountDurStat: count duration statistics */
+static void CountDurStat(DVector mean, DVector ivar, double *sum, double *sqr, IntVec sindex)
+{
+   int i, j;
+
+   for (i = 1; sindex[i] != 0; i++) {
+      j = sindex[i] - 1;
+      *sum += mean[j];
+      *sqr += 1.0 / ivar[j];
+   }
+
+   return;
+}
+
+/* SetStateDurations: set state durations */
+static void SetStateDurations(GenInfo * genInfo)
+{
+   int i, j, k, s, cnt, nStates, modeldur, start = 0, tframe = 0;
+   double sum, sqr, dur, rho = 0.0, diff = 0.0;
+   DVector *mean, *ivar;
+   Label *label;
+   HLink dm;
+   int l, crho = 0;
+   HTime pre_end = 0.0;
+
+   if (genInfo->speakRate != 1.0 && rFlags & RNDDUR)
+      HError(9999, "SetStateDurations: Cannot change speaking rate in random duration generation");
+   if (genInfo->modelAlign && rFlags & RNDDUR)
+      HError(9999, "SetStateDurations: Cannot use model-level alignments in random duration generation");
+
+   /* state duration statistics storage */
+   if ((mean = (DVector *) New(genInfo->genMem, genInfo->labseqlen * sizeof(DVector))) == NULL)
+      HError(9905, "SetStateDurations: Cannot allocate memory for mean");
+   if ((ivar = (DVector *) New(genInfo->genMem, genInfo->labseqlen * sizeof(DVector))) == NULL)
+      HError(9905, "SetStateDurations: Cannot allocate memory for inverse variance");
+   mean--;
+   ivar--;
+
+   /* prepare duration and calculate statistics to set speaking rate control parameter, rho */
+   sum = sqr = 0.0;
+   for (i = 1; i <= genInfo->labseqlen; i++) {
+      /* duration model for the i-th state */
+      dm = genInfo->dm[i];
+
+      /* # of states in the i-th model */
+      nStates = genInfo->hmm[i]->numStates - 2;
+      mean[i] = CreateDVector(genInfo->genMem, nStates);
+      ivar[i] = CreateDVector(genInfo->genMem, nStates);
+
+      /* set statistics of the i-th state */
+      for (s = cnt = 1; s <= genInfo->dset->swidth[0]; s++) {
+         for (k = 1; k <= genInfo->dset->swidth[s]; k++, cnt++) {
+            mean[i][cnt] = dm->svec[2].info->pdf[s].info->spdf.cpdf[1].mpdf->mean[k];
+            switch (dm->svec[2].info->pdf[s].info->spdf.cpdf[1].mpdf->ckind) {
+            case DIAGC:
+               ivar[i][cnt] = 1.0 / (double) dm->svec[2].info->pdf[s].info->spdf.cpdf[1].mpdf->cov.var[k];
+               break;
+            case INVDIAGC:
+               ivar[i][cnt] = (double) dm->svec[2].info->pdf[s].info->spdf.cpdf[1].mpdf->cov.var[k];
+               break;
+            case FULLC:
+               ivar[i][cnt] = (double) dm->svec[2].info->pdf[s].info->spdf.cpdf[1].mpdf->cov.inv[k][k];
+               break;
+            }
+         }
+      }
+
+      /* acc duration statistics to set rho */
+      if (genInfo->speakRate != 1.0)
+         CountDurStat(mean[i], ivar[i], &sum, &sqr, genInfo->sindex[i]);
+   }
+
+   /* set rho, please refer to
+    * T. Yoshimura, et al. "Duration Modeling in HMM-based Speech Synthesis System", 
+    * Proc. of ICSLP, vol.2, pp.29-32, 1998, for detail 
+    * */
+   if (genInfo->speakRate != 1.0)
+      rho = (genInfo->speakRate * sum - sum) / sqr;
+
+   /* set state durations of given label sequence */
+   for (i = 1; i <= genInfo->labseqlen; i++) {
+      /* # of states in the i-th model */
+      nStates = genInfo->hmm[i]->numStates - 2;
+
+      /* i-th label */
+      label = genInfo->label[i];
+
+      /* use model-level aligment */
+      if (genInfo->modelAlign && crho == 0) {
+         sum = sqr = 0.0;
+         CountDurStat(mean[i], ivar[i], &sum, &sqr, genInfo->sindex[i]);
+         crho = 1;
+         if (label->end >= 0.0) {       /* model-level alignment of the i-th label is specified */
+            rho = (((label->end - pre_end) / genInfo->frameRate) - sum) / sqr;
+         } else {               /* model-level alignment of the i-th label is not specified */
+            for (l = i + 1; l <= genInfo->labseqlen; l++) {
+               if (genInfo->label[l]->start >= 0.0) {
+                  rho = (((genInfo->label[l]->start - pre_end) / genInfo->frameRate) - sum) / sqr;
+                  break;
+               }
+               CountDurStat(mean[l], ivar[l], &sum, &sqr, genInfo->sindex[l]);
+               crho++;
+               if (genInfo->label[l]->end >= 0.0) {
+                  if (genInfo->label[l]->end < pre_end)
+                     HError(9999, "SetStateDurations: start time %f is smaller than end time %f", (double) pre_end, (double) genInfo->label[l]->end);
+                  rho = (((genInfo->label[l]->end - pre_end) / genInfo->frameRate) - sum) / sqr;
+                  break;
+               }
+            }
+            if (l > genInfo->labseqlen) {
+               HError(-9999, "SetStateDurations: model duration is not specified in the finel label");
+               genInfo->modelAlign = FALSE;
+               rho = 0.0;
+            }
+         }
+      }
+
+      /* calculate state durations for the i-th label */
+      modeldur = 0;
+      for (j = 1; genInfo->sindex[i][j] != 0; j++) {
+         k = genInfo->sindex[i][j] - 1;
+         dur = (rFlags & RNDDUR) ? GaussDeviate(mean[i][k], sqrt(1.0 / ivar[i][k]))     /* random duration sampling */
+             : mean[i][k] + rho / ivar[i][k];
+         genInfo->durations[i][j] = (int) (dur + diff + 0.5);
+
+         /* set minimum duration -> 1 */
+         if (genInfo->durations[i][j] < 1)
+            genInfo->durations[i][j] = 1;
+
+         diff += dur - (double) genInfo->durations[i][j];
+         tframe += genInfo->durations[i][j];
+         modeldur += genInfo->durations[i][j];
+      }
+
+      /* assign model duration */
+      label->start = (HTime) start *genInfo->frameRate;
+      label->end = (HTime) (start + modeldur) * genInfo->frameRate;
+      start += modeldur;
+
+      if (genInfo->modelAlign) {
+         pre_end = label->end;
+         crho--;
+      }
+   }
+   genInfo->tframe = tframe;
+
+   /* free memory */
+   Dispose(genInfo->genMem, ++mean);
+
+   return;
+}
+
+/* GetLabStateDurations: parse state durations from label */
+static void GetLabStateDurations(GenInfo * genInfo)
+{
+   int i, j, k, tframe = 0;
+   double diff = 0.0;
+   Label *label;
+
+   /* get state durations from given label sequence */
+   for (i = 1, j = 0, k = 1; i <= CountLabs(genInfo->labseq->head); i++) {
+      label = GetLabN(genInfo->labseq->head, i);
+      if (label->auxLab[1] != NULL) {
+         j++;
+         k = 1;
+      }
+
+      /* get state duration from label */
+      genInfo->durations[j][k] = (int) ((label->end - label->start) / genInfo->frameRate + diff + 0.5);
+      diff += (label->end - label->start) / genInfo->frameRate - (double) genInfo->durations[j][k];
+
+      /* count total frame */
+      tframe += genInfo->durations[j][k++];
+   }
+
+   genInfo->tframe = tframe;
+
+   return;
+}
+
+/* SetSpaceIndexes: set space indexes for each PdfStream according to MSD threshold */
+static void SetSpaceIndexes(MemHeap * x, GenInfo * genInfo)
+{
+   int i, j, d, s, m, t, p, stream;
+   float ContSpaceWeight, binomial[3];
+   Boolean ContSpace;
+   PdfStream *pst;
+   StateInfo *si;
+
+   /* initialise space indexes and total frame for each PdfStream  */
+   for (p = 1; p <= genInfo->nPdfStream[0]; p++) {
+      /* p-th PdfStream */
+      pst = &(genInfo->pst[p]);
+
+      /* prepare space indexes */
+      pst->ContSpace = CreateIntVec(x, genInfo->tframe);
+
+      /* initialize space indexes and number of continuous space */
+      for (t = 1; t <= genInfo->tframe; t++)
+         genInfo->pst[p].ContSpace[t] = FALSE;
+      genInfo->pst[p].T = 0;
+   }
+
+   /* select space according to MSD threshold */
+   for (i = 1, t = 1; i <= genInfo->labseqlen; i++) {
+      /* determine continuous space or not */
+      for (j = 1; genInfo->sindex[i][j] != 0; j++) {
+         si = genInfo->hmm[i]->svec[genInfo->sindex[i][j]].info;
+         for (d = 0; d < genInfo->durations[i][j]; d++) {
+            for (p = stream = 1; p <= genInfo->nPdfStream[0]; stream += genInfo->nPdfStream[p++]) {
+               ContSpace = FALSE;
+               for (s = stream; s < stream + genInfo->nPdfStream[p]; s++) {
+                  if (genInfo->hset->msdflag[s]) {
+                     ContSpaceWeight = 0.0;
+                     for (m = 1; m <= si->pdf[s].info->nMix; m++)
+                        if (VectorSize(si->pdf[s].info->spdf.cpdf[m].mpdf->mean) == genInfo->hset->swidth[s])   /* total weight of all continuous mixtures */
+                           ContSpaceWeight += MixWeight(genInfo->hset, si->pdf[s].info->spdf.cpdf[m].weight);
+
+                     /* binomial distribution to randomly select continuous/discrete space */
+                     binomial[1] = ContSpaceWeight;
+                     binomial[2] = 1.0 - ContSpaceWeight;
+
+                     /* if any streams in the p-th PdfStream is determined to continuous, this frame determined to be continous */
+                     if (((rFlags & RNDSPACE) && MultiNomial(binomial, 2) == 1) || (!(rFlags & RNDSPACE) && ContSpaceWeight > genInfo->MSDthresh)) {
+                        ContSpace = TRUE;
+                        break;
+                     }
+                  } else {
+                     ContSpaceWeight = 1.0;
+                     ContSpace = TRUE;
+                     break;
+                  }
+               }
+
+               if (ContSpace) {
+                  genInfo->pst[p].ContSpace[t + d] = TRUE;      /* set ContSpace flag */
+                  genInfo->pst[p].T++;  /* increment total number of frame in this PdfStream */
+               }
+            }
+         }
+         t += genInfo->durations[i][j];
+      }
+   }
+
+   if (trace & T_TOP) {
+      printf(" Total number of frames = %d\n", genInfo->tframe);
+      for (p = 1; p <= genInfo->nPdfStream[0]; p++) {
+         printf("  PdfStream[%d]: %d frames\n", p, genInfo->pst[p].T);
+      }
+      fflush(stdout);
+   }
+
+   return;
+}
+
+/* EXPORT->InitialiseGenInfo: initialize a genInfoence HMM according to the given label */
+void InitialiseGenInfo(GenInfo * genInfo, Transcription * tr, Boolean training)
+{
+   int i, j, n = 0, max = 0;
+   MLink hmacro, dmacro;
+   Label *label;
+   LabId id;
+
+   /* set input label file */
+   genInfo->labseq = tr;
+
+   /* count # of individual models in this label */
+   if (genInfo->stateAlign) {
+      for (i = 1, genInfo->labseqlen = 0; i <= CountLabs(genInfo->labseq->head); i++) {
+         label = GetLabN(genInfo->labseq->head, i);
+         if (i == 1 && label->auxLab == NULL)
+            HError(9999, "InitGenInfo: Invalid label format for parameter generation with state alignments");
+         if (label->auxLab[1] != NULL)  /* usually model name is written in auxLab[1] */
+            genInfo->labseqlen++;
+      }
+   } else
+      genInfo->labseqlen = CountLabs(genInfo->labseq->head);
+
+   /* create label storage */
+   if ((genInfo->label = (Label **) New(genInfo->genMem, genInfo->labseqlen * sizeof(Label *))) == NULL)
+      HError(9905, "InitGenInfo: Cannot allocate memory for labels");
+   genInfo->label--;
+
+
+   /* create hmm storage */
+   if ((genInfo->hmm = (HLink *) New(genInfo->genMem, genInfo->labseqlen * sizeof(HLink))) == NULL)
+      HError(9905, "InitGenInfo: Cannot allocate memory for HMMs");
+   genInfo->hmm--;
+
+   /* create duration model storage */
+   if (!genInfo->stateAlign) {
+      if ((genInfo->dm = (HLink *) New(genInfo->genMem, genInfo->labseqlen * sizeof(HLink))) == NULL)
+         HError(9905, "InitGenInfo: Cannot allocate memory for duration models");
+      genInfo->dm--;
+   }
+
+   /* parse label and compose a genInfoence HMM with state duration models */
+   for (i = 1, j = 1; i <= CountLabs(genInfo->labseq->head); i++) {
+      /* get label */
+      label = GetLabN(genInfo->labseq->head, i);
+
+      /* LabId of this model */
+      if (genInfo->stateAlign) {
+         n++;
+         if ((id = label->auxLab[1]) == NULL) { /* auxLab[1] == NULL -> ignore */
+            continue;
+         } else {
+            max = (n > max) ? n : max;
+            n = 0;
+         }
+      } else {
+         /* find state duration model */
+         id = label->labid;
+         if ((dmacro = FindMacroName(genInfo->dset, 'l', id)) == NULL)
+            HError(9935, "Generator: Cannot find duration model %s in current list", id->name);
+         genInfo->dm[j] = (HLink) dmacro->structure;
+      }
+
+      /* find HMM */
+      if ((hmacro = FindMacroName(genInfo->hset, 'l', id)) == NULL)
+         HError(9935, "Generator: Cannot find hmm %s in current model list", id->name);
+      genInfo->hmm[j] = (HLink) hmacro->structure;
+
+      /* set label */
+      genInfo->label[j] = label;
+
+      j++;
+   }
+
+
+   /* set state sequence which maximizes its state sequence prob */
+   genInfo->sindex = CreateIMatrix(genInfo->genMem, genInfo->labseqlen, ((genInfo->stateAlign) ? max + 1 : genInfo->maxStates));
+   ZeroIMatrix(genInfo->sindex);
+   SetStateSequence(genInfo);
+
+   /* set state durations which maximize their state duration prob */
+   genInfo->durations = CreateIMatrix(genInfo->genMem, genInfo->labseqlen, ((genInfo->stateAlign) ? max + 1 : genInfo->maxStates));
+   ZeroIMatrix(genInfo->durations);
+   if (genInfo->stateAlign)
+      GetLabStateDurations(genInfo);
+   else
+      SetStateDurations(genInfo);
+
+
+   /* set MSD space indexes for each PdfStream */
+   SetSpaceIndexes(genInfo->genMem, genInfo);
+
+
+   /* Create PdfStreams */
+   CreatePdfStreams(genInfo, training);
+
+   return;
+}
+
+/* EXPORT->ResetGenInfo: reset a genInfoence HMM according to the given label */
+void ResetGenInfo(GenInfo * genInfo)
+{
+   Dispose(genInfo->genMem, ++genInfo->label);
+
+   return;
+}
+
+/* EXPORT->JointProb: joint probability of given observations and state sequence */
+void JointProb(GenInfo * genInfo, UttInfo * utt)
+{
+   int i, j, d, t;
+   LogFloat prob = 0.0;
+   StateInfo *si;
+
+   /* compute output probability of given observation sequence 
+    * according to state durations */
+   for (i = 1, t = 1; i <= genInfo->labseqlen; i++) {
+      /* initial state prob */
+      prob += genInfo->hmm[i]->transP[1][genInfo->sindex[i][1]];
+
+      /* state output and self-transition prob */
+      for (j = 1; genInfo->sindex[i][j] != 0; j++) {
+         si = genInfo->hmm[i]->svec[genInfo->sindex[i][j]].info;
+
+         /* state output prob */
+         for (d = 1; d <= genInfo->durations[i][j]; d++, t++)
+            prob += POutP(genInfo->hset, &(utt->o[t]), si);
+
+         /* state transition prob */
+         prob += (genInfo->durations[i][j] - 1) * genInfo->hmm[i]->transP[genInfo->sindex[i][j]][genInfo->sindex[i][j]];
+         if (genInfo->sindex[i][j + 1] != 0)
+            prob += genInfo->hmm[i]->transP[genInfo->sindex[i][j]][genInfo->sindex[i][j + 1]];
+      }
+
+      /* final state prob */
+      prob += genInfo->hmm[i]->transP[genInfo->sindex[i][j - 1]][genInfo->hmm[i]->numStates];
+   }
+
+   utt->pr = prob;
+}
+
+/* OutProb: output probability of an observation sequence for a given state sequence */
+static void OutProb(GenInfo * genInfo, UttInfo * utt)
+{
+   int i, j, d, t;
+   LogFloat prob;
+   StateInfo *si;
+
+   utt->pr = 0.0;
+
+   for (i = 1, t = 1; i <= genInfo->labseqlen; i++) {
+      for (j = 1; genInfo->sindex[i][j] != 0; j++) {
+         si = genInfo->hmm[i]->svec[genInfo->sindex[i][j]].info;
+
+         /* state output prob */
+         for (d = 1; d <= genInfo->durations[i][j]; d++, t++) {
+            prob = POutP(genInfo->hset, &(utt->o[t]), si);
+            if (prob < LSMALL)
+               HError(-9999, "OutProb: output prob at frame %d is 0.0", t);
+            utt->pr += prob;
+         }
+      }
+   }
+
+   return;
+}
+
+/* -------------------------- Cholesky decomposition-based parameter generation -------------------------- */
+
+/* Calc_WUM_and_WUW: calcurate W'*U^{-1}*M and W'*U^{-1}*W */
+void Calc_WUM_and_WUW(PdfStream * pst, const int bias)
+{
+   int t, m, n, d, j, l, k;
+   double cov, WU;
+
+   const Boolean full = pst->fullCov;
+   const int M = (full) ? pst->order : 1;
+
+   /* initialization */
+   ZeroDMatrix(pst->WUW);
+   ZeroDVector(pst->WUM);
+
+   /* computation */
+#pragma omp parallel for private(m,n,d,j,l,cov,WU,k)
+   for (t = 1; t <= pst->T; t++) {
+      for (m = 1; m <= M; m++) {
+         for (n = 1; n <= M; n++) {
+            for (d = 0; d < pst->win.num; d++) {
+               for (j = pst->win.maxw[WLEFT]; j <= pst->win.maxw[WRIGHT]; j++) {
+                  if ((t + j > 0) && (t + j <= pst->T)) {
+                     /* accumulate W'*U^{-1}*M */
+                     if ((n == 1) && (pst->win.width[d][WLEFT] <= j) && (j <= pst->win.width[d][WRIGHT]) && (pst->win.coef[d][-j] != 0.0))
+                        pst->WUM[M * (t - 1) + m] += ((double) pst->win.coef[d][-j]) * pst->mseq[t + j][d * pst->order + m + bias];
+
+                     /* accumulate W'*U^{-1}*W */
+                     /* W'U^{-1} */
+                     for (l = ((full) ? 0 : d), WU = 0.0; l <= ((full) ? pst->win.num - 1 : d); l++) {
+                        cov = (!full) ? pst->vseq[t + j].var[pst->order * l + m + bias] : ((pst->order * l + m > pst->order * d + n) ? pst->vseq[t + j].inv[pst->order * l + m][pst->order * d + n]
+                                                                                           : pst->vseq[t + j].inv[pst->order * d + n][pst->order * l + m]);
+
+                        if (cov != 0.0 && pst->win.width[l][WLEFT] <= j && j <= pst->win.width[l][WRIGHT] && pst->win.coef[l][-j] != 0.0)
+                           WU += cov * (double) pst->win.coef[l][-j];
+                     }
+
+                     /* W'*U^{-1}*W */
+                     for (k = 0; (WU != 0.0) && (k < pst->width) && (t + k <= pst->T); k++)
+                        if ((pst->win.width[d][WLEFT] <= k - j) && (k - j <= pst->win.width[d][WRIGHT]) && (M * k + n - m + 1 > 0) && (pst->win.coef[d][k - j] != 0.0))
+                           pst->WUW[M * (t - 1) + m][M * k + n - m + 1] += WU * (double) pst->win.coef[d][k - j];
+                  }
+               }
+            }
+         }
+      }
+   }
+
+   if (trace & T_MAT) {
+      ShowDMatrix("  WUW", pst->WUW, pst->width, pst->T);
+      ShowDVector("\n  WUM", pst->WUM, pst->T);
+      fflush(stdout);
+   }
+}
+
+/* Cholesky_Factorization: Compute Cholesky factor of matrix W'*U^{-1}*W */
+void Cholesky_Factorization(PdfStream * pst)
+{
+   int t, i, j;
+
+   DMatrix WUW = pst->WUW;
+   DMatrix U = pst->WUW;
+
+   /* sizes of matrix */
+   const int M = (pst->fullCov) ? pst->order : 1;
+   const int T = M * pst->T;
+   const int width = M * pst->width;
+
+   /* Cholesky decomposition */
+   for (t = 1; t <= T; t++) {
+      for (i = 1; (i < width) && (t - i > 0); i++)
+         U[t][1] -= U[t - i][i + 1] * U[t - i][i + 1];
+
+      if (WUW[t][1] < 0.0)
+         HError(9999, "Cholesky_Factorization: (%d,%d)-th element of W'*U^{-1}*W is negative.\n", t, t);
+
+      U[t][1] = sqrt(WUW[t][1]);
+
+      for (i = 2; i <= width; i++) {
+         for (j = 1; (i + j <= width) && (t - j > 0); j++)
+            U[t][i] -= U[t - j][j + 1] * U[t - j][i + j];
+         U[t][i] /= U[t][1];
+      }
+   }
+
+   if (trace & T_MAT) {
+      ShowDMatrix("\n  Cholesky factor", U, width, T);
+      fflush(stdout);
+   }
+
+   return;
+}
+
+/* Forward_Substitution: forward substitution to solve set of linear equations */
+void Forward_Substitution(PdfStream * pst)
+{
+   int t, i;
+
+   DMatrix U = pst->WUW;
+   DVector r = pst->WUM;
+   DVector g = pst->g;
+
+   /* sizes of matrix and vector */
+   const int M = (pst->fullCov) ? pst->order : 1;
+   const int T = M * pst->T;
+   const int width = M * pst->width;
+
+   /* forward substitution */
+   for (t = 1; t <= T; t++) {
+      g[t] = r[t];
+      for (i = 1; (i < width) && (t - i > 0); i++)
+         g[t] -= U[t - i][i + 1] * g[t - i];
+      g[t] /= U[t][1];
+   }
+
+   /* random generation */
+   if (rFlags & RNDPAR) {
+      for (t = 1; t <= T; t++)
+         g[t] += GaussDeviate(rndParMean, rndParVar);
+   }
+
+   if (trace & T_MAT) {
+      ShowDVector("\n  g", g, T);
+      fflush(stdout);
+   }
+
+   return;
+}
+
+/* Backward_Substitution: backward substitution to solve set of linear equations */
+void Backward_Substitution(PdfStream * pst, const int bias)
+{
+   int t, i;
+
+   Matrix C = pst->C;
+   DMatrix U = pst->WUW;
+   DVector g = pst->g;
+   DVector c = pst->c;
+
+   /* sizes of matrix and vector */
+   const int M = (pst->fullCov) ? pst->order : 1;
+   const int T = M * pst->T;
+   const int width = M * pst->width;
+
+   if (trace & T_MAT)
+      printf("\n  solution\n   ");
+
+   /* backward substitution */
+   for (t = T; t > 0; t--) {
+      c[t] = g[t];
+      for (i = 1; (i < width) && (t + i <= T); i++)
+         c[t] -= U[t][i + 1] * c[t + i];
+      c[t] /= U[t][1];
+
+      if (trace & T_MAT) {
+         printf("%8.2lf ", c[t]);
+         fflush(stdout);
+      }
+   }
+
+   /* store generated parameters */
+   for (t = 1; t <= T; t++)
+      C[(t + M - 1) / M][(t + M - 1) % M + 1 + bias] = (float) c[t];
+
+   return;
+}
+
+/* -------------------------------- GV related functions ------------------------------------- */
+/* Calc_GV: calculate GV of the current c */
+static void Calc_GV(PdfStream * pst, const int bias, DVector mean, DVector var)
+{
+   int m, t;
+   DVector c = pst->c;
+
+   /* constant values */
+   const int M = (pst->fullCov) ? pst->order : 1;
+   const int T = M * pst->T;
+
+   /* mean */
+   ZeroDVector(mean);
+   for (t = 1; t <= T; t++) {
+      if (pst->gvFlag[(t + M - 1) / M]) {
+         m = (t + M - 1) % M + 1 + bias;
+         mean[m] += c[t];
+      }
+   }
+   for (m = 1; m <= M; m++)
+      mean[m + bias] /= pst->gvT;
+
+   /* variance */
+   ZeroDVector(var);
+   for (t = 1; t <= T; t++) {
+      if (pst->gvFlag[(t + M - 1) / M]) {
+         m = (t + M - 1) % M + 1 + bias;
+         var[m] += (c[t] - mean[m]) * (c[t] - mean[m]);
+      }
+   }
+   for (m = 1; m <= M; m++)
+      var[m + bias] /= pst->gvT;
+
+   return;
+}
+
+/* Conv_GV: expand c according to mean value of a given GV pdf */
+static void Conv_GV(PdfStream * pst, const int bias, DVector mean, DVector var)
+{
+   int m, t;
+
+   /* constant values */
+   const int M = (pst->fullCov) ? pst->order : 1;
+   const int T = M * pst->T;
+
+   /* Vector/Matrices */
+   DVector c = pst->c;
+   DVector ratio = CreateDVector(&gvStack, pst->order);
+
+   /* calculate GV of c */
+   Calc_GV(pst, bias, mean, var);
+
+   /* ratio between GV mean and variance of c */
+   for (m = 1; m <= M; m++)
+      ratio[m + bias] = (logGV) ? sqrt(exp(pst->gvmean[m + bias]) / var[m + bias])      /* log -> linear */
+          : sqrt(pst->gvmean[m + bias] / var[m + bias]);        /* linear */
+
+   /* expand c */
+   for (t = 1; t <= T; t++) {
+      if (pst->gvFlag[(t + M - 1) / M]) {
+         m = (t + M - 1) % M + 1 + bias;
+         c[t] = initweight * ratio[m] * (c[t] - mean[m]) + mean[m];
+      }
+   }
+
+   FreeDVector(&gvStack, ratio);
+
+   return;
+}
+
+/* Calc_Gradient: calculate a gradient vector of the GV objective function with respect to c */
+static LogDouble Calc_Gradient(PdfStream * pst, const int bias, DVector mean, DVector var, LogDouble * GVobj, LogDouble * HMMobj, double *norm)
+{
+   int m, l, t, i;
+   double inv, h = 1.0;
+
+   /* constant values */
+   const int M = (pst->fullCov) ? pst->order : 1;
+   const int T = M * pst->T;
+   const int width = M * pst->width;
+   const double w = 1.0 / (pst->win.num * pst->T);
+
+   /* Vector/Matrices */
+   DMatrix R = pst->WUW;
+   DVector r = pst->WUM;
+   DVector c = pst->c;
+   DVector g = pst->g;
+
+   /* GV pdf statistics */
+   DVector vd = CreateDVector(&gvStack, pst->order);
+   Vector gvmean = pst->gvmean;
+   Covariance gvcov = pst->gvcov;
+   Boolean fullGV = (gvset.ckind == FULLC) ? TRUE : FALSE;
+
+   /* recalculate GV of the current c */
+   Calc_GV(pst, bias, mean, var);
+
+   /* GV objective function and its derivative with respect to c */
+   ZeroDVector(vd);
+   for (m = 1, *GVobj = 0.0; m <= M; m++) {
+      for (l = ((fullGV) ? 1 : m); l <= ((fullGV) ? M : m); l++) {
+         inv = (fullGV) ? ((l < m) ? gvcov.inv[m + bias][l + bias] : gvcov.inv[l + bias][m + bias]) : gvcov.var[l + bias];
+         if (logGV) {
+            /* logarithmic GV */
+            *GVobj -= 0.5 * w2 * (log(var[m + bias]) - gvmean[m + bias]) * inv * (log(var[l + bias]) - gvmean[l + bias]);
+            vd[m + bias] += inv * (log(var[l + bias]) - gvmean[l + bias]);
+         } else {
+            /* linear GV */
+            *GVobj -= 0.5 * w2 * (var[m + bias] - gvmean[m + bias]) * inv * (var[l + bias] - gvmean[l + bias]);
+            vd[m + bias] += inv * (var[l + bias] - gvmean[l + bias]);
+         }
+      }
+   }
+
+   /* calculate g = R*c */
+   for (t = 1; t <= T; t++) {
+      g[t] = R[t][1] * c[t];
+      for (i = 2; i <= width; i++) {
+         if (t + i - 1 <= T)
+            g[t] += R[t][i] * c[t + i - 1];
+         if (t - i + 1 > 0)
+            g[t] += R[t - i + 1][i] * c[t - i + 1];
+      }
+   }
+
+   for (t = 1, *HMMobj = 0.0, *norm = 0.0; t <= pst->T; t++) {
+      for (m = 1; m <= M; m++) {
+         /* index */
+         i = M * (t - 1) + m;
+
+         /* objective function */
+         *HMMobj += -0.5 * w1 * w * c[i] * (g[i] - 2.0 * r[i]);
+
+         switch (optKind) {
+         case NEWTON:
+            /* only diagonal elements of Hessian matrix are used */
+            inv = (fullGV) ? gvcov.inv[m + bias][m + bias] : gvcov.var[m + bias];
+            h = -w1 * w * R[i][1] - w2 * 2.0 / (pst->T * pst->T) * ((pst->T - 1) * vd[m + bias] + 2.0 * inv * (c[i] - mean[m + bias]) * (c[i] - mean[m + bias]));
+            h = -1.0 / h;
+            break;
+         case LBFGS:
+         case STEEPEST:
+            /* do not use hessian */
+            h = 1.0;
+         }
+
+         /* derivative */
+         g[i] = w1 * w * (-g[i] + r[i]);
+         if (pst->gvFlag[t])
+            g[i] += (logGV) ? w2 * (-2.0 / pst->T * (c[i] - mean[m + bias]) * vd[m + bias]) / var[m + bias]
+                : w2 * (-2.0 / pst->T * (c[i] - mean[m + bias]) * vd[m + bias]);
+
+         /* Hessian */
+         g[i] *= h;
+
+         /* norm of gradient vector */
+         *norm += g[i] * g[i];
+      }
+   }
+
+   /* Euclidian norm of gradient vector */
+   *norm = sqrt(*norm);
+
+   /* free vector */
+   FreeDVector(&gvStack, vd);
+
+   return (*HMMobj + *GVobj);
+}
+
+/* GV_ParmGen: optimize C considering global variance */
+static void GV_ParmGen(PdfStream * pst, const int bias)
+{
+   int t, iter;
+   double norm, step = stepInit;
+   LogDouble obj, prev = LZERO, GVobj, HMMobj;
+
+   /* matrix/vectors */
+   Matrix C = pst->C;
+   DVector c = pst->c;
+   DVector g = pst->g;
+   DVector diag, w;
+
+   /* constant values */
+   const int M = (pst->fullCov) ? pst->order : 1;
+   const int T = M * pst->T;
+
+   /* GV pdf statistics */
+   DVector mean = CreateDVector(&gvStack, pst->order);
+   ZeroDVector(mean);
+   DVector var = CreateDVector(&gvStack, pst->order);
+   ZeroDVector(var);
+
+   /* variables for L-BFGS */
+   int dim = T, mem = LBFGSMEM, diagco = 0, iprint[] = { -1, 0 }, iflag = 0;
+   double f, eps = 1.0e-6, xtol = 1.0e-15;
+   diag = CreateDVector(&gvStack, T);
+   w = CreateDVector(&gvStack, T * (2 * LBFGSMEM + 1) + 2 * LBFGSMEM);
+   ZeroDVector(diag);
+   ZeroDVector(w);
+
+   /* first convert c according to GV pdf and use it as the initial value */
+   Conv_GV(pst, bias, mean, var);
+
+   /* recalculate R and r */
+   Calc_WUM_and_WUW(pst, bias);
+
+   /* iteratively optimize c */
+   for (iter = 1; iter <= maxGVIter; iter++) {
+      /* calculate GV objective and its derivative with respect to c */
+      obj = Calc_Gradient(pst, bias, mean, var, &GVobj, &HMMobj, &norm);
+
+      if (trace & T_GV) {
+         printf("   Iteration %2d: GV Obj = %e (HMM:%e GV:%e)", iter, obj, HMMobj, GVobj);
+         if (iter > 1)
+            printf("  Change = %f", obj - prev);
+         printf("\n");
+         fflush(stdout);
+      }
+
+      /* convergence check (Euclid norm, objective function, and LBFGS report) */
+      if ((optKind != LBFGS && norm < M * minEucNorm) || (iter > 1 && fabs(obj - prev) < M * GVepsilon) || (iter > 1 && optKind == LBFGS && iflag == 0)) {
+         if (trace & T_GV) {
+            if (iter > 1)
+               printf("   Converged (norm=%e, change=%e).\n", norm, fabs(obj - prev));
+            else
+               printf("   Converged (norm=%e).\n", norm);
+            fflush(stdout);
+         }
+         break;
+      }
+
+      /* accelerate/decelerate step size */
+      if (iter > 1 && optKind != LBFGS) {
+         /* objective function improved -> increase step size */
+         if (obj > prev)
+            step *= stepInc;
+
+         /* objective function degraded -> go back c and decrese step size */
+         if (obj < prev) {
+            for (t = 1; t <= T; t++)    /* go back c to that at the previous iteration */
+               c[t] -= step * diag[t];
+            step *= stepDec;
+            for (t = 1; t <= T; t++)    /* gradient c */
+               c[t] += step * diag[t];
+            continue;
+         }
+      }
+
+      switch (optKind) {
+      case STEEPEST:           /* steepest ascent */
+      case NEWTON:             /* quasi Newton (only diagonal elements of Hessian matrix are used */
+         for (t = 1; t <= T; t++)
+            c[t] += step * g[t];
+         CopyDVector(g, diag);
+         break;
+#ifdef _HAS_FORTRAN
+      case LBFGS:
+         for (t = 1; t <= T; t++)
+            g[t] = -g[t];       /* swap sign because L-BFGS minimizes objective function */
+         f = -obj;
+         /* call LBFGS FORTRAN routine */
+         lbfgs_(&dim, &mem, &c[1], &f, &g[1], &diagco, &diag[1], iprint, &eps, &xtol, &w[1], &iflag);
+         break;
+#endif                          /* _HAS_FORTRAN */
+      default:
+         HError(9999, "GV_ParmGen: Not supported optimization kind.");
+      }
+
+      prev = obj;
+   }
+
+   /* convergence check (Euclid norm, objective function, and LBFGS report) */
+   if (iter > maxGVIter && trace & T_GV) {
+      printf("   Optimization stopped by reaching max # of iterations (%d).\n", maxGVIter);
+      fflush(stdout);
+   }
+
+   /* store generated parameters */
+   for (t = 1; t <= T; t++)
+      C[(t + M - 1) / M][(t + M - 1) % M + 1 + bias] = (float) c[t];
+
+   /* free vectors allocated in this function */
+   FreeDVector(&gvStack, mean);
+
+   return;
+}
+
+/* Cholesky_ParmGen: Generate parameter sequence using Cholesky decomposition */
+static void Cholesky_ParmGen(GenInfo * genInfo, const Boolean GV)
+{
+   int p, m;
+   PdfStream *pst;
+
+   if (GV && (trace & T_GV)) {
+      char buf[MAXSTRLEN];
+      printf(" Parameter generation considering global variance (GV)\n");
+      printf("  Optimization=%s  ", OptKind2Str(optKind, buf));
+      if (optKind != LBFGS)
+         printf("step size (init=%.3f, inc=%.2f, dec=%.2f)", stepInit, stepInc, stepDec);
+      printf("\n  HMM weight=%.2f, GV weight=%.2f\n", w1, w2);
+      fflush(stdout);
+   }
+
+   for (p = 1, pst = genInfo->pst + 1; p <= genInfo->nPdfStream[0]; p++, pst++) {
+      if (pst->T < 1)
+         continue;
+
+      if ((trace & T_MAT) || (GV && (trace & T_GV))) {
+         printf("  Stream: %d\n", p);
+         fflush(stdout);
+      }
+
+      for (m = 1; m <= ((pst->fullCov) ? 1 : pst->order); m++) {
+         if ((trace & T_MAT) || (GV && (trace & T_GV))) {
+            if (pst->fullCov)
+               printf("  Feature: all\n");
+            else
+               printf("  Feature: %d\n", m);
+            fflush(stdout);
+         }
+
+         /* generate m-th feature */
+         Calc_WUM_and_WUW(pst, m - 1);
+         Cholesky_Factorization(pst);   /* Cholesky decomposition */
+         Forward_Substitution(pst);     /* forward substitution   */
+         Backward_Substitution(pst, m - 1);     /* backward substitution  */
+         if (GV && (useGVPst == NULL || useGVPst[p] == 1))
+            GV_ParmGen(pst, m - 1);     /* iterative optimization */
+      }
+   }
+
+   return;
+}
+
+/* -------------------------- Observation generation routines --------------------------------- */
+/* ApplyWindow: check t-th frame is on swithing space boundary */
+static float ApplyWindow(PdfStream * pst, const short msdflag, const int absolute_t, const int v)
+{
+   int j;
+   float otsk;
+
+   /* constants */
+   const int t = pst->t;        /* time counter in this PdfStream */
+   const int T = pst->T;        /* total number of frames in this PdfStream */
+   const int i = (v - 1) / pst->order;  /* window for this dimension */
+   const int m = (v - 1) % pst->order + 1;      /* static feature for this dimension */
+
+   /* applying window */
+   otsk = 0.0;
+   for (j = pst->win.width[i][0]; j <= pst->win.width[i][1]; j++) {
+      if (msdflag && (t + j < 1 || t + j > T || (pst->win.coef[i][j] != 0.0 && !pst->ContSpace[absolute_t + j]))) {
+         otsk = ReturnIgnoreValue();
+         break;
+      } else {
+         if (t + j >= 1 && t + j <= T)
+            otsk += pst->win.coef[i][j] * pst->C[t + j][m];
+      }
+   }
+
+   return (otsk);
+}
+
+/* UpdateUttObs: update observations in UttInfo using generated static feature vector sequence */
+static void UpdateUttObs(GenInfo * genInfo, UttInfo * utt)
+{
+   int t, s, k, p, stream, v;
+   PdfStream *pst;
+
+   const int T = utt->T;
+
+   /* initialize PdfStream time counter */
+   for (p = 1; p <= genInfo->nPdfStream[0]; p++)
+      genInfo->pst[p].t = 1;
+
+   /* construct observation vector sequence */
+   for (t = 1; t <= T; t++) {
+      for (p = stream = 1; p <= genInfo->nPdfStream[0]; stream += genInfo->nPdfStream[p++]) {
+         /* p-th PdfStream */
+         pst = &(genInfo->pst[p]);
+
+         /* whether t-th frame is continuous or not */
+         if (pst->ContSpace[t]) {
+            for (s = stream, v = 1; s < stream + genInfo->nPdfStream[p]; v += genInfo->hset->swidth[s++]) {
+               for (k = 1; k <= genInfo->hset->swidth[s]; k++)
+                  utt->o[t].fv[s][k] = ApplyWindow(pst, genInfo->hset->msdflag[s], t, v + k - 1);
+            }
+            pst->t++;
+         } else {
+            for (s = stream; s < stream + genInfo->nPdfStream[p]; s++)
+               for (k = 1; k <= genInfo->hset->swidth[s]; k++)
+                  utt->o[t].fv[s][k] = ReturnIgnoreValue();     /* ignoreValue is used for repregenInfoing MSD discrete symbol */
+         }
+      }
+   }
+
+   return;
+}
+
+/* -------------------------- EM-based parameter generation algorithm -------------------------- */
+
+/* UpdatePdfStreams: update PdfStreams according to occ prob */
+static void UpdatePdfStreams(GenInfo * genInfo, FBInfo * fbInfo, UttInfo * utt)
+{
+   int t, p, q, j, N, k, l, m, s, v, stream;
+   float Lr;
+   AlphaBeta *ab = fbInfo->ab;
+   HLink hmm;
+   MixPDF *mpdf;
+   Vector mseq_t;
+   Covariance vseq_t;
+   Boolean bound;
+   PdfStream *pst;
+
+   /* absolute time */
+   const int T = utt->T;
+
+   /* initialize time counter and statistics of each PdfStream */
+   for (p = 1; p <= genInfo->nPdfStream[0]; p++) {
+      /* p-th PdfStream */
+      pst = &(genInfo->pst[p]);
+
+      /* initialize time counter, mseq, and vseq */
+      pst->t = 1;
+      for (t = 1; t <= pst->T; t++) {
+         ZeroVector(pst->mseq[t]);
+         if (pst->fullCov)
+            ZeroTriMat(pst->vseq[t].inv);
+         else
+            ZeroVector(pst->vseq[t].var);
+      }
+   }
+
+   /* update statistics */
+   for (t = 1; t <= T; t++) {   /* absolute time */
+      for (p = stream = 1; p <= genInfo->nPdfStream[0]; stream += genInfo->nPdfStream[p++]) {
+         /* p-th PdfStream */
+         pst = &(genInfo->pst[p]);
+
+         /* whether t-th frame is continuous or not */
+         if (pst->ContSpace[t]) {
+            /* mean vector and covariance matrix at this frame */
+            mseq_t = pst->mseq[pst->t];
+            vseq_t = pst->vseq[pst->t];
+
+            /* update mseq and vseq at time t */
+            for (q = ab->pInfo->qLo[t]; q <= ab->pInfo->qHi[t]; q++) {
+               hmm = genInfo->hmm[q];
+               N = hmm->numStates;
+
+               for (j = 2; j < N; j++) {
+                  /* update statistics */
+                  for (s = stream, v = 1; s < stream + genInfo->nPdfStream[p]; v += fbInfo->al_hset->swidth[s++]) {
+                     for (m = 1; m <= hmm->svec[j].info->pdf[s].info->nMix; m++) {
+                        mpdf = hmm->svec[j].info->pdf[s].info->spdf.cpdf[m].mpdf;
+                        if (VectorSize(mpdf->mean) == fbInfo->al_hset->swidth[s]) {     /* check MSD */
+                           Lr = ab->occm[t][q][j][s][m];        /* absolute time */
+                           if (Lr > 0.0) {
+                              for (k = 1; k <= fbInfo->al_hset->swidth[s]; k++) {
+                                 bound = ChkBoundary(pst, v + k - 1, t, T);
+                                 switch (mpdf->ckind) {
+                                 case DIAGC:
+                                    mseq_t[v + k - 1] += (bound) ? 0.0 : Lr / mpdf->cov.var[k] * mpdf->mean[k];
+                                    vseq_t.var[v + k - 1] += (bound) ? 0.0 : Lr / mpdf->cov.var[k];
+                                    break;
+                                 case INVDIAGC:
+                                    mseq_t[v + k - 1] += (bound) ? 0.0 : Lr * mpdf->cov.var[k] * mpdf->mean[k];
+                                    vseq_t.var[v + k - 1] += (bound) ? 0.0 : Lr * mpdf->cov.var[k];
+                                    break;
+                                 case FULLC:
+                                    /* diagonal elements */
+                                    mseq_t[v + k - 1] += (bound) ? 0.0 : Lr * mpdf->cov.inv[k][k] * mpdf->mean[k];
+                                    vseq_t.inv[v + k - 1][v + k - 1] += (bound) ? 0.0 : Lr * mpdf->cov.inv[k][k];
+
+                                    /* off-diagonal elements */
+                                    for (l = 1; l < k; l++) {
+                                       mseq_t[v + k - 1] += (bound) ? 0.0 : Lr * mpdf->cov.inv[k][l] * mpdf->mean[l];
+                                       mseq_t[v + l - 1] += (bound) ? 0.0 : Lr * mpdf->cov.inv[k][l] * mpdf->mean[k];
+                                       vseq_t.inv[v + k - 1][v + l - 1] += (bound) ? 0.0 : Lr * mpdf->cov.inv[k][l];
+                                    }
+                                    break;
+                                 default:
+                                    HError(9999, "UpPdfStreams: Only DIAGC, INVDIAGC and FULLC are supported.");
+                                 }
+                              }
+                           }
+                        }
+                     }
+                  }
+               }
+            }
+            /* update counter */
+            pst->t++;
+         }
+      }
+   }
+
+   return;
+}
+
+/* MixUtt: compute mixture-level posterior prob */
+static Boolean MixUtt(GenInfo * genInfo, FBInfo * fbInfo, UttInfo * utt)
+{
+   int t, d, s, i, j, k, l, m;
+   LogDouble ax, bx;
+   AlphaBeta *ab = fbInfo->ab;
+   PruneInfo *p;
+   StateInfo *si;
+   MixPDF *mp;
+
+   ab->pInfo = (PruneInfo *) New(&ab->abMem, sizeof(PruneInfo));
+   p = ab->pInfo;
+
+   p->qHi = CreateShortVec(&ab->abMem, genInfo->tframe);
+   p->qLo = CreateShortVec(&ab->abMem, genInfo->tframe);
+
+   ab->occm = (Vector ****) New(&ab->abMem, genInfo->tframe * sizeof(Vector ***));
+   ab->occm--;
+
+   for (i = 1, t = 1; i <= genInfo->labseqlen; i++) {
+      for (j = 1; genInfo->sindex[i][j] != 0; j++) {
+         for (d = 1; d <= genInfo->durations[i][j]; d++, t++) {
+            /* set qLo & qHi */
+            p->qLo[t] = p->qHi[t] = i;
+
+            /* occupancy prob storage */
+            ab->occm[t] = (Vector ***) New(&ab->abMem, sizeof(Vector **));
+            ab->occm[t] -= i;
+
+            ab->occm[t][i] = (Vector **) New(&ab->abMem, genInfo->hmm[i]->numStates * sizeof(Vector *));
+            ab->occm[t][i]--;
+
+            for (k = 2; k < genInfo->hmm[i]->numStates; k++) {
+               ab->occm[t][i][k] = (Vector *) New(&ab->abMem, genInfo->hset->swidth[0] * sizeof(Vector));
+               ab->occm[t][i][k]--;
+
+               /* first compute output prob of each mix */
+               si = genInfo->hmm[i]->svec[k].info;
+               for (s = 1; s <= genInfo->hset->swidth[0]; s++) {
+                  ab->occm[t][i][k][s] = CreateVector(&ab->abMem, si->pdf[s].info->nMix);
+                  for (m = 1; m <= si->pdf[s].info->nMix; m++) {
+                     mp = si->pdf[s].info->spdf.cpdf[m].mpdf;
+                     if (k == genInfo->sindex[i][j])
+                        ab->occm[t][i][k][s][m] = MixLogWeight(genInfo->hset, si->pdf[s].info->spdf.cpdf[m].weight)
+                            + MOutP(utt->o[t].fv[s], mp);
+                     else
+                        ZeroVector(ab->occm[t][i][k][s]);
+                  }
+               }
+            }
+
+            /* then set mix-level posterior prob */
+            k = genInfo->sindex[i][j];
+            si = genInfo->hmm[i]->svec[k].info;
+            for (s = 1; s <= genInfo->hset->swidth[0]; s++) {
+               for (l = 1, ax = 0.0; l <= genInfo->hset->swidth[0]; l++) {
+                  if (l != s) {
+                     for (m = 1, bx = LZERO; m <= si->pdf[l].info->nMix; m++)
+                        bx = LAdd(bx, ab->occm[t][i][k][l][m]);
+                     ax += si->weights[l] * bx;
+                  }
+               }
+
+               for (m = 1, bx = LZERO; m <= si->pdf[s].info->nMix; m++)
+                  bx = LAdd(bx, ab->occm[t][i][k][s][m]);
+               bx += ax;
+
+               for (m = 1; m <= si->pdf[s].info->nMix; m++)
+                  ab->occm[t][i][k][s][m] = L2F(ab->occm[t][i][k][s][m] + ax - bx);
+            }
+         }
+      }
+   }
+
+   OutProb(genInfo, utt);
+
+   return ((utt->pr < LSMALL) ? FALSE : TRUE);
+}
+
+/* EXPORT->ParamGen: Generate parameter sequence */
+void ParamGen(GenInfo * genInfo, UttInfo * utt, FBInfo * fbInfo, const ParmGenType type)
+{
+   int iter;
+   Boolean success = TRUE, converged = FALSE;
+   LogFloat prev = LZERO, curr;
+
+   /* # of frames */
+   const int T = genInfo->tframe;
+
+   /* UttInfo settings */
+   utt->tgtSampRate = genInfo->frameRate;
+   utt->S = genInfo->hset->swidth[0];
+
+   /* First perform Cholesky-based parameter generation */
+   SetupPdfStreams(genInfo, -1, -1);
+   Cholesky_ParmGen(genInfo, (((type == CHOLESKY) && useGV) ? TRUE : FALSE));
+   UpdateUttObs(genInfo, utt);
+
+   /* Cholesky case */
+   if (type == CHOLESKY) {
+      OutProb(genInfo, utt);
+      if (trace & T_TOP)
+         printf("  Average LogP = %e\n", utt->pr / T);
+      return;
+   }
+
+   /* EM-based parameter generation */
+   if (trace & T_TOP) {
+      printf(" EM-based parameter generation ");
+      switch (type) {
+      case MIX:
+         printf("(Hidden: MIX, Given: STATE)\n");
+         break;
+      case FB:
+         printf("(Hidden: MIX, STATE)\n");
+      }
+      fflush(stdout);
+   }
+
+   /* Optimize pst->C using EM algorithm */
+   for (iter = 1; iter <= maxEMIter; iter++) {
+      switch (type) {
+      case MIX:
+         success = MixUtt(genInfo, fbInfo, utt);        /* compute mixture-level posterior */
+         break;
+      case FB:
+         success = FBUtt(fbInfo, utt);  /* perform forward-backward */
+         break;
+      default:
+         HError(9999, "ParamGen: not supported parameter generation type");
+      }
+      if (!success)
+         HError(-9999, "ParamGen: failed to compute output prob");
+
+      /* output prob */
+      curr = utt->pr;
+      if (trace & T_TOP) {
+         printf("  Iteration %d: Average LogP = %e", iter, curr / T);
+         if (iter > 1)
+            printf("  Change = %f", (curr - prev) / T);
+         printf("\n");
+         fflush(stdout);
+      }
+
+      /* convergence check */
+      if (iter > 1 && fabs(curr - prev) / T < EMepsilon) {
+         converged = TRUE;
+         if (trace & T_TOP) {
+            printf("  Converged (change=%e).\n", fabs(curr - prev) / T);
+            fflush(stdout);
+         }
+      }
+      if (iter == maxEMIter && trace & T_TOP) {
+         printf("  EM iteration stopped by reaching max # of iterations (%d).\n", maxEMIter);
+      }
+
+      /* generate parameters */
+      UpdatePdfStreams(genInfo, fbInfo, utt);   /* update PdfStreams */
+      Cholesky_ParmGen(genInfo, (((converged || iter == maxEMIter) && useGV) ? TRUE : FALSE));
+      UpdateUttObs(genInfo, utt);
+
+      /* reset heap */
+      ResetHeap(&fbInfo->ab->abMem);
+
+      if (converged)
+         break;
+
+      prev = curr;
+   }
+
+   return;
+}
+
+/* ------------------------ End of HGen.c -------------------------- */
diff -pbBEwurNa --ignore-matching-lines='.*vc_id.*' HTK-3.4.1/HTKLib/HGen.h HTS-2.2_for_HTK-3.4.1/HTKLib/HGen.h
--- HTK-3.4.1/HTKLib/HGen.h	1970-01-01 09:00:00.000000000 +0900
+++ HTS-2.2_for_HTK-3.4.1/HTKLib/HGen.h	2011-06-16 13:15:50.000000000 +0900
@@ -0,0 +1,199 @@
+/* ----------------------------------------------------------------- */
+/*           The HMM-Based Speech Synthesis System (HTS)             */
+/*           developed by HTS Working Group                          */
+/*           http://hts.sp.nitech.ac.jp/                             */
+/* ----------------------------------------------------------------- */
+/*                                                                   */
+/*  Copyright (c) 2001-2011  Nagoya Institute of Technology          */
+/*                           Department of Computer Science          */
+/*                                                                   */
+/*                2001-2008  Tokyo Institute of Technology           */
+/*                           Interdisciplinary Graduate School of    */
+/*                           Science and Engineering                 */
+/*                                                                   */
+/* All rights reserved.                                              */
+/*                                                                   */
+/* Redistribution and use in source and binary forms, with or        */
+/* without modification, are permitted provided that the following   */
+/* conditions are met:                                               */
+/*                                                                   */
+/* - Redistributions of source code must retain the above copyright  */
+/*   notice, this list of conditions and the following disclaimer.   */
+/* - Redistributions in binary form must reproduce the above         */
+/*   copyright notice, this list of conditions and the following     */
+/*   disclaimer in the documentation and/or other materials provided */
+/*   with the distribution.                                          */
+/* - Neither the name of the HTS working group nor the names of its  */
+/*   contributors may be used to endorse or promote products derived */
+/*   from this software without specific prior written permission.   */
+/*                                                                   */
+/* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND            */
+/* CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,       */
+/* INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF          */
+/* MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE          */
+/* DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS */
+/* BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,          */
+/* EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED   */
+/* TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,     */
+/* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON */
+/* ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,   */
+/* OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY    */
+/* OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE           */
+/* POSSIBILITY OF SUCH DAMAGE.                                       */
+/* ----------------------------------------------------------------- */
+/*         File: HGen.c: Generate parameter sequence from HMM        */
+/* ----------------------------------------------------------------- */
+
+#ifndef _HGEN_H_
+#define _HGEN_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define MAXWINNUM 30            /* maximum number of static + deltas */
+
+typedef enum { WLEFT = 0, WRIGHT = 1 } WINWIDTH;
+typedef enum { CHOLESKY = 0, MIX = 1, FB = 2 } ParmGenType;
+
+typedef struct {
+   char fn[MAXWINNUM][MAXFNAMELEN];     /* window coefficient file(s) */
+   int num;                     /* number of windows */
+   int maxw[2];                 /* max width [0(left) 1(right)] */
+   int **width;                 /* width [0..num-1][0(left) 1(right)] */
+   float **coef;                /* window coefficient [0..num][length[1]..length[2]] */
+   int max_L;
+} Window;
+
+typedef struct {
+   char ext[MAXSTRLEN];         /* filename extension for this PdfStream */
+   IntVec ContSpace;            /* space indexes */
+   Boolean fullCov;             /* full covariance flag */
+   int vSize;                   /* vector size of observation vector */
+   int order;                   /* vector size of static feature vector */
+   int t;                       /* time counter */
+   int origStart;               /* start pos of current segment in original utterance */
+   int T;                       /* number of frames */
+   int width;                   /* band width */
+   Window win;                  /* window coefficients */
+   Matrix mseq;                 /* sequence of mean vector */
+   Covariance *vseq;            /* sequence of covariance matrices */
+   Matrix C;                    /* generated parameter c */
+   DVector g;
+   DVector c;
+   DMatrix WUW;
+   DVector WUM;
+   Vector gvmean;
+   Covariance gvcov;
+   Boolean *gvFlag;
+   int gvT;
+} PdfStream;
+
+typedef struct {
+   MemHeap *genMem;             /* generation memory heap */
+
+   float speakRate;             /* speaking rate */
+   float MSDthresh;             /* MSD threshold */
+   Boolean modelAlign;          /* use model-level alignment from label */
+   Boolean stateAlign;          /* use state-level alignment from label */
+   HTime frameRate;             /* frame rate in 100ns */
+
+   HMMSet *hset;                /* set of HMMs */
+   HMMSet *dset;                /* set of duration models */
+   int maxStates;               /* max # of states in hset */
+   int maxMixes;                /* max # of mixes in hset */
+
+   PdfStream pst[SMAX];         /* PdfStream for generation */
+   int nPdfStream[SMAX];        /* # of PdfStreams and its size */
+
+   Transcription *labseq;       /* input label sequence */
+   int labseqlen;               /* # of labels */
+   Label **label;               /* labels sequence */
+
+   HLink *hmm;                  /* a sentence HMM for given label */
+   HLink *dm;                   /* a sentence duration models for given label */
+
+   IMatrix sindex;              /* state sequence indexes */
+   IMatrix durations;           /* state durations */
+   int tframe;                  /* total # of frames */
+} GenInfo;
+
+/* EXPORTED functions ------------------ */
+
+void SetrFlags(char *s);
+/* 
+   Set random generation flags 
+*/
+
+void PrintrFlags(void);
+/* 
+   Print random generation flags 
+*/
+
+void InitGen(void);
+/*
+   Initialise module
+*/
+
+void ResetGen(void);
+/*
+   Reset module
+*/
+
+void SetTraceGen(void);
+/* 
+   Set trace level 
+*/
+
+void InitialiseGenInfo(GenInfo *, Transcription *, Boolean);
+/*
+ * Initialise GenInfo 
+ */
+
+void ResetGenInfo(GenInfo *);
+/*
+ * Reset GenInfo 
+ */
+
+void JointProb(GenInfo * genInfo, UttInfo * utt);
+/* 
+   joint probability of given observations and state sequence
+*/
+
+void ParamGen(GenInfo *, UttInfo *, FBInfo *, ParmGenType);
+/*
+   Generate parameter sequence 
+ */
+
+void SetupPdfStreams(GenInfo * genInfo, int start, int end);
+/*
+  Setup PdfStreams for parameter generation
+*/
+
+void Calc_WUM_and_WUW(PdfStream * pst, const int bias);
+/*
+  Calcurate W'*U^{-1}*M and W'*U^{-1}*W
+*/
+
+void Cholesky_Factorization(PdfStream * pst);
+/*
+  Compute Cholesky factor of matrix W'*U^{-1}*W
+*/
+
+void Forward_Substitution(PdfStream * pst);
+/*
+  Forward substitution to solve set of linear equations
+*/
+
+void Backward_Substitution(PdfStream * pst, const int bias);
+/*
+  Backward substitution to solve set of linear equations
+*/
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif                          /* _HGEN_H_ */
+
+/* ------------------------ End of HGen.h -------------------------- */
diff -pbBEwurNa --ignore-matching-lines='.*vc_id.*' HTK-3.4.1/HTKLib/HGraf.c HTS-2.2_for_HTK-3.4.1/HTKLib/HGraf.c
--- HTK-3.4.1/HTKLib/HGraf.c	2009-03-13 03:43:47.000000000 +0900
+++ HTS-2.2_for_HTK-3.4.1/HTKLib/HGraf.c	2011-06-16 13:18:29.000000000 +0900
@@ -16,11 +16,56 @@
 /*    **     This banner notice must not be removed      **    */
 /*                                                             */
 /* ----------------------------------------------------------- */
-/*         File: HGraf.X.c:  HGraf for X-Windows               */
+/*         File: HGraf.c:  HGraf for X-Windows                 */
 /* ----------------------------------------------------------- */
 
+/*  *** THIS IS A MODIFIED VERSION OF HTK ***                        */
+/* ----------------------------------------------------------------- */
+/*           The HMM-Based Speech Synthesis System (HTS)             */
+/*           developed by HTS Working Group                          */
+/*           http://hts.sp.nitech.ac.jp/                             */
+/* ----------------------------------------------------------------- */
+/*                                                                   */
+/*  Copyright (c) 2001-2011  Nagoya Institute of Technology          */
+/*                           Department of Computer Science          */
+/*                                                                   */
+/*                2001-2008  Tokyo Institute of Technology           */
+/*                           Interdisciplinary Graduate School of    */
+/*                           Science and Engineering                 */
+/*                                                                   */
+/* All rights reserved.                                              */
+/*                                                                   */
+/* Redistribution and use in source and binary forms, with or        */
+/* without modification, are permitted provided that the following   */
+/* conditions are met:                                               */
+/*                                                                   */
+/* - Redistributions of source code must retain the above copyright  */
+/*   notice, this list of conditions and the following disclaimer.   */
+/* - Redistributions in binary form must reproduce the above         */
+/*   copyright notice, this list of conditions and the following     */
+/*   disclaimer in the documentation and/or other materials provided */
+/*   with the distribution.                                          */
+/* - Neither the name of the HTS working group nor the names of its  */
+/*   contributors may be used to endorse or promote products derived */
+/*   from this software without specific prior written permission.   */
+/*                                                                   */
+/* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND            */
+/* CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,       */
+/* INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF          */
+/* MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE          */
+/* DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS */
+/* BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,          */
+/* EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED   */
+/* TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,     */
+/* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON */
+/* ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,   */
+/* OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY    */
+/* OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE           */
+/* POSSIBILITY OF SUCH DAMAGE.                                       */
+/* ----------------------------------------------------------------- */
+
 char *hgraf_version = "!HVER!HGraf(X):   3.4.1 [CUED 12/03/09]";
-char *hgraf_vc_id = "$Id: HGraf.c,v 1.1.1.1 2006/10/11 09:54:57 jal58 Exp $";
+char *hgraf_vc_id = "$Id: HGraf.c,v 1.10 2011/06/16 04:18:29 uratec Exp $";
 
 /*
    This is the X Windows implementation of HGraf.  It is server
@@ -129,6 +174,12 @@ void InitGraf(void)
    }
 }
 
+/* EXPORT->ResetGraf: reset module */
+void ResetGraf(void)
+{
+   return;  /* do nothing */
+}
+
 /*------------------- Font Handling Routines -----------------------*/
 
 #define NO_OF_FONTS 10
@@ -296,7 +347,10 @@ Boolean HMousePos(int *x, int *y)
 /* EXPORT: IsInRect: return TRUE iff (x,y) is in the rectangle (x0,y0,x1,y1) */ 
 Boolean IsInRect(int x, int y, int x0, int y0, int x1, int y1)
 {
-   return (x >= x0 && x<=x1 && y >= y0 && y <= y1);
+   if (x >= x0 && x<=x1 && y >= y0 && y <= y1)
+      return TRUE;
+   else
+      return FALSE;
 }
 
 
@@ -444,7 +498,7 @@ void HFillArc(int x0,int y0,int x1,int y
 void HPrintf(int x, int y, char *format, ...)
 {
    va_list arg;
-   char s[256];
+   char s[MAXSTRLEN];
    
    va_start(arg, format);
    vsprintf(s, format, arg);
@@ -652,7 +706,7 @@ void RedrawHButton(HButton *btn)
    int pad = 2;
    int x, y, w, h, r, s, pos;
    HPoint poly[9], shad[4];
-   char sbuf[256], nullchar = '\0';
+   char sbuf[MAXSTRLEN], nullchar = '\0';
    
    x = btn->x;   y=btn->y;   w=btn->w;   h=btn->h;   r=3; s=1;
 
@@ -760,7 +814,7 @@ ButtonId TrackButtons(HButton *btnlist, 
 #endif
       do {
          hev = HGetEvent(TRUE, pressed->action);
-         done = (hev.event==HMOUSEUP);
+         done = (hev.event==HMOUSEUP) ? TRUE : FALSE;
       } while (!done);
       released = CheckButtonList(btnlist, hev.x, hev.y);
       SetButtonLit(pressed, FALSE);
@@ -813,7 +867,7 @@ static void InitGlobals(void)
 /* EXPORT-> MakeXGraf: Connect to the X-server and init globals */
 void MakeXGraf(char *wname, int x, int y, int w, int h, int bw)
 {
-   char sbuf[256], *hgraf = "HGraf";
+   char sbuf[MAXSTRLEN], *hgraf = "HGraf";
    Window window, parent;
    XSetWindowAttributes setwinattr;
    unsigned long vmask;
@@ -863,6 +917,4 @@ void TermHGraf()
    DeleteHeap(&btnHeap);
 }
 
-
-/* ------------------------ End of HGraf.X.c ------------------------- */
-
+/* ------------------------ End of HGraf.c ------------------------- */
diff -pbBEwurNa --ignore-matching-lines='.*vc_id.*' HTK-3.4.1/HTKLib/HGraf.h HTS-2.2_for_HTK-3.4.1/HTKLib/HGraf.h
--- HTK-3.4.1/HTKLib/HGraf.h	2009-03-13 03:43:57.000000000 +0900
+++ HTS-2.2_for_HTK-3.4.1/HTKLib/HGraf.h	2011-06-16 13:18:29.000000000 +0900
@@ -20,6 +20,51 @@
 /* ----------------------------------------------------------- */
 /* Win32 port: Peter Silsbee                                   */
 
+/*  *** THIS IS A MODIFIED VERSION OF HTK ***                        */
+/* ----------------------------------------------------------------- */
+/*           The HMM-Based Speech Synthesis System (HTS)             */
+/*           developed by HTS Working Group                          */
+/*           http://hts.sp.nitech.ac.jp/                             */
+/* ----------------------------------------------------------------- */
+/*                                                                   */
+/*  Copyright (c) 2001-2011  Nagoya Institute of Technology          */
+/*                           Department of Computer Science          */
+/*                                                                   */
+/*                2001-2008  Tokyo Institute of Technology           */
+/*                           Interdisciplinary Graduate School of    */
+/*                           Science and Engineering                 */
+/*                                                                   */
+/* All rights reserved.                                              */
+/*                                                                   */
+/* Redistribution and use in source and binary forms, with or        */
+/* without modification, are permitted provided that the following   */
+/* conditions are met:                                               */
+/*                                                                   */
+/* - Redistributions of source code must retain the above copyright  */
+/*   notice, this list of conditions and the following disclaimer.   */
+/* - Redistributions in binary form must reproduce the above         */
+/*   copyright notice, this list of conditions and the following     */
+/*   disclaimer in the documentation and/or other materials provided */
+/*   with the distribution.                                          */
+/* - Neither the name of the HTS working group nor the names of its  */
+/*   contributors may be used to endorse or promote products derived */
+/*   from this software without specific prior written permission.   */
+/*                                                                   */
+/* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND            */
+/* CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,       */
+/* INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF          */
+/* MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE          */
+/* DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS */
+/* BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,          */
+/* EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED   */
+/* TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,     */
+/* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON */
+/* ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,   */
+/* OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY    */
+/* OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE           */
+/* POSSIBILITY OF SUCH DAMAGE.                                       */
+/* ----------------------------------------------------------------- */
+
 /* !HVER!HGraf:   3.4.1 [CUED 12/03/09] */
 
 /*
@@ -101,6 +146,11 @@ void InitGraf(void);
    Initialise the module
 */
 
+void ResetGraf(void);
+/*
+   Reset the module
+*/
+
 void MakeXGraf(char *wname, int x, int y, int w, int h, int bw);
 /* 
    Create a window of width w and height h, with top left corner at
@@ -378,4 +428,4 @@ ButtonId TrackButtons(HButton *btnlist, 
 
 #endif  /* _HGRAF_H_ */
 
-/* --------------------------- End of HGraf.h ---------------------------- */
+/* ------------------------ End of HGraf.h ------------------------- */
diff -pbBEwurNa --ignore-matching-lines='.*vc_id.*' HTK-3.4.1/HTKLib/HGraf.null.c HTS-2.2_for_HTK-3.4.1/HTKLib/HGraf.null.c
--- HTK-3.4.1/HTKLib/HGraf.null.c	2009-03-13 03:44:05.000000000 +0900
+++ HTS-2.2_for_HTK-3.4.1/HTKLib/HGraf.null.c	2011-06-16 13:18:29.000000000 +0900
@@ -19,8 +19,53 @@
 /*         File: HGraf.null.c:  HGraf (null implementation)    */
 /* ----------------------------------------------------------- */
 
+/*  *** THIS IS A MODIFIED VERSION OF HTK ***                        */
+/* ----------------------------------------------------------------- */
+/*           The HMM-Based Speech Synthesis System (HTS)             */
+/*           developed by HTS Working Group                          */
+/*           http://hts.sp.nitech.ac.jp/                             */
+/* ----------------------------------------------------------------- */
+/*                                                                   */
+/*  Copyright (c) 2001-2011  Nagoya Institute of Technology          */
+/*                           Department of Computer Science          */
+/*                                                                   */
+/*                2001-2008  Tokyo Institute of Technology           */
+/*                           Interdisciplinary Graduate School of    */
+/*                           Science and Engineering                 */
+/*                                                                   */
+/* All rights reserved.                                              */
+/*                                                                   */
+/* Redistribution and use in source and binary forms, with or        */
+/* without modification, are permitted provided that the following   */
+/* conditions are met:                                               */
+/*                                                                   */
+/* - Redistributions of source code must retain the above copyright  */
+/*   notice, this list of conditions and the following disclaimer.   */
+/* - Redistributions in binary form must reproduce the above         */
+/*   copyright notice, this list of conditions and the following     */
+/*   disclaimer in the documentation and/or other materials provided */
+/*   with the distribution.                                          */
+/* - Neither the name of the HTS working group nor the names of its  */
+/*   contributors may be used to endorse or promote products derived */
+/*   from this software without specific prior written permission.   */
+/*                                                                   */
+/* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND            */
+/* CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,       */
+/* INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF          */
+/* MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE          */
+/* DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS */
+/* BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,          */
+/* EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED   */
+/* TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,     */
+/* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON */
+/* ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,   */
+/* OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY    */
+/* OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE           */
+/* POSSIBILITY OF SUCH DAMAGE.                                       */
+/* ----------------------------------------------------------------- */
+
 char *hgraf_version = "!HVER!HGraf(null):   3.4.1 [CUED 12/03/09]";
-char *hgraf_vc_id = "$Id: HGraf.null.c,v 1.1.1.1 2006/10/11 09:54:57 jal58 Exp $";
+char *hgraf_vc_id = "$Id: HGraf.null.c,v 1.10 2011/06/16 04:18:29 uratec Exp $";
 
 #include "HShell.h"
 #include "HMem.h"
@@ -45,6 +90,12 @@ void InitGraf(void)
    }
 }
 
+/* EXPORT->ResetGraf: reset the module */
+void ResetGraf(void)
+{
+   return;  /* do nothing */
+}
+
 /*
    This is the null implementation of HGraf.
 */
@@ -253,4 +304,4 @@ int HTextHeight(char *str)
    return 0;
 }
 
-/* ------------------------ End of HGraf.null.c ------------------------- */
+/* ------------------------ End of HGraf.null.c -------------------- */
diff -pbBEwurNa --ignore-matching-lines='.*vc_id.*' HTK-3.4.1/HTKLib/HGraf_WIN32.c HTS-2.2_for_HTK-3.4.1/HTKLib/HGraf_WIN32.c
--- HTK-3.4.1/HTKLib/HGraf_WIN32.c	2009-03-13 03:44:14.000000000 +0900
+++ HTS-2.2_for_HTK-3.4.1/HTKLib/HGraf_WIN32.c	2011-06-16 13:18:29.000000000 +0900
@@ -16,8 +16,54 @@
 /*    **     This banner notice must not be removed      **    */
 /*                                                             */
 /* ----------------------------------------------------------- */
-/*         File: HGraf.win32.c:  HGraf for Windows NT          */
+/*         File: HGraf_WIN32.c:  HGraf for Windows NT          */
 /* ----------------------------------------------------------- */
+
+/*  *** THIS IS A MODIFIED VERSION OF HTK ***                        */
+/* ----------------------------------------------------------------- */
+/*           The HMM-Based Speech Synthesis System (HTS)             */
+/*           developed by HTS Working Group                          */
+/*           http://hts.sp.nitech.ac.jp/                             */
+/* ----------------------------------------------------------------- */
+/*                                                                   */
+/*  Copyright (c) 2001-2011  Nagoya Institute of Technology          */
+/*                           Department of Computer Science          */
+/*                                                                   */
+/*                2001-2008  Tokyo Institute of Technology           */
+/*                           Interdisciplinary Graduate School of    */
+/*                           Science and Engineering                 */
+/*                                                                   */
+/* All rights reserved.                                              */
+/*                                                                   */
+/* Redistribution and use in source and binary forms, with or        */
+/* without modification, are permitted provided that the following   */
+/* conditions are met:                                               */
+/*                                                                   */
+/* - Redistributions of source code must retain the above copyright  */
+/*   notice, this list of conditions and the following disclaimer.   */
+/* - Redistributions in binary form must reproduce the above         */
+/*   copyright notice, this list of conditions and the following     */
+/*   disclaimer in the documentation and/or other materials provided */
+/*   with the distribution.                                          */
+/* - Neither the name of the HTS working group nor the names of its  */
+/*   contributors may be used to endorse or promote products derived */
+/*   from this software without specific prior written permission.   */
+/*                                                                   */
+/* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND            */
+/* CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,       */
+/* INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF          */
+/* MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE          */
+/* DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS */
+/* BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,          */
+/* EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED   */
+/* TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,     */
+/* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON */
+/* ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,   */
+/* OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY    */
+/* OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE           */
+/* POSSIBILITY OF SUCH DAMAGE.                                       */
+/* ----------------------------------------------------------------- */
+
 /* Win32 port Peter Silsbee                                    */
 
 char *hgraf_version = "!HVER!HGraf(NT):   3.4.1 [CUED 12/03/09]";
@@ -107,6 +153,12 @@ void InitGraf(void)
    }
 }
 
+/* EXPORT->ResetGraf: reset module */
+void ResetGraf (void)
+{
+   return;  /* do nothing */
+}
+
 /* EXPORT->HGetEvent: return next relevant event in event queue */
 HEventRec HGetEvent(Boolean anyEvent, void (*action)(void))
 {
@@ -589,7 +641,7 @@ void HFillArc(int x0,int y0,int x1,int y
 void HPrintf(int x, int y, char *format, ...)
 { 
    va_list arg;
-   char s[256];
+   char s[MAXSTRLEN];
    HGDIOBJ oldObject = SelectObject(memDC,theFont);
    HDC dc = GetDC(theWindow);
      
@@ -946,7 +998,7 @@ void RedrawHButton(HButton *btn)
    int pad = 2;
    int x, y, w, h, r, s, pos;
    HPoint poly[9], shad[4];
-   char sbuf[256], nullchar = '\0';
+   char sbuf[MAXSTRLEN], nullchar = '\0';
      
    x = btn->x;   y=btn->y;   w=btn->w;   h=btn->h;   r=3; s=1;
      
@@ -1078,7 +1130,7 @@ void MakeXGraf(char *wname, int x, int y
      /* WIN32: bw is ignored. */
 {
    WNDCLASS WindowClass;
-   char sbuf[256], *hgraf = "HGraf";
+   char sbuf[MAXSTRLEN], *hgraf = "HGraf";
    HDC dc;
      
    if (winCreated)
@@ -1195,5 +1247,4 @@ KeyType HGetKeyType(char c)
    }
 }
 
-
-/* ------------------------ End of HGraf.win32.c ------------------------- */
+/* ------------------------ End of HGraf_WIN32.c ------------------- */
diff -pbBEwurNa --ignore-matching-lines='.*vc_id.*' HTK-3.4.1/HTKLib/HLM.c HTS-2.2_for_HTK-3.4.1/HTKLib/HLM.c
--- HTK-3.4.1/HTKLib/HLM.c	2009-03-13 03:45:05.000000000 +0900
+++ HTS-2.2_for_HTK-3.4.1/HTKLib/HLM.c	2011-06-16 13:18:29.000000000 +0900
@@ -32,8 +32,53 @@
 /*         File: HLM.c  language model handling                */
 /* ----------------------------------------------------------- */
 
+/*  *** THIS IS A MODIFIED VERSION OF HTK ***                        */
+/* ----------------------------------------------------------------- */
+/*           The HMM-Based Speech Synthesis System (HTS)             */
+/*           developed by HTS Working Group                          */
+/*           http://hts.sp.nitech.ac.jp/                             */
+/* ----------------------------------------------------------------- */
+/*                                                                   */
+/*  Copyright (c) 2001-2011  Nagoya Institute of Technology          */
+/*                           Department of Computer Science          */
+/*                                                                   */
+/*                2001-2008  Tokyo Institute of Technology           */
+/*                           Interdisciplinary Graduate School of    */
+/*                           Science and Engineering                 */
+/*                                                                   */
+/* All rights reserved.                                              */
+/*                                                                   */
+/* Redistribution and use in source and binary forms, with or        */
+/* without modification, are permitted provided that the following   */
+/* conditions are met:                                               */
+/*                                                                   */
+/* - Redistributions of source code must retain the above copyright  */
+/*   notice, this list of conditions and the following disclaimer.   */
+/* - Redistributions in binary form must reproduce the above         */
+/*   copyright notice, this list of conditions and the following     */
+/*   disclaimer in the documentation and/or other materials provided */
+/*   with the distribution.                                          */
+/* - Neither the name of the HTS working group nor the names of its  */
+/*   contributors may be used to endorse or promote products derived */
+/*   from this software without specific prior written permission.   */
+/*                                                                   */
+/* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND            */
+/* CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,       */
+/* INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF          */
+/* MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE          */
+/* DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS */
+/* BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,          */
+/* EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED   */
+/* TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,     */
+/* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON */
+/* ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,   */
+/* OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY    */
+/* OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE           */
+/* POSSIBILITY OF SUCH DAMAGE.                                       */
+/* ----------------------------------------------------------------- */
+
 char *hlm_version = "!HVER!HLM:   3.4.1 [CUED 12/03/09]";
-char *hlm_vc_id = "$Id: HLM.c,v 1.1.1.1 2006/10/11 09:54:57 jal58 Exp $";
+char *hlm_vc_id = "$Id: HLM.c,v 1.11 2011/06/16 04:18:29 uratec Exp $";
 
 #include "HShell.h"
 #include "HMem.h"
@@ -72,6 +117,12 @@ void InitLM(void)
    }
 }
 
+/* EXPORT->ResetLM: reset the module */
+void ResetLM(void)
+{
+   return;  /* do nothing */
+}
+
 /*------------------------- Input Scanner ---------------------------*/
 
 static Source source;           /* input file */
@@ -106,7 +157,7 @@ static void SyncStr(char *buf,char *str)
 static int GetInt(void)
 {
    int x;
-   char buf[100];
+   char buf[MAXSTRLEN];
    
    if (!ReadInt(&source,&x,1,FALSE))
       HError(8150,"GetInt: Int Expected at %s",SrcPosition(source,buf));
@@ -117,7 +168,7 @@ static int GetInt(void)
 static float GetFloat(Boolean bin)
 {
    float x;
-   char buf[100];
+   char buf[MAXSTRLEN];
 
    if (!ReadFloat(&source,&x,1,bin))
       HError(8150,"GetFloat: Float Expected at %s",SrcPosition(source,buf));
@@ -372,10 +423,11 @@ static int ReadNGrams(NGramLM *nglm,int 
    float prob;
    LabId wdid;
    SEntry *cse;
-   char wd[255];
+   char wd[MAXSTRLEN];
    lmId ndx[NSIZE+1];
    NEntry *ne,*le=NULL;
-   int i, g, idx, total;
+   int i, idx, total;
+   long g;
    unsigned char size, flags=0;
 
    cse = (SEntry *) New(nglm->heap,count*sizeof(SEntry));
@@ -424,7 +476,7 @@ static int ReadNGrams(NGramLM *nglm,int 
             else {
                ReadLMWord(wd);
                wdid = GetLabId(wd, FALSE);
-               idx = (wdid==NULL?0:(int)wdid->aux);
+               idx = (wdid==NULL?0:(int)((long)wdid->aux));
             }
             if (idx<1 || idx>nglm->vocSize)
                HError(8150,"ReadNGrams: Unseen word (%s) in %dGram",wd,n);
@@ -624,7 +676,8 @@ static void ReadMatBigram(LModel *lm,cha
 {
    Vector vec;
    char buf[132];
-   int P,p,j;
+   int P,j;
+   long p;
    float sum,x;
    LabId id;
    MatBiLM *matbi;
@@ -670,7 +723,7 @@ static void ReadMatBigram(LModel *lm,cha
       if (p>P)
          HError(8150,"ReadMatBigram: More rows than columns in bigram %s",fn);
       id=GetLabId(buf,TRUE);
-      if ((int)id->aux != 0) 
+      if ((long)id->aux != 0) 
          HError(8150,"ReadMatBigram: Duplicated name %s in bigram %s",buf,fn);
       id->aux = (Ptr) p;
       matbi->wdlist[p] = id;
@@ -764,12 +817,12 @@ float GetLMProb(LModel *lm, LabId prid[N
   
    switch (lm->type) {
    case boNGram:
-      word = (int)wdid->aux;
+      word = (long)wdid->aux;
       if (word==0 || word>lm->data.ngram->vocSize)
          return(LZERO);
       for (s=-1,i=0;i<NSIZE;i++)
          if (prid[i]!=NULL) 
-            ndx[i]=(int)prid[i]->aux, cpid[i]=prid[i], s=i;
+            ndx[i]=(long)prid[i]->aux, cpid[i]=prid[i], s=i;
          else
             ndx[i]=0, cpid[i]=NULL;
 
@@ -800,8 +853,8 @@ float GetLMProb(LModel *lm, LabId prid[N
          return(bowt+GetLMProb(lm,cpid,wdid)); /* else recurse */
       break;
    case matBigram:
-      p=(int) prid[0]->aux;
-      q=(int) wdid->aux;
+      p=(long) prid[0]->aux;
+      q=(long) wdid->aux;
       return(lm->data.matbi->bigMat[p][q]);
    default:
       prob=LZERO;
@@ -914,7 +967,7 @@ LogFloat LMTrans (LModel *lm, LMState sr
    assert (lm->type == boNGram);
    nglm = lm->data.ngram;
 
-   word = (int) wdid->aux;
+   word = (long) wdid->aux;
 
    if (word==0 || word>lm->data.ngram->vocSize) {
       HError (-9999, "word %d not in LM wordlist", word);
@@ -1008,5 +1061,4 @@ LogFloat LMTrans (LModel *lm, LMState sr
 }
 #endif
 
-
-/* ------------------------- End of HLM.c ------------------------- */
+/* ------------------------ End of HLM.c --------------------------- */
diff -pbBEwurNa --ignore-matching-lines='.*vc_id.*' HTK-3.4.1/HTKLib/HLM.h HTS-2.2_for_HTK-3.4.1/HTKLib/HLM.h
--- HTK-3.4.1/HTKLib/HLM.h	2009-03-13 03:45:21.000000000 +0900
+++ HTS-2.2_for_HTK-3.4.1/HTKLib/HLM.h	2011-06-16 13:18:29.000000000 +0900
@@ -32,6 +32,51 @@
 /*         File: HLM.h language model handling                 */
 /* ----------------------------------------------------------- */
 
+/*  *** THIS IS A MODIFIED VERSION OF HTK ***                        */
+/* ----------------------------------------------------------------- */
+/*           The HMM-Based Speech Synthesis System (HTS)             */
+/*           developed by HTS Working Group                          */
+/*           http://hts.sp.nitech.ac.jp/                             */
+/* ----------------------------------------------------------------- */
+/*                                                                   */
+/*  Copyright (c) 2001-2011  Nagoya Institute of Technology          */
+/*                           Department of Computer Science          */
+/*                                                                   */
+/*                2001-2008  Tokyo Institute of Technology           */
+/*                           Interdisciplinary Graduate School of    */
+/*                           Science and Engineering                 */
+/*                                                                   */
+/* All rights reserved.                                              */
+/*                                                                   */
+/* Redistribution and use in source and binary forms, with or        */
+/* without modification, are permitted provided that the following   */
+/* conditions are met:                                               */
+/*                                                                   */
+/* - Redistributions of source code must retain the above copyright  */
+/*   notice, this list of conditions and the following disclaimer.   */
+/* - Redistributions in binary form must reproduce the above         */
+/*   copyright notice, this list of conditions and the following     */
+/*   disclaimer in the documentation and/or other materials provided */
+/*   with the distribution.                                          */
+/* - Neither the name of the HTS working group nor the names of its  */
+/*   contributors may be used to endorse or promote products derived */
+/*   from this software without specific prior written permission.   */
+/*                                                                   */
+/* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND            */
+/* CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,       */
+/* INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF          */
+/* MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE          */
+/* DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS */
+/* BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,          */
+/* EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED   */
+/* TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,     */
+/* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON */
+/* ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,   */
+/* OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY    */
+/* OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE           */
+/* POSSIBILITY OF SUCH DAMAGE.                                       */
+/* ----------------------------------------------------------------- */
+
 /* !HVER!HLM:   3.4.1 [CUED 12/03/09] */
 
 #ifndef _HLM_H_
@@ -103,6 +148,11 @@ void InitLM(void);
    Initialise the module
 */
 
+void ResetLM(void);
+/*
+   Reset the module
+*/
+
 /* ---------------- Lower Level Routines ----------------- */
 
 NGramLM *CreateBoNGram(LModel *lm,int vocSize,int counts[NSIZE+1]);
@@ -155,4 +205,4 @@ LogFloat LMTrans (LModel *lm, LMState sr
 
 #endif  /* _HLM_H_ */
 
-/* ---------------------- End of HLM.h ----------------------- */
+/* ------------------------ End of HLM.h --------------------------- */
diff -pbBEwurNa --ignore-matching-lines='.*vc_id.*' HTK-3.4.1/HTKLib/HLabel.c HTS-2.2_for_HTK-3.4.1/HTKLib/HLabel.c
--- HTK-3.4.1/HTKLib/HLabel.c	2009-03-13 03:44:22.000000000 +0900
+++ HTS-2.2_for_HTK-3.4.1/HTKLib/HLabel.c	2011-06-16 13:18:29.000000000 +0900
@@ -19,8 +19,53 @@
 /*         File: HLabel.c:   Speech Label File Input           */
 /* ----------------------------------------------------------- */
 
+/*  *** THIS IS A MODIFIED VERSION OF HTK ***                        */
+/* ----------------------------------------------------------------- */
+/*           The HMM-Based Speech Synthesis System (HTS)             */
+/*           developed by HTS Working Group                          */
+/*           http://hts.sp.nitech.ac.jp/                             */
+/* ----------------------------------------------------------------- */
+/*                                                                   */
+/*  Copyright (c) 2001-2011  Nagoya Institute of Technology          */
+/*                           Department of Computer Science          */
+/*                                                                   */
+/*                2001-2008  Tokyo Institute of Technology           */
+/*                           Interdisciplinary Graduate School of    */
+/*                           Science and Engineering                 */
+/*                                                                   */
+/* All rights reserved.                                              */
+/*                                                                   */
+/* Redistribution and use in source and binary forms, with or        */
+/* without modification, are permitted provided that the following   */
+/* conditions are met:                                               */
+/*                                                                   */
+/* - Redistributions of source code must retain the above copyright  */
+/*   notice, this list of conditions and the following disclaimer.   */
+/* - Redistributions in binary form must reproduce the above         */
+/*   copyright notice, this list of conditions and the following     */
+/*   disclaimer in the documentation and/or other materials provided */
+/*   with the distribution.                                          */
+/* - Neither the name of the HTS working group nor the names of its  */
+/*   contributors may be used to endorse or promote products derived */
+/*   from this software without specific prior written permission.   */
+/*                                                                   */
+/* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND            */
+/* CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,       */
+/* INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF          */
+/* MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE          */
+/* DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS */
+/* BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,          */
+/* EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED   */
+/* TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,     */
+/* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON */
+/* ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,   */
+/* OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY    */
+/* OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE           */
+/* POSSIBILITY OF SUCH DAMAGE.                                       */
+/* ----------------------------------------------------------------- */
+
 char *hlabel_version = "!HVER!HLabel:   3.4.1 [CUED 12/03/09]";
-char *hlabel_vc_id = "$Id: HLabel.c,v 1.1.1.1 2006/10/11 09:54:57 jal58 Exp $";
+char *hlabel_vc_id = "$Id: HLabel.c,v 1.12 2011/06/16 04:18:29 uratec Exp $";
 
 #include "HShell.h"
 #include "HMem.h"
@@ -112,7 +157,7 @@ static double htkLabelTimeScale = 1; /* 
 /* --------------- Global MLF Data Structures  --------- */
 
 #define MLFCHUNKSIZE 500
-#define MAXMLFS 200
+#define MAXMLFS 1000
 
 static int      numMLFs = 0;     /* number of MLF files opened */
 static FILE   * mlfile[MAXMLFS]; /* array [0..numMLFs-1] of MLF file */
@@ -190,6 +235,14 @@ void InitLabel(void)
    }
 }
 
+/* EXPORT->ResetLbel: reset module */
+void ResetLabel(void)
+{
+   ResetHeap(&mlfHeap);
+   ResetHeap(&namecellHeap);
+   
+   return;
+}
 
 /* EXPORT->GetLabId: return id of given name */
 LabId GetLabId(char *name, Boolean insert)
@@ -589,7 +642,7 @@ typedef enum _TrSymbol TrSymbol;
 static int curch = ' ';
 static TrSymbol trSym = TRNULL;
 static double trNum;
-static char trStr[256];
+static char trStr[MAXSTRLEN];
 
 /* IsNumeric: returns true if given string is a number */
 Boolean IsNumeric(char *s)
@@ -720,7 +773,7 @@ static void ExtendAux(MemHeap *x, LabLis
    int i,oldn;
    LabId *id;
    float *s;
-   LLink p;
+   LLink p = NULL;
 
    if (n>=99)
       HError(6570, "ExtendAux: Too many auxiliary fields in label file");
@@ -755,7 +808,7 @@ static LabList * LoadHTKList(MemHeap *x,
    int n,maxAux = 0;
    Boolean ok;
    
-   ok = (transAlt==0) || (transAlt == alt);
+   ok = ((transAlt==0) || (transAlt == alt)) ? TRUE : FALSE;
    if (ok) ll = CreateLabelList(x,maxAux);  /* assume no aux labels */
    if (trace&T_HTKL)
       printf("HLabel: looking for lab list\n");
@@ -966,7 +1019,7 @@ static void LoadSCRIBELabels(MemHeap *x,
    float score;
    ScribeLab ltype, lx;
    double sp;
-   char buf[256];
+   char buf[MAXSTRLEN];
    
    if (!GetConfFlt(cParm,numParm,"SOURCERATE",&sp))  
       sp = 500.0;   /* actual SCRIBE rate */
@@ -1020,11 +1073,11 @@ static void LoadSCRIBELabels(MemHeap *x,
 /* EXPORT->TriStrip: Remove contexts of form A- and +B from s */
 void TriStrip(char *s)
 {
-   char buf[100],*p;
+   char buf[MAXSTRLEN],*p;
    
    if ((p = strchr(s,'-')) == NULL) p = s; else ++p;
    strcpy(buf,p);
-   if ((p = strrchr(buf,'+')) != NULL) 
+   if ((p = strchr(buf,'+')) != NULL) 
       *p = '\0';
    strcpy(s,buf);
 }
@@ -1093,7 +1146,8 @@ static Boolean NoMLFHeader(char *s)
    }
    if (len != 7) return TRUE;
    *(e+1) = '\0';
-   return (strcmp(s,"#!MLF!#") != 0);
+   if (strcmp(s,"#!MLF!#") != 0) return TRUE;
+   else return FALSE;
 }
 
 static Boolean incSpaces;
@@ -1162,10 +1216,10 @@ static unsigned MLFHash(char *s)
                            and append the entries to the MLF table */
 void LoadMasterFile(char *fname)
 {
-   char buf[1024];
+   char buf[MAXFNAMELEN];
    char *men;        /* end of mode indicator */
    char *pst,*pen;   /* start/end of pattern (inc quotes) */
-   char *dst,*den;   /* start/end of subdirectory (inc quotes) */
+   char *dst=NULL,*den=NULL;   /* start/end of subdirectory (inc quotes) */
    Boolean inEntry = FALSE;   /* ignore ".." within an entry */
    MLFEntry *e;
    FILE *f;
@@ -1174,12 +1228,12 @@ void LoadMasterFile(char *fname)
       HError(6520,"LoadMasterFile: MLF file limit reached [%d]",MAXMLFS);
    if ((f = fopen(fname,"rb")) == NULL)
       HError(6510,"LoadMasterFile: cannot open MLF %s",fname);
-   if (fgets(buf,1024,f) == NULL)
+   if (fgets(buf,MAXFNAMELEN,f) == NULL)
       HError(6513,"LoadMasterFile: MLF file is empty");
    if (NoMLFHeader(buf))
       HError(6551,"LoadMasterFile: MLF file header is missing"); 
    incSpaces=FALSE;
-   while (fgets(buf,1024,f) != NULL){
+   while (fgets(buf,MAXFNAMELEN,f) != NULL){
       if (!inEntry && FindMLFStr(buf,&pst,&pen)) {
          e = (MLFEntry *)New(&mlfHeap,sizeof(MLFEntry));
          e->type = FindMLFType(pen+1,&men);
@@ -1238,10 +1292,10 @@ FILE *GetMLFFile(int fidx)
 Boolean IsMLFFile(char *fn)
 {
    FILE *f;
-   char buf[1024];
+   char buf[MAXFNAMELEN];
    
    if ((f = fopen(fn,"rb")) == NULL) return FALSE;
-   if (fgets(buf,1024,f) == NULL) {
+   if (fgets(buf,MAXFNAMELEN,f) == NULL) {
       fclose(f); return FALSE;
    }
    if (NoMLFHeader(buf)) {
@@ -1260,7 +1314,7 @@ MLFEntry *GetMLFTable(void)
               this new name is suffixed to subdir and stored in tryspec */            
 static void SplitPath(char *path, char *name, char *subdir, char *tryspec)
 {
-   char buf1[1024],buf2[1024],*p;
+   char buf1[MAXFNAMELEN],buf2[MAXFNAMELEN],*p;
    char pch[2] = " ";
    
    pch[0] = PATHCHAR;
@@ -1285,7 +1339,7 @@ static FILE * OpenLabFile(char *fname, B
 {
    FILE *f;
    MLFEntry *e;
-   char path[1024],name[256],tryspec[1024];
+   char path[MAXFNAMELEN],name[MAXSTRLEN],tryspec[MAXFNAMELEN];
    Boolean isMatch = FALSE;
    unsigned fixedHash;     /* hash value for PAT_FIXED */
    unsigned anypathHash;   /* hash value for PAT_ANYPATH */ 
@@ -1315,7 +1369,7 @@ static FILE * OpenLabFile(char *fname, B
          if (trace&T_MAT) 
             printf("HLabel:  anypath match against %s[%d]\n",e->pattern,e->patHash);
          if (e->patHash == anypathHash)
-            isMatch = strcmp(e->pattern,fnStart) == 0;
+            isMatch = (strcmp(e->pattern,fnStart) == 0) ? TRUE : FALSE;
          else
             isMatch = FALSE;
          break;
@@ -1323,7 +1377,7 @@ static FILE * OpenLabFile(char *fname, B
          if (trace&T_MAT) 
             printf("HLabel:  fixed match against %s[%d]\n",e->pattern,e->patHash);
          if (e->patHash == fixedHash)
-            isMatch = strcmp(e->pattern,fname) == 0;
+            isMatch = (strcmp(e->pattern,fname) == 0) ? TRUE : FALSE;
          else
             isMatch = FALSE;
          break;
@@ -1381,6 +1435,7 @@ Transcription *LOpen(MemHeap *x, char * 
    char buf[MAXSTRLEN];
    Transcription *t;
    Boolean isMLF;
+   int i;
 
    if (fmt == UNDEFF){
       if (GetConfStr(cParm,numParm,"SOURCELABEL",buf))
@@ -1401,7 +1456,8 @@ Transcription *LOpen(MemHeap *x, char * 
    default:
       HError(6572,"LOpen: Illegal label file format [%d]",fmt);
    }
-   if (!isMLF) fclose(f);
+   if (!isMLF) 
+      i=fclose(f);
    if (transLev > 0) FilterLevel(t,transLev-1);
    return t;
 }
@@ -1566,4 +1622,4 @@ ReturnStatus LSave(char *fname, Transcri
    return(SUCCESS);
 }
 
-/* ------------------------ End of HLabel.c ------------------------- */
+/* ------------------------ End of HLabel.c ------------------------ */
diff -pbBEwurNa --ignore-matching-lines='.*vc_id.*' HTK-3.4.1/HTKLib/HLabel.h HTS-2.2_for_HTK-3.4.1/HTKLib/HLabel.h
--- HTK-3.4.1/HTKLib/HLabel.h	2009-03-13 03:44:31.000000000 +0900
+++ HTS-2.2_for_HTK-3.4.1/HTKLib/HLabel.h	2011-06-16 13:18:29.000000000 +0900
@@ -19,6 +19,51 @@
 /*         File: HLabel.h:   Speech Label File Input           */
 /* ----------------------------------------------------------- */
 
+/*  *** THIS IS A MODIFIED VERSION OF HTK ***                        */
+/* ----------------------------------------------------------------- */
+/*           The HMM-Based Speech Synthesis System (HTS)             */
+/*           developed by HTS Working Group                          */
+/*           http://hts.sp.nitech.ac.jp/                             */
+/* ----------------------------------------------------------------- */
+/*                                                                   */
+/*  Copyright (c) 2001-2011  Nagoya Institute of Technology          */
+/*                           Department of Computer Science          */
+/*                                                                   */
+/*                2001-2008  Tokyo Institute of Technology           */
+/*                           Interdisciplinary Graduate School of    */
+/*                           Science and Engineering                 */
+/*                                                                   */
+/* All rights reserved.                                              */
+/*                                                                   */
+/* Redistribution and use in source and binary forms, with or        */
+/* without modification, are permitted provided that the following   */
+/* conditions are met:                                               */
+/*                                                                   */
+/* - Redistributions of source code must retain the above copyright  */
+/*   notice, this list of conditions and the following disclaimer.   */
+/* - Redistributions in binary form must reproduce the above         */
+/*   copyright notice, this list of conditions and the following     */
+/*   disclaimer in the documentation and/or other materials provided */
+/*   with the distribution.                                          */
+/* - Neither the name of the HTS working group nor the names of its  */
+/*   contributors may be used to endorse or promote products derived */
+/*   from this software without specific prior written permission.   */
+/*                                                                   */
+/* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND            */
+/* CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,       */
+/* INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF          */
+/* MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE          */
+/* DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS */
+/* BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,          */
+/* EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED   */
+/* TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,     */
+/* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON */
+/* ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,   */
+/* OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY    */
+/* OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE           */
+/* POSSIBILITY OF SUCH DAMAGE.                                       */
+/* ----------------------------------------------------------------- */
+
 /* !HVER!HLabel:   3.4.1 [CUED 12/03/09] */
 
 
@@ -128,6 +173,11 @@ void InitLabel(void);
    the routines in this module.
 */
 
+void ResetLabel(void);
+/*
+   Reset module
+*/
+
 LabId GetLabId(char *name, Boolean insert);
 /*
    Lookup given name in hash table and return its id.  If it
@@ -332,7 +382,4 @@ MLFEntry *GetMLFTable(void);
 
 #endif  /* _HLABEL_H_ */
 
-/* ------------------------ End of HLabel.h ------------------------- */
-
-
-
+/* ------------------------ End of HLabel.h ------------------------ */
diff -pbBEwurNa --ignore-matching-lines='.*vc_id.*' HTK-3.4.1/HTKLib/HLat.c HTS-2.2_for_HTK-3.4.1/HTKLib/HLat.c
--- HTK-3.4.1/HTKLib/HLat.c	2009-03-13 03:44:43.000000000 +0900
+++ HTS-2.2_for_HTK-3.4.1/HTKLib/HLat.c	2011-06-16 13:18:29.000000000 +0900
@@ -27,6 +27,51 @@
 /*       File: HLat.c:  Lattice Manipulation                   */
 /* ----------------------------------------------------------- */
 
+/*  *** THIS IS A MODIFIED VERSION OF HTK ***                        */
+/* ----------------------------------------------------------------- */
+/*           The HMM-Based Speech Synthesis System (HTS)             */
+/*           developed by HTS Working Group                          */
+/*           http://hts.sp.nitech.ac.jp/                             */
+/* ----------------------------------------------------------------- */
+/*                                                                   */
+/*  Copyright (c) 2001-2011  Nagoya Institute of Technology          */
+/*                           Department of Computer Science          */
+/*                                                                   */
+/*                2001-2008  Tokyo Institute of Technology           */
+/*                           Interdisciplinary Graduate School of    */
+/*                           Science and Engineering                 */
+/*                                                                   */
+/* All rights reserved.                                              */
+/*                                                                   */
+/* Redistribution and use in source and binary forms, with or        */
+/* without modification, are permitted provided that the following   */
+/* conditions are met:                                               */
+/*                                                                   */
+/* - Redistributions of source code must retain the above copyright  */
+/*   notice, this list of conditions and the following disclaimer.   */
+/* - Redistributions in binary form must reproduce the above         */
+/*   copyright notice, this list of conditions and the following     */
+/*   disclaimer in the documentation and/or other materials provided */
+/*   with the distribution.                                          */
+/* - Neither the name of the HTS working group nor the names of its  */
+/*   contributors may be used to endorse or promote products derived */
+/*   from this software without specific prior written permission.   */
+/*                                                                   */
+/* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND            */
+/* CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,       */
+/* INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF          */
+/* MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE          */
+/* DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS */
+/* BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,          */
+/* EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED   */
+/* TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,     */
+/* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON */
+/* ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,   */
+/* OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY    */
+/* OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE           */
+/* POSSIBILITY OF SUCH DAMAGE.                                       */
+/* ----------------------------------------------------------------- */
+
 /*#### todo:
 
      - implement lattice oracle WER calculation
@@ -79,7 +124,9 @@ static Boolean compressMerge = TRUE; /* 
 
 static char *llfExt = "LLF";    /* extension for LLF lattice files */
 
+#ifndef NO_LAT_LM
 static MemHeap slaHeap, slnHeap;/* MHEAPs for use in LatExpand() */
+#endif
 
 /* --------------------------- Prototypes ---------------------------- */
 
@@ -290,6 +337,18 @@ void InitLat(void)
 }
 
 
+/* EXPORT->ResetLat: reset the module */
+void ResetLat (void)
+{
+#ifndef NO_LAT_LM
+   ResetHeap(&slnHeap);
+   ResetHeap(&slaHeap);
+#endif
+   ResetHeap(&llfHeap);
+   
+   return;
+}
+
 /* --------------------------- Lattice processing ------------------- */
 
 /* LatCheck
@@ -904,7 +963,7 @@ void CalcStats (Lattice *lat)
       ln = topOrder[i];
 
       /* count words */
-      ln->word->aux = (Ptr) (((int)ln->word->aux) + 1);
+      ln->word->aux = (Ptr) (((long)ln->word->aux) + 1);
 
       /* count incoming and outgoing arcs */
       d = 0;
@@ -1789,7 +1848,7 @@ void ApplyNGram2LabLat(Lattice *lat, LMo
       fprintf(stdout, "\n");
       fprintf(stdout, "\n Vocab entries: ");
       for (j = 0; j < lat->nn - 2; j++) {
-         fprintf(stdout, "%s ", lm->data.ngram->wdlist[(int) revlab[j]->aux]->name);
+         fprintf(stdout, "%s ", lm->data.ngram->wdlist[(long) revlab[j]->aux]->name);
       }
       fprintf(stdout, "\n\n");
       fflush(stdout);
@@ -1819,3 +1878,5 @@ void ApplyNGram2LabLat(Lattice *lat, LMo
    Dispose(lat->heap, revlab);
 }
 #endif
+
+/* ------------------------ End of HLat.c -------------------------- */
diff -pbBEwurNa --ignore-matching-lines='.*vc_id.*' HTK-3.4.1/HTKLib/HLat.h HTS-2.2_for_HTK-3.4.1/HTKLib/HLat.h
--- HTK-3.4.1/HTKLib/HLat.h	2009-03-13 03:44:54.000000000 +0900
+++ HTS-2.2_for_HTK-3.4.1/HTKLib/HLat.h	2011-06-16 13:18:29.000000000 +0900
@@ -26,6 +26,51 @@
 /*       File: HLat.h:  Lattice Manipulation                   */
 /* ----------------------------------------------------------- */
 
+/*  *** THIS IS A MODIFIED VERSION OF HTK ***                        */
+/* ----------------------------------------------------------------- */
+/*           The HMM-Based Speech Synthesis System (HTS)             */
+/*           developed by HTS Working Group                          */
+/*           http://hts.sp.nitech.ac.jp/                             */
+/* ----------------------------------------------------------------- */
+/*                                                                   */
+/*  Copyright (c) 2001-2011  Nagoya Institute of Technology          */
+/*                           Department of Computer Science          */
+/*                                                                   */
+/*                2001-2008  Tokyo Institute of Technology           */
+/*                           Interdisciplinary Graduate School of    */
+/*                           Science and Engineering                 */
+/*                                                                   */
+/* All rights reserved.                                              */
+/*                                                                   */
+/* Redistribution and use in source and binary forms, with or        */
+/* without modification, are permitted provided that the following   */
+/* conditions are met:                                               */
+/*                                                                   */
+/* - Redistributions of source code must retain the above copyright  */
+/*   notice, this list of conditions and the following disclaimer.   */
+/* - Redistributions in binary form must reproduce the above         */
+/*   copyright notice, this list of conditions and the following     */
+/*   disclaimer in the documentation and/or other materials provided */
+/*   with the distribution.                                          */
+/* - Neither the name of the HTS working group nor the names of its  */
+/*   contributors may be used to endorse or promote products derived */
+/*   from this software without specific prior written permission.   */
+/*                                                                   */
+/* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND            */
+/* CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,       */
+/* INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF          */
+/* MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE          */
+/* DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS */
+/* BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,          */
+/* EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED   */
+/* TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,     */
+/* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON */
+/* ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,   */
+/* OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY    */
+/* OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE           */
+/* POSSIBILITY OF SUCH DAMAGE.                                       */
+/* ----------------------------------------------------------------- */
+
 /* !HVER!HLat:   3.4.1 [CUED 12/03/09] */
 
 
@@ -43,6 +88,11 @@ void InitLat (void);
    register module & set configuration parameters
 */
 
+void ResetLat (void);
+/*
+   reset the module
+*/
+
 /* ------------------------ Datatype ----------------------------- */
 
 /* Forward-Backward info structre attached to LNodes
@@ -110,3 +160,5 @@ void ApplyWPNet2LabLat(Lattice *lat, Lat
 #endif
 
 #endif  /* _HLAT_H_ */
+
+/* ------------------------ End of HLat.h -------------------------- */
diff -pbBEwurNa --ignore-matching-lines='.*vc_id.*' HTK-3.4.1/HTKLib/HMTrain.c HTS-2.2_for_HTK-3.4.1/HTKLib/HMTrain.c
--- HTK-3.4.1/HTKLib/HMTrain.c	1970-01-01 09:00:00.000000000 +0900
+++ HTS-2.2_for_HTK-3.4.1/HTKLib/HMTrain.c	2011-06-16 13:27:17.000000000 +0900
@@ -0,0 +1,1695 @@
+/* ----------------------------------------------------------------- */
+/*           The HMM-Based Speech Synthesis System (HTS)             */
+/*           developed by HTS Working Group                          */
+/*           http://hts.sp.nitech.ac.jp/                             */
+/* ----------------------------------------------------------------- */
+/*                                                                   */
+/*  Copyright (c) 2001-2011  Nagoya Institute of Technology          */
+/*                           Department of Computer Science          */
+/*                                                                   */
+/*                2001-2008  Tokyo Institute of Technology           */
+/*                           Interdisciplinary Graduate School of    */
+/*                           Science and Engineering                 */
+/*                                                                   */
+/* All rights reserved.                                              */
+/*                                                                   */
+/* Redistribution and use in source and binary forms, with or        */
+/* without modification, are permitted provided that the following   */
+/* conditions are met:                                               */
+/*                                                                   */
+/* - Redistributions of source code must retain the above copyright  */
+/*   notice, this list of conditions and the following disclaimer.   */
+/* - Redistributions in binary form must reproduce the above         */
+/*   copyright notice, this list of conditions and the following     */
+/*   disclaimer in the documentation and/or other materials provided */
+/*   with the distribution.                                          */
+/* - Neither the name of the HTS working group nor the names of its  */
+/*   contributors may be used to endorse or promote products derived */
+/*   from this software without specific prior written permission.   */
+/*                                                                   */
+/* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND            */
+/* CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,       */
+/* INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF          */
+/* MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE          */
+/* DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS */
+/* BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,          */
+/* EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED   */
+/* TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,     */
+/* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON */
+/* ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,   */
+/* OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY    */
+/* OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE           */
+/* POSSIBILITY OF SUCH DAMAGE.                                       */
+/* ----------------------------------------------------------------- */
+/*         File: HMTrain.c: Minimize generation error                */
+/* ----------------------------------------------------------------- */
+
+char *hmtrain_version = "!HVER!HMTrain: 2.2 [NIT 07/07/11]";
+char *hmtrain_vc_id = "$Id: HMTrain.c,v 1.2 2011/06/16 04:27:17 uratec Exp $";
+
+#include "HShell.h"
+#include "HMem.h"
+#include "HMath.h"
+#include "HSigP.h"
+#include "HAudio.h"
+#include "HWave.h"
+#include "HVQ.h"
+#include "HParm.h"
+#include "HLabel.h"
+#include "HModel.h"
+#include "HTrain.h"
+#include "HUtil.h"
+#include "HAdapt.h"
+#include "HFB.h"
+#include "HGen.h"
+#include "HMTrain.h"
+#include "math.h"
+
+/* -------------------- Trace Information -------------------- */
+
+#define T_TOP   0001            /* Top level tracing */
+#define T_STT   0002            /* trace for outputing statistical info */
+
+/* --------------------- Global Settings --------------------- */
+
+#define SMALL_VALUE            1e-10
+#define TRIM_SIL_STATE_NUM     0
+#define MAX_MEAN_UP_STEP       0.04f    /* PD maximum step for updating mean para compared to variance */
+#define MAX_VAR_UP_STEP        0.02f    /* PD maximum step for updating var para */
+#define MAX_UP_RATE_MEAN       2.0f     /* maximum range for updating mean para */
+#define MAX_UP_RATE_VAR        10.0f    /* maximum range for updating var para */
+#define MAX_MEAN_UP_STEP_XFORM 0.002f   /* PD maximum step for updating transform of mean para */
+#define MAX_VAR_UP_STEP_XFORM  0.02f    /* PD maximum step for updating transform of var para */
+#define MAX_UP_RATE_MEAN_XFORM 0.5f     /* maximum range for updating transform of mean para */
+#define MAX_UP_RATE_VAR_XFORM  5.0f     /* maximum range for updating transform of var para */
+#define STAT_UP_STEP_LIMIT     TRUE
+
+#define MAX_MSD_WGHT 0.99f
+#define MIN_MSD_WGHT 0.01f
+
+static double g_pfMeanDynScale[3] = { 1.0, 0.3, 3.0 };
+static double g_pfVarDynScale[3] = { 1.0, 2.0, 4.0 };
+static double g_pfMeanDynScale_xform[3] = { 1.0, 0.3, 3.0 };
+static double g_pfVarDynScale_xform[3] = { 1.0, 1.0, 3.0 };
+static double g_fMeanBiasScale_xform = 0.2f;
+
+#define WEIGHT_MAX 1.2f
+#define WEIGHT_MIN 0.5f
+
+#define INVALID_SHIFT -100000
+
+#define MAX_BOUND_ADJ_LEN  100
+
+/* CalGainWght: Calculate gain weight for generation error */
+static float CalGainWght(float fGain, float fComp)
+{
+   float fGainWght;
+
+   fGainWght = fGain / fComp;
+
+   if (fGainWght > WEIGHT_MAX)
+      return WEIGHT_MAX;
+   else if (fGainWght < WEIGHT_MIN)
+      return WEIGHT_MIN;
+   else
+      return fGainWght;
+}
+
+/* CalDynFeat: Calculate dynamic feature for generated feature sequence */
+static void CalDynFeat(PdfStream * pst, int m)
+{
+   int t, i, j;
+
+   for (t = 1; t <= pst->T; t++) {
+      for (i = 1; i < pst->win.num; i++) {
+         pst->C[t][i * pst->order + m] = 0.0f;
+         /* deal with the v/uv boundary */
+         if (pst->vseq[t].var[i * pst->order + m] == 0.0)
+            continue;
+         for (j = pst->win.width[i][0]; j <= pst->win.width[i][1]; j++) {
+            if (t + j > 0 && t + j <= pst->T)
+               pst->C[t][i * pst->order + m] += pst->C[t + j][m] * pst->win.coef[i][j];
+         }
+      }
+   }
+}
+
+/* EXPORT->InitMTrain: Initialise module */
+void InitMTrain()
+{
+   Register(hmtrain_version, hmtrain_vc_id);
+}
+
+/* MatchHmmStream: Get the matched HMM stream index for current p and l */
+static int MatchHmmStream(GenInfo * genInfo, int cur_p, int win_idx)
+{
+   int p, stream;
+
+   stream = 1;
+   for (p = 1; p < cur_p; p++)
+      stream += genInfo->nPdfStream[p];
+   if (genInfo->nPdfStream[p] > 1) {
+      stream += win_idx;
+   }
+
+   return stream;
+}
+
+/* CheckData: Check data file consistent with HMM definition */
+static void CheckData(char *fn, BufferInfo * bufInfo, GenInfo * genInfo)
+{
+   char tpk[MAXSTRLEN];
+   char mpk[MAXSTRLEN];
+
+   if (bufInfo->nObs != genInfo->tframe) {
+      HError(6611, "CheckData: Frame number in %s[%d] is incompatible with hmm [%d]", fn, bufInfo->nObs, genInfo->tframe);
+   }
+
+   if (bufInfo->tgtPK != genInfo->hset->pkind) {
+      HError(6611, "CheckData: Parameterisation in %s[%s] is incompatible with hmm [%s]", fn, ParmKind2Str(bufInfo->tgtPK, tpk), ParmKind2Str(genInfo->hset->pkind, mpk));
+   }
+
+   if (bufInfo->tgtVecSize != genInfo->hset->vecSize) {
+      HError(6611, "CheckData: Vector size in %s[%d] is incompatible with hmm [%d]", fn, bufInfo->tgtVecSize, genInfo->hset->vecSize);
+   }
+}
+
+/* LoadOrigData: */
+static void LoadOrigData(MgeTrnInfo * mtInfo, char *datafn)
+{
+   GenInfo *genInfo;
+   MgeStream *mst;
+   PdfStream *pst;
+   BufferInfo info;
+   ParmBuf pbuf;
+   Observation obs;
+   int p, t, pt, i, j, s, stream;
+   HMMSet *hset;
+   Boolean eSep;
+
+   genInfo = mtInfo->genInfo;
+   /* open buffer to read data */
+   pbuf = OpenBuffer(mtInfo->mgeMem, datafn, 10, UNDEFF, FALSE_dup, FALSE_dup);
+   if (pbuf == NULL)
+      HError(6611, "LoadOrigData: Can not open data file");
+   GetBufferInfo(pbuf, &info);
+   CheckData(datafn, &info, genInfo);
+
+   /* create an object to hold the input parameters */
+   hset = mtInfo->genInfo->hset;
+   SetStreamWidths(hset->pkind, hset->vecSize, hset->swidth, &eSep);
+   obs = MakeObservation(mtInfo->mgeMem, hset->swidth, hset->pkind, FALSE, eSep);
+
+   for (p = stream = 1; p <= genInfo->nPdfStream[0]; p++) {
+      if (!mtInfo->pbMTrn[p] && !mtInfo->pbAccErr[p]) {
+         stream += genInfo->nPdfStream[p];
+         continue;
+      }
+
+      mst = &(mtInfo->mst[p]);
+      pst = &(genInfo->pst[p]);
+      /* load each frames */
+      for (pt = t = 1; t <= info.nObs; t++) {
+         ReadAsTable(pbuf, t - 1, &obs);
+         /* if the value of vector is less than LSMALL, regarded as zero-space */
+         if (obs.fv[stream][1] > LSMALL) {
+            i = 1;
+            for (s = stream; s < stream + genInfo->nPdfStream[p]; s++) {
+               for (j = 1; j <= VectorSize(obs.fv[s]); j++, i++) {
+                  mst->origObs[pt][i] = obs.fv[s][j];
+               }
+            }
+            pt++;
+            /* set space index from orig data */
+            genInfo->pst[p].ContSpace[t] = TRUE;
+         } else {
+            genInfo->pst[p].ContSpace[t] = FALSE;
+         }
+      }
+      genInfo->pst[p].T = pt - 1;
+      stream += genInfo->nPdfStream[p];
+   }
+
+   CloseBuffer(pbuf);
+}
+
+/* SetupMgeTrnInfo: Setup all info struct for MGE training */
+static void SetupMgeTrnInfo(MgeTrnInfo * mtInfo, char *labfn, char *datafn)
+{
+   GenInfo *genInfo;
+   Transcription *tr;
+   PdfStream *pst;
+   MgeStream *mst;
+   int p, k, TBak;
+
+   genInfo = mtInfo->genInfo;
+
+   mtInfo->mrat = CreateDVector(mtInfo->mgeMem, WMAX);
+   mtInfo->vrat = CreateDVector(mtInfo->mgeMem, WMAX);
+
+   /* load a given input label file */
+   tr = LOpen(mtInfo->mgeMem, labfn, UNDEFF);
+   /* initialize the GenInfo structure */
+   InitialiseGenInfo(genInfo, tr, TRUE);
+
+   /* initialize MgeStream */
+   for (p = 1; p <= genInfo->nPdfStream[0]; p++) {
+      /* p-th PdfStream */
+      pst = &(genInfo->pst[p]);
+      mst = &(mtInfo->mst[p]);
+
+      if (pst->fullCov && mtInfo->pbMTrn[p])
+         HError(6610, "SetupMgeTrnInfo: Do not support full covariance");
+
+      /* before load the original data, we dont know how long is the voice region for F0 */
+      TBak = pst->T;
+      pst->T = genInfo->tframe;
+      if (mtInfo->pbMTrn[p] || mtInfo->pbAccErr[p]) {
+         mst->origObs = CreateMatrix(mtInfo->mgeMem, pst->T, pst->vSize);
+      }
+
+      if (mtInfo->pbMTrn[p]) {
+         mst->nInvQuaSize = mtInfo->pnInvQuaSize[p];
+         mst->quasi_invRef = CreateDMatrix(mtInfo->mgeMem, pst->T, mst->nInvQuaSize * 2);       /* L~-1, L*L'=WUW */
+         mst->quasi_invWUW = CreateDMatrix(mtInfo->mgeMem, pst->T, mst->nInvQuaSize * 2);       /* (WUW)~-1 */
+         mst->quasi_P = CreateDMatrix(mtInfo->mgeMem, pst->T, mst->nInvQuaSize * pst->win.num * 2);     /* P = (W'UW)~-1 * W' ~ */
+      }
+
+      pst->T = TBak;
+
+      for (k = 0; k < pst->win.num; k++)
+         mst->stmIdx[k + 1] = MatchHmmStream(genInfo, p, k);
+   }
+
+   LoadOrigData(mtInfo, datafn);
+}
+
+/* ResetMgeTrnInfo: */
+static void ResetMgeTrnInfo(MgeTrnInfo * mtInfo)
+{
+   Dispose(mtInfo->mgeMem, mtInfo->mrat);
+   ResetGenInfo(mtInfo->genInfo);
+}
+
+/* InverseWUW: */
+static void InverseWUW(MgeStream * mst, PdfStream * pst)
+{
+   int i, j, k, ii, jj, kk;
+   int nInvQuaSize;
+
+   DMatrix WUW;
+   DMatrix quasi_invRef;
+   DMatrix quasi_invWUW;
+
+   WUW = pst->WUW;
+   quasi_invRef = mst->quasi_invRef;
+   quasi_invWUW = mst->quasi_invWUW;
+   nInvQuaSize = mst->nInvQuaSize;
+
+   ZeroDMatrix(mst->quasi_invRef);
+   for (i = 1; i <= pst->T; i++) {
+      quasi_invRef[i][nInvQuaSize] = pst->WUW[i][1];
+      for (k = 1; k < pst->width; k++) {
+         if (i + k <= pst->T) {
+            quasi_invRef[i][nInvQuaSize + k] = pst->WUW[i][k + 1];
+            quasi_invRef[i + k][nInvQuaSize - k] = pst->WUW[i][k + 1];
+         }
+      }
+   }
+
+   /* inverse WUW */
+   ZeroDMatrix(quasi_invWUW);
+   /* zero left-down */
+   for (i = 1; i <= pst->T; i++) {
+      /* normalize one row */
+      quasi_invWUW[i][nInvQuaSize] = 1.0 / quasi_invRef[i][nInvQuaSize];
+      /* norm orig matrix */
+      for (k = 1; k < pst->width; k++) {
+         if (i + k <= pst->T)
+            quasi_invRef[i][nInvQuaSize + k] /= quasi_invRef[i][nInvQuaSize];
+      }
+      /* norm inv matrix */
+      j = i - nInvQuaSize + 1 > 0 ? i - nInvQuaSize + 1 : 1;
+      for (; j < i; j++)
+         quasi_invWUW[i][(j - i) + nInvQuaSize] /= quasi_invRef[i][nInvQuaSize];
+      quasi_invRef[i][nInvQuaSize] = 1.0;       /* useless code */
+
+      /* zero one colum */
+      for (k = 1; k < pst->width; k++) {
+         ii = i + k;
+         kk = nInvQuaSize - k;
+         if (ii <= pst->T) {
+            /* process inv matrix */
+            j = i - nInvQuaSize + k + 1 > 0 ? i - nInvQuaSize + k + 1 : 1;
+            jj = j - i + nInvQuaSize;
+            for (; j <= i; j++, jj++) {
+               quasi_invWUW[ii][j - i + kk] -= quasi_invWUW[i][jj] * quasi_invRef[ii][kk];
+            }
+            /* process orig matrix */
+            for (j = 1; j < pst->width; j++) {
+               if (i + j <= pst->T)
+                  quasi_invRef[ii][j + kk] -= quasi_invRef[i][j + nInvQuaSize] * quasi_invRef[ii][kk];
+            }
+         }
+      }
+   }
+
+   /* zero right-upper */
+   for (i = pst->T; i >= 1; i--) {
+      /* zero one colum */
+      for (k = 1; k < pst->width; k++) {
+         ii = i - k;
+         kk = k + nInvQuaSize;
+         if (ii > 0) {
+            /* process inv matrix */
+            j = i - nInvQuaSize + 1 > 0 ? i - nInvQuaSize + 1 : 1;
+            jj = j - i + nInvQuaSize;
+            for (; j < i + nInvQuaSize - k; j++, jj++) {
+               if (j > pst->T)
+                  break;
+               quasi_invWUW[ii][j - i + kk] -= quasi_invWUW[i][jj] * quasi_invRef[ii][kk];
+            }
+         }
+      }
+   }
+
+   /* need to make it symmetrical */
+   for (i = 1; i <= pst->T; i++) {
+      for (j = nInvQuaSize - 1; j >= 1; j--) {
+         jj = nInvQuaSize - j;
+         if (i - jj > 0) {
+            quasi_invWUW[i][j] = (quasi_invWUW[i][j] + quasi_invWUW[i - jj][nInvQuaSize + jj]) / 2;
+            quasi_invWUW[i - jj][nInvQuaSize + jj] = quasi_invWUW[i][j];
+         }
+      }
+   }
+}
+
+/* CalculateMatrixP: P = R~-1 * W' = (W'UW)~-1 * W' */
+static void CalMatrixP(MgeStream * mst, PdfStream * pst, int m)
+{
+   int t, i, j, k, start, end, jj, tj;
+   int nInvQuaSize;
+
+   ZeroDMatrix(mst->quasi_P);
+
+   nInvQuaSize = mst->nInvQuaSize;
+   /* process each row */
+   for (t = 1; t <= pst->T; t++) {
+      start = t - nInvQuaSize >= 0 ? t - nInvQuaSize : 0;
+      jj = pst->win.num * (start - t + nInvQuaSize);
+      end = t + nInvQuaSize - 1 < pst->T ? t + nInvQuaSize - 1 : pst->T;
+      start += (1 - t + nInvQuaSize);
+      end += (1 - t + nInvQuaSize);
+      for (j = start; j < end; j++, jj += pst->win.num) {
+         mst->quasi_P[t][jj + 1] = mst->quasi_invWUW[t][j];
+      }
+
+      /* delta para & acc para */
+      start = t - nInvQuaSize + pst->win.max_L > 0 ? t - nInvQuaSize + pst->win.max_L : 0;
+      end = t + nInvQuaSize - 1 - pst->win.max_L < pst->T ? t + nInvQuaSize - 1 - pst->win.max_L : pst->T;
+      start += (1 - t + nInvQuaSize);
+      end += (1 - t + nInvQuaSize);
+      for (i = 1; i < pst->win.num; i++) {
+         jj = pst->win.num * (start - 1);
+         tj = start + t - nInvQuaSize;
+         for (j = start; j < end; j++, tj++, jj += pst->win.num) {
+            /* check u/v boundary */
+            if (pst->vseq[tj].var[i * pst->order + m] == 0.0)
+               continue;
+            for (k = pst->win.width[i][0]; k <= pst->win.width[i][1]; k++)
+               mst->quasi_P[t][jj + i + 1] += mst->quasi_invWUW[t][j + k] * pst->win.coef[i][k];
+         }
+      }
+   }
+}
+
+/* ParaGenOneDim: */
+static void ParaGenOneDim(PdfStream * pst, int m, Boolean bCalDyn)
+{
+   Calc_WUM_and_WUW(pst, m - 1);
+   Cholesky_Factorization(pst); /* Cholesky decomposition */
+   Forward_Substitution(pst);   /* forward substitution   */
+   Backward_Substitution(pst, m - 1);   /* backward substitution  */
+
+   if (bCalDyn)
+      CalDynFeat(pst, m);
+}
+
+/* CalcMgeTrnInfo: */
+static void CalcMgeTrnInfo(MgeStream * mst, PdfStream * pst, int m)
+{
+   Calc_WUM_and_WUW(pst, m - 1);
+
+   /* calculate inverse matrix (W'UW)~-1 */
+   InverseWUW(mst, pst);
+   /* calculate Matrix P = R~-1 * W' = (W'UW)~-1 * W' */
+   CalMatrixP(mst, pst, m);
+
+   Cholesky_Factorization(pst); /* Cholesky decomposition */
+   Forward_Substitution(pst);   /* forward substitution   */
+   Backward_Substitution(pst, m - 1);   /* backward substitution  */
+
+   CalDynFeat(pst, m);
+}
+
+/* CheckUpStepLimit: Check the updating para, and bound it if out of limit */
+static Boolean CheckUpStepLimit(float *upRate, float limit, Boolean bRecord, IntVec pnFloorNum)
+{
+   if (*upRate > limit) {
+      *upRate = limit;
+      if (bRecord && pnFloorNum != NULL)
+         pnFloorNum[HIGH_FLOOR]++;
+      return TRUE;
+   } else if (*upRate < -limit) {
+      *upRate = -limit;
+      if (bRecord && pnFloorNum != NULL)
+         pnFloorNum[LOW_FLOOR]++;
+      return TRUE;
+   }
+   return FALSE;
+}
+
+/* CheckLinUpRange: Check the updating para, and bound it if out of limit */
+static Boolean CheckLinUpRange(float *data, float *ref_data, float limit, Boolean bRecord, IntVec pnFloorNum)
+{
+   if (*data - *ref_data > limit) {
+      *data = *ref_data + limit;
+      if (bRecord && pnFloorNum != NULL)
+         pnFloorNum[HIGH_FLOOR]++;
+      return TRUE;
+   } else if (*data - *ref_data < -limit) {
+      *data = *ref_data - limit;
+      if (bRecord && pnFloorNum != NULL)
+         pnFloorNum[LOW_FLOOR]++;
+      return TRUE;
+   }
+   return FALSE;
+}
+
+/* CheckLogUpRange: Check the updating para, and bound it if out of limit */
+static Boolean CheckLogUpRange(float *data, float *ref_data, float limit, Boolean bRecord, IntVec pnFloorNum)
+{
+   if (*data / *ref_data > limit) {
+      *data = *ref_data * limit;
+      if (bRecord && pnFloorNum != NULL)
+         pnFloorNum[HIGH_FLOOR]++;
+      return TRUE;
+   } else if (*data / *ref_data < 1 / limit) {
+      *data = *ref_data / limit;
+      if (bRecord && pnFloorNum != NULL)
+         pnFloorNum[LOW_FLOOR]++;
+      return TRUE;
+   }
+   return FALSE;
+}
+
+/* CheckMeanUpdateRange: Check the updated mean HMM para, and bound it if out of range */
+static Boolean CheckMeanUpdateRange(MixPDF * adj_mpdf, MixPDF * ref_mpdf, IntVec pnFloorNum, int k)
+{
+   float meanLimit;
+
+   meanLimit = (float) (MAX_UP_RATE_MEAN / sqrt(ref_mpdf->cov.var[k]));
+   if (adj_mpdf->mean[k] - ref_mpdf->mean[k] > meanLimit) {
+      adj_mpdf->mean[k] = ref_mpdf->mean[k] + meanLimit;
+      if (pnFloorNum != NULL)
+         pnFloorNum[HIGH_FLOOR]++;
+      return TRUE;
+   } else if (adj_mpdf->mean[k] - ref_mpdf->mean[k] < -meanLimit) {
+      adj_mpdf->mean[k] = ref_mpdf->mean[k] - meanLimit;
+      if (pnFloorNum != NULL)
+         pnFloorNum[LOW_FLOOR]++;
+      return TRUE;
+   }
+   return FALSE;
+}
+
+/* CheckVarUpdateRange: Check the updated HMM var para, and bound it if out of range */
+static Boolean CheckVarUpdateRange(MixPDF * adj_mpdf, MixPDF * ref_mpdf, IntVec pnFloorNum, int k)
+{
+   if (adj_mpdf->cov.var[k] > ref_mpdf->cov.var[k] * MAX_UP_RATE_VAR) {
+      adj_mpdf->cov.var[k] = ref_mpdf->cov.var[k] * MAX_UP_RATE_VAR;
+      if (pnFloorNum != NULL)
+         pnFloorNum[HIGH_FLOOR]++;
+      return TRUE;
+   } else if (adj_mpdf->cov.var[k] < ref_mpdf->cov.var[k] / MAX_UP_RATE_VAR) {
+      adj_mpdf->cov.var[k] = ref_mpdf->cov.var[k] / MAX_UP_RATE_VAR;
+      if (pnFloorNum != NULL)
+         pnFloorNum[LOW_FLOOR]++;
+      return TRUE;
+   }
+   return FALSE;
+}
+
+/* MatchContSpace: */
+static int MatchContSpace(IntVec ContSpace, int t)
+{
+   int ct;
+
+   ct = 1;
+   t--;
+   while (t > 0) {
+      if (ContSpace[t])
+         ct++;
+      t--;
+   }
+   return ct;
+}
+
+/* CalcUpdateRatio: Calculate updating ratio (mean & variance) for one state model */
+static int CalcUpdateRatio(MgeTrnInfo * mtInfo, MgeStream * mst, PdfStream * pst, Label * label, int p, int m)
+{
+   int lowb, highb, nGainIdx;
+   int i, k, l, t, tt, si, ei;
+   int tstart, tend;
+   double dfobs, tmrat, tvrat;
+   int nCumWinSize = mst->nInvQuaSize - 2;
+   MgeStream *gain_mst;
+
+   /* for gain weight */
+   nGainIdx = mtInfo->nGainDimIndex;
+   gain_mst = &(mtInfo->mst[mtInfo->nGainStreamIndex]);
+
+   ZeroDVector(mtInfo->mrat);
+   ZeroDVector(mtInfo->vrat);
+   /* range for accumulation of updating rate */
+   si = (int) (label->start / mtInfo->genInfo->frameRate + 0.5) + 1;
+   ei = (int) (label->end / mtInfo->genInfo->frameRate + 0.5) + 1;
+   /* match the index of cont space */
+   si = MatchContSpace(pst->ContSpace, si);
+   ei = MatchContSpace(pst->ContSpace, ei);
+   lowb = si - nCumWinSize > 0 ? si - nCumWinSize : 1;
+   highb = ei + nCumWinSize <= pst->T ? ei + nCumWinSize : pst->T;
+   for (t = lowb; t <= highb; t++) {
+      /* distance between original and generated feature */
+      dfobs = pst->C[t][m] - mst->origObs[t][m];
+      /* gain weighting */
+      if (mtInfo->pbGainWght[p]) {
+         if (nGainIdx != m || p != mtInfo->nGainStreamIndex)
+            dfobs *= CalGainWght(gain_mst->origObs[t][nGainIdx], mtInfo->fGainWghtComp);
+      }
+
+      /* accumulate updating ratio for mean and variance */
+      tstart = (si >= t + 1 - nCumWinSize) ? si : t + 1 - nCumWinSize;
+      tend = (ei <= t + 1 + nCumWinSize) ? ei : t + 1 + nCumWinSize;
+      for (l = 0; l < pst->win.num; l++) {
+         tt = pst->win.num * (tstart - t + mst->nInvQuaSize - 1) + l + 1;
+         k = l * pst->order + m;
+         tmrat = tvrat = 0.0;
+         for (i = tstart; i < tend; i++, tt += pst->win.num) {
+            if (mtInfo->uFlags & UPMEANS) {
+               tmrat += mst->quasi_P[t][tt];
+            }
+            if (mtInfo->uFlags & UPVARS) {
+               tvrat += mst->quasi_P[t][tt] * (pst->mseq[i][k] - pst->C[i][k]);
+            }
+         }
+         if (mtInfo->uFlags & UPMEANS)
+            mtInfo->mrat[l + 1] += dfobs * tmrat;
+         if (mtInfo->uFlags & UPVARS)
+            mtInfo->vrat[l + 1] += dfobs * tvrat;
+      }
+   }
+
+   if (mtInfo->funcType == MGE_TRAIN) {
+      for (l = 0; l < pst->win.num; l++) {
+         mtInfo->mrat[l + 1] *= g_pfMeanDynScale[l];
+         mtInfo->vrat[l + 1] *= g_pfVarDynScale[l];
+      }
+   } else if (mtInfo->funcType == MGE_ADAPT) {
+      for (l = 0; l < pst->win.num; l++) {
+         mtInfo->mrat[l + 1] *= g_pfMeanDynScale_xform[l];
+         mtInfo->vrat[l + 1] *= g_pfVarDynScale_xform[l];
+      }
+   }
+
+   return (ei - si);
+}
+
+/* SeqPDUpdate: Parameter updating by online PD */
+static void SeqPDUpdate(MgeTrnInfo * mtInfo, MgeStream * mst, PdfStream * pst, int p, int m)
+{
+   int s, i, j, k, l, stm;
+   int seqlen;
+   LabList *lablist;
+   Label *label;
+   LabId labid;
+   HMMDef *hmm, *ref_hmm;
+   MixPDF *mpdf, *ref_mpdf;
+   float upRate, var, meanLimit, varLimit, limitStep;
+   GenInfo *genInfo;
+   MTStatInfo *statInfo;
+   MuAcc *ma;
+   float occ, all_occ;
+
+   genInfo = mtInfo->genInfo;
+   statInfo = mtInfo->statInfo;
+   ref_hmm = NULL;
+   ref_mpdf = NULL;
+   limitStep = (float) sqrt(mtInfo->currStepSize / mtInfo->initStepSize);
+   varLimit = MAX_VAR_UP_STEP * limitStep;
+
+   lablist = genInfo->labseq->head;
+   seqlen = CountLabs(lablist);
+   label = GetLabN(lablist, 1);
+   /*i: hmm index; j: state indexo; */
+   labid = label->auxLab[1];
+   for (s = 1, i = 1, j = 2; s <= TRIM_SIL_STATE_NUM; s++, j++) {
+      label = label->succ;
+      if (label->auxLab[1] != NULL) {
+         i++;
+         j = 1;
+         labid = label->auxLab[1];
+      }
+   }
+
+   for (; s <= seqlen - TRIM_SIL_STATE_NUM;) {
+      hmm = genInfo->hmm[i];
+      /* original HMM for reference to constrain the updating range */
+      if (mtInfo->bOrigHmmRef) {
+         if (j == 2)
+            ref_hmm = FindMacroName(mtInfo->orighset, 'l', label->auxLab[1])->structure;
+         else
+            ref_hmm = FindMacroName(mtInfo->orighset, 'l', labid)->structure;
+         hmm->hook = ref_hmm;   /* link reference hmm */
+      }
+
+      for (; j < hmm->numStates; j++) {
+         all_occ = (int) ((label->end - label->start) / mtInfo->genInfo->frameRate + 0.5);
+         /* calculate updating ratio for eah state HMM */
+         occ = CalcUpdateRatio(mtInfo, mst, pst, label, p, m);
+
+         /* update model parameters */
+         for (l = 0; l < pst->win.num; l++) {
+            /* get corresponding stream & dimension index */
+            stm = mst->stmIdx[l + 1];
+            if (genInfo->nPdfStream[p] > 1)
+               k = m;
+            else
+               k = l * pst->order + m;
+
+            mpdf = hmm->svec[j].info->pdf[stm].info->spdf.cpdf[1].mpdf;
+            if (mtInfo->bOrigHmmRef && ref_hmm != NULL)
+               ref_mpdf = ref_hmm->svec[j].info->pdf[stm].info->spdf.cpdf[1].mpdf;
+
+            /* mean updating */
+            if (mtInfo->uFlags & UPMEANS) {
+               /* accumulate occ (only for mean) */
+               /* for MSD mixture weight updating */
+               ma = (MuAcc *) GetHook(mpdf->mean);
+               if (ma != NULL) {
+                  if (m == 1 && (genInfo->nPdfStream[p] > 1 || (genInfo->nPdfStream[p] == 1 && l == 0)))
+                     ma->occ += occ;
+                  if (genInfo->nPdfStream[p] > 1) {
+                     /* second mixture is unvoiced mixture */
+                     ma = (MuAcc *) GetHook(hmm->svec[j].info->pdf[stm].info->spdf.cpdf[2].mpdf->mean);
+                     if (m == 1)
+                        ma->occ += (all_occ - occ);
+                  }
+               }
+               /* calculate updating step */
+               upRate = mtInfo->currStepSize * (float) mtInfo->mrat[l + 1];
+               if (mtInfo->bMScale)
+                  upRate *= mtInfo->SRMean[p][m];
+               if (mtInfo->bMVar)
+                  upRate *= mpdf->cov.var[k];
+
+               if (mtInfo->bStepLimit) {
+                  if (mtInfo->bOrigHmmRef && ref_mpdf != NULL)
+                     var = (float) sqrt(ref_mpdf->cov.var[k]);
+                  else
+                     var = (float) sqrt(mpdf->cov.var[k]);
+                  meanLimit = MAX_MEAN_UP_STEP / var * limitStep;
+                  if (statInfo != NULL)
+                     CheckUpStepLimit(&upRate, meanLimit, !(mtInfo->bOrigHmmRef), statInfo->pnMeanFloor[p][m][l + 1]);
+                  else
+                     CheckUpStepLimit(&upRate, meanLimit, !(mtInfo->bOrigHmmRef), NULL);
+               }
+               /* update mean parameter */
+               mpdf->mean[k] -= (float) upRate;
+               if (mtInfo->bOrigHmmRef && ref_mpdf != NULL) {
+                  if (statInfo != NULL)
+                     CheckMeanUpdateRange(mpdf, ref_mpdf, statInfo->pnMeanFloor[p][m][l + 1], k);
+                  else
+                     CheckMeanUpdateRange(mpdf, ref_mpdf, NULL, k);
+               }
+            }
+
+            /* variance updating */
+            if (mtInfo->uFlags & UPVARS) {
+               upRate = mtInfo->currStepSize * (float) mtInfo->vrat[l + 1];
+               if (mtInfo->bMScale)
+                  upRate *= mtInfo->SRVar[p][m];
+               upRate *= mpdf->cov.var[k];
+
+               if (mtInfo->bStepLimit) {
+                  if (statInfo != NULL)
+                     CheckUpStepLimit(&upRate, varLimit, !(mtInfo->bOrigHmmRef), statInfo->pnVarFloor[p][m][l + 1]);
+                  else
+                     CheckUpStepLimit(&upRate, varLimit, !(mtInfo->bOrigHmmRef), NULL);
+               }
+               /* update var parameter */
+               mpdf->cov.var[k] /= (float) pow(10, upRate);
+               if (mtInfo->bOrigHmmRef && ref_mpdf != NULL) {
+                  if (statInfo != NULL)
+                     CheckVarUpdateRange(mpdf, ref_mpdf, statInfo->pnVarFloor[p][m][l + 1], k);
+                  else
+                     CheckVarUpdateRange(mpdf, ref_mpdf, NULL, k);
+               }
+            }
+         }
+         s++;
+         if (s > seqlen - TRIM_SIL_STATE_NUM)
+            break;
+         label = label->succ;
+      }
+      i++;
+      j = 2;
+   }
+}
+
+/* CalOneDimGenErr: Calcuate the generation error for certain dimension */
+static float CalOneDimGenErr(MgeTrnInfo * mtInfo, MgeStream * mst, PdfStream * pst, int p, int m)
+{
+   int t, origStart, nGainIdx;
+   float diff, err = 0.0f, wt;
+   MgeStream *gain_mst;
+
+   /* for gain weight */
+   nGainIdx = mtInfo->nGainDimIndex;
+   gain_mst = &(mtInfo->mst[mtInfo->nGainStreamIndex]);
+
+   diff = 0.0f;
+   origStart = pst->origStart - 1;
+   for (t = 1; t <= pst->T; t++) {
+      diff = (pst->C[t][m] - mst->origObs[t + origStart][m]);
+      wt = 1.0f;
+      /* gain weighting */
+      if (mtInfo->pbGainWght[p]) {
+         if (nGainIdx != m || p != mtInfo->nGainStreamIndex)
+            wt *= CalGainWght(gain_mst->origObs[t][nGainIdx], mtInfo->fGainWghtComp);
+      }
+      err += diff * diff * wt;
+   }
+   return err;
+}
+
+/* AccOneDimGenErr: Accumulate the generation error for certain dimension */
+static void AccOneDimGenErr(MgeTrnInfo * mtInfo, MgeStream * mst, PdfStream * pst, int p, int m)
+{
+   float fErr;
+
+   /* calculate generation error for one dimension */
+   fErr = CalOneDimGenErr(mtInfo, mst, pst, p, m);
+   if (mtInfo->statInfo != NULL)
+      mtInfo->statInfo->currErrAcc[p][m] += fErr;
+}
+
+/* CalGenErrorForBA: Calcuate the total generation error for current generated segment/utterance */
+static float CalGenErrorForBA(MgeTrnInfo * mtInfo, GenInfo * genInfo)
+{
+   MgeStream *mst;
+   PdfStream *pst;
+   int p, m;
+   float fTotalErr, fErr;
+
+   fTotalErr = 0.0;
+   for (p = 1; p <= genInfo->nPdfStream[0]; p++) {
+      if (!mtInfo->pbAccErr[p])
+         continue;
+
+      mst = &(mtInfo->mst[p]);
+      pst = &(genInfo->pst[p]);
+      for (m = 1; m <= pst->order; m += 1) {
+         ParaGenOneDim(pst, m, FALSE);
+         fErr = CalOneDimGenErr(mtInfo, mst, pst, p, m);
+         fTotalErr += fErr * mtInfo->DWght[p][m];
+      }
+   }
+
+   return fTotalErr;
+}
+
+/* HMMTrainByMge: */
+static void HmmTrainByMge(MgeTrnInfo * mtInfo, float stepSize, Boolean bOnlyAccErr)
+{
+   GenInfo *genInfo;
+   MgeStream *mst;
+   PdfStream *pst;
+   int p, m;
+
+   mtInfo->currStepSize = stepSize;
+   genInfo = mtInfo->genInfo;
+
+   for (p = 1; p <= genInfo->nPdfStream[0]; p++) {
+      mst = &(mtInfo->mst[p]);
+      pst = &(genInfo->pst[p]);
+      for (m = 1; m <= pst->order; m += 1) {
+         if (mtInfo->pbMTrn[p] && !bOnlyAccErr)
+            CalcMgeTrnInfo(mst, pst, m);        /* calculate the info for MGE updating */
+         else if (mtInfo->pbAccErr[p])
+            ParaGenOneDim(pst, m, FALSE);
+
+         /* calculation of MGE updating ratio */
+         if (mtInfo->pbMTrn[p] && !bOnlyAccErr) {
+            SeqPDUpdate(mtInfo, mst, pst, p, m);
+         }
+         if (mtInfo->pbAccErr[p])
+            AccOneDimGenErr(mtInfo, mst, pst, p, m);
+      }
+   }
+}
+
+/* EXPORT->OneSentMgeTrain: MGE-based HMM training for one utterance */
+void OneSentMgeTrain(MgeTrnInfo * mtInfo, char *labfn, char *datafn, float stepSize)
+{
+   SetupMgeTrnInfo(mtInfo, labfn, datafn);
+   SetupPdfStreams(mtInfo->genInfo, -1, -1);
+   HmmTrainByMge(mtInfo, stepSize, FALSE);
+   ResetMgeTrnInfo(mtInfo);
+}
+
+/* AccGenError: Accumulate the generation error for each dimension */
+static void AccGenError(MgeTrnInfo * mtInfo)
+{
+   HmmTrainByMge(mtInfo, 0.0, TRUE);
+}
+
+/* EXPORT->OneSentGenErrAcc: Accumulate generation error for one utterance */
+void OneSentGenErrAcc(MgeTrnInfo * mtInfo, char *labfn, char *datafn)
+{
+   SetupMgeTrnInfo(mtInfo, labfn, datafn);
+   SetupPdfStreams(mtInfo->genInfo, -1, -1);
+   AccGenError(mtInfo);
+   ResetMgeTrnInfo(mtInfo);
+}
+
+/* UpdateOneMSDWeight: Update MSD mixture weight for one state models */
+static void UpdateOneMSDWeight(MgeTrnInfo * mtInfo, StateElem * se, float all_occ, int p)
+{
+   int l, stm;
+   GenInfo *genInfo;
+   PdfStream *pst;
+   MgeStream *mst;
+   MuAcc *ma;
+   MixtureElem *cpdf;
+
+   genInfo = mtInfo->genInfo;
+   if (genInfo->nPdfStream[p] <= 1)
+      return;
+   pst = genInfo->pst + p;
+   mst = mtInfo->mst + p;
+
+   /* update Mixture weight */
+   for (l = 0; l < pst->win.num; l++) {
+      /* get corresponding stream & dimension index */
+      stm = mst->stmIdx[l + 1];
+      cpdf = se->info->pdf[stm].info->spdf.cpdf;        /* voiced space */
+      /* mean acc */
+      ma = (MuAcc *) GetHook(cpdf[1].mpdf->mean);
+      if (ma != NULL) {
+         cpdf[1].weight = ma->occ / all_occ;    /* voiced space weight */
+         if (cpdf[1].weight > MAX_MSD_WGHT)
+            cpdf[1].weight = MAX_MSD_WGHT;
+         else if (cpdf[1].weight < MIN_MSD_WGHT)
+            cpdf[1].weight = MIN_MSD_WGHT;
+         cpdf[2].weight = 1.0f - cpdf[1].weight;        /* unvoiced space weight */
+      }
+   }
+}
+
+/* GetAllUVOcc: */
+static float GetAllUVOcc(MgeTrnInfo * mtInfo, StateElem * se, int p)
+{
+   GenInfo *genInfo;
+   PdfStream *pst;
+   MgeStream *mst;
+   MuAcc *ma;
+   MixtureElem *cpdf;
+   int stm;
+   float all_occ = 0.0f;
+
+   genInfo = mtInfo->genInfo;
+   pst = genInfo->pst + p;
+   mst = mtInfo->mst + p;
+   stm = mst->stmIdx[1];
+   cpdf = se->info->pdf[stm].info->spdf.cpdf;
+   if (genInfo->nPdfStream[p] <= 1) {
+      return 0.0f;
+   }
+
+   /* voiced space */
+   ma = (MuAcc *) GetHook(cpdf[1].mpdf->mean);
+   if (ma != NULL)
+      all_occ += ma->occ;
+   /* unvoice space */
+   ma = (MuAcc *) GetHook(cpdf[2].mpdf->mean);
+   if (ma != NULL)
+      all_occ += ma->occ;
+   return all_occ;
+}
+
+/* EXPORT->UpdateAllMSDWeight: Update MSD mixture weight for all state models */
+void UpdateAllMSDWeight(MgeTrnInfo * mtInfo)
+{
+   int p;
+   UPDSet uFlags;
+   HMMSet *hset;
+   HSetKind hsKind;
+   HMMScanState hss;
+   StateElem *se;
+   GenInfo *genInfo;
+   float all_occ;
+
+   genInfo = mtInfo->genInfo;
+   hset = mtInfo->genInfo->hset;
+   hsKind = hset->hsKind;
+   uFlags = mtInfo->uFlags;
+
+   NewHMMScan(hset, &hss);
+   do {
+      se = hss.se;
+      for (p = 1; p <= genInfo->nPdfStream[0]; p++) {
+         all_occ = GetAllUVOcc(mtInfo, se, p);
+         if (all_occ <= 0.0f)
+            continue;
+         UpdateOneMSDWeight(mtInfo, se, all_occ, p);
+      }
+   } while (GoNextState(&hss, FALSE));
+   EndHMMScan(&hss);
+}
+
+/* GetPrevSegIdx: Get the index of previous segment */
+static Boolean GetPrevSegIdx(GenInfo * genInfo, int curr_i, int curr_j, int *prev_i, int *prev_j)
+{
+   int j;
+
+   if (curr_j > 1) {
+      *prev_i = curr_i;
+      *prev_j = curr_j - 1;
+      return TRUE;
+   }
+   if (curr_i <= 1)
+      return FALSE;
+
+   *prev_i = curr_i - 1;
+   j = 1;
+   while (genInfo->durations[*prev_i][j] > 0) {
+      j++;
+   }
+   if (j <= 1)
+      return FALSE;
+   *prev_j = j - 1;
+   return TRUE;
+}
+
+/* GetNextSegIdx: Get the index of next segment */
+static Boolean GetNextSegIdx(GenInfo * genInfo, int curr_i, int curr_j, int *next_i, int *next_j)
+{
+   if (genInfo->durations[curr_i][curr_j + 1] > 0) {
+      *next_i = curr_i;
+      *next_j = curr_j + 1;
+      return TRUE;
+   }
+   if (curr_i >= genInfo->labseqlen)
+      return FALSE;
+
+   *next_i = curr_i + 1;
+   *next_j = 1;
+   if (genInfo->durations[*next_i][*next_j] <= 0)
+      return FALSE;
+   return TRUE;
+}
+
+/* ShiftOneFrame: Shift one frame of the boundary (before the segment of (labi, statej)) */
+static int ShiftOneFrame(GenInfo * genInfo, int labi, int statej, ShiftType type)
+{
+   int nMod, pi, pj, ni, nj;
+   Boolean bFlag;
+
+   nMod = 1;
+   bFlag = GetPrevSegIdx(genInfo, labi, statej, &pi, &pj);
+   if (!bFlag)
+      return INVALID_SHIFT;
+
+   if (type == ST_Left) {
+      if (genInfo->durations[pi][pj] > 1) {
+         genInfo->durations[pi][pj] -= 1;
+         genInfo->durations[labi][statej] += 1;
+      } else {
+         nMod += ShiftOneFrame(genInfo, pi, pj, type);
+         if (nMod < 0)
+            return INVALID_SHIFT;
+         genInfo->durations[pi][pj] -= 1;
+         genInfo->durations[labi][statej] += 1;
+      }
+   } else if (type == ST_Right) {
+      if (genInfo->durations[labi][statej] > 1) {
+         genInfo->durations[labi][statej] -= 1;
+         genInfo->durations[pi][pj] += 1;
+      } else {
+         bFlag = GetNextSegIdx(genInfo, labi, statej, &ni, &nj);
+         if (!bFlag)
+            return INVALID_SHIFT;
+         nMod += ShiftOneFrame(genInfo, ni, nj, type);
+         if (nMod < 0)
+            return INVALID_SHIFT;
+         genInfo->durations[labi][statej] -= 1;
+         genInfo->durations[pi][pj] += 1;
+      }
+   }
+   return nMod;
+}
+
+/* ShiftBackOneFrame: Shift back the boundary */
+static Boolean ShiftBackOneFrame(GenInfo * genInfo, int labi, int statej, ShiftType type, int nMod)
+{
+   int ni, nj;
+
+   if (type == ST_Right) {
+      for (; nMod > 1; nMod--) {
+         GetNextSegIdx(genInfo, labi, statej, &ni, &nj);
+         labi = ni;
+         statej = nj;
+      }
+      nMod = ShiftOneFrame(genInfo, labi, statej, ST_Left);
+   } else if (type == ST_Left) {
+      for (; nMod > 1; nMod--) {
+         GetPrevSegIdx(genInfo, labi, statej, &ni, &nj);
+         labi = ni;
+         statej = nj;
+      }
+      nMod = ShiftOneFrame(genInfo, labi, statej, ST_Right);
+   }
+   assert(nMod > 0);
+   return TRUE;
+}
+
+/* ShiftBackSegBound: Shift back the boundary for several frames */
+static Boolean ShiftBackSegBound(GenInfo * genInfo, int labi, int statej, ShiftType type, int *pnMod, int nShiftFrms)
+{
+   int i, nMod;
+
+   for (i = nShiftFrms; i >= 1; i--) {
+      nMod = ShiftBackOneFrame(genInfo, labi, statej, type, pnMod[i]);
+      assert(nMod > 0);
+   }
+   return TRUE;
+}
+
+/* ShiftSegBound: Shift the boundary for several frames */
+static Boolean ShiftSegBound(GenInfo * genInfo, int labi, int statej, ShiftType type, int *pnMod, int nShiftFrms)
+{
+   int i, nMod;
+
+   for (i = 1; i <= nShiftFrms; i++) {
+      nMod = ShiftOneFrame(genInfo, labi, statej, type);
+      if (nMod < 0) {
+         for (i--; i >= 1; i--)
+            ShiftBackOneFrame(genInfo, labi, statej, type, pnMod[i]);
+         return FALSE;
+      }
+      pnMod[i] = nMod;
+      if (nMod > pnMod[0]) {
+         for (; i >= 1; i--)
+            ShiftBackOneFrame(genInfo, labi, statej, type, pnMod[i]);
+         return FALSE;
+      }
+   }
+   return TRUE;
+}
+
+/* AdjustOneStepLab: Adjust one label from the results of bound adjust */
+static void AdjustOneStepLab(Label * label, int nMod, HTime frameRate, ShiftType type)
+{
+   int j;
+
+   /* shift left */
+   if (type == ST_Left) {
+      label->start -= frameRate;
+      for (j = 0; j < nMod - 1; j++) {
+         label = label->pred;
+         label->start -= frameRate;
+         label->end -= frameRate;
+      }
+      label->pred->end -= frameRate;
+      assert(label->pred->end > label->pred->start);
+   }
+   /* shift right */
+   else if (type == ST_Right) {
+      label->pred->end += frameRate;
+      for (j = 0; j < nMod - 1; j++) {
+         label->start += frameRate;
+         label->end += frameRate;
+         label = label->succ;
+      }
+      label->start += frameRate;
+      assert(label->start < label->end);
+   }
+}
+
+/* AdjustLabel: Adjust the label from the results of bound adjust */
+static void AdjustLabel(Label * label, int *pnMod, int nShiftSteps, HTime frameRate, ShiftType type)
+{
+   int i;
+
+   for (i = 1; i <= nShiftSteps; i++) {
+      AdjustOneStepLab(label, pnMod[i], frameRate, type);
+   }
+}
+
+/* AdjustOneBound: Try to shift the boundary to left/right, and choose the direction with minimum generation error */
+static Boolean AdjustOneBound(MgeTrnInfo * mtInfo, GenInfo * genInfo, float *fErr, int labi, int statej, int nBAStep)
+{
+   int start, end, ti, tj, nPos, sdx;
+   float origErr, slErr, srErr;
+   Label *label;
+   int pnLeftMod[MAX_BOUND_ADJ_LEN], pnRightMod[MAX_BOUND_ADJ_LEN];
+   Boolean bFlag;
+
+   nPos = 1;
+   for (sdx = 1, ti = 1; ti <= genInfo->labseqlen; ti++) {
+      for (tj = 1; genInfo->durations[ti][tj] > 0; tj++, sdx++) {
+         if (ti == labi && tj == statej)
+            break;
+         nPos += genInfo->durations[ti][tj];
+      }
+      if (genInfo->durations[ti][tj] > 0)
+         break;
+   }
+   start = nPos - mtInfo->nBoundAdjWin;
+   end = nPos + mtInfo->nBoundAdjWin;
+   if (start <= 0)
+      start = 1;
+   if (end >= genInfo->tframe)
+      end = genInfo->tframe;
+
+   /* maximum forced shift length */
+   pnLeftMod[0] = pnRightMod[0] = MAX_BOUND_ADJ_LEN;
+   /* calculate the gen error for original boundary */
+   SetupPdfStreams(genInfo, start, end);
+   origErr = CalGenErrorForBA(mtInfo, genInfo);
+   slErr = srErr = origErr + 10.0f;
+
+   /* shift the boundary to left, and re-calculate the gen error */
+   bFlag = ShiftSegBound(genInfo, labi, statej, ST_Left, pnLeftMod, nBAStep);
+   if (bFlag) {
+      SetupPdfStreams(genInfo, start, end);
+      slErr = CalGenErrorForBA(mtInfo, genInfo);
+      ShiftBackSegBound(genInfo, labi, statej, ST_Left, pnLeftMod, nBAStep);
+   }
+
+   /* shift the boundary to right, and re-calculate the gen error */
+   bFlag = ShiftSegBound(genInfo, labi, statej, ST_Right, pnRightMod, nBAStep);
+   if (bFlag) {
+      SetupPdfStreams(genInfo, start, end);
+      srErr = CalGenErrorForBA(mtInfo, genInfo);
+      ShiftBackSegBound(genInfo, labi, statej, ST_Right, pnRightMod, nBAStep);
+   }
+
+   /* adjust label */
+   label = GetLabN(genInfo->labseq->head, sdx);
+   if (slErr < origErr && slErr < srErr) {
+      ShiftSegBound(genInfo, labi, statej, ST_Left, pnLeftMod, nBAStep);
+      AdjustLabel(label, pnLeftMod, nBAStep, genInfo->frameRate, ST_Left);
+      if (fErr != NULL)
+         *fErr = slErr;
+      return TRUE;
+   } else if (srErr < origErr) {
+      ShiftSegBound(genInfo, labi, statej, ST_Right, pnRightMod, nBAStep);
+      AdjustLabel(label, pnRightMod, nBAStep, genInfo->frameRate, ST_Right);
+      if (fErr != NULL)
+         *fErr = srErr;
+      return TRUE;
+   }
+
+   return FALSE;
+}
+
+/* CheckAdjFlagWin: */
+static Boolean CheckAdjFlagWin(IntVec pbAdjFlag, int nPos, int nWinLen)
+{
+   int nVecSize, i, start, end;
+
+   nVecSize = IntVecSize(pbAdjFlag);
+   start = nPos - nWinLen;
+   end = nPos + nWinLen;
+   if (start < 1)
+      start = 1;
+   if (end > nVecSize)
+      end = nVecSize;
+   for (i = start; i <= end; i++) {
+      if (pbAdjFlag[i])
+         return TRUE;
+   }
+   return FALSE;
+}
+
+/* EXPORT->OneSentBoundAdjust: Boundary adjustment for one utterance */
+int OneSentBoundAdjust(MgeTrnInfo * mtInfo, char *labfn, char *datafn, char *outlabdir, int nBAIter, int nBALen, Boolean bAccErr)
+{
+   GenInfo *genInfo;
+   int i, j, sdx, nSegNum, nAdjNum, nTotalAdj;
+   Boolean bFlag;
+   char labExt[16];
+   float fErr = 0.0f;
+   IntVec pbPrevAdjFlag, pbCurrAdjFlag;
+
+   genInfo = mtInfo->genInfo;
+   if (nBAIter <= 0)
+      nBAIter = 1;              /* temporary maximum value */
+
+   /* initializatioin for mge train info */
+   SetupMgeTrnInfo(mtInfo, labfn, datafn);
+   /* create vecctor to store the boundary adjustment flags of last iteration */
+   for (nSegNum = 0, i = 1; i <= genInfo->labseqlen; i++) {
+      for (j = 1; genInfo->durations[i][j] > 0; j++)
+         nSegNum++;
+   }
+   pbPrevAdjFlag = CreateIntVec(mtInfo->mgeMem, nSegNum);
+   pbCurrAdjFlag = CreateIntVec(mtInfo->mgeMem, nSegNum);
+   for (sdx = 1; sdx <= nSegNum; sdx++) {
+      pbPrevAdjFlag[sdx] = TRUE;
+      pbCurrAdjFlag[sdx] = FALSE;
+   }
+
+   nTotalAdj = 0;
+   do {
+      nAdjNum = 0;
+      for (sdx = 1, i = 1; i <= genInfo->labseqlen; i++) {
+         for (j = 1; genInfo->durations[i][j] > 0; j++, sdx++) {
+            /* check whether the boundary adjustment is necessary */
+            if (CheckAdjFlagWin(pbPrevAdjFlag, sdx, mtInfo->nBoundAdjWin) == FALSE && CheckAdjFlagWin(pbCurrAdjFlag, sdx, mtInfo->nBoundAdjWin) == FALSE)
+               continue;
+            bFlag = AdjustOneBound(mtInfo, genInfo, &fErr, i, j, nBALen);
+            if (bFlag)
+               nAdjNum++;
+            pbCurrAdjFlag[sdx] = bFlag;
+         }
+      }
+      if (nAdjNum <= 0) {
+         nBALen--;
+         continue;
+      }
+      nBAIter--;
+
+      nTotalAdj += nAdjNum;
+      for (sdx = 1; sdx <= nSegNum; sdx++) {
+         pbPrevAdjFlag[sdx] = pbCurrAdjFlag[sdx];
+         pbCurrAdjFlag[sdx] = FALSE;
+      }
+   } while (nBAIter > 0 && nBALen > 0);
+
+   /* output label files */
+   if (outlabdir != NULL) {
+      ExtnOf(labfn, labExt);
+      MakeFN(datafn, outlabdir, labExt, labfn);
+   }
+   LSave(labfn, genInfo->labseq, HTK);
+
+   /* accumulate generation error */
+   SetupPdfStreams(mtInfo->genInfo, -1, -1);
+   if (bAccErr)
+      AccGenError(mtInfo);
+
+   /* reset the mge train info */
+   ResetMgeTrnInfo(mtInfo);
+   return nTotalAdj;
+}
+
+/* CopyOneMixPDF: */
+static void CopyOneMixPDF(HMMSet * hset, MixPDF * mp_src, MixPDF * mp_dest)
+{
+   int size;
+
+   size = VectorSize(mp_src->mean);
+   if (size <= 0)
+      return;
+
+   /* copy mean parameter */
+   CopyVector(mp_src->mean, mp_dest->mean);
+   /* copy variance parameter */
+   /* only support diagonal covariance */
+   if (mp_src->ckind == DIAGC || mp_src->ckind == INVDIAGC) {
+      CopyVector(mp_src->cov.var, mp_dest->cov.var);
+   }
+}
+
+/* CopyOneModelPara: */
+static void CopyModelPara(HMMSet * hset, HLink hmm_src, HLink hmm_dest)
+{
+   int j, s, m;
+   StreamInfo *sti_src, *sti_dest;
+
+   for (j = 2; j < hmm_src->numStates; j++) {
+      for (s = 1; s <= hset->swidth[0]; s++) {
+         sti_src = hmm_src->svec[j].info->pdf[s].info;
+         sti_dest = hmm_dest->svec[j].info->pdf[s].info;
+         for (m = 1; m <= sti_src->nMix; m++) {
+            CopyOneMixPDF(hset, sti_src->spdf.cpdf[m].mpdf, sti_dest->spdf.cpdf[m].mpdf);
+         }
+      }
+   }
+}
+
+/* TransformOneModel: Transform model parameter */
+static void TransformOneModel(HMMSet * hset, HLink hmm)
+{
+   int j, s, m;
+   StreamInfo *sti;
+   AdaptXForm *xform;
+   Boolean full;
+
+   xform = hset->curXForm;
+   if (xform->xformSet->xkind == MLLRCOV || xform->xformSet->xkind == CMLLR || xform->xformSet->xkind == SEMIT)
+      full = TRUE;
+   else
+      full = FALSE;
+
+   for (j = 2; j < hmm->numStates; j++) {
+      for (s = 1; s <= hset->swidth[0]; s++) {
+         sti = hmm->svec[j].info->pdf[s].info;
+         for (m = 1; m <= sti->nMix; m++) {
+            ApplyCompXForm(sti->spdf.cpdf[m].mpdf, xform, full);
+         }
+      }
+   }
+}
+
+/* EXPORT->OneSentTransform: Apply transform to the models related to this sentences */
+void OneSentTransform(MgeTrnInfo * mtInfo, char *labfn, char *datafn)
+{
+   int i;
+   Transcription *tr;
+   MLink hmacro;
+   HLink hmm_trans, hmm_orig;
+   Label *label;
+   LabId id;
+
+   /* load a given input label file */
+   tr = LOpen(mtInfo->mgeMem, labfn, UNDEFF);
+   /* transform the models related to each labels */
+   for (i = 1; i <= CountLabs(tr->head); i++) {
+      label = GetLabN(tr->head, i);
+      if (label->auxLab[1] == NULL)     /* usually model name is written in auxLab[1] */
+         continue;
+
+      /* find model */
+      id = label->auxLab[1];
+      if ((hmacro = FindMacroName(mtInfo->hset, 'l', id)) == NULL)
+         HError(9935, "OneSentTransform: Cannot find hmm %s in current model list", id->name);
+      hmm_trans = (HLink) hmacro->structure;
+      if ((hmacro = FindMacroName(mtInfo->orighset, 'l', id)) == NULL)
+         HError(9935, "OneSentTransform: Cannot find hmm %s in original model list", id->name);
+      hmm_orig = (HLink) hmacro->structure;
+      hmm_trans->hook = hmm_orig;       /* link reference hmm */
+
+      /* first copy model parameter from original hmm */
+      CopyModelPara(mtInfo->hset, hmm_orig, hmm_trans);
+
+      /* underlying assumption: no tying between mixs inside one hmm */
+      /* transform model parameter */
+      TransformOneModel(mtInfo->hset, hmm_trans);
+   }
+}
+
+/* UpdateMeanXForm: Update transform of mean */
+static void UpdateMeanXForm(MgeTrnInfo * mtInfo, LinXForm * lxform, LinXForm * ref_lxform, Vector ref_mean, Vector ivar, int dim, float rate, float limitStep, IntVec pnFloorNum)
+{
+   int b, bsize;
+   Matrix A, ref_A;
+   float upRate, meanLimit;
+   float fold, fmean, fsvar, fbias;
+   int bi, bj, i, j;
+
+   /* check dimensions */
+   assert(lxform->vecSize > 0);
+   limitStep = MAX_MEAN_UP_STEP_XFORM * limitStep;
+
+   bsize = 0;
+   /* locate the corresponding block */
+   for (b = 1, i = 1; b <= IntVecSize(lxform->blockSize); b++) {
+      bsize = lxform->blockSize[b];
+      if (i + bsize > dim)
+         break;
+      i += bsize;
+   }
+   A = lxform->xform[b];
+
+   /* reference for limit the update range */
+   if (ref_lxform != NULL)
+      ref_A = ref_lxform->xform[b];
+   else
+      ref_A = NULL;
+
+   fsvar = 1.0f / (float) sqrt(ivar[dim]);
+   fbias = 0.0f;
+   bi = dim - i + 1;
+   for (bj = 1, j = i; bj <= bsize; bj++, j++) {
+      /* ignore if A[i][j] = 0 */
+      if (A[bi][bj] == 0.0f)
+         continue;
+      /* update rate for each element */
+      fmean = ref_mean[j];
+
+      upRate = fmean * rate;
+      if (fmean != 0.0f)
+         meanLimit = limitStep * fsvar / (float) fabs(fmean);
+      else
+         meanLimit = limitStep * fsvar;
+      /* limit the update step */
+      if (mtInfo->bStepLimit) {
+         CheckUpStepLimit(&upRate, meanLimit, STAT_UP_STEP_LIMIT, pnFloorNum);
+      }
+      fold = A[bi][bj];
+      /* update parameter */
+      A[bi][bj] -= upRate;
+      /* limit the update range */
+      if (ref_A != NULL) {
+         CheckLinUpRange(A[bi] + bj, ref_A[bi] + bj, MAX_UP_RATE_MEAN_XFORM, !STAT_UP_STEP_LIMIT, pnFloorNum);
+      }
+      /* prevent A[bi][bj] equal to zero */
+      if (A[bi][bj] == 0.0f)
+         A[bi][bj] = (float) SMALL_VALUE;
+   }
+
+   /* apply bias if required (igore if bias[i] = 0 */
+   if (lxform->bias != NULL && lxform->bias[dim] != 0.0f) {
+      upRate = rate * g_fMeanBiasScale_xform;
+      meanLimit = limitStep / (float) sqrt(ivar[dim]);
+      /* limit the update step */
+      if (mtInfo->bStepLimit) {
+         CheckUpStepLimit(&upRate, meanLimit, STAT_UP_STEP_LIMIT, pnFloorNum);
+      }
+      /* update parameter */
+      lxform->bias[dim] -= upRate;
+      /* limit the update range */
+      if (ref_lxform != NULL) {
+         CheckLinUpRange(lxform->bias + dim, ref_lxform->bias + dim, MAX_UP_RATE_MEAN_XFORM, !STAT_UP_STEP_LIMIT, pnFloorNum);
+      }
+      /* prevent A[bi][bj] equal to zero */
+      if (lxform->bias[dim] == 0.0f)
+         lxform->bias[dim] = (float) SMALL_VALUE;
+   }
+}
+
+/* UpdateVarXForm: Update transform of variance. currently, only support diagonal variance matrix */
+static void UpdateVarXForm(MgeTrnInfo * mtInfo, LinXForm * lxform, LinXForm * ref_lxform, Vector ref_ivar, int dim, float rate, float limitStep, IntVec pnFloorNum)
+{
+   int b, bsize;
+   Matrix A, ref_A;
+   float upRate, varLimit;
+   int bi, bj, i, j;
+
+   /* check dimensions */
+   assert(lxform->vecSize > 0);
+   varLimit = MAX_VAR_UP_STEP_XFORM * limitStep;
+
+   bsize = 0;
+   /* locate the corresponding block */
+   for (b = 1, i = 1; b <= IntVecSize(lxform->blockSize); b++) {
+      bsize = lxform->blockSize[b];
+      if (i + bsize > dim)
+         break;
+      i += bsize;
+   }
+   A = lxform->xform[b];
+
+   /* reference for limit the update range */
+   if (ref_lxform != NULL)
+      ref_A = ref_lxform->xform[b];
+   else
+      ref_A = NULL;
+
+   bi = dim - i + 1;
+   for (bj = 1, j = i; bj <= bsize; bj++, j++) {
+      /* ignore if A[i][j] = 0 */
+      if (A[bi][bj] == 0.0f)
+         continue;
+      /* update rate for each element */
+      /* to be optimized, log vs. linear */
+      upRate = rate * ref_ivar[j] / A[bi][bj];
+      /* limit the update step */
+      if (mtInfo->bStepLimit) {
+         CheckUpStepLimit(&upRate, varLimit, STAT_UP_STEP_LIMIT, pnFloorNum);
+      }
+      /* update parameter */
+      A[bi][bj] *= (float) pow(10, upRate);
+      /* limit the update range */
+      if (ref_A != NULL) {
+         CheckLogUpRange(A[bi] + bj, ref_A[bi] + bj, MAX_UP_RATE_VAR_XFORM, !STAT_UP_STEP_LIMIT, pnFloorNum);
+      }
+      /* prevent A[bi][bj] less than zero */
+      if (A[bi][bj] <= 0.0f)
+         A[bi][bj] = (float) SMALL_VALUE;
+   }
+}
+
+/* SeqPDAdapt: Parameter updating by online PD */
+static void SeqPDAdapt(MgeTrnInfo * mtInfo, MgeStream * mst, PdfStream * pst, int p, int m)
+{
+   int s, i, j, k, l, stm, seqlen;
+   LabList *lablist;
+   Label *label;
+   LabId labid;
+   HMMDef *hmm, *ref_hmm;
+   MixPDF *mpdf, *ref_mpdf;
+   float upRate, limitStep;
+   GenInfo *genInfo;
+   MTStatInfo *statInfo;
+   float occ, all_occ;
+   LinXForm *xform, *ref_xform;
+   IntVec pnFloorNum = NULL;
+
+   genInfo = mtInfo->genInfo;
+   statInfo = mtInfo->statInfo;
+   ref_hmm = NULL;
+   ref_mpdf = NULL;
+   limitStep = (float) sqrt(mtInfo->currStepSize / mtInfo->initStepSize);
+
+   lablist = genInfo->labseq->head;
+   seqlen = CountLabs(lablist);
+   label = GetLabN(lablist, 1);
+   /*i: hmm index; j: state indexo; */
+   labid = label->auxLab[1];
+   for (s = 1, i = 1, j = 2; s <= TRIM_SIL_STATE_NUM; s++, j++) {
+      label = label->succ;
+      if (label->auxLab[1] != NULL) {
+         i++;
+         j = 1;
+         labid = label->auxLab[1];
+      }
+   }
+
+   ref_xform = NULL;
+   for (; s <= seqlen - TRIM_SIL_STATE_NUM;) {
+      hmm = genInfo->hmm[i];
+      ref_hmm = hmm->hook;      /* ref_hmm has been hooked in ::OneSentTransform */
+
+      for (; j < hmm->numStates; j++) {
+         all_occ = (int) ((label->end - label->start) / mtInfo->genInfo->frameRate + 0.5);
+         /* calculate updating ratio for eah state HMM */
+         occ = CalcUpdateRatio(mtInfo, mst, pst, label, p, m);
+
+         /* update transform parameters */
+         for (l = 0; l < pst->win.num; l++) {
+            /* get corresponding stream & dimension index */
+            stm = mst->stmIdx[l + 1];
+            if (genInfo->nPdfStream[p] > 1)
+               k = m;
+            else
+               k = l * pst->order + m;
+
+            mpdf = hmm->svec[j].info->pdf[stm].info->spdf.cpdf[1].mpdf;
+            if (ref_hmm != NULL)
+               ref_mpdf = ref_hmm->svec[j].info->pdf[stm].info->spdf.cpdf[1].mpdf;
+
+            /* updating transform of mean */
+            if (mtInfo->uFlags & UPMEANS) {
+               /* get related transform */
+               xform = GetRelateXForm(mtInfo->hset, mpdf, MLLRMEAN);
+               if (ref_hmm != NULL)
+                  ref_xform = GetRelateXForm(mtInfo->orighset, mpdf, MLLRMEAN);
+
+               /* calculate updating step */
+               upRate = mtInfo->currStepSize * (float) mtInfo->mrat[l + 1];
+               if (mtInfo->bMScale)
+                  upRate *= mtInfo->SRMean[p][m];
+               if (mtInfo->bMVar)
+                  upRate *= mpdf->cov.var[k];
+
+               if (statInfo != NULL)
+                  pnFloorNum = statInfo->pnMeanFloor[p][m][l + 1];
+               /* update transform of mean */
+               UpdateMeanXForm(mtInfo, xform, ref_xform, ref_mpdf->mean, mpdf->cov.var, k, upRate, limitStep, pnFloorNum);
+            }
+
+            /* updating transform of variance */
+            /* currently, only support diagonal covariance */
+            if (mtInfo->uFlags & UPVARS) {
+               /* get related transform */
+               xform = GetRelateXForm(mtInfo->hset, mpdf, MLLRVAR);
+               if (ref_hmm != NULL)
+                  ref_xform = GetRelateXForm(mtInfo->orighset, mpdf, MLLRVAR);
+
+               /* calculate updating step */
+               upRate = mtInfo->currStepSize * (float) mtInfo->vrat[l + 1];
+               if (mtInfo->bMScale)
+                  upRate *= mtInfo->SRVar[p][m];
+
+               if (statInfo != NULL)
+                  pnFloorNum = statInfo->pnVarFloor[p][m][l + 1];
+               /* update transform of variance */
+               UpdateVarXForm(mtInfo, xform, ref_xform, ref_mpdf->cov.var, k, upRate, limitStep, pnFloorNum);
+            }
+         }
+         s++;
+         if (s > seqlen - TRIM_SIL_STATE_NUM)
+            break;
+         label = label->succ;
+      }
+      i++;
+      j = 2;
+   }
+}
+
+/* AdaptHMMByMge: MGE adaptation training, currenly only support SEQ_PD updating algorithm */
+static void AdaptHMMByMge(MgeTrnInfo * mtInfo, float stepSize, Boolean bOnlyAccErr)
+{
+   GenInfo *genInfo;
+   MgeStream *mst;
+   PdfStream *pst;
+   int p, m;
+
+   mtInfo->currStepSize = stepSize;
+   genInfo = mtInfo->genInfo;
+
+   for (p = 1; p <= genInfo->nPdfStream[0]; p++) {
+      mst = &(mtInfo->mst[p]);
+      pst = &(genInfo->pst[p]);
+      for (m = 1; m <= pst->order; m += 1) {
+         if (mtInfo->pbMTrn[p] && !bOnlyAccErr)
+            CalcMgeTrnInfo(mst, pst, m);        /* calculate the info for MGE updating */
+         else if (mtInfo->pbAccErr[p])
+            ParaGenOneDim(pst, m, FALSE);
+
+         /* calculation of MGE updating ratio */
+         if (mtInfo->pbMTrn[p] && (mtInfo->uFlags & UPXFORM) && !bOnlyAccErr) {
+            SeqPDAdapt(mtInfo, mst, pst, p, m);
+         }
+         if (mtInfo->pbAccErr[p])
+            AccOneDimGenErr(mtInfo, mst, pst, p, m);
+      }
+   }
+}
+
+/* EXPORT->OneSentMgeAdapt: MGE-based adaptation for one utterance */
+void OneSentMgeAdapt(MgeTrnInfo * mtInfo, char *labfn, char *datafn, float stepSize)
+{
+   SetupMgeTrnInfo(mtInfo, labfn, datafn);
+   SetupPdfStreams(mtInfo->genInfo, -1, -1);
+   AdaptHMMByMge(mtInfo, stepSize, FALSE);
+   ResetMgeTrnInfo(mtInfo);
+}
+
+/* ------------------------ End of HMTrain.c ----------------------- */
diff -pbBEwurNa --ignore-matching-lines='.*vc_id.*' HTK-3.4.1/HTKLib/HMTrain.h HTS-2.2_for_HTK-3.4.1/HTKLib/HMTrain.h
--- HTK-3.4.1/HTKLib/HMTrain.h	1970-01-01 09:00:00.000000000 +0900
+++ HTS-2.2_for_HTK-3.4.1/HTKLib/HMTrain.h	2011-06-16 13:15:50.000000000 +0900
@@ -0,0 +1,172 @@
+/* ----------------------------------------------------------------- */
+/*           The HMM-Based Speech Synthesis System (HTS)             */
+/*           developed by HTS Working Group                          */
+/*           http://hts.sp.nitech.ac.jp/                             */
+/* ----------------------------------------------------------------- */
+/*                                                                   */
+/*  Copyright (c) 2001-2011  Nagoya Institute of Technology          */
+/*                           Department of Computer Science          */
+/*                                                                   */
+/*                2001-2008  Tokyo Institute of Technology           */
+/*                           Interdisciplinary Graduate School of    */
+/*                           Science and Engineering                 */
+/*                                                                   */
+/* All rights reserved.                                              */
+/*                                                                   */
+/* Redistribution and use in source and binary forms, with or        */
+/* without modification, are permitted provided that the following   */
+/* conditions are met:                                               */
+/*                                                                   */
+/* - Redistributions of source code must retain the above copyright  */
+/*   notice, this list of conditions and the following disclaimer.   */
+/* - Redistributions in binary form must reproduce the above         */
+/*   copyright notice, this list of conditions and the following     */
+/*   disclaimer in the documentation and/or other materials provided */
+/*   with the distribution.                                          */
+/* - Neither the name of the HTS working group nor the names of its  */
+/*   contributors may be used to endorse or promote products derived */
+/*   from this software without specific prior written permission.   */
+/*                                                                   */
+/* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND            */
+/* CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,       */
+/* INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF          */
+/* MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE          */
+/* DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS */
+/* BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,          */
+/* EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED   */
+/* TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,     */
+/* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON */
+/* ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,   */
+/* OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY    */
+/* OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE           */
+/* POSSIBILITY OF SUCH DAMAGE.                                       */
+/* ----------------------------------------------------------------- */
+/*         File: HMTrain.h: Minimize generation error                */
+/* ----------------------------------------------------------------- */
+
+#ifndef HMTRAIN_H
+#define HMTRAIN_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define WMAX               4    /* maximum # of window */
+#define LOW_FLOOR          1
+#define HIGH_FLOOR         2
+
+typedef enum _ShiftType {
+   ST_Left,
+   ST_Right
+} ShiftType;
+
+typedef enum _MFType {
+   MGE_EVAL = 0,
+   MGE_TRAIN = 1,
+   MGE_ADAPT = 2
+} MFType;
+
+/* Config information of MGE training */
+typedef struct {
+   int order;
+   DVector initErrAcc[SMAX];    /* accumulation of generation error */
+   DVector prevErrAcc[SMAX];    /* accumulation of generation error */
+   DVector currErrAcc[SMAX];    /* accumulation of generation error */
+   int pnTotalFrm[SMAX];        /* number of valid frames */
+   IMatrix *pnMeanFloor[SMAX];  /* # of mean flooring[1..Order][1..WinNum][1(Lower) 2(Upper)] */
+   IMatrix *pnVarFloor[SMAX];   /* # of var flooring [1..Order][1..WinNum][1(Lower) 2(Upper)] */
+} MTStatInfo;
+
+typedef struct {
+   Matrix origObs;
+   DMatrix quasi_invRef;
+   DMatrix quasi_invWUW;
+   DMatrix quasi_P;
+   DMatrix origMean;            /* mean vector of original feature sequence */
+   DMatrix origVar;             /* variance vector of original feature sequence */
+   DMatrix genMean;             /* mean vector of generated feature sequence */
+   DMatrix genVar;              /* variance vector of generated feature sequence */
+   DMatrix varRatio;            /* ratio between original and generated variance */
+   int stmIdx[WMAX];            /* model stream index [1..WinSize] */
+   int nInvQuaSize;             /* bandwith of quasi-diagonal inversion matrix */
+   int nVarWinSize;             /* size of the window for variance calculation */
+} MgeStream;
+
+typedef struct {
+   MemHeap *mgeMem;
+   GenInfo *genInfo;            /* Point to GenInfo */
+   MTStatInfo *statInfo;        /* Point to MTStatInfo */
+   MgeStream mst[SMAX];         /* Mge stream data */
+   HMMSet *hset;
+   HMMSet *orighset;            /* Original HMM set (before updating) */
+   Boolean bOrigHmmRef;         /* Whether re-load the original HMM as refernece */
+   MFType funcType;             /* Mge function type */
+   Boolean pbMTrn[SMAX];        /* Whether perform MGE train for the stream */
+   Boolean pbAccErr[SMAX];      /* Accumulate generation error */
+   int pnInvQuaSize[SMAX];      /* Bandwith of quasi-diagonal inversion matrix */
+   Boolean pbGVTrn[SMAX];       /* Whether incorporate GV component to MGE training */
+   int pnVarWin[SMAX];          /* Size of the window for variance calculation */
+   float fGVDistWght;           /* Distance weight for gv component */
+   float pfGVWght[SMAX];        /* Distance weight for gv component */
+   int nGainStreamIndex;        /* Stream index of gain in the vector */
+   int nGainDimIndex;           /* Dimension index of gain in the vector */
+   float fGainWghtComp;         /* Compensation for gain weighting */
+   Boolean pbGainWght[SMAX];    /* Log gain for weighting generation error */
+   float initStepSize;
+   float currStepSize;
+   Boolean bMVar;               /* Mutiply variance ratio for mean updating */
+   Boolean bMScale;             /* Mutiply scale ratio for mean updating */
+   Boolean bStepLimit;          /* Limit the updating rate for each step */
+   UPDSet uFlags;               /* Update flags */
+   Boolean bBoundAdj;           /* Adjust the segmentation boundary by MGE */
+   int nBoundAdjWin;            /* Size of the window for boundary adjustment */
+   int order;                   /* Total order of feature (order = vec_size / win_size) */
+   Vector SRMean[SMAX];         /* Scaling rate for different model parameter updating (mean) */
+   Vector SRVar[SMAX];          /* Scaling rate for different model parameter updating (var) */
+   Vector DWght[SMAX];          /* Distance weight for different dimension of parameters */
+   DVector mrat;                /* temporary updating rate for mean */
+   DVector vrat;                /* temporary updating rate for variance */
+} MgeTrnInfo;
+
+void InitMTrain();
+/*
+  Initialise module
+*/
+
+void OneSentMgeTrain(MgeTrnInfo * mtInfo, char *labfn, char *datafn, float stepSize);
+/*
+  MGE-based HMM training for one utterance 
+*/
+
+void OneSentGenErrAcc(MgeTrnInfo * mtInfo, char *labfn, char *datafn);
+/*
+  Accumulate generation error for one utterance
+*/
+
+void UpdateAllMSDWeight(MgeTrnInfo * mtInfo);
+/*
+  Update MSD mixture weight for all state models 
+*/
+
+int OneSentBoundAdjust(MgeTrnInfo * mtInfo, char *labfn, char *datafn, char *outlabdir, int nBAIter, int nBALen, Boolean bAccErr);
+/*
+  Boundary adjustment for one utterance
+*/
+
+void OneSentTransform(MgeTrnInfo * mtInfo, char *labfn, char *datafn);
+/*
+  Apply transform to the models related to this sentences
+*/
+
+void OneSentMgeAdapt(MgeTrnInfo * mtInfo, char *labfn, char *datafn, float stepSize);
+/*
+  MGE-based adaptation for one utterance
+*/
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif                          /* _HMTRAIN_H_ */
+
+/* ------------------------ End of HMTrain.h ----------------------- */
diff -pbBEwurNa --ignore-matching-lines='.*vc_id.*' HTK-3.4.1/HTKLib/HMap.c HTS-2.2_for_HTK-3.4.1/HTKLib/HMap.c
--- HTK-3.4.1/HTKLib/HMap.c	2009-03-13 03:45:31.000000000 +0900
+++ HTS-2.2_for_HTK-3.4.1/HTKLib/HMap.c	2011-06-16 13:18:29.000000000 +0900
@@ -32,6 +32,51 @@
 /*            File: HMap.c  - MAP Model Updates               */
 /* ----------------------------------------------------------- */
 
+/*  *** THIS IS A MODIFIED VERSION OF HTK ***                        */
+/* ----------------------------------------------------------------- */
+/*           The HMM-Based Speech Synthesis System (HTS)             */
+/*           developed by HTS Working Group                          */
+/*           http://hts.sp.nitech.ac.jp/                             */
+/* ----------------------------------------------------------------- */
+/*                                                                   */
+/*  Copyright (c) 2001-2011  Nagoya Institute of Technology          */
+/*                           Department of Computer Science          */
+/*                                                                   */
+/*                2001-2008  Tokyo Institute of Technology           */
+/*                           Interdisciplinary Graduate School of    */
+/*                           Science and Engineering                 */
+/*                                                                   */
+/* All rights reserved.                                              */
+/*                                                                   */
+/* Redistribution and use in source and binary forms, with or        */
+/* without modification, are permitted provided that the following   */
+/* conditions are met:                                               */
+/*                                                                   */
+/* - Redistributions of source code must retain the above copyright  */
+/*   notice, this list of conditions and the following disclaimer.   */
+/* - Redistributions in binary form must reproduce the above         */
+/*   copyright notice, this list of conditions and the following     */
+/*   disclaimer in the documentation and/or other materials provided */
+/*   with the distribution.                                          */
+/* - Neither the name of the HTS working group nor the names of its  */
+/*   contributors may be used to endorse or promote products derived */
+/*   from this software without specific prior written permission.   */
+/*                                                                   */
+/* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND            */
+/* CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,       */
+/* INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF          */
+/* MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE          */
+/* DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS */
+/* BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,          */
+/* EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED   */
+/* TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,     */
+/* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON */
+/* ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,   */
+/* OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY    */
+/* OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE           */
+/* POSSIBILITY OF SUCH DAMAGE.                                       */
+/* ----------------------------------------------------------------- */
+
 /*
   Calculates the MAP estimate of the new model parameters ASSUMING
   that the stats associated with the updates have been stored
@@ -75,7 +120,7 @@ static float minObs  = 0;        /* min 
 static int maxM;
 static int S;
 static float mapTau     = 20.0;                /* Guides the MAP process */
-
+static Boolean applyVFloor = TRUE;      /* apply variance flooring */
 static ConfParam *cParm[MAXGLOBS];      /* config parameters */
 static int nParm = 0;
 
@@ -84,6 +129,7 @@ void InitMap(void)
 {
    int i;
    double f;
+   Boolean b;
 
    Register(hmap_version,hmap_vc_id);
    nParm = GetConfig("HMAP", TRUE, cParm, MAXGLOBS);
@@ -91,12 +137,37 @@ void InitMap(void)
      if (GetConfInt(cParm,nParm,"TRACE",&i)) trace = i;
      if (GetConfInt(cParm,nParm,"MINEGS",&i)) minEgs = i;
      if (GetConfFlt(cParm,nParm,"MINOBS",&f)) minObs = f;
-     if (GetConfFlt(cParm,nParm,"MINVAR",&f)) minVar = f;
+     if (GetConfFlt(cParm,nParm,"MINVAR",&f)) { minVar = f; applyVFloor = TRUE; }
      if (GetConfFlt(cParm,nParm,"MAPTAU",&f)) mapTau = f;
+     if (GetConfBool(cParm,nParm,"APPLYVFLOOR",&b)) applyVFloor = b;
      if (GetConfFlt(cParm,nParm,"MIXWEIGHTFLOOR",&f)) mixWeightFloor = MINMIX*f;
    }
 }
 
+/* EXPORT->ResetMap: reset the module */
+void ResetMap(void)
+{
+   return;   /* do nothing */
+}
+
+/* EXPORT->SetMapTau: set mapTau from outside */
+void SetMapTau(float tau)
+{
+   mapTau = tau;
+}
+
+/* EXPORT->SetMixWeightFloor: set mixWeightFloor from outside */
+void SetMixWeightFloor(float wFloor)
+{
+   mixWeightFloor = wFloor;
+}
+
+/* EXPORT->SetMinVar: set minVar from outside */
+void SetMinVar(float mVar)
+{
+   minVar = mVar;
+}
+
 /* --------------------------- Model Update --------------------- */
 
 static int nFloorVar = 0;     /* # of floored variance comps */
@@ -179,18 +250,18 @@ static void FloorDProbs(ShortVec mixes, 
    }
 }
 
-static void FloorMixtures(HSetKind hskind, StreamElem *ste, int M, float floor)
+static void FloorMixtures(HSetKind hskind, StreamInfo *sti, int M, float floor)
 {
   switch (hskind){
   case DISCRETEHS:
-    FloorDProbs(ste->spdf.dpdf,M,floor);
+    FloorDProbs(sti->spdf.dpdf,M,floor);
     break;
   case TIEDHS:
-    FloorTMMixes(ste->spdf.tpdf,M,floor);
+    FloorTMMixes(sti->spdf.tpdf,M,floor);
     break;
   case PLAINHS:
   case SHAREDHS:
-    FloorMixes(ste->spdf.cpdf+1,M,floor);
+    FloorMixes(sti->spdf.cpdf+1,M,floor);
     break;
   }
 }
@@ -211,8 +282,7 @@ static void UpdateWeights(HMMSet *hset, 
    for (i=2; i<N; i++,se++){
       ste = se->info->pdf+1; 
       for (s=1;s<=S; s++,ste++){
-	vSize = hset->swidth[s];
-	wa = (WtAcc *)ste->hook;
+	wa = (WtAcc *)ste->info->hook;
 	switch (hset->hsKind){
   	case TIEDHS:
 	  M=hset->tmRecs[s].nMix;
@@ -220,20 +290,22 @@ static void UpdateWeights(HMMSet *hset, 
 	case DISCRETEHS:
 	case PLAINHS:
 	case SHAREDHS:
-	  M=ste->nMix;
+	  M=ste->info->nMix;
 	  break;
 	}
 	if (wa != NULL) {
 	  occi = wa->occ; 
 	  if (occi>0) {
-	    me = ste->spdf.cpdf + 1; denom=0;
+	    me = ste->info->spdf.cpdf + 1; denom=0;
 	    for (m=1; m<=M; m++,me++){
+              vSize = VectorSize(me->mpdf->mean);
 	      tmp = me->weight*vSize*mapTau -1;
 	      if (tmp<0) tmp = 0;
 	      denom += tmp;
 	    }
-	    me = ste->spdf.cpdf + 1;
+	    me = ste->info->spdf.cpdf + 1;
 	    for (m=1; m<=M; m++,me++){
+              vSize = VectorSize(me->mpdf->mean);
 	      tmp = me->weight*vSize*mapTau -1;
 	      if (tmp<0) tmp = 0;
 	      x = (tmp + wa->c[m])/(denom + occi); 
@@ -245,34 +317,34 @@ static void UpdateWeights(HMMSet *hset, 
 	      }
 	      switch (hset->hsKind){
 	      case TIEDHS:
-		ste->spdf.tpdf[m] = x;
+		ste->info->spdf.tpdf[m] = x;
 		break;
 	      case DISCRETEHS:
-		ste->spdf.dpdf[m]=DProb2Short(x);
+		ste->info->spdf.dpdf[m]=DProb2Short(x);
 		break;
 	      case PLAINHS:
 	      case SHAREDHS:
-		me=ste->spdf.cpdf+m;
+		me=ste->info->spdf.cpdf+m;
 		me->weight = x;
 		break;
 	      }
 	    }
 	    if (mixWeightFloor>0.0){
-	      FloorMixtures(hset->hsKind,ste,M,mixWeightFloor);		 
+	      FloorMixtures(hset->hsKind,ste->info,M,mixWeightFloor);		 
 	    }
 	    /* Force a normalisation becomes of weird zeroing .... */
 	    if ((hset->hsKind == PLAINHS) || (hset->hsKind == SHAREDHS)) {
-	      me = ste->spdf.cpdf + 1; x=0;
+	      me = ste->info->spdf.cpdf + 1; x=0;
 	      for (m=1; m<=M; m++,me++)
 		x += me->weight;
 	      if (x>1.001)
 		HError(-1,"Updating Weights, sum too large (%f)\n",x);
-	      me = ste->spdf.cpdf + 1;
+	      me = ste->info->spdf.cpdf + 1;
 	      for (m=1; m<=M; m++,me++)
 		me->weight /= x;	      
 	    } 
 	  }
-	  ste->hook = NULL;
+	  ste->info->hook = NULL;
 	}
       }
    }
@@ -294,11 +366,12 @@ static int UpdateMeans(HMMSet *hset, int
    for (i=2; i<N; i++,se++){
       ste = se->info->pdf+1; 
       for (s=1;s<=S;s++,ste++){
-         vSize = hset->swidth[s];
-         me = ste->spdf.cpdf + 1; M = ste->nMix;
+         me = ste->info->spdf.cpdf + 1; 
+         M = ste->info->nMix;
          for (m=1;m<=M;m++,me++)
             if (MixWeight(hset,me->weight) > MINMIX){
                mean = me->mpdf->mean;
+               vSize = VectorSize(mean);
                ma = GetHook(mean);
                if (ma != NULL){
                   occim = ma->occ;
@@ -335,20 +408,21 @@ static void UpdateVars(HMMSet *hset, int
    for (i=2; i<N; i++,se++){
       ste = se->info->pdf+1;
       for (s=1;s<=S;s++,ste++){
-         vSize = hset->swidth[s];
          minV = vFloor[s];
-         me = ste->spdf.cpdf + 1; M = ste->nMix;
+         me = ste->info->spdf.cpdf + 1; 
+         M = ste->info->nMix;
          for (m=1;m<=M;m++,me++)
 	   if (MixWeight(hset,me->weight) > MINMIX){
                cov = me->mpdf->cov;
                va = GetHook(cov.var);
                mean = me->mpdf->mean;
+               vSize = VectorSize(mean);
                ma = GetHook(mean);
                if (va != NULL){
                   occim = va->occ;
                   mixFloored = FALSE;
                   if (occim > 0.0){
-		    shared=(GetUse(cov.var)>1 || ma==NULL || ma->occ<=0.0);
+                     shared = (GetUse(cov.var)>1 || ma==NULL || ma->occ<=0.0) ? TRUE : FALSE;
                      if (me->mpdf->ckind==DIAGC) {
 		         var = cov.var;
 			 for (k=1; k<=vSize; k++){
@@ -358,7 +432,7 @@ static void UpdateVars(HMMSet *hset, int
 			     muDiffk = 2*dmu*ma->mu[k] - dmu*dmu*occim;
 			   }
                            x = (mapTau*var[k]  + va->cov.var[k] - muDiffk) / (mapTau + occim);
-			   if (x<minV[k]) {
+                           if (applyVFloor && x<minV[k]) {
                              x = minV[k];
                               nFloorVar++;
                               mixFloored = TRUE;
@@ -411,7 +485,8 @@ void MAPUpdateModels(HMMSet *hset, UPDSe
 {
   HMMScanState hss;
   HLink hmm;
-  int px,n,nmapped=0,totM;
+  int px,nmapped=0,totM;
+  long n;
 
   if (hset->logWt == TRUE) HError(999,"HMap: requires linear weights");
 
@@ -429,7 +504,7 @@ void MAPUpdateModels(HMMSet *hset, UPDSe
   px=1;
   do {   
     hmm = hss.hmm;
-    n = (int)hmm->hook;
+    n = (long)hmm->hook;
     if (n<minEgs && !(trace&T_UPD))
       HError(-2331,"UpdateModels: %s[%d] copied: only %d egs\n",
 	     HMMPhysName(hset,hmm),px,n);
@@ -457,4 +532,9 @@ void MAPUpdateModels(HMMSet *hset, UPDSe
 	     nFloorVar,nFloorVarMix);
     fflush(stdout);
   }
+   
+  /* Reset vfloor */
+  ResetVFloor(hset,vFloor);
 }
+
+/* ------------------------ End of HMap.c -------------------------- */
diff -pbBEwurNa --ignore-matching-lines='.*vc_id.*' HTK-3.4.1/HTKLib/HMap.h HTS-2.2_for_HTK-3.4.1/HTKLib/HMap.h
--- HTK-3.4.1/HTKLib/HMap.h	2009-03-11 19:07:40.000000000 +0900
+++ HTS-2.2_for_HTK-3.4.1/HTKLib/HMap.h	2011-06-16 13:18:29.000000000 +0900
@@ -29,15 +29,72 @@
 /*    **     This banner notice must not be removed      **    */
 /*                                                             */
 /* ----------------------------------------------------------- */
-/*            File: HMap.c  - MAP Model Updates                */
+/*         File: HMap.h  - MAP Model Updates                   */
 /* ----------------------------------------------------------- */
 
+/*  *** THIS IS A MODIFIED VERSION OF HTK ***                        */
+/* ----------------------------------------------------------------- */
+/*           The HMM-Based Speech Synthesis System (HTS)             */
+/*           developed by HTS Working Group                          */
+/*           http://hts.sp.nitech.ac.jp/                             */
+/* ----------------------------------------------------------------- */
+/*                                                                   */
+/*  Copyright (c) 2001-2011  Nagoya Institute of Technology          */
+/*                           Department of Computer Science          */
+/*                                                                   */
+/*                2001-2008  Tokyo Institute of Technology           */
+/*                           Interdisciplinary Graduate School of    */
+/*                           Science and Engineering                 */
+/*                                                                   */
+/* All rights reserved.                                              */
+/*                                                                   */
+/* Redistribution and use in source and binary forms, with or        */
+/* without modification, are permitted provided that the following   */
+/* conditions are met:                                               */
+/*                                                                   */
+/* - Redistributions of source code must retain the above copyright  */
+/*   notice, this list of conditions and the following disclaimer.   */
+/* - Redistributions in binary form must reproduce the above         */
+/*   copyright notice, this list of conditions and the following     */
+/*   disclaimer in the documentation and/or other materials provided */
+/*   with the distribution.                                          */
+/* - Neither the name of the HTS working group nor the names of its  */
+/*   contributors may be used to endorse or promote products derived */
+/*   from this software without specific prior written permission.   */
+/*                                                                   */
+/* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND            */
+/* CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,       */
+/* INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF          */
+/* MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE          */
+/* DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS */
+/* BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,          */
+/* EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED   */
+/* TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,     */
+/* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON */
+/* ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,   */
+/* OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY    */
+/* OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE           */
+/* POSSIBILITY OF SUCH DAMAGE.                                       */
+/* ----------------------------------------------------------------- */
+
 void InitMap(void);
 /* 
    Initialise configuration variables for the MAP adaptation
    library module.
 */
 
+void ResetMap(void);
+/*
+   reset the odule 
+*/
+
+void SetMapTau(float tau);
+void SetMixWeightFloor(float wFloor);
+void SetMinVar(float mVar);
+/*
+   set varables from outside modules
+*/
+
 void MAPUpdateModels(HMMSet *hset, UPDSet uflags);
 /*
   Using the accumulates obtained using FB perform Gauvain
@@ -49,5 +106,4 @@ void MAPUpdateModels(HMMSet *hset, UPDSe
   2) TIEDHS model kind MAP updates not supported
 */
 
-
-
+/* ------------------------ End of HMap.h -------------------------- */
diff -pbBEwurNa --ignore-matching-lines='.*vc_id.*' HTK-3.4.1/HTKLib/HMath.c HTS-2.2_for_HTK-3.4.1/HTKLib/HMath.c
--- HTK-3.4.1/HTKLib/HMath.c	2009-03-13 03:45:45.000000000 +0900
+++ HTS-2.2_for_HTK-3.4.1/HTKLib/HMath.c	2011-06-16 13:18:29.000000000 +0900
@@ -19,8 +19,53 @@
 /*         File: HMath.c   Math Support Module                 */
 /* ----------------------------------------------------------- */
 
+/*  *** THIS IS A MODIFIED VERSION OF HTK ***                        */
+/* ----------------------------------------------------------------- */
+/*           The HMM-Based Speech Synthesis System (HTS)             */
+/*           developed by HTS Working Group                          */
+/*           http://hts.sp.nitech.ac.jp/                             */
+/* ----------------------------------------------------------------- */
+/*                                                                   */
+/*  Copyright (c) 2001-2011  Nagoya Institute of Technology          */
+/*                           Department of Computer Science          */
+/*                                                                   */
+/*                2001-2008  Tokyo Institute of Technology           */
+/*                           Interdisciplinary Graduate School of    */
+/*                           Science and Engineering                 */
+/*                                                                   */
+/* All rights reserved.                                              */
+/*                                                                   */
+/* Redistribution and use in source and binary forms, with or        */
+/* without modification, are permitted provided that the following   */
+/* conditions are met:                                               */
+/*                                                                   */
+/* - Redistributions of source code must retain the above copyright  */
+/*   notice, this list of conditions and the following disclaimer.   */
+/* - Redistributions in binary form must reproduce the above         */
+/*   copyright notice, this list of conditions and the following     */
+/*   disclaimer in the documentation and/or other materials provided */
+/*   with the distribution.                                          */
+/* - Neither the name of the HTS working group nor the names of its  */
+/*   contributors may be used to endorse or promote products derived */
+/*   from this software without specific prior written permission.   */
+/*                                                                   */
+/* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND            */
+/* CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,       */
+/* INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF          */
+/* MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE          */
+/* DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS */
+/* BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,          */
+/* EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED   */
+/* TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,     */
+/* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON */
+/* ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,   */
+/* OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY    */
+/* OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE           */
+/* POSSIBILITY OF SUCH DAMAGE.                                       */
+/* ----------------------------------------------------------------- */
+
 char *hmath_version = "!HVER!HMath:   3.4.1 [CUED 12/03/09]";
-char *hmath_vc_id = "$Id: HMath.c,v 1.1.1.1 2006/10/11 09:54:58 jal58 Exp $";
+char *hmath_vc_id = "$Id: HMath.c,v 1.15 2011/06/16 04:18:29 uratec Exp $";
 
 /*
    This library provides math support in the following three areas
@@ -132,6 +177,19 @@ void CopyVector(Vector v1, Vector v2)
       v2[i] = v1[i];
 }
 
+/* EXPORT->CopyRVector: copy v1 into v2 */
+void CopyRVector(Vector v1, Vector v2, int n)
+{
+   int i,size; 
+   
+   size = VectorSize(v1);
+   if (n>size) 
+      n = size;
+      
+   for (i=1; i<=n; i++) 
+      v2[i] = v1[i];
+}
+
 /* EXPORT->CopyDVector: copy v1 into v2 */
 void CopyDVector(DVector v1, DVector v2)
 {
@@ -163,6 +221,12 @@ Boolean ReadVector(Source *src, Vector v
    return ReadFloat(src,v+1,VectorSize(v),binary);
 }
 
+/* EXPORT->ReadDVector: read double vector from src in ascii or binary */
+Boolean ReadDVector(Source *src, DVector v, Boolean binary)
+{
+   return ReadDouble(src,v+1,DVectorSize(v),binary);
+}
+
 /* EXPORT->WriteShortVec: write vector v to stream f */
 void WriteShortVec(FILE *f, ShortVec v, Boolean binary)
 {
@@ -184,6 +248,13 @@ void WriteVector(FILE *f, Vector v, Bool
    if (!binary) fputc('\n',f);
 }
 
+/* EXPORT->WriteDVector: write double vector v to stream f */
+void WriteDVector(FILE *f, DVector v, Boolean binary)
+{
+   WriteDouble(f,v+1,DVectorSize(v),binary);
+   if (!binary) fputc('\n',f);
+}
+
 /* Export->ShowShortVec: show the short vector v preceded by title */
 void ShowShortVec(char * title, ShortVec v,int maxTerms)
 {
@@ -258,6 +329,16 @@ void ZeroMatrix(Matrix m)
       for (j=1;j<=nc;j++) m[i][j]=0.0;
 }
 
+/* EXPORT->ZeroIMatrix: Zero the elements of m */
+void ZeroIMatrix(IMatrix m)
+{
+   int i,j,nr,nc;
+   
+   nr=NumIRows(m); nc=IntVecSize(m[1]);
+   for (i=1;i<=nr;i++)
+      for (j=1;j<=nc;j++) m[i][j]=0.0;
+}
+
 /* EXPORT->ZeroDMatrix: Zero the elements of m */
 void ZeroDMatrix(DMatrix m)
 {
@@ -278,6 +359,16 @@ void ZeroTriMat(TriMat m)
       for (j=1;j<=i;j++) m[i][j]=0.0;
 }
 
+/* EXPORT->ZeroDTriMat: Zero the elements of m */
+void ZeroDTriMat(DTriMat m)
+{
+   int i,j,size;
+   
+   size = DTriMatSize(m);
+   for (i=1;i<=size;i++)
+      for (j=1;j<=i;j++) m[i][j]=0.0;
+}
+
 /* EXPORT->CopyMatrix: copy matrix m1 to m2 */
 void CopyMatrix(Matrix m1, Matrix m2)
 {
@@ -291,6 +382,19 @@ void CopyMatrix(Matrix m1, Matrix m2)
       CopyVector(m1[i],m2[i]);
 }
 
+/* EXPORT->CopyIMatrix: copy integer matrix m1 to m2 */
+void CopyIMatrix(IMatrix m1, IMatrix m2)
+{
+   int i,nrows;
+   
+   nrows = NumIRows(m1);
+   if (nrows != NumIRows(m2))
+      HError(5270,"CopyIMatrix: row sizes differ %d vs %d",
+             nrows,NumIRows(m2));
+   for (i=1; i<=nrows; i++)
+      CopyIntVec(m1[i],m2[i]);
+}
+
 /* EXPORT->CopyDMatrix: copy matrix m1 to m2 */
 void CopyDMatrix(DMatrix m1, DMatrix m2)
 {
@@ -317,6 +421,19 @@ void CopyTriMat(TriMat m1, TriMat m2)
       CopyVector(m1[i],m2[i]);
 }
 
+/* EXPORT->CopyDTriMat: copy double triangular matrix m1 to m2 */
+void CopyDTriMat(DTriMat m1, DTriMat m2)
+{
+   int i,size;
+   
+   size = DTriMatSize(m1);
+   if (size != DTriMatSize(m2))
+      HError(5270,"CopyDTriMat: sizes differ %d vs %d",
+             size,DTriMatSize(m2));
+   for (i=1; i<=size; i++)
+      CopyDVector(m1[i],m2[i]);
+}
+
 /* EXPORT->Mat2DMat: convert matrix m1 to double matrix m2 */
 void Mat2DMat(Matrix m1,  DMatrix m2)
 {
@@ -389,6 +506,42 @@ void Tri2Mat (TriMat m1, Matrix m2)
       }
 }
 
+/* EXPORT->DMat2DTri: convert double matrix m1 to double tri matrix m2 */
+void DMat2DTri (DMatrix m1, DTriMat m2)
+{
+   int i,j,nrows,ncols;
+
+   nrows = NumDRows(m1); ncols = NumDCols(m1);
+   if (nrows != ncols)
+      HError(5270,"DMat2DTri: source matrix not square %d vs %d",
+             nrows,ncols);   
+   if (ncols != DTriMatSize(m2))
+      HError(5270,"DMat2DTri: sizes differ %d vs %d",
+             ncols,DTriMatSize(m2));
+   for (i=1; i<=nrows; i++)
+      for (j=1; j<=i; j++) 
+         m2[i][j] = m1[i][j];
+}
+
+/* EXPORT->DTri2DMat: convert double tri matrix m1 to double matrix m2 */
+void DTri2DMat (DTriMat m1, DMatrix m2)
+{
+   int i,j,nrows,ncols;
+
+   nrows = NumDRows(m2); ncols = NumDCols(m2);
+   if (nrows != ncols)
+      HError(5270,"DTri2DMat: target matrix not square %d vs %d",
+             nrows,ncols);   
+   if (ncols != DTriMatSize(m1))
+      HError(5270,"DTri2DMat: sizes differ %d vs %d",
+             DTriMatSize(m1),ncols);
+   for (i=1; i<=nrows; i++)
+      for (j=1; j<=i; j++) {
+         m2[i][j] = m1[i][j];
+         if (i!=j) m2[j][i] = m1[i][j];
+      }
+}
+
 /* EXPORT->ReadMatrix: read matrix from source into m */
 Boolean ReadMatrix(Source *src, Matrix m, Boolean binary)
 {
@@ -401,6 +554,30 @@ Boolean ReadMatrix(Source *src, Matrix m
    return TRUE;
 }
 
+/* EXPORT->ReadIMatrix: read integer matrix from source into m */
+Boolean ReadIMatrix(Source *src, IMatrix m, Boolean binary)
+{
+   int i,nrows;
+   
+   nrows = NumIRows(m);
+   for (i=1; i<=nrows; i++)
+      if (!ReadIntVec(src,m[i],binary)) 
+         return FALSE;
+   return TRUE;
+}
+
+/* EXPORT->ReadDMatrix: read double matrix from source into m */
+Boolean ReadDMatrix(Source *src, DMatrix m, Boolean binary)
+{
+   int i,nrows;
+   
+   nrows = NumDRows(m);
+   for (i=1; i<=nrows; i++)
+      if (!ReadDVector(src,m[i],binary)) 
+         return FALSE;
+   return TRUE;
+}
+
 /* EXPORT->ReadTriMat: read symmetric matrix in lower triangular
                        form from source into m */
 Boolean ReadTriMat(Source *src, TriMat m, Boolean binary)
@@ -416,6 +593,21 @@ Boolean ReadTriMat(Source *src, TriMat m
    return TRUE;
 }
 
+/* EXPORT->ReadDTriMat: read symmetric double matrix in lower triangular
+                        form from source into m */
+Boolean ReadDTriMat(Source *src, DTriMat m, Boolean binary)
+{
+   int i,j,size;
+   
+   size = DTriMatSize(m);
+   for (j=1; j<=size; j++) {
+      for (i=j; i<=size; i++)
+         if (!ReadDouble(src,&(m[i][j]),1,binary))
+            return FALSE;
+   }
+   return TRUE;
+}
+
 /* EXPORT->WriteMatrix: write matrix to f */
 void WriteMatrix(FILE *f, Matrix m, Boolean binary)
 {
@@ -426,6 +618,26 @@ void WriteMatrix(FILE *f, Matrix m, Bool
       WriteVector(f,m[i],binary);
 }
 
+/* EXPORT->WriteIMatrix: write integer matrix to f */
+void WriteIMatrix(FILE *f, IMatrix m, Boolean binary)
+{
+   int i,nrows;
+   
+   nrows = NumIRows(m);
+   for (i=1; i<=nrows; i++)
+      WriteIntVec(f,m[i],binary);
+}
+
+/* EXPORT->WriteDMatrix: write double matrix to f */
+void WriteDMatrix(FILE *f, DMatrix m, Boolean binary)
+{
+   int i,nrows;
+   
+   nrows = NumDRows(m);
+   for (i=1; i<=nrows; i++)
+      WriteDVector(f,m[i],binary);
+}
+
 /* EXPORT->WriteTriMat: write symmetric matrix to stream f in
                         upper triangular form */
 void WriteTriMat(FILE *f, TriMat m, Boolean binary)
@@ -440,6 +652,20 @@ void WriteTriMat(FILE *f, TriMat m, Bool
    }
 }
 
+/* EXPORT->WriteDTriMat: write symmetric double matrix to stream f in
+                         upper triangular form */
+void WriteDTriMat(FILE *f, DTriMat m, Boolean binary)
+{
+   int i,j,size;
+   
+   size = DTriMatSize(m);
+   for (j=1; j<=size; j++) {
+      for (i=j; i<=size; i++)
+         WriteDouble(f,&(m[i][j]),1,binary);
+      if (!binary) fputc('\n',f);
+   }
+}
+
 /* Export->ShowMatrix: show the matrix m preceded by title */
 void ShowMatrix(char * title,Matrix m,int maxCols,int maxRows)
 {
@@ -462,6 +688,28 @@ void ShowMatrix(char * title,Matrix m,in
       printf("   ...\n");
 }
 
+/* Export->ShowIMatrix: show the matrix m preceded by title */
+void ShowIMatrix(char * title, IMatrix m, int maxCols, int maxRows)
+{
+   int i,j;
+   int maxi,maxj,nrows,ncols;
+   
+   maxi = nrows = NumIRows(m);
+   if (maxi>maxRows) maxi = maxRows;
+   maxj = ncols = IntVecSize(m[1]);
+   if (maxj>maxCols) maxj = maxCols;
+   printf("%s\n",title);
+   for (i=1;i<=maxi;i++) {
+      printf("   ");
+      for (j=1;j<=maxj;j++)
+         printf("%5d ",m[i][j]);
+      if (maxj<ncols) printf("...");
+      printf("\n");
+   }
+   if (maxi<nrows)
+      printf("   ...\n");
+}
+
 /* Export->ShowDMatrix: show the matrix m preceded by title */
 void ShowDMatrix(char * title,DMatrix m,int maxCols,int maxRows)
 {
@@ -507,8 +755,58 @@ void ShowTriMat(char * title,TriMat m,in
       printf("   ...\n");
 }
 
+/* Export->ShowDTriMat: show the matrix m preceded by title */
+void ShowDTriMat(char * title,DTriMat m,int maxCols,int maxRows)
+{
+   int i,j;
+   int maxi,maxj,size;
+   
+   size = DTriMatSize(m);
+   maxi = size;
+   if (maxi>maxRows) maxi = maxRows;
+   printf("%s\n",title);
+   for (i=1;i<=maxi;i++) {
+      printf("   ");
+      maxj = i;
+      if (maxj>maxCols) maxj = maxCols;
+      for (j=1;j<=maxj;j++)
+         printf("%10.4f ",m[i][j]);
+      if (maxj<i) printf("...");
+      printf("\n");
+   }
+   if (maxi<size)
+      printf("   ...\n");
+}
+
 /* -------------------- Matrix Operations ---------------------- */
 
+/* EXPORT->MatrixMult: Product between two given matrices */
+void MatrixMult(Matrix m1, Matrix m2, Matrix m)
+{
+   double tempElem;
+   int i,j,k;
+   Matrix mat;
+
+   mat = CreateMatrix(&gstack,NumRows(m1),NumCols(m2));
+   if (NumCols(m1)==NumRows(m2)) {
+      for (i=1;i<=NumRows(m);i++) {
+         for (j=1;j<=NumCols(m);j++) {
+            tempElem=0.0;
+            for (k=1;k<=NumCols(m1);k++) {
+               if (m1[i][k]!=0.0 && m2[k][j]!=0.0)
+                  tempElem+=m1[i][k]*m2[k][j];
+            }
+            mat[i][j]=tempElem;
+         }
+      }
+      CopyMatrix(mat,m);
+   }
+   else {
+      HError(999,"MatrixMult: Matrices are not the same size!\n");
+   }
+   FreeMatrix(&gstack,mat);
+}
+
 /* Choleski: Place lower triangular choleski factor of A in L.*/
 /*           Return FALSE if matrix singular or not +definite */
 static Boolean Choleski(TriMat A, DMatrix L)
@@ -538,6 +836,35 @@ static Boolean Choleski(TriMat A, DMatri
    return TRUE;
 }
 
+/* DCholeski: Place lower triangular choleski factor of A in L.*/
+/*            Return FALSE if matrix singular or not +definite */
+static Boolean DCholeski(DTriMat A, DMatrix L)
+{
+   int size,i,j,k;
+   double sum;
+
+   size = DTriMatSize(A);
+   for (i=1; i<=size; i++)
+      for (j=1; j<=i; j++) {
+         sum=A[i][j];
+         for (k=1; k<j; k++)
+            sum -= (L[i][k]*L[j][k]);
+         if ((i==j)&&(sum<=0.0)) 
+            return FALSE;
+         else if (i==j)
+            sum = sqrt(sum);
+         else if (L[j][j]==0.0)
+            return FALSE;
+         else
+            sum /= L[j][j];
+         L[i][j] = sum;
+      }
+   for (i=1; i<=size; i++) 
+      for (j=i+1; j<=size; j++) 
+         L[i][j] = 0.0;
+   return TRUE;
+}
+
 /* MSolve: solve Ly=e^i and L^t x = y, where e^i is a unit vector */
 static void MSolve(DMatrix L, int i, DVector x, DVector y)
 {
@@ -568,7 +895,7 @@ LogFloat CovInvert(TriMat c, Matrix invc
 {
    DMatrix l;     /* Lower Tri Choleski Matrix */
    DVector x,y;   /* for f/b substitution */
-   LogFloat ldet = 0.0;
+   LogDouble ldet = 0.0;
    int i,j,n;
    Boolean isTri;
    
@@ -586,6 +913,33 @@ LogFloat CovInvert(TriMat c, Matrix invc
    } else
       HError(5220,"CovInvert: [%f ...] not invertible",c[1][1]);
    FreeDMatrix(&gstack,l);    /* cut back stack to entry state */
+   return ((LogFloat)2.0*ldet);
+}
+
+/* EXPORT->DCovInvert: puts inverse of c in invc, returns log(Det(c)) */
+/*          Note that c must be positive definite */
+LogDouble DCovInvert(DTriMat c, DMatrix invc)
+{
+   DMatrix l;     /* Lower Tri Choleski Matrix */
+   DVector x,y;   /* for f/b substitution */
+   LogDouble ldet = 0.0;
+   int i,j,n;
+   Boolean isTri;
+   
+   n = DTriMatSize(c); isTri = IsDTriMat(invc);
+   l = CreateDMatrix(&gstack,n,n);
+   x = CreateDVector(&gstack,n);
+   y = CreateDVector(&gstack,n);
+   if (DCholeski(c,l)){
+      for (j=1; j<=n; j++){
+         MSolve(l,j,x,y);
+         for (i=isTri?j:1; i<=n; i++)
+            invc[i][j] = x[i];
+         ldet += log(l[j][j]);
+      }
+   } else
+      HError(5220,"DCovInvert: [%f ...] not invertible",c[1][1]);
+   FreeDMatrix(&gstack,l);    /* cut back stack to entry state */
    return 2.0*ldet;
 }
 
@@ -593,7 +947,7 @@ LogFloat CovInvert(TriMat c, Matrix invc
 LogFloat CovDet(TriMat c)
 {
    DMatrix l;  /* Lower Tri Choleski Matrix */
-   LogFloat ldet = 0.0;
+   LogDouble ldet = 0.0;
    int j,n;
    
    n = TriMatSize(c);
@@ -604,6 +958,24 @@ LogFloat CovDet(TriMat c)
    } else
       HError(5220,"CovDet: [%f ...] not invertible",c[1][1]);
    FreeDMatrix(&gstack,l);
+   return((LogFloat)2.0*ldet);
+}
+
+/* EXPORT->DCovDet: Returns log(Det(c)), c must be positive definite */
+LogDouble DCovDet(DTriMat c)
+{
+   DMatrix l;  /* Lower Tri Choleski Matrix */
+   LogDouble ldet = 0.0;
+   int j,n;
+   
+   n = DTriMatSize(c);
+   l = CreateDMatrix(&gstack,n,n);
+   if (DCholeski(c,l)){
+      for (j=1; j<=n; j++)
+         ldet += log(l[j][j]);
+   } else
+      HError(5220,"DCovDet: [%f ...] not invertible",c[1][1]);
+   FreeDMatrix(&gstack,l);
    return 2.0*ldet;
 }
 
@@ -684,6 +1056,7 @@ void LinTranQuaProd(Matrix Prod, Matrix 
 #define sgn(x)  ((x) >= 0 ? 1 : -1)
 #define minab(a,b) ((a) > (b) ? (b) : (a))
 #define MAX_STACK       100
+#define MAX_VSIZE       256
 
 /* Givens -- returns c,s parameters for Givens rotation to
    eliminate y in the vector [ x y ]' */
@@ -1303,7 +1676,7 @@ float MatDet(Matrix c)
    a=CreateMatrix(&gstack,n,n);
    CopyMatrix(c,a);                /* Make a copy of c */
    LUDecompose(a,perm,&sign);      /* Do LU Decomposition */
-   det = sign;                     /* Calc Det(c) */
+   det = (float)sign;              /* Calc Det(c) */
    for (i=1; i<=n; i++) {
       det *= a[i][i];
    }
@@ -1331,7 +1704,7 @@ static Boolean DLUDecompose(DMatrix a, i
          if ((xx = fabs(a[i][j])) > scale )
             scale = xx;
       if (scale == 0.0) {
-         HError(-1,"LUDecompose: Matrix is Singular");
+         HError(-1,"DLUDecompose: Matrix is Singular");
          return(FALSE);
       }
       vv[i] = 1.0/scale;
@@ -1358,7 +1731,7 @@ static Boolean DLUDecompose(DMatrix a, i
       }
       perm[j]=imax;
       if (a[j][j] == 0.0) {
-         HError(-1,"LUDecompose: Matrix is Singular");
+         HError(-1,"DLUDecompose: Matrix is Singular");
          return(FALSE);
       }
       if (j != n) {
@@ -1382,7 +1755,7 @@ double DMatDet(DMatrix c)
    a=CreateDMatrix(&gstack,n,n);
    CopyDMatrix(c,a);                /* Make a copy of c */
    DLUDecompose(a,perm,&sign);      /* Do LU Decomposition */
-   det = sign;                     /* Calc Det(c) */
+   det = (double)sign;              /* Calc Det(c) */
    for (i=1; i<=n; i++) {
       det *= a[i][i];
    }
@@ -1405,7 +1778,7 @@ static void LinSolve(Matrix a, int *perm
       if (ii)
          for (j=ii;j<=i-1;j++) sum -=a[i][j]*b[j];
       else
-         if (sum) ii=i;
+         if (sum!=0.0) ii=i;
       b[i]=sum;
    }
    for (i=n; i>=1; i--) {
@@ -1421,10 +1794,10 @@ static void LinSolve(Matrix a, int *perm
 float MatInvert(Matrix c, Matrix invc)
 {
    Matrix a;
-   float col[100];
+   float col[MAX_VSIZE];
    float det;
    int sign;
-   int n,i,j,perm[100];
+   int n,i,j,perm[MAX_VSIZE];
    
    n=NumRows(c);
    a=CreateMatrix(&gstack,n,n);
@@ -1438,7 +1811,7 @@ float MatInvert(Matrix c, Matrix invc)
       for (i=1; i<=n; i++)
          invc[i][j] = col[i];
    }  
-   det = sign;                /* Calc log(det(c)) */
+   det = (float)sign;         /* Calc log(det(c)) */
    for (i=1; i<=n; i++) {
       det *= a[i][i];
    }
@@ -1474,10 +1847,10 @@ static void DLinSolve(DMatrix a, int *pe
 double DMatInvert(DMatrix c, DMatrix invc)
 {
    DMatrix a;
-   double col[100];
+   double col[MAX_VSIZE];
    double det;
    int sign;
-   int n,i,j,perm[100];
+   int n,i,j,perm[MAX_VSIZE];
    
    n=NumDRows(c);
    a=CreateDMatrix(&gstack,n,n);
@@ -1491,7 +1864,7 @@ double DMatInvert(DMatrix c, DMatrix inv
       for (i=1; i<=n; i++)
          invc[i][j] = col[i];
    }  
-   det = sign;                /* Calc log(det(c)) */
+   det = (double)sign;                /* Calc log(det(c)) */
    for (i=1; i<=n; i++) {
       det *= a[i][i];
    }
@@ -1503,17 +1876,17 @@ double DMatInvert(DMatrix c, DMatrix inv
 double DMatCofact(DMatrix c, int r, DVector cofact)
 {
    DMatrix a;
-   double col[100];
+   double col[MAX_VSIZE];
    double det;
    int sign;
-   int n,i,perm[100];
+   int n,i,perm[MAX_VSIZE];
    
    n=NumDRows(c);
    a=CreateDMatrix(&gstack,n,n);
    CopyDMatrix(c,a);                      /* Make a copy of c */
    if (! DLUDecompose(a,perm,&sign))      /* Do LU Decomposition */
      return 0;
-   det = sign;                         /* Calc det(c) */
+   det = (double)sign;                    /* Calc det(c) */
    for (i=1; i<=n; i++) {
       det *= a[i][i];
    }
@@ -1532,10 +1905,10 @@ double MatCofact(Matrix c, int r, Vector
 {
    DMatrix a;
    DMatrix b;
-   double col[100];
+   double col[MAX_VSIZE];
    float det;
    int sign;
-   int n,i,perm[100];
+   int n,i,perm[MAX_VSIZE];
  
    n=NumRows(c);
    a=CreateDMatrix(&gstack,n,n);
@@ -1544,7 +1917,7 @@ double MatCofact(Matrix c, int r, Vector
    CopyDMatrix(b,a);                      /* Make a copy of c */
    if (! DLUDecompose(a,perm,&sign))      /* Do LU Decomposition */
      return 0;
-   det = sign;                         /* Calc det(c) */
+   det = (double)sign;                    /* Calc det(c) */
    for (i=1; i<=n; i++) {
       det *= a[i][i];
    }
@@ -1636,7 +2009,7 @@ void RandInit(int seed)
    SRAND(seed);
 }
 
-/* EXPORT->RandomValue:  */
+/* EXPORT->RandomValue: Return a random number in range 0.0->1.0 with uniform distribution */
 float RandomValue(void)
 {
    return RANDF();
@@ -1668,6 +2041,25 @@ float GaussDeviate(float mu, float sigma
    return x*sigma+mu;
 }
 
+/* EXPORT->MultiNomial: return a random number in range 1->N with multinomial distribution */
+int MultiNomial(Vector prob, const int N)
+{
+   int i;
+   float p,sum=0.0;
+   
+   if (N==1) return 1;
+
+   for (i=1; i<=N; i++) sum += prob[i];
+
+   p = sum * RandomValue();  sum = 0.0;
+   for (i=1; i<=N; sum+=prob[i++]) {
+      if (sum<p && p<=sum+prob[i])
+         return i;
+   }
+   
+   return N;
+}
+
 /* --------------------- Initialisation ---------------------- */
 
 /* EXPORT->InitMath: initialise this module */
@@ -1684,4 +2076,10 @@ void InitMath(void)
    }
 }
 
-/* ------------------------- End of HMath.c ------------------------- */
+/* EXPORT->ResetMath: reset this module */
+void ResetMath(void)
+{
+   return;  /* do nothing */
+}
+
+/* ------------------------ End of HMath.c ------------------------- */
diff -pbBEwurNa --ignore-matching-lines='.*vc_id.*' HTK-3.4.1/HTKLib/HMath.h HTS-2.2_for_HTK-3.4.1/HTKLib/HMath.h
--- HTK-3.4.1/HTKLib/HMath.h	2009-03-13 03:46:01.000000000 +0900
+++ HTS-2.2_for_HTK-3.4.1/HTKLib/HMath.h	2011-06-16 13:18:29.000000000 +0900
@@ -19,6 +19,51 @@
 /*         File: HMath.h:   Math Support                       */
 /* ----------------------------------------------------------- */
 
+/*  *** THIS IS A MODIFIED VERSION OF HTK ***                        */
+/* ----------------------------------------------------------------- */
+/*           The HMM-Based Speech Synthesis System (HTS)             */
+/*           developed by HTS Working Group                          */
+/*           http://hts.sp.nitech.ac.jp/                             */
+/* ----------------------------------------------------------------- */
+/*                                                                   */
+/*  Copyright (c) 2001-2011  Nagoya Institute of Technology          */
+/*                           Department of Computer Science          */
+/*                                                                   */
+/*                2001-2008  Tokyo Institute of Technology           */
+/*                           Interdisciplinary Graduate School of    */
+/*                           Science and Engineering                 */
+/*                                                                   */
+/* All rights reserved.                                              */
+/*                                                                   */
+/* Redistribution and use in source and binary forms, with or        */
+/* without modification, are permitted provided that the following   */
+/* conditions are met:                                               */
+/*                                                                   */
+/* - Redistributions of source code must retain the above copyright  */
+/*   notice, this list of conditions and the following disclaimer.   */
+/* - Redistributions in binary form must reproduce the above         */
+/*   copyright notice, this list of conditions and the following     */
+/*   disclaimer in the documentation and/or other materials provided */
+/*   with the distribution.                                          */
+/* - Neither the name of the HTS working group nor the names of its  */
+/*   contributors may be used to endorse or promote products derived */
+/*   from this software without specific prior written permission.   */
+/*                                                                   */
+/* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND            */
+/* CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,       */
+/* INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF          */
+/* MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE          */
+/* DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS */
+/* BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,          */
+/* EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED   */
+/* TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,     */
+/* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON */
+/* ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,   */
+/* OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY    */
+/* OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE           */
+/* POSSIBILITY OF SUCH DAMAGE.                                       */
+/* ----------------------------------------------------------------- */
+
 /* !HVER!HMath:   3.4.1 [CUED 12/03/09] */
 
 #ifndef _HMATH_H_
@@ -75,6 +120,11 @@ void InitMath(void);
    Initialise the module
 */
 
+void ResetMath(void);
+/*
+   Reset the module
+*/
+
 /* ------------------ Vector Oriented Routines ----------------------- */
 
 void ZeroShortVec(ShortVec v);
@@ -88,6 +138,7 @@ void ZeroDVector(DVector v);
 void CopyShortVec(ShortVec v1, ShortVec v2);
 void CopyIntVec(IntVec v1, IntVec v2);
 void CopyVector(Vector v1, Vector v2);
+void CopyRVector(Vector v1, Vector v2, int n);
 void CopyDVector(DVector v1, DVector v2);
 /*
    Copy v1 into v2; sizes must be the same
@@ -96,6 +147,7 @@ void CopyDVector(DVector v1, DVector v2)
 Boolean ReadShortVec(Source *src, ShortVec v, Boolean binary);
 Boolean ReadIntVec(Source *src, IntVec v, Boolean binary);
 Boolean ReadVector(Source *src, Vector v, Boolean binary);
+Boolean ReadDVector(Source *src, DVector v,  Boolean binary);
 /*
    Read vector v from source in ascii or binary
 */
@@ -103,6 +155,7 @@ Boolean ReadVector(Source *src, Vector v
 void WriteShortVec(FILE *f, ShortVec v, Boolean binary);
 void WriteIntVec(FILE *f, IntVec v, Boolean binary);
 void WriteVector(FILE *f, Vector v, Boolean binary);
+void WriteDVector(FILE *f, DVector v,  Boolean binary);
 /*
    Write vector v to stream f in ascii or binary
 */
@@ -121,15 +174,19 @@ void LinTranQuaProd(Matrix Prod, Matrix 
 /* ------------------ Matrix Oriented Routines ----------------------- */
 
 void ZeroMatrix(Matrix m);
+void ZeroIMatrix(IMatrix m);
 void ZeroDMatrix(DMatrix m);
 void ZeroTriMat(TriMat m);
+void ZeroDTriMat(DTriMat m);
 /*
    Zero the elements of m
 */
 
 void CopyMatrix (Matrix m1,  Matrix m2);
+void CopyIMatrix(IMatrix m1, IMatrix m2);
 void CopyDMatrix(DMatrix m1, DMatrix m2);
 void CopyTriMat (TriMat m1,  TriMat m2);
+void CopyDTriMat(DTriMat m1, DTriMat m2);
 /*
    Copy matrix m1 to m2 which must have identical dimensions
 */
@@ -138,13 +195,18 @@ void Mat2DMat(Matrix m1,  DMatrix m2);
 void DMat2Mat(DMatrix m1, Matrix m2);
 void Mat2Tri (Matrix m1,  TriMat m2);
 void Tri2Mat (TriMat m1,  Matrix m2);
+void DMat2DTri(DMatrix m1, DTriMat m2);
+void DTri2DMat(DTriMat m1, DMatrix m2);
 /*
    Convert matrix format from m1 to m2 which must have identical 
    dimensions
 */
 
 Boolean ReadMatrix(Source *src, Matrix m, Boolean binary);
+Boolean ReadIMatrix(Source *src, IMatrix m, Boolean binary);
+Boolean ReadDMatrix(Source *src, DMatrix m, Boolean binary);
 Boolean ReadTriMat(Source *src, TriMat m, Boolean binary);
+Boolean ReadDTriMat(Source *src, DTriMat m, Boolean binary);
 /*
    Read matrix from source into m using ascii or binary.
    TriMat version expects m to be in upper triangular form
@@ -152,7 +214,10 @@ Boolean ReadTriMat(Source *src, TriMat m
 */
    
 void WriteMatrix(FILE *f, Matrix m, Boolean binary);
+void WriteIMatrix(FILE *f, IMatrix m, Boolean binary);
+void WriteDMatrix(FILE *f, DMatrix m, Boolean binary);
 void WriteTriMat(FILE *f, TriMat m, Boolean binary);
+void WriteDTriMat(FILE *f, DTriMat m, Boolean binary);
 /*
     Write matrix to stream in ascii or binary.  TriMat version 
     writes m in upper triangular form even though it is stored
@@ -160,8 +225,10 @@ void WriteTriMat(FILE *f, TriMat m, Bool
 */
 
 void ShowMatrix (char * title,Matrix m, int maxCols,int maxRows);
+void ShowIMatrix(char *title, IMatrix m, int maxCols, int maxRows);  
 void ShowDMatrix(char * title,DMatrix m,int maxCols,int maxRows);
 void ShowTriMat (char * title,TriMat m, int maxCols,int maxRows);
+void ShowDTriMat(char *title, DTriMat m, int maxCols, int maxRows);
 /*
    Print the title followed by upto maxCols elements of upto
    maxRows rows of m.
@@ -169,13 +236,20 @@ void ShowTriMat (char * title,TriMat m, 
 
 /* ------------------- Linear Algebra Routines ----------------------- */
 
+void MatrixMult(Matrix m1, Matrix m2, Matrix m);
+/* 
+   Matrix multiplication
+*/
+
 LogFloat CovInvert(TriMat c, Matrix invc);
+LogDouble DCovInvert(DTriMat c, DMatrix invc);
 /*
    Computes inverse of c in invc and returns the log of Det(c),
    c must be positive definite.
 */
 
 LogFloat CovDet(TriMat c);
+LogDouble DCovDet(DTriMat c);
 /*
    Returns log of Det(c), c must be positive definite.
 */
@@ -247,10 +321,15 @@ float GaussDeviate(float mu, float sigma
    Return a random number with a N(mu,sigma) distribution
 */
 
+int MultiNomial(Vector prob, const int N);
+/* 
+   Return a random number in range 1->N with multinomial distribution
+*/
+
 #ifdef __cplusplus
 }
 #endif
 
 #endif  /* _HMATH_H_ */
 
-/* ------------------------- End of HMath.h -------------------------- */
+/* ------------------------ End of HMath.h ------------------------- */
diff -pbBEwurNa --ignore-matching-lines='.*vc_id.*' HTK-3.4.1/HTKLib/HMem.c HTS-2.2_for_HTK-3.4.1/HTKLib/HMem.c
--- HTK-3.4.1/HTKLib/HMem.c	2009-03-13 03:46:12.000000000 +0900
+++ HTS-2.2_for_HTK-3.4.1/HTKLib/HMem.c	2011-06-16 13:18:29.000000000 +0900
@@ -19,8 +19,53 @@
 /*         File: HMem.c:   Memory Management Module            */
 /* ----------------------------------------------------------- */
 
+/*  *** THIS IS A MODIFIED VERSION OF HTK ***                        */
+/* ----------------------------------------------------------------- */
+/*           The HMM-Based Speech Synthesis System (HTS)             */
+/*           developed by HTS Working Group                          */
+/*           http://hts.sp.nitech.ac.jp/                             */
+/* ----------------------------------------------------------------- */
+/*                                                                   */
+/*  Copyright (c) 2001-2011  Nagoya Institute of Technology          */
+/*                           Department of Computer Science          */
+/*                                                                   */
+/*                2001-2008  Tokyo Institute of Technology           */
+/*                           Interdisciplinary Graduate School of    */
+/*                           Science and Engineering                 */
+/*                                                                   */
+/* All rights reserved.                                              */
+/*                                                                   */
+/* Redistribution and use in source and binary forms, with or        */
+/* without modification, are permitted provided that the following   */
+/* conditions are met:                                               */
+/*                                                                   */
+/* - Redistributions of source code must retain the above copyright  */
+/*   notice, this list of conditions and the following disclaimer.   */
+/* - Redistributions in binary form must reproduce the above         */
+/*   copyright notice, this list of conditions and the following     */
+/*   disclaimer in the documentation and/or other materials provided */
+/*   with the distribution.                                          */
+/* - Neither the name of the HTS working group nor the names of its  */
+/*   contributors may be used to endorse or promote products derived */
+/*   from this software without specific prior written permission.   */
+/*                                                                   */
+/* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND            */
+/* CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,       */
+/* INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF          */
+/* MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE          */
+/* DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS */
+/* BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,          */
+/* EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED   */
+/* TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,     */
+/* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON */
+/* ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,   */
+/* OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY    */
+/* OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE           */
+/* POSSIBILITY OF SUCH DAMAGE.                                       */
+/* ----------------------------------------------------------------- */
+
 char *hmem_version = "!HVER!HMem:   3.4.1 [CUED 12/03/09]";
-char *hmem_vc_id = "$Id: HMem.c,v 1.1.1.1 2006/10/11 09:54:58 jal58 Exp $";
+char *hmem_vc_id = "$Id: HMem.c,v 1.11 2011/06/16 04:18:29 uratec Exp $";
 
 #include "HShell.h"
 #include "HMem.h"
@@ -106,7 +151,7 @@ static BlockP AllocBlock(size_t size, si
    int i;
    
    if (trace&T_TOP)
-      printf("HMem: AllocBlock of %u bytes\n",num*size);
+      printf("HMem: AllocBlock of %zd bytes\n",num*size);
    if ((p = (BlockP) malloc(sizeof(Block))) == NULL)
       HError(5105,"AllocBlock: Cannot allocate Block");
    if ((p->data = (void *)malloc(size*num)) == NULL)
@@ -201,6 +246,14 @@ void InitMem(void)
    }
 }
 
+/* EXPORT->ResetMem: reset module */
+void ResetMem(void)
+{
+   ResetHeap(&gstack);
+   
+   return;
+}
+
 /* EXPORT->CreateHeap: create a memory heap with given characteristics */
 void CreateHeap(MemHeap *x, char *name, HeapType type, size_t elemSize, 
                 float growf, size_t numElem, size_t maxElem)
@@ -231,7 +284,7 @@ void CreateHeap(MemHeap *x, char *name, 
       case MSTAK: c='S'; break;
       case CHEAP: c='C'; break;
       }
-      printf("HMem: Create Heap %s[%c] %u %.1f %u %u\n",name,c,
+      printf("HMem: Create Heap %s[%c] %zd %.1f %zd %zd\n",name,c,
              elemSize, growf, numElem, maxElem);
    }
 }
@@ -322,7 +375,7 @@ void *New(MemHeap *x,size_t size)
          HError(5173,"New: MHEAP req for %u size elem from heap %s size %u",
                 size,x->name,x->elemSize);
 
-      noSpace = x->totUsed == x->totAlloc;
+      noSpace = (x->totUsed == x->totAlloc) ? TRUE : FALSE;
       if (noSpace || (q=GetElem(x->heap,x->elemSize,x->type)) == NULL) {
          if (!noSpace) BlockReorder(&(x->heap),1);
          if (noSpace || (q=GetElem(x->heap,x->elemSize,x->type)) == NULL) {
@@ -339,7 +392,7 @@ void *New(MemHeap *x,size_t size)
       }
       x->totUsed++;
       if (trace&T_MHP)
-         printf("HMem: %s[M] %u bytes at %p allocated\n",x->name,size,q);
+         printf("HMem: %s[M] %zd bytes at %p allocated\n",x->name,size,q);
       return q;
    case CHEAP:
       chdr = MRound(sizeof(size_t));
@@ -350,7 +403,7 @@ void *New(MemHeap *x,size_t size)
       x->totAlloc += size+chdr;
       ip = (size_t *)q; *ip = size;
       if (trace&T_CHP)
-         printf("HMem: %s[C] %u+%u bytes at %p allocated\n",x->name,chdr,size,q);
+         printf("HMem: %s[C] %zd+%zd bytes at %p allocated\n",x->name,chdr,size,q);
       return (Ptr)((ByteP)q+chdr);
    case MSTAK:
       /* set required size - must alloc on double boundaries */
@@ -374,9 +427,9 @@ void *New(MemHeap *x,size_t size)
       }
       x->totUsed += size;
       if (trace&T_STK)
-         printf("HMem: %s[S] %u bytes at %p allocated\n",x->name,size,q);
+         printf("HMem: %s[S] %zd bytes at %p allocated\n",x->name,size,q);
       if (x->protectStk) {
-         pp = (Ptr *)((long)q + size - sizeof(Ptr)); /* #### fix this! */
+         pp = (Ptr *)((size_t)q + size - sizeof(Ptr)); /* #### fix this! */
          *pp = q;
       }
       return q;
@@ -416,8 +469,7 @@ void Dispose(MemHeap *x, void *p)
       size = x->elemSize;
       while (cur != NULL && !found) {
          num = cur->numElem;
-         found = cur->data <= p && 
-            (((void*)((ByteP)cur->data+(num-1)*size)) >= p);
+         found = (cur->data <= p && (((void*)((ByteP)cur->data+(num-1)*size)) >= p)) ? TRUE : FALSE;
          if (!found) {
             prev=cur; cur=cur->next;
          }   
@@ -437,7 +489,7 @@ void Dispose(MemHeap *x, void *p)
          free(cur->data); free(cur->used); free(cur);
       }
       if (trace&T_MHP)
-         printf("HMem: %s[M] %u bytes at %p de-allocated\n",x->name,size,p);
+         printf("HMem: %s[M] %zd bytes at %p de-allocated\n",x->name,size,p);
       return;
    case MSTAK:
       /* search for item to dispose */
@@ -457,8 +509,7 @@ void Dispose(MemHeap *x, void *p)
       while (cur != NULL && !found){
          /* check current block */
          num = cur->numElem;
-         found = cur->data <= p && 
-            (((void*)((ByteP)cur->data+num)) > p);
+         found = (cur->data <= p && (((void*)((ByteP)cur->data+num)) > p)) ? TRUE : FALSE;
          if (!found) {     /* item not in cur block so delete it */
             x->heap = cur->next;
             x->totAlloc -= cur->numElem;
@@ -480,7 +531,7 @@ void Dispose(MemHeap *x, void *p)
       cur->firstFree -= size;
       cur->numFree += size; x->totUsed -= size;
       if (trace&T_STK)
-         printf("HMem: %s[S] %u bytes at %p de-allocated\n",x->name,size,p);
+         printf("HMem: %s[S] %zd bytes at %p de-allocated\n",x->name,size,p);
       return;
    case CHEAP:
       chdr = MRound(sizeof(size_t));
@@ -488,7 +539,7 @@ void Dispose(MemHeap *x, void *p)
       ip = (size_t *)bp;
       x->totAlloc -= (*ip + chdr); x->totUsed -= *ip;
       if (trace&T_CHP)
-         printf("HMem: %s[C] %u+%u bytes at %p de-allocated\n",
+         printf("HMem: %s[C] %zd+%zd bytes at %p de-allocated\n",
                 x->name,chdr,*ip,bp);
       free(bp);
       return;
@@ -508,7 +559,7 @@ void PrintHeapStats(MemHeap *x)
    case CHEAP: tc = 'C'; break;
    }
    for (p=x->heap; p != NULL; p = p->next) ++nBlocks;
-   printf("nblk=%3d, siz=%6u*%-3u, used=%9u, alloc=%9u : %s[%c]\n",
+   printf("nblk=%3d, siz=%6zd*%-3zd, used=%9zd, alloc=%9zd : %s[%c]\n",
           nBlocks, x->curElem, x->elemSize, x->totUsed, 
           x->totAlloc*x->elemSize,x->name,tc) ;
    fflush(stdout);
@@ -674,6 +725,10 @@ size_t MatrixElemSize(int nrows,int ncol
 {
    return VectorElemSize(ncols) * nrows + (nrows+1)*sizeof(Vector);
 }
+size_t IMatrixElemSize(int nrows,int ncols)
+{
+   return IntVecElemSize(ncols) * nrows + (nrows+1)*sizeof(IntVec);
+}
 size_t DMatrixElemSize(int nrows,int ncols)
 {
    return MRound(DVectorElemSize(ncols) * nrows + (nrows+1)*sizeof(DVector));
@@ -687,6 +742,11 @@ size_t TriMatElemSize(int size)
    return size*(VectorElemSize(0)*2 + (size+1)*sizeof(float))/2
       + (size+1)*sizeof(Vector);
 }
+size_t DTriMatElemSize(int size)
+{
+   return size*(DVectorElemSize(0)*2 + (size+1)*sizeof(double))/2
+      + (size+1)*sizeof(DVector);
+}
 size_t STriMatElemSize(int size)
 {
    return size*(VectorElemSize(0)*2 + (size+1)*sizeof(float))/2
@@ -713,6 +773,26 @@ Matrix CreateMatrix(MemHeap *x, int nrow
    return m;
 }
 
+/* EXPORT->CreateIMatrix:  Allocate space for integer matrix m[1..nrows][1..ncols] */
+IMatrix CreateIMatrix(MemHeap *x, int nrows, int ncols)
+{
+   size_t vsize;
+   int *i,j;
+   IntVec *m;   
+   char *p;
+   
+   p =(char *)  New(x,IMatrixElemSize(nrows,ncols)); 
+   i = (int *)p; *i = nrows;
+   vsize = IntVecElemSize(ncols);
+   m = (IntVec *)p;
+   p += (nrows+1)*sizeof(IntVec);
+   for (j=1;j<=nrows; j++, p += vsize) {
+      i = (int *) p; *i = ncols;
+      m[j] = (IntVec) p;
+   }
+   return m;
+}
+
 /* EXPORT->CreateTriMat:  Allocate space for matrix m[1..size][1..i] */
 TriMat CreateTriMat(MemHeap *x,int size)
 {
@@ -751,6 +831,24 @@ DMatrix CreateDMatrix(MemHeap *x, int nr
    return m;
 }
 
+/* EXPORT->CreateDTriMat:  Allocate space for double matrix m[1..size][1..i] */
+DTriMat CreateDTriMat(MemHeap *x,int size)
+{
+   int *i,j;
+   DVector *m;   
+   char *p;
+      
+   p = (char *) New(x,DTriMatElemSize(size)); 
+   i = (int *)p; *i = size;
+   m = (DVector *)p;
+   p += (size+1)*sizeof(DVector);
+   for (j=1;j<=size; j++) {
+      i = (int *) p; *i = j;
+      m[j] = (DVector) p; p += DVectorElemSize(j);
+   }
+   return m;
+}
+
 /* EXPORT->CreateSMatrix:  Allocate space for matrix m[1..nrows][1..ncols] */
 Matrix CreateSMatrix(MemHeap *x, int nrows,int ncols)
 {
@@ -804,6 +902,17 @@ Boolean IsTriMat(Matrix m)
    return(TRUE);
 }
 
+/* EXPORT->IsDTriMat: True if double matrix is lower triangular */
+Boolean IsDTriMat(DMatrix m)
+{
+   int i,n;
+
+   n=NumDRows(m);
+   for(i=1;i<=n;i++)
+      if (DVectorSize(m[i])!=i) return(FALSE);
+   return(TRUE);
+}
+
 /* EXPORT->NumRows: number of rows in matrix m */
 int NumRows(Matrix m)
 {
@@ -822,6 +931,24 @@ int NumCols(Matrix m)
    return *ncols;
 }
 
+/* EXPORT->NumIRows: number of rows in matrix m */
+int NumIRows(IMatrix m)
+{
+   int *nrows;
+   
+   nrows = (int *) m;
+   return *nrows;
+}
+
+/* EXPORT->NumICols: number of columns in matrix m */
+int NumICols(IMatrix m)
+{
+   int *ncols;
+   
+   ncols = (int *) m[1];
+   return *ncols;
+}
+
 /* EXPORT->NumDRows: number of rows in double matrix m */
 int NumDRows(DMatrix m)
 {
@@ -849,12 +976,27 @@ int TriMatSize(TriMat m)
    return *nrows;
 }
 
+/* EXPORT->DTriMatSize: number of rows/cols in double triangular matrix m */
+int DTriMatSize(DTriMat m)
+{
+   int *nrows;
+   
+   nrows = (int *) m;
+   return *nrows;
+}
+
 /* EXPORT->FreeMatrix: Free space allocated for matrix m */
 void FreeMatrix(MemHeap *x, Matrix m)
 {
    Dispose(x,m);
 }
 
+/* EXPORT->FreeIMatrix: Free space allocated for matrix m */
+void FreeIMatrix(MemHeap *x, IMatrix m)
+{
+   Dispose(x,m);
+}
+
 /* EXPORT->FreeDMatrix: Free space allocated for matrix m */
 void FreeDMatrix(MemHeap *x, DMatrix m)
 {
@@ -875,6 +1017,12 @@ void FreeTriMat(MemHeap *x,TriMat m)
    Dispose(x,m);
 }
 
+/* EXPORT->FreeDTriMat: Free space allocated for double tri matrix m */
+void FreeDTriMat(MemHeap *x,DTriMat m)
+{
+   Dispose(x,m);
+}
+
 /* EXPORT->FreeSTriMat: Free space allocated for shared tri matrix m */
 void FreeSTriMat(MemHeap *x,STriMat m)
 {
@@ -938,7 +1086,10 @@ Boolean IsSeenV(Ptr m)
    int i;
    
    p = (Ptr *) m; --p; i = *((int *)p);
-   return i<0;
+   if (i<0) 
+      return TRUE;
+   else
+      return FALSE;
 }
 
 /* EXPORT->TouchV: mark use flag as seen */
@@ -989,4 +1140,4 @@ char *CopyString(MemHeap *x, char *s)
    return t;
 }
 
-/* -------------------------- End of HMem.c ---------------------------- */
+/* ------------------------ End of HMem.c -------------------------- */
diff -pbBEwurNa --ignore-matching-lines='.*vc_id.*' HTK-3.4.1/HTKLib/HMem.h HTS-2.2_for_HTK-3.4.1/HTKLib/HMem.h
--- HTK-3.4.1/HTKLib/HMem.h	2009-03-13 03:46:25.000000000 +0900
+++ HTS-2.2_for_HTK-3.4.1/HTKLib/HMem.h	2011-06-16 13:18:29.000000000 +0900
@@ -19,6 +19,51 @@
 /*         File: HMem.h:   Memory Management Module            */
 /* ----------------------------------------------------------- */
 
+/*  *** THIS IS A MODIFIED VERSION OF HTK ***                        */
+/* ----------------------------------------------------------------- */
+/*           The HMM-Based Speech Synthesis System (HTS)             */
+/*           developed by HTS Working Group                          */
+/*           http://hts.sp.nitech.ac.jp/                             */
+/* ----------------------------------------------------------------- */
+/*                                                                   */
+/*  Copyright (c) 2001-2011  Nagoya Institute of Technology          */
+/*                           Department of Computer Science          */
+/*                                                                   */
+/*                2001-2008  Tokyo Institute of Technology           */
+/*                           Interdisciplinary Graduate School of    */
+/*                           Science and Engineering                 */
+/*                                                                   */
+/* All rights reserved.                                              */
+/*                                                                   */
+/* Redistribution and use in source and binary forms, with or        */
+/* without modification, are permitted provided that the following   */
+/* conditions are met:                                               */
+/*                                                                   */
+/* - Redistributions of source code must retain the above copyright  */
+/*   notice, this list of conditions and the following disclaimer.   */
+/* - Redistributions in binary form must reproduce the above         */
+/*   copyright notice, this list of conditions and the following     */
+/*   disclaimer in the documentation and/or other materials provided */
+/*   with the distribution.                                          */
+/* - Neither the name of the HTS working group nor the names of its  */
+/*   contributors may be used to endorse or promote products derived */
+/*   from this software without specific prior written permission.   */
+/*                                                                   */
+/* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND            */
+/* CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,       */
+/* INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF          */
+/* MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE          */
+/* DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS */
+/* BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,          */
+/* EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED   */
+/* TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,     */
+/* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON */
+/* ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,   */
+/* OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY    */
+/* OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE           */
+/* POSSIBILITY OF SUCH DAMAGE.                                       */
+/* ----------------------------------------------------------------- */
+
 /* !HVER!HMem:   3.4.1 [CUED 12/03/09] */
 
 /*
@@ -103,6 +148,11 @@ void InitMem(void);
    routine in this module
 */
 
+void ResetMem(void);
+/* 
+   reset the module 
+*/
+
 void CreateHeap(MemHeap *x, char *name, HeapType type, size_t elemSize, 
                 float growf, size_t numElem,  size_t maxElem);
 /*
@@ -156,11 +206,13 @@ void PrintAllHeapStats(void);
 /* Basic Numeric Types */
 typedef short *ShortVec;   /* short vector[1..size] */
 typedef int   *IntVec;     /* int vector[1..size] */
+typedef int   **IMatrix;   /* int matrix[1...nrows][1...ncols] */
 typedef float *Vector;     /* vector[1..size]   */
 typedef float **Matrix;    /* matrix[1..nrows][1..ncols] */
 typedef Matrix TriMat;     /* matrix[1..nrows][1..i] (lower triangular) */
 typedef double *DVector;   /* double vector[1..size]   */
 typedef double **DMatrix;  /* double matrix[1..nrows][1..ncols] */
+typedef DMatrix DTriMat;   /* double matrix [1..nrows][1..i] (lower triangular) */
 
 /* Shared versions */
 typedef Vector SVector;    /* shared vector[1..size]   */
@@ -206,9 +258,11 @@ void FreeSVector(MemHeap *x,SVector v);
 */
 
 size_t MatrixElemSize(int nrows,int ncols);
+size_t IMatrixElemSize(int nrows,int ncols);
 size_t DMatrixElemSize(int nrows,int ncols);
 size_t SMatrixElemSize(int nrows,int ncols);
 size_t TriMatElemSize(int size);
+size_t DTriMatElemSize(int size);
 size_t STriMatElemSize(int size);
 /* 
    Return elemSize of a Matrix with given number of rows
@@ -217,9 +271,11 @@ size_t STriMatElemSize(int size);
    MHEAP heaps.
 */
 Matrix  CreateMatrix(MemHeap *x,int nrows,int ncols);
+IMatrix CreateIMatrix(MemHeap *x,int nrows,int ncols);
 DMatrix CreateDMatrix(MemHeap *x,int nrows,int ncols);
 SMatrix CreateSMatrix(MemHeap *x,int nrows,int ncols);
 TriMat  CreateTriMat(MemHeap *x,int size);
+DTriMat CreateDTriMat(MemHeap *x,int size);
 STriMat CreateSTriMat(MemHeap *x,int size);
 /*
    Create and return a matrix with nrows rows and ncols columns.
@@ -229,24 +285,30 @@ STriMat CreateSTriMat(MemHeap *x,int siz
 */
 
 Boolean IsTriMat(Matrix m);
+Boolean IsDTriMat(DMatrix m);
 /*
    Return true if m is actually TriMat
 */
 
 int NumRows(Matrix m);
+int NumIRows(IMatrix m);
 int NumDRows(DMatrix m);
 int NumCols(Matrix m);
+int NumICols(IMatrix m);
 int NumDCols(DMatrix m);
 int TriMatSize(TriMat m);
+int DTriMatSize(DTriMat m);
 /*
    Return the number of rows/cols in matrix m.  These can be
    applied to shared variants also.
 */
 
 void FreeMatrix(MemHeap *x,Matrix m);
+void FreeIMatrix(MemHeap *x,IMatrix m);
 void FreeDMatrix(MemHeap *x,DMatrix m);
 void FreeSMatrix(MemHeap *x,SMatrix m);
 void FreeTriMat(MemHeap *x,TriMat m);
+void FreeDTriMat(MemHeap *x,DTriMat m);
 void FreeSTriMat(MemHeap *x,STriMat m);
 /*
    Free the space occupied by matrix m
@@ -292,4 +354,4 @@ char *CopyString(MemHeap *x, char *s);
 
 #endif  /* _HMEM_H_ */
 
-/* -------------------------- End of HMem.h ---------------------------- */
+/* ------------------------ End of HMem.h -------------------------- */
diff -pbBEwurNa --ignore-matching-lines='.*vc_id.*' HTK-3.4.1/HTKLib/HModel.c HTS-2.2_for_HTK-3.4.1/HTKLib/HModel.c
--- HTK-3.4.1/HTKLib/HModel.c	2009-03-13 03:46:34.000000000 +0900
+++ HTS-2.2_for_HTK-3.4.1/HTKLib/HModel.c	2011-06-16 14:07:56.000000000 +0900
@@ -32,8 +32,53 @@
 /*         File: HModel.c  HMM Model Definition Data Type      */
 /* ----------------------------------------------------------- */
 
+/*  *** THIS IS A MODIFIED VERSION OF HTK ***                        */
+/* ----------------------------------------------------------------- */
+/*           The HMM-Based Speech Synthesis System (HTS)             */
+/*           developed by HTS Working Group                          */
+/*           http://hts.sp.nitech.ac.jp/                             */
+/* ----------------------------------------------------------------- */
+/*                                                                   */
+/*  Copyright (c) 2001-2011  Nagoya Institute of Technology          */
+/*                           Department of Computer Science          */
+/*                                                                   */
+/*                2001-2008  Tokyo Institute of Technology           */
+/*                           Interdisciplinary Graduate School of    */
+/*                           Science and Engineering                 */
+/*                                                                   */
+/* All rights reserved.                                              */
+/*                                                                   */
+/* Redistribution and use in source and binary forms, with or        */
+/* without modification, are permitted provided that the following   */
+/* conditions are met:                                               */
+/*                                                                   */
+/* - Redistributions of source code must retain the above copyright  */
+/*   notice, this list of conditions and the following disclaimer.   */
+/* - Redistributions in binary form must reproduce the above         */
+/*   copyright notice, this list of conditions and the following     */
+/*   disclaimer in the documentation and/or other materials provided */
+/*   with the distribution.                                          */
+/* - Neither the name of the HTS working group nor the names of its  */
+/*   contributors may be used to endorse or promote products derived */
+/*   from this software without specific prior written permission.   */
+/*                                                                   */
+/* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND            */
+/* CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,       */
+/* INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF          */
+/* MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE          */
+/* DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS */
+/* BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,          */
+/* EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED   */
+/* TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,     */
+/* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON */
+/* ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,   */
+/* OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY    */
+/* OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE           */
+/* POSSIBILITY OF SUCH DAMAGE.                                       */
+/* ----------------------------------------------------------------- */
+
 char *hmodel_version = "!HVER!HModel:   3.4.1 [CUED 12/03/09]";
-char *hmodel_vc_id = "$Id: HModel.c,v 1.2 2006/12/07 11:09:08 mjfg Exp $";
+char *hmodel_vc_id = "$Id: HModel.c,v 1.42 2011/06/16 05:07:56 bonanza Exp $";
 
 #include "HShell.h"
 #include "HMem.h"
@@ -68,8 +113,6 @@ static int trace = 0;
 
 /* ------------------ Input XForm directory info ------------------- */
 
-typedef struct _XFDirInfo *XFDirLink;
-
 typedef struct _XFDirInfo {
   char *dirName;           /* input XForm directory name */
   XFDirLink next;          /* next directory name in list */
@@ -92,10 +135,7 @@ static Boolean reorderComps=FALSE;      
 
 static Boolean allowOthers=TRUE;        /* allow unseen models in files */
 static HSetKind cfHSKind;
-static char orphanMacFile[100];         /* last resort file for new macros */
-
-static XFDirLink xformDirNames = NULL;  /* linked list of input transform directories */
-static Boolean indexSet = FALSE;        /* have the indexes been set for the model set */
+static char orphanMacFile[MAXSTRLEN];   /* last resort file for new macros */
 
 static MemHeap xformStack;              /* For Storage of xforms with no model sets ... */
 
@@ -110,6 +150,8 @@ static int nGaussPDE1 = 0;
 static int nGaussPDE2 = 0;
 #endif
 
+static float ignoreValue = LZERO;      /* ignore value for multi-space distribution */
+
 void InitSymNames(void);
 
 /* EXPORT->InitModel: initialise memory and configuration parameters */
@@ -152,28 +194,38 @@ void InitModel(void)
       if (GetConfInt(cParm,nParm,"PDE2BLOCKEND",&i)) pde2BlockEnd = i;
       if (GetConfFlt(cParm,nParm,"PDETHRESHOLD1",&d)) pdeTh1 = d;
       if (GetConfFlt(cParm,nParm,"PDETHRESHOLD2",&d)) pdeTh2 = d;
+      if (GetConfFlt(cParm,nParm,"IGNOREVALUE",&d)) ignoreValue = d;
    }
 }
 
+/* EXPORT->ResetModel: reset module */
+void ResetModel (void)
+{
+   ResetHeap(&xformStack);
+   
+   return;
+}
+
 /* -------------------- Check Model Consistency -------------------- */
 
 /* CheckMix: check given mixture pdf of state n, stream s, mixture m */
-static ReturnStatus CheckMix(char *defName, MixPDF *mp, int n, int s, int m, int sw)
+static ReturnStatus CheckMix(char *defName, MixPDF *mp, int n, int s, int m, int sw, int mf)
 {  
    if (trace&T_CHK) {
       printf("HModel:       checking mix %d\n",m);  fflush(stdout);
    }
-   if (mp->mean == NULL){
+   if (!mf && mp->mean == NULL) {
       HRError(7030,"CheckMix: %s: pdf for s=%d,j=%d,m=%d has NULL mean",
               defName,n,s,m);
       return(FAIL);
    }
-   if (VectorSize(mp->mean) != sw){
+   if ((!mf && VectorSize(mp->mean) != sw)
+       || (mf && VectorSize(mp->mean) > sw)) {
       HRError(7030,"CheckMix: %s: mean for s=%d,j=%d,m=%d has bad vecSize",
               defName,n,s,m);
       return(FAIL);
    }
-   if (mp->cov.var == NULL){
+   if (!mf && mp->cov.var == NULL) {
       HRError(7030,"CheckMix: %s: pdf for s=%d,j=%d,m=%d has NULL covariance",
               defName,n,s,m);
       return(FAIL);
@@ -181,7 +233,7 @@ static ReturnStatus CheckMix(char *defNa
    
    switch(mp->ckind){
    case DIAGC:
-      if (VectorSize(mp->cov.var) != sw){
+      if (!mf && VectorSize(mp->cov.var) != sw) {
          HRError(7030,"CheckMix: %s: var for s=%d,j=%d,m=%d has bad vecSize",
                  defName,n,s,m);
          return(FAIL);
@@ -189,14 +241,14 @@ static ReturnStatus CheckMix(char *defNa
       break;
    case FULLC:
    case LLTC:
-      if (TriMatSize(mp->cov.inv) != sw){
+      if (!mf && TriMatSize(mp->cov.inv) != sw) {
          HRError(7030,"CheckMix: %s: inv for s=%d,j=%d,m=%d has bad dimens",
                  defName,n,s,m);
          return(FAIL);
       }
       break;
    case XFORMC:
-      if (NumCols(mp->cov.xform) != sw){
+      if (!mf && NumCols(mp->cov.xform) != sw) {
          HRError(7030,"CheckMix: %s: xform for s=%d,j=%d,m=%d has bad dimens",
                  defName,n,s,m);
          return(FAIL);
@@ -218,26 +270,28 @@ static ReturnStatus CheckMix(char *defNa
 }
 
 /* CheckStream: check the stream s for state n */
-static ReturnStatus CheckStream(char *defName, HLink hmm, StreamElem *se, int s, int n)
+static ReturnStatus CheckStream(char *defName, HLink hmm, StreamInfo *sti, int s, int n)
 {
    double sum=0.0;
-   int m,sw;
+   int m,sw,mf;
    LogFloat wt;
    MixtureElem *me;
    MixPDF *mp;
    HSetKind  hk;
    
    if (trace&T_CHK) {
-      printf("HModel:    checking stream %d, se=%p\n",s,se); 
+      printf("HModel:    checking stream %d, se=%p\n",s,sti); 
       fflush(stdout);
    }
    hk = hmm->owner->hsKind;
    sw = hmm->owner->swidth[s];
+   mf = hmm->owner->msdflag[s];
+
    switch(hk){
    case PLAINHS:
    case SHAREDHS:
-      me = se->spdf.cpdf+1;
-      for (m=1; m<=se->nMix; m++,me++){
+      me = sti->spdf.cpdf+1;
+      for (m=1; m<=sti->nMix; m++,me++){
          wt=me->weight; wt = MixWeight(hmm->owner,wt);
          sum += wt;
          if (wt > MINMIX ){
@@ -247,18 +301,18 @@ static ReturnStatus CheckStream(char *de
                return(FAIL);
             }
             mp = me->mpdf;
-            if((!IsSeen(mp->nUse))&&(CheckMix(defName,me->mpdf,n,s,m,sw)<SUCCESS))
+            if((!IsSeen(mp->nUse))&&(CheckMix(defName,me->mpdf,n,s,m,sw,mf)<SUCCESS))
                return(FAIL);
          }
       }
       break;
    case TIEDHS:
-      for (m=1; m<=se->nMix; m++)
-         sum += se->spdf.tpdf[m];
+      for (m=1; m<=sti->nMix; m++)
+         sum += sti->spdf.tpdf[m];
       break;
    case DISCRETEHS:
-      for (m=1; m<=se->nMix; m++)
-         sum += exp((float)se->spdf.dpdf[m]/DLOGSCALE);
+      for (m=1; m<=sti->nMix; m++)
+         sum += exp((float)sti->spdf.dpdf[m]/DLOGSCALE);
       break;
    }
    if (sum<0.99 || sum>1.01){
@@ -266,6 +320,7 @@ static ReturnStatus CheckStream(char *de
               defName,sum,s,n);
       return(FAIL);
    }
+   Touch(&sti->nUse);
    return(SUCCESS);
 }
 
@@ -274,6 +329,7 @@ static ReturnStatus CheckState(char *def
 {
    int s,S;
    StreamElem *ste;
+   StreamInfo *sti;
    
    if (trace&T_CHK) {
       printf("HModel:  checking state %d, si=%p\n",n,si); fflush(stdout);
@@ -285,11 +341,12 @@ static ReturnStatus CheckState(char *def
    }
    ste = si->pdf+1;
    for (s=1; s<=S; s++,ste++){
-      if (ste->spdf.cpdf == NULL){
+      sti = ste->info;
+      if (sti->spdf.cpdf == NULL){
          HRError(7030,"CheckState: %s: Stream %d missing in state %d",defName,s,n);
          return(FAIL);
       }
-      if(CheckStream(defName,hmm,ste,s,n)<SUCCESS)
+      if((!IsSeen(sti->nUse))&&(CheckStream(defName,hmm,sti,s,n)<SUCCESS))
          return(FAIL);
    }
    if (S>1)
@@ -323,10 +380,10 @@ static ReturnStatus CheckHMM(char *defNa
    return(SUCCESS);
 }
 
-/* CheckTMRecs: check the tied mix codebook attached to a HMM Set */
+/* CheckTMRecs: check the tied mix codebook attached to an HMM Set */
 static ReturnStatus CheckTMRecs(HMMSet *hset)
 {
-   int s,m,sw;
+   int s,m,sw,mf;
    MixPDF *mp;
    
    if (trace&T_CHK) {
@@ -334,6 +391,7 @@ static ReturnStatus CheckTMRecs(HMMSet *
    }
    for (s=1;s<=hset->swidth[0]; s++){
       sw = hset->swidth[s];
+      mf = hset->msdflag[s];
       if (hset->tmRecs[s].mixId == NULL){
          HRError(7030,"CheckTMRecs: no mix id set in stream %d",s);
          return(FAIL);
@@ -344,7 +402,7 @@ static ReturnStatus CheckTMRecs(HMMSet *
       }
       for (m=1; m<=hset->tmRecs[s].nMix; m++){
          mp = hset->tmRecs[s].mixes[m];
-         if(CheckMix("TMRec",mp,0,s,m,sw)<SUCCESS)
+         if(CheckMix("TMRec",mp,0,s,m,sw,mf)<SUCCESS)
             return(FAIL);
       }
    }
@@ -365,8 +423,8 @@ static ReturnStatus CheckDiscrete(HMMSet
    return (SUCCESS);
 }
 
-/* CheckHSet: check the consistency of a complete HMM Set */
-static ReturnStatus CheckHSet(HMMSet *hset)
+/* EXPORT->CheckHSet: check the consistency of a complete HMM Set */
+ReturnStatus CheckHSet(HMMSet *hset)
 {
    int h;
    MLink m;
@@ -393,7 +451,7 @@ static ReturnStatus CheckHSet(HMMSet *hs
 /* Internal and binary keyword representation */
 typedef enum {   /* Only a character big !! */
    BEGINHMM, USEMAC, ENDHMM, NUMMIXES, 
-   NUMSTATES, STREAMINFO, VECSIZE, 
+   NUMSTATES, STREAMINFO, VECSIZE, MSDINFO, 
    NDUR, PDUR, GDUR, RELDUR, GENDUR,
    DIAGCOV,  FULLCOV, XFORMCOV,
    STATE, TMIX, MIXTURE, STREAM, SWEIGHTS,
@@ -418,7 +476,7 @@ static struct {
    { { "BEGINHMM", BEGINHMM }, { "USE", USEMAC }, 
      { "ENDHMM", ENDHMM }, { "NUMMIXES", NUMMIXES }, 
      { "NUMSTATES", NUMSTATES }, { "STREAMINFO", STREAMINFO }, 
-     { "VECSIZE", VECSIZE }, { "NULLD", NDUR }, 
+     { "VECSIZE", VECSIZE }, { "MSDINFO", MSDINFO }, { "NULLD", NDUR }, 
      { "POISSOND", PDUR }, { "GAMMAD", GDUR }, 
      { "RELD", RELDUR }, { "GEND", GENDUR }, 
      { "DIAGC", DIAGCOV }, {  "FULLC", FULLCOV }, 
@@ -485,7 +543,7 @@ static void TermScanner(Source *src)
    CloseSource(src);
 }
 
-/* HMError: report a HMM definition error */
+/* HMError: report an HMM definition error */
 static void HMError(Source *src, char *message)
 {
    char buf[MAXSTRLEN];
@@ -515,7 +573,7 @@ static ReturnStatus GetToken(Source *src
    if (c == '~'){                    /* If macro sym return immediately */
       c = tolower(GetCh(src));
       if (c!='s' && c!='m' && c!='u' && c!='x' && c!='d' && c!='c' &&
-          c!='r' && c!='a' && c!='b' && c!='g' && c!='f' && c!='y' && c!='j' &&
+          c!='r' && c!='a' && c!='b' && c!='g' && c!='f' && c!='y' && c!='j' && c!='p' &&
           c!='v' && c!='i' && c!='t' && c!='w' && c!='h' && c!='o')
          {
             HMError(src,"GetToken: Illegal macro type");
@@ -596,12 +654,12 @@ static void OWarn(HMMSet *hset,Boolean e
       HRError(-7032,"OWarn: change HMM Set %s",opt);
 }
 
-/* GetOption: read a HMM option specifier - value set in nState pointer */
+/* GetOption: read an HMM option specifier - value set in nState pointer */
 static ReturnStatus GetOption(HMMSet *hset, Source *src, Token *tok, int *nState)
 {
    DurKind dk;
    char buf[MAXSTRLEN];
-   short vs,sw[SMAX],nSt=0;
+   short vs,sw[SMAX],mf[SMAX],nSt=0;
    int i;
    Boolean ntok=TRUE;
 
@@ -616,7 +674,7 @@ static ReturnStatus GetOption(HMMSet *hs
       *nState=nSt;
       break;
    case PARMKIND:    
-      OWarn(hset,hset->pkind==tok->pkind,"parmKind");
+      OWarn(hset,((hset->pkind==tok->pkind) ? TRUE:FALSE),"parmKind");
       hset->pkind = tok->pkind;
       break;
    case NDUR:
@@ -625,7 +683,7 @@ static ReturnStatus GetOption(HMMSet *hs
    case RELDUR:
    case GENDUR:
       dk = (DurKind) (NULLD + (tok->sym-NDUR));
-      OWarn(hset,hset->dkind==dk,"durKind");
+      OWarn(hset,((hset->dkind==dk) ? TRUE:FALSE),"durKind");
       hset->dkind = dk; 
       break;
    case HMMSETID:
@@ -672,15 +730,31 @@ static ReturnStatus GetOption(HMMSet *hs
          HMError(src,"Vector Size Expected");
          return(FAIL);
       }
-      OWarn(hset,hset->vecSize==vs,"vecSize");
+      OWarn(hset,((hset->vecSize==vs) ? TRUE:FALSE),"vecSize");
       hset->vecSize = vs;
       break;
+   case MSDINFO:
+      if (!ReadShort(src,mf,1,tok->binForm)) {
+         HMError(src,"Num Streams Expected");
+         return(FAIL);
+      }
+      if (mf[0] >= SMAX) {
+         HMError(src,"Stream limit exceeded");
+         return(FAIL);
+      }
+      if (!ReadShort(src,mf+1,mf[0],tok->binForm)) {
+         HMError(src,"MSD flag Expected");
+         return(FAIL);
+      }
+      OWarn(hset,((hset->msdflag[0]==mf[0]) ? TRUE:FALSE),"msdflag[0]");       
+      for (i=0; i<=mf[0]; i++) hset->msdflag[i] = mf[i];
+      break;
    case PROJSIZE:
       if (!ReadShort(src,&vs,1,tok->binForm)){
          HMError(src,"Projection vector Size Expected");
          return(FAIL);
       }
-      OWarn(hset,hset->projSize==vs,"projSize");
+      OWarn(hset,((hset->projSize==vs) ? TRUE:FALSE),"projSize");
       hset->projSize = vs;
       break;
    case STREAMINFO:
@@ -696,27 +770,27 @@ static ReturnStatus GetOption(HMMSet *hs
          HMError(src,"Stream Widths Expected");
          return(FAIL);
       }
-      OWarn(hset,hset->swidth[0]==sw[0],"swidth[0]");       
+      OWarn(hset,((hset->swidth[0]==sw[0]) ? TRUE:FALSE),"swidth[0]");       
       for (i=0; i<=sw[0]; i++) hset->swidth[i] = sw[i];
       break;
    case DIAGCOV:
-      OWarn(hset,hset->ckind==DIAGC,"covKind");
+      OWarn(hset,((hset->ckind==DIAGC) ? TRUE:FALSE),"covKind");
       hset->ckind = DIAGC; 
       break;
    case FULLCOV:
-      OWarn(hset,hset->ckind==FULLC,"covKind");
+      OWarn(hset,((hset->ckind==FULLC) ? TRUE:FALSE),"covKind");
       hset->ckind = FULLC; 
       break;
    case XFORMCOV:
-      OWarn(hset,hset->ckind==XFORMC,"covKind");
+      OWarn(hset,((hset->ckind==XFORMC) ? TRUE:FALSE),"covKind");
       hset->ckind = XFORMC; 
       break;
    case INVDIAGCOV:
-      OWarn(hset,hset->ckind==INVDIAGC,"covKind");
+      OWarn(hset,((hset->ckind==INVDIAGC) ? TRUE:FALSE),"covKind");
       hset->ckind = INVDIAGC; 
       break;
    case LLTCOV:
-      OWarn(hset,hset->ckind==LLTC,"covKind");
+      OWarn(hset,((hset->ckind==LLTC) ? TRUE:FALSE),"covKind");
       hset->ckind = LLTC; 
       break;
    default: 
@@ -738,9 +812,11 @@ static ReturnStatus FreezeOptions(HMMSet
    
    if (hset->optSet) return(SUCCESS);
    if (hset->vecSize == 0) {
-      if (hset->swidth[0] > 0 && hset->swidth[1] > 0)
+      /* set vecSize according to <StreamInfo> */
+      if (hset->swidth[0] > 0 && hset->swidth[1] > 0) {
          for (i=1; i<=hset->swidth[0]; i++)
             hset->vecSize += hset->swidth[i];
+      }
       else{
          HRError(7032,"FreezeOptions: vecSize not set");
          return(FAIL);
@@ -754,6 +830,10 @@ static ReturnStatus FreezeOptions(HMMSet
    if (hset->swidth[0] == 0) {
       hset->swidth[0] = 1; hset->swidth[1] = hset->vecSize;
    }
+   if (hset->msdflag[0] == 0) {
+      hset->msdflag[0] = hset->swidth[0];
+      for (i=1; i<=hset->swidth[0]; i++) hset->msdflag[i] = 0;
+   }
    if (hset->pkind == 0){
       HRError(7032,"FreezeOptions: parmKind not set");
       return(FAIL);
@@ -765,6 +845,16 @@ static ReturnStatus FreezeOptions(HMMSet
 /* CheckOptions: check that options are set in given HMM set */
 static ReturnStatus CheckOptions(HMMSet *hset)
 {
+   int i, vecSize;
+   
+   if (hset->vecSize!=0 && hset->swidth[0]>0) {
+      /* check consistency between <VecSize> and <StreamInfo> */
+      for (i=1,vecSize=0; i<=hset->swidth[0]; vecSize+=hset->swidth[i++]);
+      if (vecSize != hset->vecSize) {
+         HRError(7032,"CheckOptions: inconsistent vecSize between <VecSize> (%d) and <StreamInfo> (%d)", hset->vecSize, vecSize);
+         return(FAIL);
+      }
+   }      
    if (!hset->optSet){
       HRError(7032,"CheckOptions: options not set in HMM Set");
       return(FAIL);
@@ -819,10 +909,10 @@ void AddInXFormDir(HMMSet *hset, char *d
   p = (XFDirLink)New(hset->hmem,sizeof(XFDirInfo));
   p->next = NULL;
   p->dirName = CopyString(hset->hmem,dirname);
-  if (xformDirNames == NULL)
-    xformDirNames = p;
+  if (hset->xformDirNames == NULL)
+    hset->xformDirNames = p;
   else {  /* store in order of arrival */
-    for (q=xformDirNames; q->next != NULL; q=q->next);
+    for (q=hset->xformDirNames; q->next != NULL; q=q->next);
     q->next = p;
   }
 }
@@ -1003,7 +1093,7 @@ ReturnStatus GetTiedMixtures(HMMSet *hse
       return(FAIL);
    }
    id = GetLabId(tmName,TRUE);
-   isNew = hset->tmRecs[s].mixId == NULL;
+   isNew = (hset->tmRecs[s].mixId == NULL) ? TRUE:FALSE;
    if (isNew) {
       InitTMixRecs(hset,s,M);
       hset->tmRecs[s].mixId = id;
@@ -1108,14 +1198,14 @@ static ReturnStatus CheckBaseClass(HMMSe
 	mp->mIdx = -mp->mIdx;
 	ncomp++;
       } else { /* item appears in list multiple times */
-	HRError(999,"Component specified multiple times");  
+        HRError(999,"CheckBaseClass: Component specified multiple times");  
 	return(FAIL);
       }
     }
   }
   /* have all the components been seen? */
   if (ncomp != hset->numMix) {
-    HRError(999,"Components missing from Base Class list (%d %d)",ncomp,hset->numMix);
+    HRError(999,"CheckBaseClass: Components missing from Base Class list (%d %d)",ncomp,hset->numMix);
     return(FAIL);
   }
   /* mIdx is used in HRec, so reset */
@@ -1124,7 +1214,7 @@ static ReturnStatus CheckBaseClass(HMMSe
       mp = ((MixtureElem *)i->item)->mpdf;
       if (mp->mIdx<0) mp->mIdx = -mp->mIdx;
       else 
-	HError(999,"CompressItemList: corrupted item list");
+        HError(999,"CheckBaseClass: corrupted item list");
     }
   }
   return(SUCCESS);
@@ -1174,6 +1264,38 @@ static void CompressItemList(MemHeap *x,
     printf(" CompressItemList: kept %d components, deleted %d components\n",ncomp,ndel);
 }
 
+static int GetStreamClass(BaseClass *bclass, const int b)
+{
+   int j,s,m;
+   ILink i;
+   MixtureElem *me;
+   StreamInfo *sti;
+   HLink hmm;
+   
+   /* currently does not check consistency of stream indexes */
+   if ((i=bclass->ilist[b])==NULL) {
+      HError(-999,"GetStreamClass: class %d has no items",b);
+      return 1;
+   }
+   
+   me  = (MixtureElem *)i->item;
+   hmm = i->owner;
+   
+   /* search MixtureElem which matches me */
+   for (j=2; j<hmm->numStates; j++) { 
+      for (s=1; s<=bclass->swidth[0]; s++) {
+         sti = hmm->svec[j].info->pdf[s].info;
+         for (m=1; m<=sti->nMix; m++) {
+            if (sti->spdf.cpdf+m == me)
+               return s;
+         } 
+      }
+   }
+   HError(999,"GetStreamClass: cannot find stream of given class");
+   
+   return 1;
+}
+
 static BaseClass* GetBaseClass(HMMSet *hset,Source *src, Token *tok)
 {
   BaseClass *bclass;
@@ -1182,6 +1304,9 @@ static BaseClass* GetBaseClass(HMMSet *h
   int nbases, i, b;
   ILink ilist;
 
+  const int maxM = MaxMixInSet(hset);
+  const int maxS = MaxStatesInSet(hset);
+   
   void SetIndexes(HMMSet *hset);
 
   if (trace&T_PAR) printf("HModel: GetBaseClass\n");
@@ -1235,7 +1360,10 @@ static BaseClass* GetBaseClass(HMMSet *h
     } else {
       if (hset->swidth[0] != 1)
 	HError(999,"<STREAMINFO> must be specified in multiple stream base classes");
-      bclass->swidth = NULL; /* indicates a single stream - don't care */
+
+        bclass->swidth = CreateIntVec(hset->hmem,2);
+        bclass->swidth[0] = 1;
+        bclass->swidth[1] = hset->vecSize;
     }
     if (tok->sym == NUMCLASSES) {
       if (!ReadInt(src,&nbases,1,tok->binForm)){
@@ -1254,7 +1382,7 @@ static BaseClass* GetBaseClass(HMMSet *h
     bclass->ilist = (ILink *)New(hset->hmem,sizeof(ILink)*(nbases+1));
     /* Set the indexes for the models - just in case being loaded from 
        a macro */
-    if (!indexSet) SetIndexes(hset);
+    if (!hset->indexSet) SetIndexes(hset);
     /* BaseClasses Can only refer to physical HMMs for wild cards */
     SetParsePhysicalHMM(TRUE);
     for (i=1;i<=nbases;i++) {
@@ -1269,7 +1397,7 @@ static BaseClass* GetBaseClass(HMMSet *h
       if (b!=i)
 	HError(999,"Error reading classes in BaseClass");
       ilist= NULL; bclass->ilist[i] = NULL;
-      PItemList(&ilist,&type,hset,src,(trace&T_PAR));
+      PItemList(&ilist,&type,hset,src,NULL,maxM,maxS,((trace&T_PAR) ? TRUE:FALSE));
       CompressItemList(hset->hmem,ilist,bclass->ilist+i);
       ResetUtilItemList();
       /* multiple examples of the same component may be specified */
@@ -1282,6 +1410,12 @@ static BaseClass* GetBaseClass(HMMSet *h
     if (CheckBaseClass(hset,bclass)<SUCCESS)
       HError(999,"BaseClass check failed");
     bclass->nUse = 0;
+
+    /* set stream index to each base class */
+    bclass->stream = CreateIntVec(hset->hmem,bclass->numClasses);
+    for (b=1; b<=bclass->numClasses; b++)
+      bclass->stream[b] = GetStreamClass(bclass,b);
+
   } else if (tok->sym==MACRO && tok->macroType=='b'){
     if((bclass=(BaseClass *)GetStructure(hset,src,'b'))==NULL){
       HMError(src,"GetStructure Failed");
@@ -1301,19 +1435,20 @@ static BaseClass* GetBaseClass(HMMSet *h
 
 
 /* Find a node in the regression tree given the index and return the node */
-static RegNode *FindNode(RegNode *n, RegNode *r, int id)
+static RegNode *FindNode(RegTree *rtree, const int id)
 {
-  int i;
+   ILink i;
+   RegNode *r;
 
-  if (n != NULL) {
-    if (n->nodeIndex == id)
-      return n;
-    for (i=1;i<=n->numChild;i++) 
-      r = FindNode(n->child[i], r, id);
-  }
+   for (i=rtree->nodes; i!=NULL; i=i->next) {
+      r = (RegNode *) i->item;
+      if (r->nodeIndex==id)
   return r;
 }
 
+   return NULL;
+}
+
 static RegNode *CreateRegNode(MemHeap *m, int nodeId)
 {
    RegNode *n;
@@ -1325,7 +1460,10 @@ static RegNode *CreateRegNode(MemHeap *m
    n->child = NULL;
    n->baseClasses = NULL;
    n->info = NULL;
-   n->vsize = 0;
+   n->vsize = -1;
+   n->stream = -1;
+   n->valid = TRUE;
+
    return n;
 }
 
@@ -1368,6 +1506,9 @@ static RegTree *GetRegTree(HMMSet *hset,
 	   rtree->valid = FALSE;
      }
      rtree->root = root = CreateRegNode(hset->hmem,1);
+     rtree->numNodes = rtree->numTNodes = 0;
+     rtree->nodes = NULL;
+     AddItem(NULL,root,&rtree->nodes);
      while ((tok->sym != EOFSYM) && 
 	    ((tok->sym==NODE) || (tok->sym==TNODE))) {
        switch(tok->sym) {
@@ -1376,7 +1517,7 @@ static RegTree *GetRegTree(HMMSet *hset,
 	   HMError(src,"Node index for regression tree expected");
 	   return(NULL);
 	 }
-	 if ((rnode = FindNode(root, NULL, index)) == NULL)
+         if ((rnode = FindNode(rtree, index)) == NULL)
 	   HError(999,"Nodes are expected in numerical order");
 	 rtree->numNodes ++;
 	 if (!ReadInt(src,&nchild,1,tok->binForm)){
@@ -1391,6 +1532,7 @@ static RegTree *GetRegTree(HMMSet *hset,
 	     return(NULL);
 	   }
 	   rnode->child[i] = CreateRegNode(hset->hmem,index);
+           AddItem(NULL,rnode->child[i],&rtree->nodes);
 	 }
 	 break;
        case TNODE:
@@ -1398,7 +1540,7 @@ static RegTree *GetRegTree(HMMSet *hset,
 	   HMError(src,"Node index for regression tree expected");
 	   return(NULL);
 	 }
-	 if ((rnode = FindNode(root, NULL, index)) == NULL)
+         if ((rnode = FindNode(rtree, index)) == NULL)
 	   HError(999,"Nodes are expected in numerical order");
 	 rtree->numTNodes ++;
 	 if (!ReadInt(src,&nbases,1,tok->binForm)){
@@ -1423,6 +1565,7 @@ static RegTree *GetRegTree(HMMSet *hset,
 	 return(NULL);
        }
      }
+     FreeItems(&rtree->nodes);
    } else 
      HMError(src,"Regression Tree definition expected");     
    return rtree; 
@@ -1441,12 +1584,17 @@ static SVector GetMean(HMMSet *hset, Sou
          HMError(src,"Size of Mean Vector expected");
          return(NULL);
       }
+      if (size > 0) {
       m = CreateSVector(hset->hmem,size);
       if (!ReadVector(src,m,tok->binForm)){
          HMError(src,"Mean Vector expected");
          return(NULL);
       }
    }
+      else if (size == 0) {
+         m = CreateSVector(hset->hmem,0);
+      }
+   }
    
    else if (tok->sym==MACRO && tok->macroType=='u'){
       if((m=(SVector)GetStructure(hset,src,'u'))==NULL){
@@ -1477,12 +1625,17 @@ static SVector GetVariance(HMMSet *hset,
          HMError(src,"Size of Variance Vector expected");
          return(NULL);
       }
+      if (size > 0) {
       v = CreateSVector(hset->hmem,size);
       if (!ReadVector(src,v,tok->binForm)){
          HMError(src,"Variance Vector expected");
          return(NULL);
       }
    }
+      else if (size == 0) {
+         v = CreateSVector(hset->hmem,0);
+      }
+   }
    
    else if (tok->sym==MACRO && tok->macroType=='v'){
       if((v=(SVector)GetStructure(hset,src,'v'))==NULL){
@@ -1665,6 +1818,7 @@ static MixPDF *GetMixPDF(HMMSet *hset, S
       mp = (MixPDF *)New(hset->hmem,sizeof(MixPDF));
       mp->nUse = 0; mp->hook = NULL; mp->gConst = LZERO;
       mp->mIdx = 0; mp->stream = 0; mp->vFloor = NULL; mp->info = NULL;
+      mp->cov.var = NULL;  mp->cov.inv = NULL; mp->cov.xform = NULL; mp->ckind = NULLC;
       if((mp->mean = GetMean(hset,src,tok))==NULL){      
          HMError(src,"GetMean Failed");
          return(NULL);
@@ -1803,15 +1957,10 @@ static ReturnStatus GetMixture(HMMSet *h
 /* CreateSE: create an array of S StreamElems */
 static StreamElem *CreateSE(HMMSet *hset, int S)
 {
-   int s;
-   StreamElem *se,*p;
+   StreamElem *ste,*p;
    
-   se = (StreamElem *)New(hset->hmem,S*sizeof(StreamElem));
-   p = se-1;
-   for (s=1;s<=S;s++,se++){
-      se->hook = NULL;
-      se->spdf.cpdf = NULL;
-   }
+   ste = (StreamElem *)New(hset->hmem,S*sizeof(StreamElem));
+   p = ste-1;
    return p;
 }
 
@@ -1846,84 +1995,137 @@ static MixPDF *EmptyMixPDF(HMMSet *hset,
    return t[s];
 }
 
-/* GetStream: parse src and store a StreamElem in pdf array */
-static ReturnStatus GetStream(HMMSet *hset, Source *src, Token *tok,
-                              StreamElem *pdf, short *nMix)
+/* GetStreamInfo: parse src and store a StreamInfo in StreamElement */
+static StreamInfo *GetStreamInfo(HMMSet *hset, Source *src, Token *tok, int s)
 {
-   int m,S,M;
-   short s;
+   StreamInfo *sti;
    MixtureElem *cpdf;
+   int m;
   
-   S=hset->swidth[0];
-   if (trace&T_PAR) {
-      printf("HModel: GetStream - nMix =");
-      for (s=1; s<=S; s++) printf(" %d",nMix[s]);
-      printf("\n");
+   if (tok->sym == MACRO && tok->macroType == 'p') {
+      if ((sti = (StreamInfo *)GetStructure(hset,src,'p')) ==NULL) {
+         HMError(src,"Get Stream Info failed");
+         return(NULL);
    }
-   s = 1;
-   if (tok->sym == STREAM) {
-      if (!ReadShort(src,&s,1,tok->binForm)){
-         HMError(src,"Stream Index expected");
-         return(FAIL);
+      ++sti->nUse;
+      if (GetToken(src,tok)<SUCCESS) {
+         HMError(src,"Get Token failed");
+         return(NULL);
       }
-      if (s<1 || s>S){
-         HMError(src,"Stream Index out of range");
-         return(FAIL);
+   }
+   else {
+      sti = (StreamInfo *)New(hset->hmem,sizeof(StreamInfo));
+      sti->nUse = 0;
+      sti->hook = NULL;
+      sti->spdf.cpdf = NULL;
+      sti->pIdx = 0;
+      if (tok->sym == STREAM) {
+         if (!ReadShort(src,&sti->stream,1,tok->binForm)) {
+            HMError(src,"Stream index in expected");
+            return(NULL);
       }
       if(GetToken(src,tok)<SUCCESS){
          HMError(src,"GetToken failed");
-         return(FAIL);
+            return(NULL);
       }
    }
-   M = nMix[s];
-   pdf[s].nMix = M;
-   if (tok->sym == TMIX ) {
+      else 
+         sti->stream = s;
+      
+      /* Number of Mixture components */
+      if (tok->sym == NUMMIXES) {
+         if (!ReadInt(src,&sti->nMix,1,tok->binForm)) {
+            HMError(src,"Num Mix in Shared Stream expected");
+            return(NULL);
+         }
+         if (GetToken(src,tok)<SUCCESS) {
+            HMError(src,"GetToken failed");
+            return(NULL);
+         }
+      } else 
+         sti->nMix=1;
+
+      if (tok->sym == TMIX ) {    /* Tied Mixture */
       if (hset->hsKind == PLAINHS)
          hset->hsKind = TIEDHS;
       else 
          if (hset->hsKind != TIEDHS){
             HRError(7032,"GetStream: change to TIEDHS from other than PLAINHS");
-            return(FAIL);
+               return(NULL);
          }
-      pdf[s].spdf.tpdf = CreateTME(hset,M);
-      if((GetTiedMixtures(hset,src,tok,M,s,pdf[s].spdf.tpdf))<SUCCESS){
+         sti->spdf.tpdf = CreateTME(hset,sti->nMix);
+
+         if ((GetTiedMixtures(hset,src,tok,sti->nMix,s,sti->spdf.tpdf))<SUCCESS) {
          HMError(src,"GetTiedMixtures failed");
-         return(FAIL);
+            return(NULL);
       }
    } 
-   else 
+      else     /* Discrete */
       if (tok->sym == DPROB) {
          if (hset->hsKind == PLAINHS)
             hset->hsKind = DISCRETEHS;
          else if (hset->hsKind != DISCRETEHS){
             HRError(7032,"GetStream: change to DISCRETEHS from other than PLAINHS");
-            return(FAIL);
+               return(NULL);
          }
-         pdf[s].spdf.dpdf = CreateDME(hset,M);
-         if((GetDiscreteWeights(src,tok,M,pdf[s].spdf.dpdf))<SUCCESS){
+         sti->spdf.dpdf = CreateDME(hset,sti->nMix);
+         if ((GetDiscreteWeights(src,tok,sti->nMix,sti->spdf.dpdf))<SUCCESS) {
             HMError(src,"GetDiscreteWeights failed");
-            return(FAIL);
+            return(NULL);
          }
       } else {  /* PLAIN/SHARED Mixtures */
-         cpdf = pdf[s].spdf.cpdf = CreateCME(hset,M);
-         if((GetMixture(hset,src,tok,M,cpdf))<SUCCESS){
+         cpdf = sti->spdf.cpdf = CreateCME(hset,sti->nMix);
+         if ((GetMixture(hset,src,tok,sti->nMix,cpdf))<SUCCESS) {
             HMError(src,"GetMixtures failed");
-            return(FAIL);
+            return(NULL);
          }
          while (tok->sym==MIXTURE)
-            if((GetMixture(hset,src,tok,M,cpdf))<SUCCESS){
+            if ((GetMixture(hset,src,tok,sti->nMix,cpdf))<SUCCESS) {
                HMError(src,"GetMixtures failed");
-               return(FAIL);
+               return(NULL);
             }
-         for (m=1; m<=M; m++)
+         for (m=1; m<=sti->nMix; m++)
             if (cpdf[m].mpdf == NULL){
-               if((cpdf[m].mpdf = EmptyMixPDF(hset,hset->swidth[s],s))==NULL){
+               if ((cpdf[m].mpdf = EmptyMixPDF(hset,hset->swidth[sti->stream],sti->stream))==NULL) {
                   HMError(src,"EmptyMixPDF failed");
-                  return(FAIL);
+                  return(NULL);
                }
                cpdf[m].weight = 0.0;
             }
       }
+   }
+   return sti;
+}
+
+
+/* GetStream: parse src and store a StreamElem in pdf array */
+static ReturnStatus GetStream(HMMSet *hset, Source *src, Token *tok,
+                              StreamElem *ste)
+{
+   int S;
+   short s;
+  
+   S=hset->swidth[0];
+   s = 1;
+   if (tok->sym == STREAM) {
+      if (!ReadShort(src,&s,1,tok->binForm)){
+         HMError(src,"Stream Index expected");
+         return(FAIL);
+      }
+      if (s<1 || s>S){
+         HMError(src,"Stream Index out of range");
+         return(FAIL);
+      }
+      if(GetToken(src,tok)<SUCCESS){
+         HMError(src,"GetToken failed");
+         return(FAIL);
+      }
+   }
+   if ( (ste[s].info = GetStreamInfo(hset, src, tok,s))==NULL ) {
+      HMError(src,"Get Stream Information failed");
+      return(FAIL);
+   }
+
    return(SUCCESS);
 }
   
@@ -1931,11 +2133,10 @@ static ReturnStatus GetStream(HMMSet *hs
 static StateInfo *GetStateInfo(HMMSet *hset, Source *src, Token *tok)
 {
    StateInfo *si;
-   int i,S;
-   short nMix[SMAX];
+   int i,s,S;
 
    if (trace&T_PAR) printf("HModel: GetStateInfo\n");
-   S = hset->swidth[0];
+   S = s = hset->swidth[0];
    if (tok->sym==MACRO && tok->macroType=='s') {
       if((si = (StateInfo *)GetStructure(hset,src,'s'))==NULL){
          HMError(src,"GetStructure failed");
@@ -1947,21 +2148,9 @@ static StateInfo *GetStateInfo(HMMSet *h
          return(NULL);
       }
    } else {
-      if (tok->sym == NUMMIXES){
-         if (!ReadShort(src,nMix+1,S,tok->binForm)){
-            HMError(src,"Num Mix in Each Stream expected");
-            return(NULL);
-         }
-         if(GetToken(src,tok)<SUCCESS){
-            HMError(src,"GetToken failed");
-            return(NULL);
-         }
-      } else {
-         for (i=1;i<=S;i++)
-            nMix[i] = 1;
-      }
       si = (StateInfo *)New(hset->hmem,sizeof(StateInfo));
       si->nUse = 0; si->hook = NULL; si->weights = NULL;
+      si->dur = NULL; si->sIdx = 0; si->stateCounter = 0;
       si->pdf = CreateSE(hset,S);
       if (tok->sym==SWEIGHTS || (tok->sym==MACRO && tok->macroType=='w')){
          if((si->weights = GetSWeights(hset,src,tok))==NULL){
@@ -1973,12 +2162,12 @@ static StateInfo *GetStateInfo(HMMSet *h
             return(NULL);
          }
       }
-      if((GetStream(hset,src,tok,si->pdf,nMix))<SUCCESS){
+      if ((GetStream(hset,src,tok,si->pdf))<SUCCESS) {
          HMError(src,"GetStream failed");
          return(NULL);
       }
       while(tok->sym==STREAM)
-         if((GetStream(hset,src,tok,si->pdf,nMix))<SUCCESS){
+         if ((GetStream(hset,src,tok,si->pdf))<SUCCESS) {
             HMError(src,"GetStream failed");
             return(NULL);
          }
@@ -2097,6 +2286,7 @@ static ReturnStatus GetHMMDef(HMMSet *hs
       return(FAIL);
    }
    hmm->numStates = N = nState;
+   hmm->hIdx=0;
    se = (StateElem *)New(hset->hmem,(N-2)*sizeof(StateElem));
    hmm->svec = se - 2;
    while (tok->sym == STATE) {
@@ -2204,6 +2394,7 @@ static LinXForm* GetLinXForm(HMMSet *hse
     if (hset==NULL) hmem = &xformStack;
     else hmem = hset->hmem;
     xf = (LinXForm *)New(hmem,sizeof(LinXForm));
+    memset(xf, 0, sizeof(LinXForm));
     if (!ReadInt(src,&(xf->vecSize),1,tok->binForm)){
       HRError(7013,"GetLinXForm: cannot read vector size");
       return(NULL);
@@ -2458,6 +2649,7 @@ static AdaptXForm* GetAdaptXForm(HMMSet 
     xform->rtree = NULL;
     xform->nUse = 0;
     xform->xformName = NULL;
+    xform->swapXForm = xform->parentXForm = NULL;
     if (!ReadString(src,buf)){
       HRError(7013,"GetAdaptXForm: cannot read Transform Kind");
       return(NULL);
@@ -2617,7 +2809,7 @@ void PutTiedWeight(FILE *f, short repeat
 }
 
 /* PutTiedWeights: output mixture weights in compact format */
-void PutTiedWeights(FILE *f, StreamElem *se, Boolean binary)
+void PutTiedWeights(FILE *f, StreamInfo *sti, Boolean binary)
 {
    int repCount=0;
    float weight= -1;
@@ -2625,7 +2817,7 @@ void PutTiedWeights(FILE *f, StreamElem 
    Vector v;
    
    putWtActive = FALSE;
-   M = se->nMix; v = se->spdf.tpdf;
+   M = sti->nMix; v = sti->spdf.tpdf;
    for (m=1; m<=M; m++){
       if (v[m] == weight && repCount < 255)
          ++repCount;
@@ -2675,7 +2867,7 @@ void PutMixWeight(FILE *f, short repeatL
 }
 
 /* PutDiscreteWeights: output mixture weights in compact format */
-void PutDiscreteWeights(FILE *f, StreamElem *se, Boolean binary)
+void PutDiscreteWeights(FILE *f, StreamInfo *sti, Boolean binary)
 {
    int repCount=0;
    short weight= -1;
@@ -2683,7 +2875,7 @@ void PutDiscreteWeights(FILE *f, StreamE
    ShortVec v;
    
    putWtActive = FALSE;
-   M = se->nMix; v = se->spdf.dpdf;
+   M = sti->nMix; v = sti->spdf.dpdf;
    for (m=1; m<=M; m++){
       if (v[m] == weight && repCount < 255)
          ++repCount;
@@ -2703,20 +2895,20 @@ void PutDiscreteWeights(FILE *f, StreamE
 }
 
 /* PutTiedMixtures: output mixture weights in compact tied mix format */
-void PutTiedMixtures(HMMSet *hset,FILE *f,int s,StreamElem *se,Boolean binary)
+void PutTiedMixtures(HMMSet *hset,FILE *f,StreamInfo *sti,Boolean binary)
 {
    PutSymbol(f,TMIX,binary);
-   fprintf(f," %s",ReWriteString(hset->tmRecs[s].mixId->name,NULL,DBL_QUOTE));
+   fprintf(f," %s",ReWriteString(hset->tmRecs[sti->stream].mixId->name,NULL,DBL_QUOTE));
    if (!binary) fprintf(f,"\n");
-   PutTiedWeights(f,se,binary);
+   PutTiedWeights(f,sti,binary);
 }
 
 /* PutDiscrete: output discrete weights in compact format */
-void PutDiscrete(FILE *f, StreamElem *se, Boolean binary)
+void PutDiscrete(FILE *f, StreamInfo *sti, Boolean binary)
 {
    PutSymbol(f,DPROB,binary);
    if (!binary) fprintf(f,"\n");
-   PutDiscreteWeights(f,se,binary);
+   PutDiscreteWeights(f,sti,binary);
 }
 
 /* ---------- Standard Macro Definition Output Routines ------------------ */
@@ -2753,7 +2945,7 @@ static void PutMean(HMMSet *hset, FILE *
       PutSymbol(f,MEAN,binary);
       size = VectorSize(m);
       WriteShort(f,&size,1,binary);
-      if (!binary) fprintf(f,"\n");
+      if (!binary && size != 0) fprintf(f,"\n");
       WriteVector(f,m,binary);
    }
 }
@@ -2772,7 +2964,7 @@ static void PutVariance(HMMSet *hset, FI
       PutSymbol(f,VARIANCE,binary);
       size = VectorSize(v);
       WriteShort(f,&size,1,binary);
-      if (!binary) fprintf(f,"\n");
+      if (!binary  && size != 0) fprintf(f,"\n");
       WriteVector(f,v,binary);
    }
 }
@@ -2859,19 +3051,28 @@ static void PutSWeights(HMMSet *hset, FI
                         Boolean inMacro, Boolean binary)
 {
    int nUse;
-   short size;
+   short s,size;
+   Boolean out = FALSE;
 
    nUse = GetUse(v);
    if (nUse > 0 || inMacro) 
       PutMacroHdr(hset,f,q,'w',v,binary);
    if (nUse == 0 || inMacro){
-      PutSymbol(f,SWEIGHTS,binary);
       size = VectorSize(v);
+      for (s=1;s<=size;s++) {
+         if (v[s]!=1.0) {
+            out = TRUE;
+            break;
+         }
+      }
+      if (out) {
+         PutSymbol(f,SWEIGHTS,binary);
       WriteShort(f,&size,1,binary);
       if (!binary) fprintf(f,"\n");
       WriteVector(f,v,binary);
    }
 }
+}
 
 /* PutTransMat: output transition matrix to stream f */
 static void PutTransMat(HMMSet *hset, FILE *f, MLink q, SMatrix m,
@@ -2922,6 +3123,7 @@ static void GetMixPDFInfo(HMMSet *hset, 
    Boolean found;
    StateElem *se;
    StreamElem *ste;
+   StreamInfo *sti;
    MixtureElem *me;
 
    found = FALSE;
@@ -2932,7 +3134,8 @@ static void GetMixPDFInfo(HMMSet *hset, 
    for (i=2; i<N; i++,se++){
       ste = se->info->pdf+1;
       for (s=1;s<=S;s++,ste++){
-         me = ste->spdf.cpdf + 1; M = ste->nMix;
+         sti = ste->info;
+         me = sti->spdf.cpdf + 1; M = sti->nMix;
          for (m=1;m<=M;m++,me++) {
             if (me == tme) {
                *state = i; *stream = s;
@@ -2953,9 +3156,9 @@ static void PutBaseClass(HMMSet *hset, F
 			 Boolean inMacro, Boolean binary) 
 {
   char buf[MAXSTRLEN];
-  int numClass, c;
+   int numClass, c, j;
   ILink i;
-  int stream, state, comp;
+   int stream=1, state=2, comp=1;
   HMMDef *hmm;
   
   if (bclass->fname == NULL)
@@ -2969,6 +3172,14 @@ static void PutBaseClass(HMMSet *hset, F
     PutSymbol(f,PARAMETERS,binary);
     WriteString(f,BaseClassKind2Str(bclass->bkind,buf),DBL_QUOTE);
     if (!binary) fprintf(f,"\n");
+    /* put <StreamInfo> for multiple streams system */
+    if (hset->swidth[0]>1) {
+      PutSymbol(f,STREAMINFO,binary);
+      WriteShort(f, hset->swidth, 1, binary);
+      for (j=1; j<=hset->swidth[0]; j++)
+        WriteShort(f, hset->swidth+j, 1, binary);
+        if (!binary) fprintf(f,"\n");
+    }
     PutSymbol(f,NUMCLASSES,binary);
     numClass = bclass->numClasses;
     WriteInt(f,&(numClass),1,binary);
@@ -3049,54 +3260,41 @@ static void PutMixPDF(HMMSet *hset, FILE
    }  
 }
 
-/* PutStateInfo: output state info to stream f */
-static void PutStateInfo(HMMSet *hset, FILE *f, MLink q, StateInfo *si, 
+/* PutStreamInfo: output stream info */
+static void PutStreamInfo(HMMSet *hset, FILE *f, MLink q, StreamInfo *sti, 
                          Boolean inMacro, Boolean binary)
 {
-   int S;
+   short m;
    float wt;
-   StreamElem *se;
    MixtureElem *me;
-   short m,s,nMix[SMAX];
-   Boolean needNM = FALSE;
    
-   S = hset->swidth[0];
-   if (si->nUse > 0 || inMacro) 
-      PutMacroHdr(hset,f,q,'s',si,binary);
-   if (si->nUse == 0 || inMacro){
-      se = si->pdf+1;
-      for (s=1; s<=S; s++,se++) {
-         if (se->nMix>1) needNM = TRUE;
-         nMix[s] = se->nMix;
-      }
-      if (needNM){
-         PutSymbol(f,NUMMIXES,binary);
-         WriteShort(f,nMix+1,S,binary);
+   if (sti->nUse > 0 || inMacro) 
+      PutMacroHdr(hset,f,q,'p',sti,binary);
+
+   if (sti->nUse == 0 || inMacro) {
+      if (inMacro) {
+	     PutSymbol(f,STREAM,binary);
+	     WriteShort(f,&sti->stream,1,binary);
          if (!binary) fprintf(f,"\n");
       }
-      if (si->weights != NULL)
-         PutSWeights(hset,f,NULL,si->weights,FALSE,binary);
-      se = si->pdf+1;
-      for (s=1; s<=S; s++,se++){
-         if (S>1){
-            PutSymbol(f,STREAM,binary);
-            WriteShort(f,&s,1,binary);
+      if (sti->nMix>1) {
+	     PutSymbol(f,NUMMIXES,binary);
+         WriteInt(f,&sti->nMix,1,binary);
             if (!binary) fprintf(f,"\n");
          }
          switch (hset->hsKind) {
          case TIEDHS:
-            PutTiedMixtures(hset,f,s,se,binary);
+            PutTiedMixtures(hset,f,sti,binary);
             break;
          case DISCRETEHS:
-            PutDiscrete(f,se,binary);
+            PutDiscrete(f,sti,binary);
             break;
          case PLAINHS:
          case SHAREDHS:
-            me = se->spdf.cpdf+1;
-            for (m=1; m<=se->nMix; m++,me++){
+            me = sti->spdf.cpdf+1;
+            for (m=1; m<=sti->nMix; m++,me++) {
                wt = MixWeight(hset,me->weight);
-               if (wt > MINMIX) {
-                  if (se->nMix > 1){
+               if (sti->nMix > 1) { 
                      PutSymbol(f,MIXTURE,binary);
                      WriteShort(f,&m,1,binary);
                      WriteFloat(f,&wt,1,binary);
@@ -3104,10 +3302,34 @@ static void PutStateInfo(HMMSet *hset, F
                   }
                   PutMixPDF(hset,f,NULL,me->mpdf,FALSE,binary);
                }
-            }
             break;
          }
       }
+}
+
+/* PutStateInfo: output state info to stream f */
+static void PutStateInfo(HMMSet *hset, FILE *f, MLink q, StateInfo *si, 
+                         Boolean inMacro, Boolean binary)
+{
+   int S;
+   StreamElem *ste;
+   short s;
+   
+   S = hset->swidth[0];
+   if (si->nUse > 0 || inMacro) 
+      PutMacroHdr(hset,f,q,'s',si,binary);
+   if (si->nUse == 0 || inMacro) {
+      if (si->weights != NULL)
+         PutSWeights(hset,f,NULL,si->weights,FALSE,binary);
+      ste = si->pdf+1;
+      for (s=1; s<=S; s++,ste++) {
+         if (S>1) {
+            PutSymbol(f,STREAM,binary);
+            WriteShort(f,&s,1,binary);
+            if (!binary) fprintf(f,"\n");
+         }
+         PutStreamInfo(hset,f,NULL,ste->info,FALSE,binary);
+      }
       if (hset->dkind!=NULLD && si->dur != NULL)
          PutDuration(hset,f,NULL,si->dur,FALSE,binary);
    }
@@ -3230,8 +3452,9 @@ static void PutAdaptXForm(HMMSet *hset, 
 /* PutOptions: write the current global options to f */
 static void PutOptions(HMMSet *hset, FILE *f, Boolean binary)
 {
-   short i,S;
+   short i,s,S,M;
    char buf[64];
+   Boolean msd;
 
    if (hset->hmmSetId!=NULL) {
       PutSymbol(f,HMMSETID,binary);
@@ -3243,6 +3466,24 @@ static void PutOptions(HMMSet *hset, FIL
    for (i=1;i<=S;i++)
       WriteShort(f,hset->swidth+i,1,binary);
    if (!binary) fprintf(f,"\n");
+
+   /* MSD check: if any MSDs are not used, we need not to put options about MSD */
+   for (s=1,msd=FALSE; s<=hset->swidth[0]; s++) {
+      if (hset->msdflag[s]!=0) {
+         msd = TRUE;
+         break;
+      }
+   }
+   
+   if (msd) {
+      M = hset->msdflag[0];
+      PutSymbol(f,MSDINFO,binary);
+      WriteShort(f,hset->msdflag,1,binary);
+      for (i=1;i<=M;i++)
+         WriteShort(f,hset->msdflag+i,1,binary);
+      if (!binary) fprintf(f,"\n");
+   }
+   
    PutSymbol(f,VECSIZE,binary);
    WriteShort(f,&hset->vecSize,1,binary);
    if (hset->projSize > 0) {
@@ -3323,7 +3564,7 @@ static unsigned Hash(char *name)
 /* EXPORT-> NewMacro: append a macro with given values to list */
 MLink NewMacro(HMMSet *hset, short fidx, char type, LabId id, Ptr structure)
 {
-   unsigned int hashval;
+   unsigned long hashval;
    MLink m;
    PtrMap *p;
 
@@ -3380,10 +3621,11 @@ MLink NewMacro(HMMSet *hset, short fidx,
    hashval = Hash(id->name);
    m->type = type; m->fidx = fidx;
    m->id = id;
+   m->hook = NULL;
    m->structure = structure;
    m->next = hset->mtab[hashval]; hset->mtab[hashval] = m;
    if (hset->pmap != NULL) {
-      hashval = (unsigned int)m->structure % PTRHASHSIZE;
+      hashval = (unsigned long)m->structure % PTRHASHSIZE;
       p = (PtrMap *)New(hset->hmem,sizeof(PtrMap));
       p->ptr = m->structure; p->m = m; 
       p->next = hset->pmap[hashval]; hset->pmap[hashval] = p;
@@ -3438,7 +3680,7 @@ MLink FindMacroStruct(HMMSet *hset, char
 {
    MLink m;
    int h,n;
-   unsigned int i;
+   unsigned long i;
    PtrMap *p;
    
 
@@ -3447,7 +3689,7 @@ MLink FindMacroStruct(HMMSet *hset, char
       if (trace&T_PMP) printf("HModel: creating pointer map hash table\n");
       for (n=0,h=0; h<MACHASHSIZE; h++)
          for (m=hset->mtab[h]; m!=NULL; m=m->next){
-            i = (unsigned int)m->structure % PTRHASHSIZE;
+            i = (unsigned long)m->structure % PTRHASHSIZE;
             p = (PtrMap *)New(hset->hmem,sizeof(PtrMap));
             p->ptr = m->structure; p->m = m; 
             p->next = hset->pmap[i]; hset->pmap[i] = p;
@@ -3455,7 +3697,7 @@ MLink FindMacroStruct(HMMSet *hset, char
          }
       if (trace&T_PMP) printf("HModel: %d pointers hashed\n",n);
    }
-   i = (unsigned int)structure % PTRHASHSIZE;
+   i = (unsigned long)structure % PTRHASHSIZE;
    for (p = hset->pmap[i]; p != NULL; p = p->next) {
       m = p->m;
       if (p->ptr == structure && m->type == type)
@@ -3498,6 +3740,7 @@ void SetSemiTiedVFloor(HMMSet *hset)
    bclass = xform->bclass;
    for (b=1;b<=bclass->numClasses;b++) {
       numXf = xform->xformWgts.assign[b];
+      if (numXf!=0) {
       vFloor = xform->xformSet->xforms[numXf]->vFloor;
       if (vFloor != NULL) {
          for (il=bclass->ilist[b]; il!=NULL; il=il->next) {
@@ -3507,12 +3750,13 @@ void SetSemiTiedVFloor(HMMSet *hset)
       }
    } 
 }
+}
 
 /* EXPORT->SetVFloor: set vFloor[1..S] from macros "varFloorN" */
 void SetVFloor(HMMSet *hset, Vector *vFloor, float minVar)
 {
    int j,s,S,size;
-   char mac[256], num[10];
+   char mac[MAXSTRLEN], num[10];
    LabId id;
    MLink m;
    SVector v;
@@ -3541,6 +3785,27 @@ void SetVFloor(HMMSet *hset, Vector *vFl
    }
 }
 
+/* EXPORT->ResetVFloor: reset vFloor[1..S] */
+void ResetVFloor(HMMSet *hset, Vector *vFloor)
+{
+   int s;
+   char mac[MAXSTRLEN], num[10];
+   LabId id;
+   MLink m;
+   
+   if (vFloor==NULL) return;
+   
+   for (s=hset->swidth[0]; s>0; s--) {
+      strcpy(mac,"varFloor");
+      sprintf(num,"%d",s); strcat(mac,num);
+      id = GetLabId(mac,FALSE);
+      if (id != NULL  && (m=FindMacroName(hset,'v',id)) != NULL)
+         vFloor[s] = NULL;
+      else  
+         FreeVector(hset->hmem,vFloor[s]);
+   }
+}
+
 /* EXPORT->ApplyVFloor: apply the variance floors in hset to all mix comps */
 void ApplyVFloor(HMMSet *hset)
 {
@@ -3579,9 +3844,10 @@ void ApplyVFloor(HMMSet *hset)
       mixFloored = FALSE;
       cov=hss.mp->cov;
       minv = vFloor[hss.s];
-      vSize = VectorSize(minv);
+      vSize = VectorSize(hss.mp->mean);
       switch (hss.mp->ckind) {
       case DIAGC: /* diagonal covariance matrix */ 
+         if (vSize == VectorSize(minv)) {  /* check MSD */ 
          for (k=1; k<=vSize; k++){
             if (cov.var[k]<minv[k]) {
                cov.var[k] = minv[k];
@@ -3590,8 +3856,10 @@ void ApplyVFloor(HMMSet *hset)
             }
          }
          FixDiagGConst(hss.mp); 
+         }
          break;
       case INVDIAGC: /* inverse diagonal covariance matrix */ 
+         if (vSize == VectorSize(minv)) {  /* check MSD */ 
          for (k=1; k<=vSize; k++){
             if (cov.var[k]> 1.0/minv[k]) {
                cov.var[k] = 1.0/minv[k];
@@ -3600,8 +3868,10 @@ void ApplyVFloor(HMMSet *hset)
             }
          }
          FixInvDiagGConst(hss.mp); 
+         }
          break;
       case FULLC: /* full covariance matrix */ 
+         if (vSize == VectorSize(minv)) {  /* check MSD */ 
          CovInvert(cov.inv,cov.inv);
          for (k=1; k<=vSize; k++){
             if (cov.inv[k][k]<minv[k]) {
@@ -3611,6 +3881,7 @@ void ApplyVFloor(HMMSet *hset)
             }
          }
          FixFullGConst(hss.mp, CovInvert(cov.inv,cov.inv) ); 
+         }
          break;
       case LLTC:
       case XFORMC:   
@@ -3644,7 +3915,11 @@ void PrintHMMProfile(FILE *f, HLink hmm)
    for (i=2;i<N;i++) fprintf(f,"%3d",i); fprintf(f," (width)\n");
    for (s=1;s<=S;s++){
       fprintf(f," Mixes  s%d: ",s); 
-      for (i=2;i<N;i++) fprintf(f,"%3d",hmm->svec[i].info->pdf[s].nMix);
+      for (i=2;i<N;i++) fprintf(f,"%3d",hmm->svec[i].info->pdf[s].info->nMix);
+      fprintf(f," ( %2d  )\n",hmm->owner->swidth[s]);
+      if (hmm->owner->msdflag[s])
+         fprintf(f," ( MSD  <= %2d )\n",hmm->owner->swidth[s]);
+      else
       fprintf(f," ( %2d  )\n",hmm->owner->swidth[s]);
       fprintf(f," Num Using: "); 
       for (i=2;i<N;i++) fprintf(f,"%3d",hmm->svec[i].info->nUse); 
@@ -3729,7 +4004,7 @@ void PrintHSetProfile(FILE *f, HMMSet *h
    }
 
    fprintf (f, " Global CovKind = %s\n", CovKind2Str(hset->ckind, buf));
-   for (ck = 0; ck < NUMCKIND; ck++) 
+   for (ck = (CovKind) 0; ck < NUMCKIND; ck++) 
       if (hset->ckUsage[ck] > 0 ) 
 	 fprintf (f, "   CK %-8s = %d mixcomps\n", CovKind2Str (ck, buf), hset->ckUsage[ck]);
 
@@ -3785,7 +4060,7 @@ static ReturnStatus LoadAllMacros(HMMSet
             return(FAIL);
          }
          id = GetLabId(buf,TRUE);
-         if (type == 'h'){    /* load a HMM definition */
+         if (type == 'h'){    /* load an HMM definition */
             m = FindMacroName(hset,'h',id);
             if (m == NULL) {
                if (!allowOthers){
@@ -3797,7 +4072,7 @@ static ReturnStatus LoadAllMacros(HMMSet
                dset=*hset;
                dset.hmem=&gstack;
                dhmm = (HLink) New(&gstack,sizeof(HMMDef));
-               dhmm->owner=NULL; dhmm->numStates=0; dhmm->nUse=0; dhmm->hook=NULL;
+               dhmm->owner=NULL; dhmm->numStates=0; dhmm->nUse=0; dhmm->hook=NULL; dhmm->hIdx=0;
                if (trace&T_MAC)
                   printf("HModel: skipping HMM Def from macro %s\n",id->name);
                if(GetToken(&src,&tok)<SUCCESS){
@@ -3843,6 +4118,7 @@ static ReturnStatus LoadAllMacros(HMMSet
             }
             switch(type){
             case 's': structure = GetStateInfo(hset,&src,&tok); break;
+            case 'p': structure = GetStreamInfo(hset,&src,&tok,0); break;
             case 'm': structure = GetMixPDF(hset,&src,&tok);    break;
             case 'u': structure = GetMean(hset,&src,&tok);      break;
             case 'v': structure = GetVariance(hset,&src,&tok);  break;
@@ -3912,7 +4188,9 @@ static Boolean IsShared(HMMSet *hset)
    char types[20];
    
    if (HasMacros(hset,types)) {
-      if (strchr(types,'m') != NULL ||  strchr(types,'s') != NULL)
+      if (strchr(types,'m') != NULL ||  
+          strchr(types,'s') != NULL || 
+          strchr(types,'p') != NULL )
          return TRUE;
    }
    return FALSE;
@@ -3943,17 +4221,26 @@ void SetIndexes(HMMSet *hset)
 {
    HMMScanState hss;
    StateInfo *si;
+   StreamInfo *sti;
    MixPDF *mp;
    MLink m;
-   int h,nm,nsm,ns,nss,nt;
+   int h,nm,nsm,ns,nss,nsp,np,nh,nt;
    
    /* Reset indexes */
-   indexSet = TRUE;
-   nt=0;
+   hset->indexSet = TRUE;
+   nt=nh=0;
    NewHMMScan(hset,&hss);
    while(GoNextState(&hss,FALSE))
       hss.si->sIdx=-1;
    EndHMMScan(&hss);
+
+   if (hset->hsKind == PLAINHS || hset->hsKind == SHAREDHS) {
+      NewHMMScan(hset,&hss);
+      while (GoNextStream(&hss,FALSE))
+         hss.sti->pIdx=-1;
+      EndHMMScan(&hss);
+   }
+
    if (hset->hsKind == PLAINHS || hset->hsKind == SHAREDHS) {
       NewHMMScan(hset,&hss);
       while(GoNextMix(&hss,FALSE))
@@ -3964,10 +4251,11 @@ void SetIndexes(HMMSet *hset)
    NewHMMScan(hset,&hss);
    do {
       if (!IsSeenV(hss.hmm->transP)) {
-         SetHook(hss.hmm->transP,(Ptr)(++nt));
+         SetHook(hss.hmm->transP,(Ptr)((long)(++nt)));
          TouchV(hss.hmm->transP);
       }
-      hss.hmm->tIdx=(int)GetHook(hss.hmm->transP);
+      hss.hmm->tIdx=(int)((long)GetHook(hss.hmm->transP));
+      hss.hmm->hIdx=nh++;
    }
    while(GoNextHMM(&hss));
    EndHMMScan(&hss);
@@ -3979,23 +4267,36 @@ void SetIndexes(HMMSet *hset)
    while(GoNextHMM(&hss));
    EndHMMScan(&hss);
 
-   nsm=nss=0;
+   nsm=nss=nsp=0;
    for (h=0; h<MACHASHSIZE; h++)
       for (m=hset->mtab[h]; m!=NULL; m=m->next) {
-         if (m->type=='s') {
+         if (m->type=='s') { /* shared state */
             si=(StateInfo *)m->structure;
             if (si->sIdx<0) si->sIdx=++nss;
          }
-         if (m->type=='m') {
+         if (m->type=='p') { /* shared stream */
+            sti=(StreamInfo *)m->structure;
+            if (sti->pIdx<0) sti->pIdx=++nsp;
+         }
+         if (m->type=='m') { /* shared mixture */
             mp=(MixPDF *)m->structure;
             if (mp->mIdx<0) mp->mIdx=++nsm;
          }
       }
-   nm=nsm;ns=nss;
+
+   nm=nsm;ns=nss;np=nsp;
    NewHMMScan(hset,&hss);
    while(GoNextState(&hss,FALSE))
       if (hss.si->sIdx<0) hss.si->sIdx=++ns;
    EndHMMScan(&hss);
+
+   if (hset->hsKind == PLAINHS || hset->hsKind == SHAREDHS) {
+      NewHMMScan(hset,&hss);
+      while (GoNextStream(&hss,FALSE))
+         if (hss.sti->pIdx<0) hss.sti->pIdx=++np;
+      EndHMMScan(&hss);
+   }
+
    if (hset->hsKind == PLAINHS || hset->hsKind == SHAREDHS) {
       NewHMMScan(hset,&hss);
       while(GoNextMix(&hss,FALSE))
@@ -4007,6 +4308,7 @@ void SetIndexes(HMMSet *hset)
       EndHMMScan(&hss);
    }
    hset->numStates=ns; hset->numSharedStates=nss;
+   hset->numStreams=np; hset->numSharedStreams=nsp;
    hset->numMix=nm; hset->numSharedMix=nsm;
    hset->numTransP=nt;
 }
@@ -4022,7 +4324,7 @@ void SetCovKindUsage (HMMSet *hset)
    HMMScanState hss;
    CovKind ck;
 
-   for (ck = 0; ck < NUMCKIND; ck++)
+   for (ck = (CovKind) 0; ck < NUMCKIND; ck++)
       hset->ckUsage[ck] =0;
 
    if (hset->hsKind == DISCRETEHS) return;
@@ -4037,7 +4339,7 @@ void SetCovKindUsage (HMMSet *hset)
       CovKind lastSeenCK = NULLC;
       int nCK = 0;
 
-      for (ck = 0; ck < NUMCKIND; ck++)
+      for (ck = (CovKind) 0; ck < NUMCKIND; ck++)
          if (hset->ckUsage[ck] > 0) {
             ++nCK;
             lastSeenCK = ck;
@@ -4194,10 +4496,10 @@ void CreateHMMSet(HMMSet *hset, MemHeap 
    hset->hmmSetId = NULL;
    hset->mmfNames = NULL; hset->numFiles = 0;
    hset->allowTMods = allowTMods;  hset->optSet = FALSE;
-   hset->vecSize = 0; hset->swidth[0] = 0;
+   hset->vecSize = 0; hset->swidth[0] = 0; hset->msdflag[0] = 0;
    hset->dkind = NULLD; hset->ckind = NULLC; hset->pkind = 0;
    hset->numPhyHMM = hset->numLogHMM = hset->numMacros = 0;
-   hset->xf = NULL; hset->logWt = FALSE;
+   hset->xf = NULL; hset->logWt = FALSE; hset->indexSet = FALSE;
    for (s=1; s<SMAX; s++) {
       hset->tmRecs[s].nMix = 0; hset->tmRecs[s].mixId = NULL;
       hset->tmRecs[s].probs = NULL; hset->tmRecs[s].mixes = NULL;
@@ -4214,6 +4516,7 @@ void CreateHMMSet(HMMSet *hset, MemHeap 
    hset->semiTiedMacro = NULL;
    hset->semiTied = NULL;
    hset->projSize = 0;
+   hset->xformDirNames = NULL;
 }
 
 /* CreateHMM: create logical macro. If pId is unknown, create macro for
@@ -4234,6 +4537,7 @@ static ReturnStatus CreateHMM(HMMSet *hs
    if (m == NULL) {  /* need to create new phys macro and HMMDef */
       hmm = (HLink)New(hset->hmem,sizeof(HMMDef));
       hmm->owner = hset; hmm->nUse = 1; hmm->hook = NULL;
+      hmm->svec = NULL; hmm->dur = NULL; hmm->transP = NULL; hmm->tIdx=0;
       hmm->numStates = 0;  /* indicates HMMDef not yet defined */
       if((m=NewMacro(hset,0,'h',pId,hmm))==NULL){
          HRError(7091,"CreateHMM: NewMacro (Physical) failed"); /*will never happen*/
@@ -4258,7 +4562,7 @@ static ReturnStatus CreateHMM(HMMSet *hs
 }
 
 
-/* InitHMMSet: Init a HMM set by reading the HMM list in fname.
+/* InitHMMSet: Init an HMM set by reading the HMM list in fname.
                If isSingle, then fname is the name of a single HMM */
 static ReturnStatus InitHMMSet(HMMSet *hset, char *fname, Boolean isSingle)
 {
@@ -4316,7 +4620,7 @@ static ReturnStatus InitHMMSet(HMMSet *h
 }
 
 
-/* EXPORT->MakeHMMSet: Make a HMM set by reading the HMM list in fname */
+/* EXPORT->MakeHMMSet: Make an HMM set by reading the HMM list in fname */
 ReturnStatus MakeHMMSet(HMMSet *hset, char *fname)
 {
    if(InitHMMSet(hset, fname, FALSE)<SUCCESS){
@@ -4387,15 +4691,19 @@ static void SaveMacros(FILE *f, HMMSet *
 	       /* should these be associated with the models or not ??? */
             default: break;
             }
-   for (h=0; h<MACHASHSIZE; h++)    /* then higher levels */
+   for (h=0; h<MACHASHSIZE; h++)    /* then higher levels (mixture) */
       for (m=hset->mtab[h]; m!=NULL; m=m->next)
          if (m->fidx == fidx && m->type == 'm')
             PutMixPDF(hset,f,m,(MixPDF *)m->structure,TRUE,binary);
-   for (h=0; h<MACHASHSIZE; h++)    /* then higher levels */
+   for (h=0; h<MACHASHSIZE; h++)    /* then higher levels (stream) */
+      for (m=hset->mtab[h]; m!=NULL; m=m->next)
+         if (m->fidx == fidx && m->type == 'p')
+            PutStreamInfo(hset,f,m,(StreamInfo *)m->structure,TRUE,binary);
+   for (h=0; h<MACHASHSIZE; h++)    /* then higher levels (state) */
       for (m=hset->mtab[h]; m!=NULL; m=m->next)
          if (m->fidx == fidx && m->type == 's')
             PutStateInfo(hset,f,m,(StateInfo *)m->structure,TRUE,binary);
-   for (h=0; h<MACHASHSIZE; h++)    /* then top model level */
+   for (h=0; h<MACHASHSIZE; h++)    /* then top level (HMM) */
       for (m=hset->mtab[h]; m!=NULL; m=m->next)
          if (m->fidx == fidx && m->type == 'h')
             PutHMMDef(hset,f,m,TRUE,binary); 
@@ -4491,7 +4799,7 @@ static char *InitXFormScanner(HMMSet *hs
   if ((fname==NULL) || ((f=FOpen(fname,NoFilter,&isPipe)) == NULL)) {
     if ((trace&T_XFD) && (fname!=NULL))
       HRError(7010,"InitXFormScanner: Cannot open source file %s",fname);
-    p = xformDirNames;
+    p = hset->xformDirNames;
     while ((p!=NULL) && 
 	   ((f=FOpen(MakeFN(macroname,p->dirName,NULL,buf),NoFilter,&isPipe)) == NULL)) {
       if (trace&T_XFD) 
@@ -4745,7 +5053,7 @@ void SaveAllXForms(HMMSet *hset, char *f
   Boolean isPipe;
   int fidx=CREATEFIDX;
       
-  binary = binary||saveBinary;
+  binary = (binary||saveBinary) ? TRUE : FALSE;
   if ((f=FOpen(fname,HMMDefOFilter,&isPipe)) == NULL){
     HError(7011,"SaveAllXForm: Cannot create output file %s",fname);
   }
@@ -4810,7 +5118,7 @@ void SaveOneXForm(HMMSet *hset, AdaptXFo
 
   if (xform->nUse>0) 
     HError(999,"Shared AdaptXForm cannot store to a single file");
-  binary = binary||saveBinary;
+  binary = (binary||saveBinary) ? TRUE : FALSE;
   if (xform->swapXForm != NULL) { /* need to save the parent xform */
      swapxform = xform->swapXForm;
      xform->swapXForm = NULL;
@@ -4841,6 +5149,7 @@ void SaveInputXForm(HMMSet *hset, InputX
   FILE *f;
   Boolean isPipe;
 
+  binary = (binary||saveBinary) ? TRUE : FALSE;
   if ((f=FOpen(fname,HMMDefOFilter,&isPipe)) == NULL){
     HError(7011,"SaveInputXForm: Cannot create output file %s",fname);
   }
@@ -4879,12 +5188,12 @@ void SaveInOneFile(HMMSet *hset, char *f
 void FixOrphanMacros(HMMSet *hset)
 {
    int h,numMacs=0,numHMMs = 0;
-   short firstx,firsth,firsts,firstm;
+   short firstx,firsth,firsts,firstp,firstm;
    MLink m;
    MILink p;
 
    /* find first occ of major macro classes */
-   firsth=firsts=firstm=firstx=hset->numFiles+1;
+   firsth=firsts=firstp=firstm=firstx=hset->numFiles+1;
    for (h=0; h<MACHASHSIZE; h++)
       for (m=hset->mtab[h]; m!=NULL; m=m->next)
          if (m->fidx == 0)
@@ -4902,6 +5211,9 @@ void FixOrphanMacros(HMMSet *hset)
             case 's':
                if (m->fidx<firsts) firsts=m->fidx;
                break;
+            case 'p':
+               if (m->fidx<firstp) firstp=m->fidx;
+               break;
             case 'm':
                if (m->fidx<firstm) firstm=m->fidx;
                break;
@@ -4921,11 +5233,12 @@ void FixOrphanMacros(HMMSet *hset)
          firsts=firsth;
          if (firsts>2) --firsts;
       }
-      if (firstm>firsts) firstm = firsts;
+      if (firstp>firsts) firstp = firsts;
+      if (firstm>firstp) firstm = firstp;
       if (firstx>firstm) firstx = firstm;
       if (trace&T_ORP)
-         printf("  files=%d h=%d,s=%d,m=%d,x=%d\n",
-                hset->numFiles,firsth,firsts,firstm,firstx);
+         printf("  files=%d h=%d,s=%d,p=%d,m=%d,x=%d\n",
+                hset->numFiles,firsth,firsts,firstp,firstm,firstx);
       /* finally fix the fidx's */
       for (h=0; h<MACHASHSIZE; h++)
          for (m=hset->mtab[h]; m!=NULL; m=m->next)
@@ -4939,6 +5252,8 @@ void FixOrphanMacros(HMMSet *hset)
                   break;
                case 's':
                   m->fidx = firsts; break;
+               case 'p':
+                  m->fidx = firstp; break; 
                case 'm':
                   m->fidx = firstm; break;
                case 'o':
@@ -4971,7 +5286,7 @@ static void ReOrderComponents(HMMSet *hs
 
    NewHMMScan(hset,&hss);
    while(GoNextStream(&hss,FALSE))
-      qsort(hss.ste->spdf.cpdf+1,hss.M,sizeof(MixtureElem),gconst_cmp);
+      qsort(hss.sti->spdf.cpdf+1,hss.M,sizeof(MixtureElem),gconst_cmp);
    EndHMMScan(&hss);
 }
 
@@ -4980,7 +5295,7 @@ ReturnStatus SaveHMMSet(HMMSet *hset, ch
 {
    FILE *f;
    MILink p;
-   char fname[256];
+   char fname[MAXSTRLEN];
    int h,i;
    MLink m;
    Boolean isPipe;
@@ -4989,7 +5304,7 @@ ReturnStatus SaveHMMSet(HMMSet *hset, ch
    /* Sort mixture components according to the gConst values */
    if ((hset->hsKind == PLAINHS || hset->hsKind == SHAREDHS) && reorderComps)
       ReOrderComponents(hset);
-   binary = binary || saveBinary;
+   binary = (binary || saveBinary) ? TRUE : FALSE;
    /* First output to all named MMF files */
    for (p=hset->mmfNames,i=1; p!=NULL; p=p->next,i++) 
       if (p->isLoaded) {
@@ -5025,7 +5340,7 @@ ReturnStatus SaveHMMSet(HMMSet *hset, ch
    return(SUCCESS);
 }
 
-/* EXPORT->SaveHMMList: Save a HMM list in fname describing given HMM set */
+/* EXPORT->SaveHMMList: Save an HMM list in fname describing given HMM set */
 ReturnStatus SaveHMMList(HMMSet *hset, char *fname)
 {
    int h;
@@ -5063,7 +5378,7 @@ ReturnStatus SaveHMMList(HMMSet *hset, c
 /* EXPORT->IsSeen: return true if flag is "set" */
 Boolean IsSeen(int flag)
 {
-   return (flag<0);
+   return ((flag<0) ? TRUE : FALSE);
 }
 
 /* EXPORT->Touch: set given flag */
@@ -5085,15 +5400,15 @@ void Untouch(int *flag)
 }
 
 /* EXPORT->ClearStreams: clear flags in given stream */
-void ClearStreams(HMMSet *hset, StreamElem *ste, ClearDepth depth)
+void ClearStreams(HMMSet *hset, StreamInfo *sti, ClearDepth depth)
 {
    MixPDF *mp;
    int m;
    
-   Untouch(&ste->nMix);
+   Untouch(&sti->nUse);
    if (depth==CLR_ALL && (hset->hsKind==PLAINHS || hset->hsKind==SHAREDHS)) {
-      for (m=1; m<=ste->nMix; m++){
-         mp = ste->spdf.cpdf[m].mpdf;
+      for (m=1; m<=sti->nMix; m++){
+         mp = sti->spdf.cpdf[m].mpdf;
          Untouch(&mp->nUse);
          UntouchV(mp->mean);
          UntouchV(mp->cov.var);  
@@ -5127,7 +5442,7 @@ void ClearSeenFlags(HMMSet *hset, ClearD
                   if (si->dur != NULL) UntouchV(si->dur);
                   if (depth>=CLR_STREAMS)
                      for (s=1,ste=si->pdf+1; s<=S; s++,ste++)
-                        ClearStreams(hset,ste,depth);
+                        ClearStreams(hset,ste->info,depth);
                }
          }
    if ((hset->hsKind == TIEDHS) && (depth==CLR_ALL)) {
@@ -5147,13 +5462,13 @@ void ClearSeenFlags(HMMSet *hset, ClearD
 int MaxMixtures(HLink hmm)
 {
    int i,s,S,maxM = 0;
-   StreamElem *se;
+   StreamElem *ste;
    
    S = hmm->owner->swidth[0];
    for (i=2; i<hmm->numStates; i++){
-      se = hmm->svec[i].info->pdf +1;
-      for (s=1; s<=S; s++,se++)
-         if (se->nMix > maxM) maxM = se->nMix;
+      ste = hmm->svec[i].info->pdf +1;
+      for (s=1; s<=S; s++,ste++)
+         if (ste->info->nMix > maxM) maxM = ste->info->nMix;
    }
    return maxM;
 }
@@ -5162,11 +5477,11 @@ int MaxMixtures(HLink hmm)
 int MaxMixInS(HLink hmm, int s)
 {
    int i,maxM = 0;
-   StreamElem *se;
+   StreamElem *ste;
    
    for (i=2; i<hmm->numStates; i++){
-      se = hmm->svec[i].info->pdf +s;
-      if (se->nMix > maxM) maxM = se->nMix;
+      ste = hmm->svec[i].info->pdf +s;
+      if (ste->info->nMix > maxM) maxM = ste->info->nMix;
    }
    return maxM;
 }
@@ -5344,7 +5659,7 @@ void PrecomputeTMix(HMMSet *hset, Observ
 }
 
 /* DOutP: Log prob of x in given mixture - Diagonal Case */
-static LogFloat DOutP(Vector x, int vecSize, MixPDF *mp)
+static LogFloat DOutP(Vector x, const int vecSize, MixPDF *mp)
 {
    int i;
    float sum,xmm;
@@ -5358,7 +5673,7 @@ static LogFloat DOutP(Vector x, int vecS
 }
 
 /* FOutP: Log prob of x in given mixture - Full Covariance Case */
-static LogFloat FOutP(Vector x, int vecSize, MixPDF *mp)
+static LogFloat FOutP(Vector x, const int vecSize, MixPDF *mp)
 {
    float sum;
    int i,j;
@@ -5382,14 +5697,14 @@ static LogFloat FOutP(Vector x, int vecS
 
 
 /* COutP: Log prob of x in given mixture - LLT (Choleski) Cov Case */
-static LogFloat COutP(Vector x, int vecSize, MixPDF *mp)
+static LogFloat COutP(Vector x, const int vecSize, MixPDF *mp)
 {
    HError(7001,"COutP: Choleski storage not yet implemented");
    return 0.0;
 }
 
 /* XOutP: Log prob of x in given mixture - XForm Case */
-static LogFloat XOutP(Vector x, int vecSize, MixPDF *mp)
+static LogFloat XOutP(Vector x, const int vecSize, MixPDF *mp)
 {
    Vector xmm,trans_xmm;
    int i,j;
@@ -5417,7 +5732,7 @@ static LogFloat XOutP(Vector x, int vecS
 }
 
 /* EXPORT-> IDOutP: Log prob of x in given mixture - Inverse Diagonal Case */
-LogFloat IDOutP(Vector x, int vecSize, MixPDF *mp)
+LogFloat IDOutP(Vector x, const int vecSize, MixPDF *mp)
 {
    int i;
    float sum,xmm;
@@ -5486,7 +5801,11 @@ LogFloat MOutP(Vector x, MixPDF *mp)
    int vSize;
    LogFloat px;
    
-   vSize=VectorSize(x);
+   px = LZERO;
+   vSize = SpaceOrder(x);   
+   if (vSize == VectorSize(mp->mean)) {
+      if (vSize == 0) px = 0.0;
+      else 
    switch (mp->ckind) {
    case DIAGC:    px=DOutP(x,vSize,mp); break;
    case INVDIAGC: px=IDOutP(x,vSize,mp); break;
@@ -5495,12 +5814,34 @@ LogFloat MOutP(Vector x, MixPDF *mp)
    case XFORMC:   px=XOutP(x,vSize,mp); break;
    default:       px = LZERO;
    }
+   }
    return px;
 }
 
 
+/* ------------------------- DAEM -------------------------- */
+
+static float tempDAEM = 1.0;       /* temerature parameter for DAEM */
+
+/* EXPORT-> SetDAEMTemp: sets temperature for DAEM */
+void SetDAEMTemp(float temp)
+{
+   tempDAEM = temp;
+}
+
+/* EXPORT-> ApplyDAEM: returns log prob * temperature parameter  */
+LogFloat ApplyDAEM(LogFloat lprob)
+{
+   LogFloat lp;
+ 
+   if (lprob==LZERO) return lprob;
+   lp = lprob * tempDAEM;
+   return (lp<LSMALL) ? LZERO : lp;
+}
+
+
 /* EXPORT-> SOutP: returns log prob of stream s of observation x */
-LogFloat SOutP(HMMSet *hset, int s, Observation *x, StreamElem *se)
+LogFloat SOutP(HMMSet *hset, int s, Observation *x, StreamInfo *sti)
 {
    int m,vSize;
    LogDouble bx,px;
@@ -5518,12 +5859,17 @@ LogFloat SOutP(HMMSet *hset, int s, Obse
    case PLAINHS:
    case SHAREDHS:
       v = x->fv[s];
+      if (hset->msdflag[s]) {
+         vSize = SpaceOrder(v);
+      } 
+      else {
       vSize = VectorSize(v);
       if (vSize != hset->swidth[s])
          HError(7071,"SOutP: incompatible stream widths %d vs %d",
                 vSize,hset->swidth[s]);
-      me = se->spdf.cpdf+1;
-      if (se->nMix == 1){     /* Single Mixture Case */
+      }
+      me = sti->spdf.cpdf+1;
+      if (sti->nMix == 1) {     /* Single Mixture Case */
          mp = me->mpdf; 
          switch (mp->ckind) {
          case DIAGC:    px=DOutP(v,vSize,mp); break;
@@ -5533,13 +5879,18 @@ LogFloat SOutP(HMMSet *hset, int s, Obse
          case XFORMC:   px=XOutP(v,vSize,mp); break;
          default:       px=LZERO;
          }
+         px = ApplyDAEM((LogFloat)px);
          return px;
       } else {
          bx = LZERO;                   /* Multi Mixture Case */
-         for (m=1; m<=se->nMix; m++,me++) {
+         for (m=1; m<=sti->nMix; m++,me++) {
             wt=MixLogWeight(hset,me->weight);
             if (wt>LMINMIX) {  
                mp = me->mpdf; 
+               if (!hset->msdflag[s] || vSize == VectorSize(mp->mean)) {
+                  if (vSize == 0) 
+                     px = 0.0;
+                  else {
                switch (mp->ckind) {
                case DIAGC:    px=DOutP(v,vSize,mp); break;
                case INVDIAGC: px=IDOutP(v,vSize,mp); break;
@@ -5548,10 +5899,14 @@ LogFloat SOutP(HMMSet *hset, int s, Obse
                case XFORMC:   px=XOutP(v,vSize,mp); break;
                default:       px = LZERO;
                }
+                  }
+                  px = ApplyDAEM((LogFloat)px);
+                  wt = ApplyDAEM((LogFloat)wt);
                bx = LAdd(bx,wt+px);
             }
          }
       }
+      }
       return bx;
    case TIEDHS:
       v = x->fv[s];
@@ -5560,12 +5915,12 @@ LogFloat SOutP(HMMSet *hset, int s, Obse
          HError(7071,"SOutP: incompatible stream widths %d vs %d",
                 vSize,hset->swidth[s]);
       sum = 0.0; tr = hset->tmRecs+s;
-      tm = tr->probs+1; tv = se->spdf.tpdf;
+      tm = tr->probs+1; tv = sti->spdf.tpdf;
       for (m=1; m<=tr->topM; m++,tm++)
          sum += tm->prob * tv[tm->index];
       return (sum>=MINLARG)?log(sum)+tr->maxP:LZERO;
    case DISCRETEHS:
-      uv = se->spdf.dpdf; m = x->vq[s];
+      uv = sti->spdf.dpdf; m = x->vq[s];
       ix = uv[m];
       if (discreteLZero && ix == DLOGZERO) 
          return LZERO;
@@ -5580,15 +5935,16 @@ LogFloat SOutP(HMMSet *hset, int s, Obse
 LogFloat POutP(HMMSet *hset,Observation *x, StateInfo *si)
 {
    LogFloat bx;
-   StreamElem *se;
+   StreamElem *ste;
    Vector w;
-   int s,S = x->swidth[0];
+   int s;
+   const int S = x->swidth[0];
    
    if (S==1 && si->weights==NULL)
-      return SOutP(hset,1,x,si->pdf+1);
-   bx=0.0; se=si->pdf+1; w = si->weights;
-   for (s=1;s<=S;s++,se++)
-      bx += w[s]*SOutP(hset,s,x,se);
+      return SOutP(hset,1,x,(si->pdf+1)->info);
+   bx=0.0; ste=si->pdf+1; w = si->weights;
+   for (s=1;s<=S;s++,ste++)
+      bx += w[s]*SOutP(hset,s,x,ste->info);
    return bx;
 }
 
@@ -5598,16 +5954,16 @@ LogFloat OutP(Observation *x, HLink hmm,
 {
    StateInfo *si;
    LogFloat bx;
-   StreamElem *se;
+   StreamElem *ste;
    Vector w;
    int s,S = x->swidth[0];
    
    si = (hmm->svec+state)->info;
    if (S==1 && si->weights==NULL)
-      return SOutP(hmm->owner,1,x,si->pdf+1);
-   bx=0.0; se=si->pdf+1; w = si->weights;
-   for (s=1;s<=S;s++,se++)
-      bx += w[s]*SOutP(hmm->owner,s,x,se);
+      return SOutP(hmm->owner,1,x,si->pdf[1].info);
+   bx=0.0; ste=si->pdf+1; w = si->weights;
+   for (s=1;s<=S;s++,ste++) 
+      bx += w[s]*SOutP(hmm->owner,s,x,ste->info);
    return bx;
 }
 
@@ -5688,17 +6044,19 @@ void FixFullGConst(MixPDF *mp, LogFloat 
 void FixGConsts(HLink hmm)
 {
    int n,m,s,S;
-   StateElem *ste;
+   StateElem *se;
    MixtureElem *me;
-   StreamElem *se;
+   StreamElem *ste;
+   StreamInfo *sti;
    MixPDF *mp;
    
-   ste = hmm->svec+2; S = hmm->owner->swidth[0];
-   for (n=2; n<hmm->numStates; n++,ste++) {
-      se = ste->info->pdf+1;
-      for (s=1; s<=S; s++,se++){
-         me = se->spdf.cpdf+1;
-         for (m=1; m<=se->nMix; m++,me++)
+   se = hmm->svec+2; S = hmm->owner->swidth[0];
+   for (n=2; n<hmm->numStates; n++,se++) {
+      ste = se->info->pdf+1;
+      for (s=1; s<=S; s++,ste++) {
+         sti = ste->info;
+         me = sti->spdf.cpdf+1;
+         for (m=1; m<=sti->nMix; m++,me++)
             if (me->weight > MixFloor(hmm->owner)){
                mp = me->mpdf;
                switch (mp->ckind) {
@@ -5759,7 +6117,7 @@ void FixAllGConsts(HMMSet *hset)
 /* EXPORT-> DurKind2Str: Return string representation of enum DurKind */
 char *DurKind2Str(DurKind dkind, char *buf)
 {
-   static char *durmap[] = {"NULLD","POISSOND","GAMMAD","RELD","GEND"};
+   static char *durmap[] = {"NULLD","POISSOND","GAMMAD","RELD","GEND","GAUSSD"};
    return strcpy(buf,durmap[dkind]);
 }
 
@@ -5791,4 +6149,171 @@ char *BaseClassKind2Str(BaseClassKind bk
    return strcpy(buf,basemap[bkind]);
 }
 
-/* ------------------------- End of HModel.c --------------------------- */
+/* ------------- for Multi-Space probability Density ------------------ */
+
+/* EXPORT-> CreateMSDInfo: Create MSD infomation of each stream */
+MSDInfo *** CreateMSDInfo(MemHeap *mem, HLink hmm)
+{
+   int i,j,k,nStream;
+   StreamElem *ste;
+   StreamInfo *sti;
+   MSDInfo ***msdInfo;
+   IntVec sorder;
+   Ptr cur_si, pre_si;
+
+   msdInfo = (MSDInfo***)New(mem, (hmm->numStates-2)*sizeof(MSDInfo**));
+   msdInfo -= 2;
+   for (i=2; i<hmm->numStates; i++) {
+      nStream = hmm->owner->swidth[0];
+      msdInfo[i] = (MSDInfo**)New(mem, nStream*sizeof(MSDInfo *));
+      --msdInfo[i];
+      for (j=1; j<=nStream; j++) {
+         msdInfo[i][j] = (MSDInfo*)New(mem, sizeof(MSDInfo));
+         ste = hmm->svec[i].info->pdf+j;
+         sti = ste->info;
+       
+         sorder = CreateIntVec(mem, sti->nMix);
+       
+         msdInfo[i][j]->nSpace = sti->nMix;
+         msdInfo[i][j]->nKindS = 0;
+         msdInfo[i][j]->sorder = sorder;
+         msdInfo[i][j]->next   = NULL;
+       
+         for (k=1; k<=sti->nMix; k++) {
+            sorder[k] = VectorSize(sti->spdf.cpdf[k].mpdf->mean);
+            pre_si = msdInfo[i][j];
+            cur_si = msdInfo[i][j]->next;
+            while (cur_si != NULL) {
+               if (((SpaceInfo *)cur_si)->order == sorder[k]) break;
+               pre_si = cur_si;
+               cur_si = ((SpaceInfo *)pre_si)->next;
+            }
+            if (cur_si == NULL) {
+               msdInfo[i][j]->nKindS++;
+               ((SpaceInfo *)pre_si)->next = (SpaceInfo *)New(mem, sizeof(SpaceInfo));
+               cur_si = ((SpaceInfo *)pre_si)->next;
+               ((SpaceInfo *)cur_si)->order = sorder[k];
+               ((SpaceInfo *)cur_si)->count = 0;
+               ((SpaceInfo *)cur_si)->sindex = CreateIntVec(mem, sti->nMix);
+               ((SpaceInfo *)cur_si)->next = NULL;
+               ZeroIntVec(((SpaceInfo *)cur_si)->sindex);
+            }
+            ((SpaceInfo *)cur_si)->count++;
+            ((SpaceInfo *)cur_si)->sindex[((SpaceInfo *)cur_si)->count] = k;
+         }
+      }
+   }
+   
+   return msdInfo;
+}
+
+/* EXPORT-> SpaceOrder: Count order of Vector which is excepted ignVal */
+int SpaceOrder(Vector vec)
+{
+  int order;
+  
+  order = VectorSize(vec);
+   
+  while (order != 0) {
+     if (vec[order] == ignoreValue) --order;
+     else break;
+  }
+  
+  return order;
+}
+
+/* EXPORT->IncludeSpace: Search space in MSD information */
+int IncludeSpace(MSDInfo *msdInfo, const int order)
+{
+   int i = 1;
+   SpaceInfo *spaceInfo;
+   
+   spaceInfo = msdInfo->next;
+   
+   while (spaceInfo != NULL) {
+      if (spaceInfo->order == order) break;
+      spaceInfo = spaceInfo->next;
+      i++;
+   }
+   
+   if (spaceInfo == NULL) return 0;
+   else return i;
+}
+
+/* EXPORT-> NumNonZeroSpace: Return the number of space which order is not zero */
+int NumNonZeroSpace(StreamInfo *sti) 
+{
+   int m, n;
+
+   for (m=1,n=0; m<=sti->nMix; m++)
+      if (VectorSize(sti->spdf.cpdf[m].mpdf->mean)>0)
+         n++;
+    
+   return n;
+}
+
+/* EXPORT -> ReturnIgnoreValue: Return ignore value for MSD */
+float ReturnIgnoreValue (void)
+{
+   return ignoreValue;
+}
+
+/* -------------- Calculate symmetric KL divergence ------------------- */
+
+/* EXPORT -> CalKLDist: Calculate symmetric KL divergence of single pdf, only support diagonal covariance matrix */
+float CalKLDist(MixPDF * mp1, MixPDF * mp2)
+{
+   int i, vsize;
+   float kld1, kld2, diff;
+
+   if (VectorSize(mp1->mean) != VectorSize(mp2->mean))
+      HError(6611, "CalKLDist: Only support same vector size");
+   if (mp1->ckind != DIAGC || mp2->ckind != DIAGC)
+      HError(6611, "CalKLDist: Only support diagonal covariance matrix");
+
+   vsize = VectorSize(mp1->mean);
+
+   kld1 = kld2 = 0.0;
+   kld1 -= vsize;
+   kld2 -= vsize;
+   for (i = 1; i <= vsize; i++) {
+      diff = (mp2->mean[i] - mp1->mean[i]);
+      diff *= diff;
+      kld1 += mp1->cov.var[i] / mp2->cov.var[i];
+      kld1 += diff / mp2->cov.var[i];
+      kld2 += mp2->cov.var[i] / mp1->cov.var[i];
+      kld2 += diff / mp1->cov.var[i];
+   }
+
+   return (kld1 + kld2) * 0.5f;
+}
+
+/* EXPORT -> CalStrKLDist: Calculate symmetric KL divergence of stream,
+                           only support single mixture distribution and MSD distribution */
+float CalStrKLDist(StreamInfo *sti1, StreamInfo *sti2)
+{
+   MixtureElem *me1, *me2;
+   MixPDF *mp1, *mp2;
+   float kld, wt1, wt2;
+   int m;
+
+   kld = 0.0;
+   me1 = sti1->spdf.cpdf+1;
+   me2 = sti2->spdf.cpdf+1;
+   for (m = 1; m <= sti1->nMix; m++, me1++, me2++) {
+     if (sti1->nMix > 1) {
+         wt1 = me1->weight;
+         wt2 = me2->weight;
+         kld += wt1 * log(wt1) - wt1 * log(wt2);
+         kld += wt2 * log(wt2) - wt2 * log(wt1);
+      }
+
+      mp1 = me1->mpdf;
+      mp2 = me2->mpdf;
+      kld += CalKLDist(mp1, mp2);
+   }
+
+   return kld;
+}
+
+/* ------------------------ End of HModel.c ------------------------ */
diff -pbBEwurNa --ignore-matching-lines='.*vc_id.*' HTK-3.4.1/HTKLib/HModel.h HTS-2.2_for_HTK-3.4.1/HTKLib/HModel.h
--- HTK-3.4.1/HTKLib/HModel.h	2009-03-13 03:46:49.000000000 +0900
+++ HTS-2.2_for_HTK-3.4.1/HTKLib/HModel.h	2011-06-16 14:13:37.000000000 +0900
@@ -32,6 +32,51 @@
 /*         File: HModel.h  HMM Model Definition Data Type      */
 /* ----------------------------------------------------------- */
 
+/*  *** THIS IS A MODIFIED VERSION OF HTK ***                        */
+/* ----------------------------------------------------------------- */
+/*           The HMM-Based Speech Synthesis System (HTS)             */
+/*           developed by HTS Working Group                          */
+/*           http://hts.sp.nitech.ac.jp/                             */
+/* ----------------------------------------------------------------- */
+/*                                                                   */
+/*  Copyright (c) 2001-2011  Nagoya Institute of Technology          */
+/*                           Department of Computer Science          */
+/*                                                                   */
+/*                2001-2008  Tokyo Institute of Technology           */
+/*                           Interdisciplinary Graduate School of    */
+/*                           Science and Engineering                 */
+/*                                                                   */
+/* All rights reserved.                                              */
+/*                                                                   */
+/* Redistribution and use in source and binary forms, with or        */
+/* without modification, are permitted provided that the following   */
+/* conditions are met:                                               */
+/*                                                                   */
+/* - Redistributions of source code must retain the above copyright  */
+/*   notice, this list of conditions and the following disclaimer.   */
+/* - Redistributions in binary form must reproduce the above         */
+/*   copyright notice, this list of conditions and the following     */
+/*   disclaimer in the documentation and/or other materials provided */
+/*   with the distribution.                                          */
+/* - Neither the name of the HTS working group nor the names of its  */
+/*   contributors may be used to endorse or promote products derived */
+/*   from this software without specific prior written permission.   */
+/*                                                                   */
+/* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND            */
+/* CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,       */
+/* INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF          */
+/* MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE          */
+/* DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS */
+/* BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,          */
+/* EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED   */
+/* TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,     */
+/* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON */
+/* ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,   */
+/* OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY    */
+/* OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE           */
+/* POSSIBILITY OF SUCH DAMAGE.                                       */
+/* ----------------------------------------------------------------- */
+
 /* !HVER!HModel:   3.4.1 [CUED 12/03/09] */
 
 #ifndef _HMODEL_H_
@@ -42,8 +87,8 @@ extern "C" {
 #endif
 
 /* 
-   The following types define the in-memory representation of a HMM.
-   All HMM's belong to a HMMSet which includes a macro table for
+   The following types define the in-memory representation of an HMM.
+   All HMM's belong to an HMMSet which includes a macro table for
    rapidly mapping macro/hmm names into structures.  
 */
 
@@ -51,6 +96,7 @@ extern "C" {
 #define PTRHASHSIZE  513   /* Size of each HMM Set ptr map hash table */
 #define MINMIX  1.0E-5     /* Min usable mixture weight */
 #define LMINMIX -11.5129254649702     /* log(MINMIX) */
+#define MINSWEIGHT 1.0E-5  /* Min usable stream weight */
 
 #define MINDLOGP 0.000001  /* prob = exp(shortform/DLOGSCALE) */
 #define DLOGSCALE -2371.8  /* = 32767/ln(MINDLOGP) */
@@ -76,7 +122,7 @@ typedef struct _MMFInfo{
 
 /* -------------------- HMM Definition ----------------------- */
 
-enum _DurKind {NULLD, POISSOND, GAMMAD, RELD, GEND};
+enum _DurKind {NULLD, POISSOND, GAMMAD, RELD, GEND, GAUSSD};
 typedef enum _DurKind DurKind;
 
 enum _HSetKind {PLAINHS, SHAREDHS, TIEDHS, DISCRETEHS};
@@ -122,8 +168,15 @@ typedef struct {        /* A Tied Mixtur
 
 typedef struct {        /* 1 of these per stream */
    int nMix;            /* num mixtures in this stream */
+   short stream;        /* position of stream of this stream info */
    MixtureVector spdf;  /* Mixture Vector */
+   int pIdx;            /* Stream index */
+   int nUse;            /* usage counter */
    Ptr hook;            /* general hook */
+} StreamInfo;
+
+typedef struct {        /* 1 of these per stream */
+   StreamInfo *info;    /* information for this stream */
 }StreamElem;
 
 typedef struct {
@@ -147,6 +200,7 @@ typedef struct {
    SVector dur;            /* vector of model duration params, if any */   
    SMatrix transP;         /* transition matrix (logs) */
    int tIdx;               /* Transition matrix index */
+   int hIdx;               /* hmm index */
    int nUse;               /* num logical hmm's sharing this def */
    Ptr hook;               /* general hook */
 } HMMDef;
@@ -170,7 +224,7 @@ typedef struct _ItemRec *ILink;
 
 typedef struct _ItemRec {
    HLink owner;      /* HMM owning this item */
-   Ptr item;         /* -> to a HMM structure */
+   Ptr item;         /* -> to an HMM structure */
    ILink next;
 }ItemRec;
 
@@ -180,15 +234,18 @@ typedef struct {
   IntVec swidth;       /* stream width size */
   int numClasses;      /* number of baseclasses */
   ILink *ilist;        /* 1..numClasses of ilists */
+  IntVec stream;       /* 1..numClasses of stream indexes */
   int nUse;            /* usage counter */
   char *fname;         /* filename of where the baseclass was loaded */
 } BaseClass;
 
 typedef struct _RegNode {
-  float nodeOcc;            /* occupancy for this node */
+  double nodeOcc;           /* occupancy for this node */
   int vsize;                /* vector size associated with the baseclasses of this node */
+  int stream;               /* stream index associated with the baseclasses of this node */
   int nodeIndex;            /* index number of node */
   int numChild;             /* number of children - 0 if terminal */
+  Boolean valid;            /* whether transform can be generated in this node */
   struct _RegNode **child;  /* children of this node NULL if terminal */
   IntVec baseClasses;       /* if a terminal node the set of baseclasses else NULL */
   Ptr info;                 /* hook to hang information from */
@@ -199,9 +256,10 @@ typedef struct RegTree {
   int numTNodes;       /* number of terminal nodes in tree */
   BaseClass *bclass;   /* baseclass associated with this regression tree */
   RegNode *root;       /* pointer to the root node of the tree */
+  ILink nodes;         /* list of nodes */
   Boolean valid;       /* is it valid to generate a transform at the root node */
                        /* handles multiple stream adaptation issues */
-  float thresh;        /* split threshold to determine stopping in tree */
+  float thresh[SMAX];  /* split threshold to determine stopping in tree */
   char *fname;         /* filename of where the regTree was loaded */
 } RegTree;             
 
@@ -262,6 +320,8 @@ typedef struct {
   int nUse;            /* usage counter */
 } InputXForm;
 
+typedef struct _XFDirInfo *XFDirLink;
+
 /* ---------------------- Macros/HMM Hashing ------------------- */
 
 /* 
@@ -272,7 +332,7 @@ typedef struct {
      x xform      w strm wts  o options   c lltcovar  * deleted
      r regtree    b baseclass a adaptXfrm j inputXfm  f linXfm
      g xformSet   y xformBias
-   a HMMDef will have exactly 1 phyHMM macro referencing it but it can 
+   an HMMDef will have exactly 1 phyHMM macro referencing it but it can
    have 0 or more logHMM macros referencing it.
 */
 
@@ -284,6 +344,7 @@ typedef struct _MacroDef{
    short fidx;             /* idx of MMF file (0 = SMF) */
    LabId id;               /* name of macro */
    Ptr structure;          /* -> shared structure or HMM Def */
+   Ptr hook;               /* general hook */
 } MacroDef;
 
 typedef struct _PtrMap {   /* used for finding macros via ptr's */
@@ -307,8 +368,10 @@ typedef struct _HMMSet{
    PtrMap ** pmap;         /* Array[0..PTRHASHSIZE-1]OF PtrMap* */
    Boolean allowTMods;     /* true if HMMs can have Tee Models */
    Boolean optSet;         /* true if global options have been set */
+   Boolean indexSet;       /* have the indexes been set for the model set*/
    short vecSize;          /* dimension of observation vectors */
    short swidth[SMAX];     /* [0]=num streams,[i]=width of stream i */
+   short msdflag[SMAX];    /* flag for multi-space probability density */
    ParmKind pkind;         /* kind of obs vector components */
    DurKind dkind;          /* kind of duration model (model or state) */
    CovKind ckind;          /* cov kind - only global in V1.X */
@@ -316,6 +379,8 @@ typedef struct _HMMSet{
    TMixRec tmRecs[SMAX];   /* array[1..S]of tied mixture record */
    int numStates;          /* Number of states in HMMSet */
    int numSharedStates;    /* Number of shared states in HMMSet */
+   int numStreams;         /* Number of streams in HMMSet */
+   int numSharedStreams;   /* Number of shared streams in HMMSet */
    int numMix;             /* Number of mixture components in HMMSet */
    int numSharedMix;       /* Number of shared mixtures in HMMSet */
    int numTransP;          /* Number of distinct transition matrices */
@@ -323,6 +388,7 @@ typedef struct _HMMSet{
    InputXForm *xf;         /* Input transform of HMMSet */
    AdaptXForm *semiTied;   /* SemiTied transform associated with model set */
    short projSize;         /* dimension of vector to update */
+   XFDirLink xformDirNames;/* linked list of input transform directories */
 
    /* Adaptation information accumulates */
    Boolean attRegAccs;   /* have the set of accumulates been attached */
@@ -339,6 +405,23 @@ typedef struct _HMMSet{
 
 } HMMSet;
 
+/* ---------------------- MSD Information ----------------------- */
+
+/* Multi-Space probability Density information */
+typedef struct _SpaceInfo {
+   int order;                  /* order of space */
+   int count;                  /* number of spaces with same order*/
+   IntVec sindex;              /* space index */
+   struct _SpaceInfo *next;    /* link to next SpaceInfo */
+} SpaceInfo;
+
+typedef struct _MSDInfo {
+   int nSpace;                 /* number of space (= Mixture) */
+   int nKindS;                 /* number of kind of space */
+   IntVec sorder;              /* order of space sorder[1..nSpace] */
+   SpaceInfo *next;            /* link to head SpaceInfo */
+} MSDInfo;
+
 /* --------------------------- Initialisation ---------------------- */
 
 void InitModel(void);
@@ -346,6 +429,11 @@ void InitModel(void);
    Initialise the module
 */
 
+void ResetModel(void);
+/*
+   Reset the module
+*/
+
 /* --------------- Input XForm DIrectory access -------------------- */
 
 /* EXPORT->AddInXFormDir: Add given file directory to set */
@@ -402,6 +490,11 @@ void SetVFloor(HMMSet *hset, Vector *vFl
    components are set to minVar.
 */
 
+void ResetVFloor(HMMSet *hset, Vector *vFloor);
+/*
+   Reset the variance floors
+*/
+
 void ApplyVFloor(HMMSet *hset);
 /* 
    Apply the variance floors in hset to all covariances in the model set 
@@ -420,13 +513,13 @@ void PrintHSetProfile(FILE *f, HMMSet *h
 
 /* ------------------- HMM Set Load/Store ---------------------- */
 
-/* the basic sequence needed to create a HMM set is
+/* the basic sequence needed to create an HMM set is
       CreateHMMSet {AddMMF} (MakeHMMSet | MakeOneHMM) LoadHMMSet
 */
 
 void CreateHMMSet(HMMSet *hset, MemHeap *heap, Boolean allowTMods);
 /* 
-   Create a HMMSet using given heap.  This routine simply
+   Create an HMMSet using given heap.  This routine simply
    initialises the basic HMMSet structure. It must be followed by
    a call to either MakeOneHMM or MakeHMMSet.  
 */
@@ -443,8 +536,8 @@ MILink AddMMF(HMMSet *hset, char *fname)
 
 ReturnStatus MakeHMMSet(HMMSet *hset, char *fname);
 /*
-   Make a HMMSet by reading the file fname.  Each line of fname
-   should contain the logical name of a HMM optionally followed by a
+   Make an HMMSet by reading the file fname.  Each line of fname
+   should contain the logical name of an HMM optionally followed by a
    physical name.  If no physical name is given it is assumed to be
    the same as the logical name.  This routine creates the macro hash
    table, macro definitions for each HMM and HMMDef structures.  It
@@ -490,7 +583,14 @@ ReturnStatus SaveHMMSet(HMMSet *hset, ch
 
 ReturnStatus SaveHMMList(HMMSet *hset, char *fname);
 /*
-   Save a HMM list in fname describing given HMM set 
+   Save an HMM list in fname describing given HMM set
+*/
+
+void SetIndexes(HMMSet *hset);
+void SetCovKindUsage (HMMSet *hset);
+ReturnStatus CheckHSet(HMMSet *hset);
+/*
+   Check the consistency of a complete HMM Set
 */
 
 
@@ -564,7 +664,13 @@ LogFloat POutP(HMMSet *hset, Observation
    state of given model
 */
 
-LogFloat SOutP(HMMSet *hset, int s, Observation *x, StreamElem *se);
+
+/* ------------------------- DAEM -------------------------- */
+
+void SetDAEMTemp(float temp);
+LogFloat ApplyDAEM(LogFloat lprob);
+
+LogFloat SOutP(HMMSet *hset, int s, Observation *x, StreamInfo *sti);
 /*
    Return Stream log output prob of stream s of observation x
 */
@@ -664,10 +770,47 @@ XFormKind Str2XFormKind(char *str);
 /* EXPORT-> Str2AdaptKind: parse the string into the correct xform kind */
 AdaptKind Str2AdaptKind(char *str);
 
+
+/* ------------- for Multi-Space probability Density ------------------ */
+
+MSDInfo ***CreateMSDInfo(MemHeap *mem, HLink hmm);
+/*
+   Create MSD information of each stream
+*/
+
+int SpaceOrder(Vector vec);
+/*
+   Count order of Vector which is excepted ignVal
+*/
+
+int IncludeSpace(MSDInfo *msdInfo, int order);
+/*
+   Search space in MSD information
+*/
+
+int NumNonZeroSpace(StreamInfo *sti);
+/*
+   NumNonZeroSpace: Return the number of space which order is not zero
+*/
+
+float ReturnIgnoreValue(void);
+/*
+   ReturnIgnoreValue: Return ignoreValue for MSD
+*/
+
+/* -------------- Calculate symmetric KL divergence ------------------- */
+
+/* EXPORT -> CalKLDist: Calculate symmetric KL divergence of single pdf, only support diagonal covariance matrix */
+float CalKLDist(MixPDF * mp1, MixPDF * mp2);
+
+/* EXPORT -> CalStrKLDist: Calculate symmetric KL divergence of stream,
+                           only support single mixture distribution and MSD distribution */
+float CalStrKLDist(StreamInfo *sti1, StreamInfo *sti2);
+
 #ifdef __cplusplus
 }
 #endif
 
 #endif  /* _HMODEL_H_ */
 
-/* ------------------------- End of HModel.h --------------------------- */
+/* ------------------------ End of HModel.h ------------------------ */
diff -pbBEwurNa --ignore-matching-lines='.*vc_id.*' HTK-3.4.1/HTKLib/HNet.c HTS-2.2_for_HTK-3.4.1/HTKLib/HNet.c
--- HTK-3.4.1/HTKLib/HNet.c	2009-03-13 03:46:59.000000000 +0900
+++ HTS-2.2_for_HTK-3.4.1/HTKLib/HNet.c	2011-06-16 13:18:29.000000000 +0900
@@ -32,8 +32,53 @@
 /*         File: HNet.c  Network and Lattice Functions         */
 /* ----------------------------------------------------------- */
 
+/*  *** THIS IS A MODIFIED VERSION OF HTK ***                        */
+/* ----------------------------------------------------------------- */
+/*           The HMM-Based Speech Synthesis System (HTS)             */
+/*           developed by HTS Working Group                          */
+/*           http://hts.sp.nitech.ac.jp/                             */
+/* ----------------------------------------------------------------- */
+/*                                                                   */
+/*  Copyright (c) 2001-2011  Nagoya Institute of Technology          */
+/*                           Department of Computer Science          */
+/*                                                                   */
+/*                2001-2008  Tokyo Institute of Technology           */
+/*                           Interdisciplinary Graduate School of    */
+/*                           Science and Engineering                 */
+/*                                                                   */
+/* All rights reserved.                                              */
+/*                                                                   */
+/* Redistribution and use in source and binary forms, with or        */
+/* without modification, are permitted provided that the following   */
+/* conditions are met:                                               */
+/*                                                                   */
+/* - Redistributions of source code must retain the above copyright  */
+/*   notice, this list of conditions and the following disclaimer.   */
+/* - Redistributions in binary form must reproduce the above         */
+/*   copyright notice, this list of conditions and the following     */
+/*   disclaimer in the documentation and/or other materials provided */
+/*   with the distribution.                                          */
+/* - Neither the name of the HTS working group nor the names of its  */
+/*   contributors may be used to endorse or promote products derived */
+/*   from this software without specific prior written permission.   */
+/*                                                                   */
+/* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND            */
+/* CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,       */
+/* INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF          */
+/* MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE          */
+/* DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS */
+/* BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,          */
+/* EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED   */
+/* TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,     */
+/* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON */
+/* ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,   */
+/* OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY    */
+/* OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE           */
+/* POSSIBILITY OF SUCH DAMAGE.                                       */
+/* ----------------------------------------------------------------- */
+
 char *hnet_version = "!HVER!HNet:   3.4.1 [CUED 12/03/09]";
-char *hnet_vc_id = "$Id: HNet.c,v 1.1.1.1 2006/10/11 09:54:58 jal58 Exp $";
+char *hnet_vc_id = "$Id: HNet.c,v 1.11 2011/06/16 04:18:29 uratec Exp $";
 
 #include "HShell.h"
 #include "HMem.h"
@@ -91,7 +136,7 @@ Boolean factorLM=FALSE;
 
 char *frcSil=NULL,frcSilBuf[MAXSTRLEN];
 /* 
-   Automagically add these sil models to the end of words.
+   Automatically add these sil models to the end of words.
 */
 Boolean remDupPron=TRUE;
 /*
@@ -137,6 +182,12 @@ void InitNet(void)
    }
 }
 
+/* EXPORT->ResetNet: reset module */
+void ResetNet(void)
+{
+   return;  /* do nothing */
+}
+
 /* ------------------------ Lattice Creation ------------------------- */
 
 #define SafeCopyString(heap,str) ((str)==NULL?NULL:CopyString((heap),(str)))
@@ -330,7 +381,7 @@ static Lattice *GetSubLat(LabId subLatId
       subLatHashTab=NULL;
       return(NULL);
    }
-   h=(((unsigned) subLatId)%SUBLATHASHSIZE);
+   h=(((unsigned long) subLatId)%SUBLATHASHSIZE);
    for (cur=subLatHashTab[h];cur!=NULL;cur=cur->chain)
       if (cur->subLatId==subLatId) break;
    if (subLat!=NULL) {
@@ -553,9 +604,9 @@ ReturnStatus WriteOneLattice(Lattice *la
          ln=lat->lnodes+order[i];
          rorder[order[i]]=i;
          ln->n = i;
-         OutputIntField('I',i,format&HLAT_LBIN,"%-4d",file);
+         OutputIntField('I',i,((format&HLAT_LBIN) ? TRUE:FALSE),"%-4d",file);
          if (format&HLAT_TIMES)
-            OutputFloatField('t',ln->time / lat->tscale,format&HLAT_LBIN,"%-5.2f",file);
+            OutputFloatField('t',ln->time / lat->tscale,((format&HLAT_LBIN) ? TRUE:FALSE),"%-5.2f",file);
          if (!(format&HLAT_ALABS)) {
             if (ln->word==lat->voc->subLatWord && ln->sublat!=NULL)
                fprintf(file,"L=%-19s ",
@@ -566,7 +617,7 @@ ReturnStatus WriteOneLattice(Lattice *la
                        ReWriteString(ln->word->wordName->name,
                                      NULL,ESCAPE_CHAR));
                if ((format&HLAT_PRON) && ln->v>=0)
-                  OutputIntField('v',ln->v,format&HLAT_LBIN,"%-2d",file);
+                  OutputIntField('v',ln->v,((format&HLAT_LBIN) ? TRUE:FALSE),"%-2d",file);
                if ((format&HLAT_TAGS) && ln->tag!=NULL)
                   fprintf(file,"s=%-19s ",
                           ReWriteString(ln->tag,NULL,ESCAPE_CHAR));
@@ -589,11 +640,11 @@ ReturnStatus WriteOneLattice(Lattice *la
    }
    for (i=0;i<lat->na;i++) {
       la=NumbLArc(lat,order[i]);
-      OutputIntField('J',i,format&HLAT_LBIN,"%-5d",file);
+      OutputIntField('J',i,((format&HLAT_LBIN) ? TRUE:FALSE),"%-5d",file);
       st=rorder[la->start-lat->lnodes];
       en=rorder[la->end-lat->lnodes];
-      OutputIntField('S',st,format&HLAT_LBIN,"%-4d",file);
-      OutputIntField('E',en,format&HLAT_LBIN,"%-4d",file);
+      OutputIntField('S',st,((format&HLAT_LBIN) ? TRUE:FALSE),"%-4d",file);
+      OutputIntField('E',en,((format&HLAT_LBIN) ? TRUE:FALSE),"%-4d",file);
       if (format&HLAT_ALABS) {
          if (la->end->word!=NULL) 
             fprintf(file,"W=%-19s ",
@@ -602,19 +653,19 @@ ReturnStatus WriteOneLattice(Lattice *la
          else
             fprintf(file,"W=%-19s ","!NULL");
          if ((format&HLAT_PRON) && ln->v>=0)
-            OutputIntField('v',la->end->v,format&HLAT_LBIN,"%-2d",file);
+            OutputIntField('v',la->end->v,((format&HLAT_LBIN) ? TRUE:FALSE),"%-2d",file);
       }
       if (!(lat->format&HLAT_SHARC) && (format&HLAT_ACLIKE))
-         OutputFloatField ('a', ConvLogLikeToBase(lat->logbase, la->aclike), format&HLAT_LBIN, "%-9.2f", file);
+         OutputFloatField ('a', ConvLogLikeToBase(lat->logbase, la->aclike), ((format&HLAT_LBIN) ? TRUE:FALSE), "%-9.2f", file);
       if (format&HLAT_LMLIKE) {
          if (lat->net==NULL)
             OutputFloatField('l', ConvLogLikeToBase(lat->logbase, la->lmlike*lat->lmscale+lat->wdpenalty),
-                             format&HLAT_LBIN,"%-8.2f",file);
+                             ((format&HLAT_LBIN) ? TRUE:FALSE),"%-8.2f",file);
          else
-            OutputFloatField('l',ConvLogLikeToBase(lat->logbase, la->lmlike), format&HLAT_LBIN, "%-7.3f", file);
+            OutputFloatField('l',ConvLogLikeToBase(lat->logbase, la->lmlike), ((format&HLAT_LBIN) ? TRUE:FALSE), "%-7.3f", file);
       }
       if (!(lat->format&HLAT_SHARC) && (format&HLAT_PRLIKE))
-         OutputFloatField('r', ConvLogLikeToBase(lat->logbase, la->prlike), format&HLAT_LBIN, "%-6.2f", file);
+         OutputFloatField('r', ConvLogLikeToBase(lat->logbase, la->prlike), ((format&HLAT_LBIN) ? TRUE:FALSE), "%-6.2f", file);
       if (!(lat->format&HLAT_SHARC) && (format&HLAT_ALIGN) && la->nAlign>0)
          OutputAlign(la,format,file);
       fprintf(file,"\n");
@@ -1613,7 +1664,7 @@ NodeId FindLatEnd(Lattice *lat)
 
 static void PrintNode(NetNode *node,HMMSet *hset)
 {
-   printf("Node[%05d] ",(((unsigned) node)/sizeof(NetNode))%100000);
+   printf("Node[%05ld] ",(((unsigned long) node)/sizeof(NetNode))%100000);
    if (node->type & n_hmm)
       printf("{%s}\n",HMMPhysName(hset,node->info.hmm));
    else if (node->type == n_word && node->info.pron==NULL) {
@@ -1641,8 +1692,8 @@ static void PrintLinks(NetLink *links,in
    int i;
 
    for (i=0; i<nlinks; i++) {
-      printf("    %-2d: -> [%05d] == %7.3f\n",i,
-             (((unsigned) links[i].node)/sizeof(NetNode)%100000),
+      printf("    %-2d: -> [%05ld] == %7.3f\n",i,
+             (((unsigned long) links[i].node)/sizeof(NetNode)%100000),
              links[i].like);
       fflush(stdout);
    }
@@ -1696,7 +1747,7 @@ static void AddChain(Network*net, NetNod
    of type shortArc to minimise lattice storage requirements).
    
    Cross word context dependent networks are created in an
-   automagic manner from the hmmlist and monophone dictionary.
+   automatic manner from the hmmlist and monophone dictionary.
 
    Contexts
    -1 == context free - skip this phone when determining context
@@ -1817,7 +1868,7 @@ int AddHCIContext(HMMSetCxtInfo *hci,Lab
 int GetHCIContext(HMMSetCxtInfo *hci,LabId labid)
 {
    LabId cxt;
-   char buf[80];
+   char buf[MAXSTRLEN];
    int c;
 
    if (hci->nc==0) return(0);
@@ -1893,7 +1944,7 @@ static int DefineContexts(HMMSetCxtInfo 
 {
    MLink ml,il;
    LabId labid;
-   char buf[80],*ptr;
+   char buf[MAXSTRLEN],*ptr;
    int h,c,*temp;
 
    hci->nc=0; hci->sLeft=hci->sRight=FALSE;
@@ -1999,7 +2050,7 @@ static NetNode *FindWordNode(MemHeap *he
    NetNode *node;
 
    hash=0;
-   un.ptrs[0]=pron;un.ptrs[1]=pInst;un.ptrs[2]=(Ptr)type;
+   un.ptrs[0]=pron;un.ptrs[1]=pInst;un.ptrs[2]=(Ptr)((long)type);
    for (i=0;i<12;i++)
       hash=((hash<<8)+un.chars[i])%WNHASHSIZE;
 
@@ -2053,7 +2104,7 @@ static HLink FindModel(HMMSetCxtInfo *hc
 {
    LabId labid;
    MLink ml;
-   char buf[80];
+   char buf[MAXSTRLEN];
 
    /* Word internal hack */
    /* Cross word will need proper specification of context */
@@ -3658,4 +3709,4 @@ Network *ExpandWordNet(MemHeap *heap,Lat
    return(net);
 }   
 
-/* ------------------------ End of HNet.c ------------------------- */
+/* ------------------------ End of HNet.c -------------------------- */
diff -pbBEwurNa --ignore-matching-lines='.*vc_id.*' HTK-3.4.1/HTKLib/HNet.h HTS-2.2_for_HTK-3.4.1/HTKLib/HNet.h
--- HTK-3.4.1/HTKLib/HNet.h	2009-03-13 03:47:13.000000000 +0900
+++ HTS-2.2_for_HTK-3.4.1/HTKLib/HNet.h	2011-06-16 13:18:29.000000000 +0900
@@ -32,6 +32,51 @@
 /*         File: HNet.h  Network and Lattice Functions         */
 /* ----------------------------------------------------------- */
 
+/*  *** THIS IS A MODIFIED VERSION OF HTK ***                        */
+/* ----------------------------------------------------------------- */
+/*           The HMM-Based Speech Synthesis System (HTS)             */
+/*           developed by HTS Working Group                          */
+/*           http://hts.sp.nitech.ac.jp/                             */
+/* ----------------------------------------------------------------- */
+/*                                                                   */
+/*  Copyright (c) 2001-2011  Nagoya Institute of Technology          */
+/*                           Department of Computer Science          */
+/*                                                                   */
+/*                2001-2008  Tokyo Institute of Technology           */
+/*                           Interdisciplinary Graduate School of    */
+/*                           Science and Engineering                 */
+/*                                                                   */
+/* All rights reserved.                                              */
+/*                                                                   */
+/* Redistribution and use in source and binary forms, with or        */
+/* without modification, are permitted provided that the following   */
+/* conditions are met:                                               */
+/*                                                                   */
+/* - Redistributions of source code must retain the above copyright  */
+/*   notice, this list of conditions and the following disclaimer.   */
+/* - Redistributions in binary form must reproduce the above         */
+/*   copyright notice, this list of conditions and the following     */
+/*   disclaimer in the documentation and/or other materials provided */
+/*   with the distribution.                                          */
+/* - Neither the name of the HTS working group nor the names of its  */
+/*   contributors may be used to endorse or promote products derived */
+/*   from this software without specific prior written permission.   */
+/*                                                                   */
+/* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND            */
+/* CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,       */
+/* INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF          */
+/* MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE          */
+/* DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS */
+/* BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,          */
+/* EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED   */
+/* TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,     */
+/* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON */
+/* ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,   */
+/* OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY    */
+/* OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE           */
+/* POSSIBILITY OF SUCH DAMAGE.                                       */
+/* ----------------------------------------------------------------- */
+
 /* !HVER!HNET:   3.4.1 [CUED 12/03/09] */
 
 /*
@@ -62,6 +107,11 @@ void InitNet(void);
    register module & set configuration parameters
 */
 
+void ResetNet(void);
+/*
+   reset module
+*/
+
 /* -------------------- Lattice Definintions ------------------------- */
 
 /*
@@ -531,3 +581,5 @@ int AddHCIContext(HMMSetCxtInfo *hci,Lab
 #endif
 
 #endif  /* _HNET_H_ */
+
+/* ------------------------ End of HNet.h -------------------------- */
diff -pbBEwurNa --ignore-matching-lines='.*vc_id.*' HTK-3.4.1/HTKLib/HParm.c HTS-2.2_for_HTK-3.4.1/HTKLib/HParm.c
--- HTK-3.4.1/HTKLib/HParm.c	2009-03-13 03:47:21.000000000 +0900
+++ HTS-2.2_for_HTK-3.4.1/HTKLib/HParm.c	2011-06-16 13:18:29.000000000 +0900
@@ -32,8 +32,53 @@
 /*       File: HParm.c:  Speech Parameter File Input/Output    */
 /* ----------------------------------------------------------- */
 
+/*  *** THIS IS A MODIFIED VERSION OF HTK ***                        */
+/* ----------------------------------------------------------------- */
+/*           The HMM-Based Speech Synthesis System (HTS)             */
+/*           developed by HTS Working Group                          */
+/*           http://hts.sp.nitech.ac.jp/                             */
+/* ----------------------------------------------------------------- */
+/*                                                                   */
+/*  Copyright (c) 2001-2011  Nagoya Institute of Technology          */
+/*                           Department of Computer Science          */
+/*                                                                   */
+/*                2001-2008  Tokyo Institute of Technology           */
+/*                           Interdisciplinary Graduate School of    */
+/*                           Science and Engineering                 */
+/*                                                                   */
+/* All rights reserved.                                              */
+/*                                                                   */
+/* Redistribution and use in source and binary forms, with or        */
+/* without modification, are permitted provided that the following   */
+/* conditions are met:                                               */
+/*                                                                   */
+/* - Redistributions of source code must retain the above copyright  */
+/*   notice, this list of conditions and the following disclaimer.   */
+/* - Redistributions in binary form must reproduce the above         */
+/*   copyright notice, this list of conditions and the following     */
+/*   disclaimer in the documentation and/or other materials provided */
+/*   with the distribution.                                          */
+/* - Neither the name of the HTS working group nor the names of its  */
+/*   contributors may be used to endorse or promote products derived */
+/*   from this software without specific prior written permission.   */
+/*                                                                   */
+/* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND            */
+/* CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,       */
+/* INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF          */
+/* MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE          */
+/* DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS */
+/* BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,          */
+/* EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED   */
+/* TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,     */
+/* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON */
+/* ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,   */
+/* OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY    */
+/* OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE           */
+/* POSSIBILITY OF SUCH DAMAGE.                                       */
+/* ----------------------------------------------------------------- */
+
 char *hparm_version = "!HVER!HParm:   3.4.1 [CUED 12/03/09]";
-char *hparm_vc_id = "$Id: HParm.c,v 1.1.1.1 2006/10/11 09:54:58 jal58 Exp $";
+char *hparm_vc_id = "$Id: HParm.c,v 1.15 2011/06/16 04:18:29 uratec Exp $";
 
 #include "HShell.h"
 #include "HMem.h"
@@ -940,6 +985,16 @@ ReturnStatus InitParm(void)
    return(SUCCESS);
 }
  
+/* EXPORT->ResetParm: reset parmHeap */
+void ResetParm (void)
+{
+   Dispose(&gcheap,defChan->confName);
+   Dispose(&gcheap,defChan);
+   ResetHeap(&parmHeap);
+   
+   return;
+}
+ 
 /* EXPORT->SetNewConfig: Sets config parms for libmod */
 ReturnStatus SetChannel(char *confName)
 { 
@@ -1109,7 +1164,7 @@ char *ParmKind2Str(ParmKind kind, char *
 ParmKind Str2ParmKind(char *str)
 {
    ParmKind i = -1;
-   char *s,buf[255];
+   char *s,buf[MAXSTRLEN];
    Boolean hasE,hasD,hasN,hasA,hasT,hasF,hasC,hasK,hasZ,has0,hasV,found;
    int len;
    
@@ -1166,16 +1221,16 @@ ParmKind Str2ParmKind(char *str)
 ParmKind BaseParmKind(ParmKind kind) { return kind & BASEMASK; }
 
 /* EXPORT->HasXXXX: returns true if XXXX included in ParmKind */
-Boolean HasEnergy(ParmKind kind){return (kind & HASENERGY) != 0;}
-Boolean HasDelta(ParmKind kind) {return (kind & HASDELTA) != 0;}
-Boolean HasAccs(ParmKind kind)  {return (kind & HASACCS) != 0;}
-Boolean HasThird(ParmKind kind) {return (kind & HASTHIRD) != 0;}
-Boolean HasNulle(ParmKind kind) {return (kind & HASNULLE) != 0;}
-Boolean HasCompx(ParmKind kind) {return (kind & HASCOMPX) != 0;}
-Boolean HasCrcc(ParmKind kind)  {return (kind & HASCRCC) != 0;}
-Boolean HasZerom(ParmKind kind) {return (kind & HASZEROM) != 0;}
-Boolean HasZeroc(ParmKind kind) {return (kind & HASZEROC) != 0;}
-Boolean HasVQ(ParmKind kind)    {return (kind & HASVQ) != 0;}
+Boolean HasEnergy(ParmKind kind){return (((kind & HASENERGY) != 0) ? TRUE:FALSE);}
+Boolean HasDelta(ParmKind kind) {return (((kind & HASDELTA)  != 0) ? TRUE:FALSE);}
+Boolean HasAccs(ParmKind kind)  {return (((kind & HASACCS)   != 0) ? TRUE:FALSE);}
+Boolean HasThird(ParmKind kind) {return (((kind & HASTHIRD)  != 0) ? TRUE:FALSE);}
+Boolean HasNulle(ParmKind kind) {return (((kind & HASNULLE)  != 0) ? TRUE:FALSE);}
+Boolean HasCompx(ParmKind kind) {return (((kind & HASCOMPX)  != 0) ? TRUE:FALSE);}
+Boolean HasCrcc(ParmKind kind)  {return (((kind & HASCRCC)   != 0) ? TRUE:FALSE);}
+Boolean HasZerom(ParmKind kind) {return (((kind & HASZEROM)  != 0) ? TRUE:FALSE);}
+Boolean HasZeroc(ParmKind kind) {return (((kind & HASZEROC)  != 0) ? TRUE:FALSE);}
+Boolean HasVQ(ParmKind kind)    {return (((kind & HASVQ)     != 0) ? TRUE:FALSE);}
 
 /* EXPORT->SyncBuffers: if matrix transformations are used this syncs the two buffers */
 Boolean SyncBuffers(ParmBuf pbuf,ParmBuf pbuf2)
@@ -1517,7 +1572,7 @@ static Boolean EqualKind(ParmKind a, Par
 {
    /* Energy suppression only occurs at observation level */
    a = a&(~HASNULLE); b = b&(~HASNULLE);
-   return a==b;
+   return ((a==b) ? TRUE:FALSE);
 }
 
 /* --------------- Parameter Conversion Routines ----------------- */
@@ -1546,7 +1601,7 @@ static Boolean EqualKind(ParmKind a, Par
    For buffers, they may be positive. */
       
 /* Note that unlike before this function really will process nRows of data */
-/* And will not automagically do extra (which was a necessary and probably */
+/* And will not automatically do extra (which was a necessary and probably */
 /* unintended side effect of the way the function worked previously) */
 
 static void AddDiffs(float *data, int nRows, int nCols, int si, int ti, int d, 
@@ -1618,7 +1673,7 @@ static void DeleteColumn(float *data, in
 static void AddQualifiers(ParmBuf pbuf,float *data, int nRows, IOConfig cf, 
                           int hdValid, int tlValid)
 {
-   char buf[100],buff1[256],buff2[256];
+   char buf[MAXSTRLEN],buff1[MAXSTRLEN],buff2[MAXSTRLEN];
    int si,ti,d=0,ds,de, i, j, step, size;
    short span[12];
    float *fp, mean, scale;
@@ -1852,15 +1907,15 @@ static void AddQualifiers(ParmBuf pbuf,f
     Conversion is applied to the single row pointed to by data. */ 
 static void DelQualifiers(float *data, IOConfig cf)
 {
-   char buf[100];
+   char buf[MAXSTRLEN];
    int si,d,used=cf->nUsed;
    short span[12];
    Boolean baseX,statX,eX,zX;
    
-   statX = (cf->curPK&BASEMASK) != (cf->tgtPK&BASEMASK);
-   eX = (cf->curPK&HASENERGY) && !(cf->tgtPK&HASENERGY);
-   zX = (cf->curPK&HASZEROC) && !(cf->tgtPK&HASZEROC);
-   baseX = statX || eX || zX;
+   statX = ((cf->curPK&BASEMASK)  !=  (cf->tgtPK&BASEMASK))  ? TRUE:FALSE;
+   eX    = ((cf->curPK&HASENERGY) && !(cf->tgtPK&HASENERGY)) ? TRUE:FALSE;
+   zX    = ((cf->curPK&HASZEROC)  && !(cf->tgtPK&HASZEROC))  ? TRUE:FALSE;
+   baseX = (statX || eX || zX) ? TRUE:FALSE;
    if (trace&T_TOP)
       printf("HParm:  deleting Qualifiers in %s ...",ParmKind2Str(cf->curPK,buf));
    FindSpans(span,cf->curPK,cf->nUsed);
@@ -2143,7 +2198,7 @@ void ZeroMeanFrame(Vector v)
 /* SetUpForCoding: set style, sizes and  working storage */
 static void SetUpForCoding(MemHeap *x, IOConfig cf, int frSize)
 {
-   char buf[50];
+   char buf[MAXSTRLEN];
    ParmKind btgt;
   
    cf->s = CreateVector(x,frSize);
@@ -2166,7 +2221,7 @@ static void SetUpForCoding(MemHeap *x, I
       cf->fbank = CreateVector(x,cf->numChans);
       cf->fbInfo = InitFBank (x, frSize, (long) cf->srcSampRate, cf->numChans, 
                               cf->loFBankFreq, cf->hiFBankFreq, cf->usePower, 
-                              (btgt == PLP) ? FALSE : btgt != MELSPEC,
+                              (btgt == PLP) ? FALSE : ((btgt != MELSPEC) ? TRUE:FALSE),
                               cf->doubleFFT,
                               cf->warpFreq, cf->warpLowerCutOff, cf->warpUpperCutOff);
       
@@ -2853,7 +2908,7 @@ static void ExtractObservation(float *fp
       for (i=0; i<j; i++) printf("%8.4f ",fp[i]); printf("\n");
    }
    if (o->eSep){
-      wantE = !(o->pk&HASNULLE);
+      wantE = (!(o->pk&HASNULLE)) ? TRUE:FALSE;
       if (numS == 2){
          w1 = o->swidth[1]; w2 = NumEnergy(o->pk); 
          w = w1+w2; n = w/w2;
@@ -2879,7 +2934,7 @@ static void ExtractObservation(float *fp
          HError(6391,"ExtractObservation: %d of %d E vals copied",
                 k-1,o->swidth[numS]);
    } else {
-      skipE = (o->pk&(HASENERGY|HASZEROC)) && (o->pk&HASNULLE);
+      skipE = ((o->pk&(HASENERGY|HASZEROC)) && (o->pk&HASNULLE)) ? TRUE:FALSE;
       if (skipE) {
          nStatic = o->swidth[1];
          if (numS==1) nStatic = (nStatic+1)/NumEnergy(o->pk) - 1;
@@ -2924,6 +2979,16 @@ Observation MakeObservation(MemHeap *x, 
    return ob;
 }
 
+/* EXPORT->ResetObservation: Reset obs */
+void ResetObservation(MemHeap *x, Observation *ob, short *swidth, ParmKind pkind)
+{
+   int s; 
+   
+   if ((pkind&BASEMASK) != DISCRETE)
+      for (s=swidth[0]; s>0; s--)
+         FreeVector(x, ob->fv[s]);
+}
+
 #define OBMARGIN 6         /* margin width for displaying observations */
 #define OBFLTFORM "%8.3f"  /* format for displaying component values */
 #define OBEXPFORM "%8s"    /* format for displaying component names */
@@ -2997,9 +3062,9 @@ void ExplainObservation(Observation *o, 
             strcpy(str,""); strcpy(buf,""); isE = FALSE;
             if ((o->pk&(HASENERGY|HASZEROC)) && !o->eSep ) {
                if(s==1)
-                  isE = (!(o->pk&HASNULLE) && (j==nStatic)) || (j==nDel) || (j==nTotal);
+                  isE = ((!(o->pk&HASNULLE) && (j==nStatic)) || (j==nDel) || (j==nTotal)) ? TRUE:FALSE;
                else
-                  isE = j==o->swidth[s];
+                  isE = (j==o->swidth[s]) ? TRUE:FALSE;
             }
             if (isE) strcpy(str,(o->pk&HASENERGY)?"E":"C0");
             switch(s){
@@ -3108,7 +3173,7 @@ void  SetStreamWidths(ParmKind pk, int s
       for (s=1; s<=swidth[0]; s++) swidth[s]=1;
       return;
    }
-   isSet = swidth[1] != 0;
+   isSet = (swidth[1] != 0) ? TRUE:FALSE;
    ZeroStreamWidths(swidth[0],sw);
    FindSpans(span,pk,size);
    neObs = neTab = NumEnergy(pk);
@@ -3538,7 +3603,7 @@ static int FramesInParm(ParmBuf pbuf)
    if (pbuf->lastRow<0) {
 #ifdef STREAM_PARM_FILES
       long l;
-      /* Automagically determine the end of file */
+      /* Automatically determine the end of file */
       ioctl(fileno(pbuf->cf->src.f),FIONREAD,&l);
       if (pbuf->cf->srcPK&HASCRCC) l-=2;
       if (pbuf->fShort)
@@ -3929,7 +3994,7 @@ static void FillBufFromChannel(ParmBuf p
    IOConfig cf = pbuf->cf;
    PBlock *pb,*lb;
    Boolean dis,cleared;
-   char b1[100];
+   char b1[MAXSTRLEN];
    int availRows,newRows,space,i,head,tail,nShift;
    short *sp1=NULL, *sp2;
    float *fp1=NULL, *fp2;
@@ -3973,8 +4038,8 @@ static void FillBufFromChannel(ParmBuf p
          }
          else {
             nShift=pbuf->main.nRows-pbuf->minRows; /* Max shift */
-            dis = ((pbuf->outRow-nShift>pbuf->main.stRow) && 
-                   pbuf->main.next==NULL && pbuf->noTable);
+            dis = (((pbuf->outRow-nShift>pbuf->main.stRow) && 
+                     pbuf->main.next==NULL && pbuf->noTable)) ? TRUE:FALSE;
          }
          if (trace&T_BUF)
             printf("%s %d from %d/%d @%d\n",(dis?"Discarding":"Moving"),
@@ -4148,7 +4213,7 @@ static ReturnStatus OpenAsChannel(ParmBu
 {
    ChannelType chType;
    BufferInfo info;
-   int initRows;
+   int initRows=0;
    long dBytes;
    char b1[50];
    IOConfig cf = pbuf->cf;
@@ -4660,7 +4725,7 @@ void GetBufferInfo(ParmBuf pbuf, BufferI
    info->xform = cf->xform;
 
    /* Fake spDetParmsSet to make self calibrating appear always set */
-   info->spDetParmsSet=(chan->spDetParmsSet||(cf->selfCalSilDet!=0));
+   info->spDetParmsSet=((chan->spDetParmsSet||(cf->selfCalSilDet!=0))) ? TRUE:FALSE;
    info->spDetSil=chan->spDetSil;
    info->chPeak=chan->chPeak;
    info->spDetSp=chan->spDetSp;
@@ -4743,7 +4808,7 @@ ParmBuf EmptyBuffer(MemHeap *x, int size
    dBytes = cf->nCols * size * (pbuf->dShort?sizeof(short):sizeof(float));
    pbuf->main.data = New(pbuf->mem,dBytes); 
    pbuf->main.stRow=0; pbuf->main.nRows=0; pbuf->main.maxRows=size;
-   pbuf->chType = 0;
+   pbuf->chType = (ChannelType) 0;
    return pbuf;
 }
 
@@ -5021,7 +5086,7 @@ ReturnStatus SaveBuffer(ParmBuf pbuf, ch
       break;
    case ESIG:
       WriteESIGPHeader(f, cf, sampPeriod, sampSize, kind); 
-      bSwap = vaxOrder && !natWriteOrder;
+      bSwap = (vaxOrder && !natWriteOrder) ? TRUE:FALSE;
       break;
    default:
       HRError(6270,"SaveBuffer: Cannot save data as %s.",
@@ -5044,7 +5109,7 @@ ReturnStatus SaveBuffer(ParmBuf pbuf, ch
    cf->crcc=0;
 
    if (cf->saveCompressed)
-      CalcCompress(pbuf,pbInit,cf->nCols,((kind&BASEMASK) == LPREFC));
+      CalcCompress(pbuf,pbInit,cf->nCols,(((kind&BASEMASK) == LPREFC) ? TRUE:FALSE));
         
    if (cf->saveCompressed && (kind&BASEMASK) != LPREFC) {
       WriteFloat(f,cf->A+1,cf->nCols,hparmBin);
@@ -5147,4 +5212,4 @@ void AddToBuffer(ParmBuf pbuf, Observati
    pbuf->qst++; pbuf->qen++; 
 }
 
-/* --------------------------  HParm.c ------------------------- */
+/* ------------------------ End of HParm.c ------------------------- */
diff -pbBEwurNa --ignore-matching-lines='.*vc_id.*' HTK-3.4.1/HTKLib/HParm.h HTS-2.2_for_HTK-3.4.1/HTKLib/HParm.h
--- HTK-3.4.1/HTKLib/HParm.h	2009-03-13 03:47:30.000000000 +0900
+++ HTS-2.2_for_HTK-3.4.1/HTKLib/HParm.h	2011-06-16 13:18:29.000000000 +0900
@@ -32,6 +32,51 @@
 /*         File: HParm.h:   Speech Parameter Input/Output      */
 /* ----------------------------------------------------------- */
 
+/*  *** THIS IS A MODIFIED VERSION OF HTK ***                        */
+/* ----------------------------------------------------------------- */
+/*           The HMM-Based Speech Synthesis System (HTS)             */
+/*           developed by HTS Working Group                          */
+/*           http://hts.sp.nitech.ac.jp/                             */
+/* ----------------------------------------------------------------- */
+/*                                                                   */
+/*  Copyright (c) 2001-2011  Nagoya Institute of Technology          */
+/*                           Department of Computer Science          */
+/*                                                                   */
+/*                2001-2008  Tokyo Institute of Technology           */
+/*                           Interdisciplinary Graduate School of    */
+/*                           Science and Engineering                 */
+/*                                                                   */
+/* All rights reserved.                                              */
+/*                                                                   */
+/* Redistribution and use in source and binary forms, with or        */
+/* without modification, are permitted provided that the following   */
+/* conditions are met:                                               */
+/*                                                                   */
+/* - Redistributions of source code must retain the above copyright  */
+/*   notice, this list of conditions and the following disclaimer.   */
+/* - Redistributions in binary form must reproduce the above         */
+/*   copyright notice, this list of conditions and the following     */
+/*   disclaimer in the documentation and/or other materials provided */
+/*   with the distribution.                                          */
+/* - Neither the name of the HTS working group nor the names of its  */
+/*   contributors may be used to endorse or promote products derived */
+/*   from this software without specific prior written permission.   */
+/*                                                                   */
+/* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND            */
+/* CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,       */
+/* INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF          */
+/* MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE          */
+/* DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS */
+/* BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,          */
+/* EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED   */
+/* TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,     */
+/* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON */
+/* ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,   */
+/* OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY    */
+/* OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE           */
+/* POSSIBILITY OF SUCH DAMAGE.                                       */
+/* ----------------------------------------------------------------- */
+
 /* !HVER!HParm:   3.4.1 [CUED 12/03/09] */
 
 #ifndef _HPARM_H_
@@ -167,6 +212,11 @@ ReturnStatus InitParm(void);
    Initialise the module
 */
 
+void ResetParm(void);
+/*
+   Reset the module
+*/
+
 /* -------------------- Channel functions ------------------ */
 
 ReturnStatus SetChannel(char *chanName);
@@ -338,6 +388,11 @@ Observation MakeObservation(MemHeap *x, 
    read from a continuous parameter parmbuffer.
 */
 
+void ResetObservation(MemHeap *x, Observation *ob, short *swidth, ParmKind pkind);
+/*
+   Reset given observation.
+*/
+
 void ExplainObservation(Observation *o, int itemsPerLine);
 /* 
    Explain the structure of given observation by printing
diff -pbBEwurNa --ignore-matching-lines='.*vc_id.*' HTK-3.4.1/HTKLib/HRec.c HTS-2.2_for_HTK-3.4.1/HTKLib/HRec.c
--- HTK-3.4.1/HTKLib/HRec.c	2009-03-13 03:47:40.000000000 +0900
+++ HTS-2.2_for_HTK-3.4.1/HTKLib/HRec.c	2011-06-16 13:18:29.000000000 +0900
@@ -19,8 +19,53 @@
 /*         File: HRec.c  Viterbi Recognition Engine Library    */
 /* ----------------------------------------------------------- */
 
+/*  *** THIS IS A MODIFIED VERSION OF HTK ***                        */
+/* ----------------------------------------------------------------- */
+/*           The HMM-Based Speech Synthesis System (HTS)             */
+/*           developed by HTS Working Group                          */
+/*           http://hts.sp.nitech.ac.jp/                             */
+/* ----------------------------------------------------------------- */
+/*                                                                   */
+/*  Copyright (c) 2001-2011  Nagoya Institute of Technology          */
+/*                           Department of Computer Science          */
+/*                                                                   */
+/*                2001-2008  Tokyo Institute of Technology           */
+/*                           Interdisciplinary Graduate School of    */
+/*                           Science and Engineering                 */
+/*                                                                   */
+/* All rights reserved.                                              */
+/*                                                                   */
+/* Redistribution and use in source and binary forms, with or        */
+/* without modification, are permitted provided that the following   */
+/* conditions are met:                                               */
+/*                                                                   */
+/* - Redistributions of source code must retain the above copyright  */
+/*   notice, this list of conditions and the following disclaimer.   */
+/* - Redistributions in binary form must reproduce the above         */
+/*   copyright notice, this list of conditions and the following     */
+/*   disclaimer in the documentation and/or other materials provided */
+/*   with the distribution.                                          */
+/* - Neither the name of the HTS working group nor the names of its  */
+/*   contributors may be used to endorse or promote products derived */
+/*   from this software without specific prior written permission.   */
+/*                                                                   */
+/* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND            */
+/* CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,       */
+/* INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF          */
+/* MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE          */
+/* DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS */
+/* BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,          */
+/* EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED   */
+/* TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,     */
+/* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON */
+/* ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,   */
+/* OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY    */
+/* OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE           */
+/* POSSIBILITY OF SUCH DAMAGE.                                       */
+/* ----------------------------------------------------------------- */
+
 char *hrec_version = "!HVER!HRec:   3.4.1 [CUED 12/03/09]";
-char *hrec_vc_id = "$Id: HRec.c,v 1.1.1.1 2006/10/11 09:54:58 jal58 Exp $";
+char *hrec_vc_id = "$Id: HRec.c,v 1.11 2011/06/16 04:18:29 uratec Exp $";
 
 #include "HShell.h"
 #include "HMem.h"
@@ -46,6 +91,7 @@ char *hrec_vc_id = "$Id: HRec.c,v 1.1.1.
 
 static int trace=0;
 static Boolean forceOutput=FALSE;
+static Boolean pde=FALSE; /* partial distance elimination */
 
 const Token null_token={LZERO,0.0,NULL,NULL};
 
@@ -149,7 +195,7 @@ struct _NetInst
 typedef struct precomp
 {
    int id;                  /* Unique identifier for current frame */
-   LogFloat outp;           /* State/mixture output likelihood */
+   LogFloat outp;           /* State/Stream/Mixture output likelihood */
 }
 PreComp;
 
@@ -160,8 +206,11 @@ struct psetinfo
 
    int max;                 /* Max states in HMM set */
    Boolean mixShared;
+   Boolean streamShared;
    int nsp;
    PreComp *sPre;           /* Array[1..nsp] State PreComps */
+   int npp;
+   PreComp *pPre;           /* Array[1..npp] Stream(pdf) PreComps */
    int nmp;
    PreComp *mPre;           /* Array[1..nmp] Shared mixture PreComps */
    int ntr;
@@ -269,9 +318,15 @@ void InitRec(void)
    if (nParm>0){
       if (GetConfInt(cParm,nParm,"TRACE",&i)) trace = i;
       if (GetConfBool(cParm,nParm,"FORCEOUT",&b)) forceOutput = b;
+      if (GetConfBool(cParm,nParm,"PDE",&b)) pde = b;
    }
 }
 
+/* EXPORT->ResetRec: reset module */
+void ResetRec(void)
+{
+   return;  /* do nothing */
+}
 
 /* Basic token merging step used during propagation.      */ 
 /* Token in cmp plus extra info from src merged into res. */
@@ -435,7 +490,7 @@ static void TokSetMerge(TokenSet *res,To
 }
 
 /* Caching version of SOutP used when mixPDFs shared */
-static LogFloat cSOutP(HMMSet *hset, int s, Observation *x, StreamElem *se,
+static LogFloat cMOutP(HMMSet *hset, int s, Observation *x, StreamInfo *sti,
                        int id)
 {
    PreComp *pre;
@@ -451,8 +506,8 @@ static LogFloat cSOutP(HMMSet *hset, int
    case PLAINHS:
    case SHAREDHS:
       v=x->fv[s];
-      me=se->spdf.cpdf+1;
-      if (se->nMix==1){     /* Single Mixture Case */
+      me=sti->spdf.cpdf+1;
+      if (sti->nMix==1){     /* Single Mixture Case */
          if (me->mpdf->mIdx>0 && me->mpdf->mIdx<=pri->psi->nmp)
             pre=pri->psi->mPre+me->mpdf->mIdx;
          else pre=NULL;
@@ -469,7 +524,7 @@ static LogFloat cSOutP(HMMSet *hset, int
             bx=pre->outp;
       } else {
          bx=LZERO;                   /* Multi Mixture Case */
-         for (m=1; m<=se->nMix; m++,me++) {
+         for (m=1; m<=sti->nMix; m++,me++) {
             wt = MixLogWeight(hset, me->weight);
             if (wt>LMINMIX) {   
                if (me->mpdf->mIdx>0 && me->mpdf->mIdx<=pri->psi->nmp)
@@ -498,7 +553,7 @@ static LogFloat cSOutP(HMMSet *hset, int
          HError(7071,"SOutP: incompatible stream widths %d vs %d",
                 vSize,hset->swidth[s]);
       sum = 0.0; tr = hset->tmRecs+s;
-      tm = tr->probs+1; tv = se->spdf.tpdf;
+      tm = tr->probs+1; tv = sti->spdf.tpdf;
       for (m=1; m<=tr->topM; m++,tm++)
          sum += tm->prob * tv[tm->index];
       return (sum>=MINLARG)?log(sum)+tr->maxP:LZERO;
@@ -507,13 +562,92 @@ static LogFloat cSOutP(HMMSet *hset, int
    return LZERO; /* to keep compiler happy */   
 }
 
+/*  outP calculation from HModel.c and extended for new adapt code */
+static LogFloat SOutP_HMod (HMMSet *hset, int s, Observation *x, StreamInfo *sti, int id)
+{
+   int m;
+   LogFloat bx,px,wt,det;
+   MixtureElem *me;
+   MixPDF *mp;
+   Vector v,otvs;
+
+   /* Note hset->kind == SHAREDHS */
+   assert (hset->hsKind == SHAREDHS);
+
+   v=x->fv[s];
+   me=sti->spdf.cpdf+1;
+   if (sti->nMix==1){     /* Single Mixture Case */
+      bx= MOutP(ApplyCompFXForm(me->mpdf,v,inXForm,&det,id),me->mpdf);
+      bx += det;
+   }
+   else if (!pde) {
+      bx=LZERO;                   /* Multi Mixture Case */
+      for (m=1; m<=sti->nMix; m++,me++) {
+         wt = MixLogWeight(hset,me->weight);
+         if (wt>LMINMIX) {
+            px= MOutP(ApplyCompFXForm(me->mpdf,v,inXForm,&det,id),me->mpdf);
+	    px += det;
+            bx=LAdd(bx,wt+px);
+         }
+      }
+   }
+   else {   /* Partial distance elimination */
+      wt = MixLogWeight(hset,me->weight);
+      mp = me->mpdf;
+      if (!hset->msdflag[s] || SpaceOrder(v)==VectorSize(mp->mean)) {
+         otvs = ApplyCompFXForm(mp,v,inXForm,&det,id);
+         px = IDOutP(otvs,VectorSize(otvs),mp);
+      }
+      else {
+         px = LZERO;
+         det = 0.0;
+      }
+      bx = wt+px+det;
+      for (m=2,me=sti->spdf.cpdf+2;m<=sti->nMix;m++,me++) {
+         wt = MixLogWeight(hset,me->weight);
+         if (wt>LMINMIX){
+            mp = me->mpdf;
+            otvs = ApplyCompFXForm(mp,v,inXForm,&det,id);
+            if (PDEMOutP(otvs,mp,&px,bx-wt-det) == TRUE)
+               bx = LAdd(bx,wt+px+det);
+         }
+      }
+   }
+   return bx;
+}
+
+/* Caching version of SOutP used when streaminfo shared */
+static LogFloat cSOutP(HMMSet *hset, int s, Observation *x, StreamInfo *sti,
+                       int id)
+{
+   PreComp *pre;
+   LogFloat bx;
+   Vector v;
+   
+   /* Note hset->kind == SHAREDHS */
+   v=x->fv[s];
+   if (sti->pIdx>0 && sti->pIdx<=pri->psi->npp)
+      pre= pri->psi->pPre + sti->pIdx;
+   else pre=NULL;
+   if (pre==NULL)
+      bx=SOutP_HMod(hset,s,x,sti,id);
+   else if (pre->id!=id) {
+      bx=SOutP_HMod(hset,s,x,sti,id);
+      pre->id=id;
+      pre->outp=bx;
+   }
+   else
+      bx=pre->outp;
+   
+   return bx;
+}
 
 /* Version of POutP that caches outp values with frame id */
 static LogFloat cPOutP(PSetInfo *psi,Observation *obs,StateInfo *si,int id)
 {
    PreComp *pre;
    LogFloat outp;
-   StreamElem *se;
+   StreamInfo *sti;
    Vector w;
    int s,S;
 
@@ -527,20 +661,28 @@ static LogFloat cPOutP(PSetInfo *psi,Obs
 #endif
    
    if (pre->id!=id) { /* bodged at the moment - fix !! */
-      if ((FALSE && psi->mixShared==FALSE) || (psi->hset->hsKind == DISCRETEHS)) {
+      if ((FALSE && psi->mixShared==FALSE && psi->streamShared==FALSE) || 
+          (psi->hset->hsKind == DISCRETEHS)) {
          outp=POutP(psi->hset,obs,si);
       }
       else {
          S=obs->swidth[0];
          if (S==1 && si->weights==NULL){
-            outp=cSOutP(psi->hset,1,obs,si->pdf+1,id);
+            sti=si->pdf[1].info;
+            if (psi->streamShared)
+               outp=cSOutP(psi->hset,1,obs,sti,id);
+            else 
+               outp=cMOutP(psi->hset,1,obs,sti,id);
          }
          else {
             outp=0.0;
-            se=si->pdf+1;
             w=si->weights;
-            for (s=1;s<=S;s++,se++){
-               outp+=w[s]*cSOutP(psi->hset,s,obs,se,id);
+            for (s=1;s<=S;s++) {
+               sti = si->pdf[s].info;
+               if (psi->streamShared)
+                  outp+=w[s]*cSOutP(psi->hset,s,obs,sti,id);
+               else
+                  outp+=w[s]*cMOutP(psi->hset,s,obs,sti,id);
             }
          }
       }
@@ -760,6 +902,7 @@ static void StepHMM1(NetNode *node) /* M
    }
    if (res->tok.like>LSMALL){
       tok.like=res->tok.like+inst->wdlk;
+      tok.align=NULL; tok.path=NULL; tok.lm=0.0;
       if (tok.like > pri->wordMaxTok.like) {
          pri->wordMaxTok=tok;
          pri->wordMaxNode=node;
@@ -1441,7 +1584,7 @@ PSetInfo *InitPSetInfo(HMMSet *hset)
    HLink hmm;
    MLink q;
    PreComp *pre;
-   char name[80];
+   char name[MAXSTRLEN];
    static int psid=0;
 
    psi=(PSetInfo*) New(&gcheap,sizeof(PSetInfo));
@@ -1481,9 +1624,25 @@ PSetInfo *InitPSetInfo(HMMSet *hset)
             CreateSEIndex(psi,hmm);
          }
       }
+
+   /* state */
    psi->nsp=hset->numStates;
    psi->sPre=(PreComp*) New(&psi->heap, sizeof(PreComp)*psi->nsp);
    psi->sPre--;
+
+   /* stream */
+   for(i=1,pre=psi->sPre+1;i<=psi->nsp;i++,pre++) pre->id=-1;
+   if (hset->numSharedStreams>0) {
+      psi->streamShared=TRUE;
+      psi->npp=hset->numSharedStreams;
+      psi->pPre=(PreComp*) New(&psi->heap, sizeof(PreComp)*psi->npp);
+      psi->pPre--;
+      for(i=1,pre=psi->pPre+1;i<=psi->npp;i++,pre++) pre->id=-1;
+   }
+   else
+      psi->streamShared=FALSE,psi->npp=0,psi->pPre=NULL;
+
+   /* mixture */
    for(i=1,pre=psi->sPre+1;i<=psi->nsp;i++,pre++) pre->id=-1;
    if (hset->numSharedMix>0) {
       psi->mixShared=TRUE;
@@ -1517,8 +1676,8 @@ static void LatFromPaths(Path *path,int 
    NxtPath tmp,*pth;
    Align *align,*al,*pr;
    MLink ml;
-   LabId labid,splabid,labpr = NULL;
-   char buf[80];
+   LabId labid=NULL,splabid,labpr=NULL;
+   char buf[MAXSTRLEN];
    int i,frame;
    double prlk,dur,like,wp;
 
@@ -1763,7 +1922,7 @@ VRecInfo *InitVRecInfo(PSetInfo *psi,int
    VRecInfo *vri;
    PreComp *pre;
    int i,n;
-   char name[80];
+   char name[MAXSTRLEN];
    static int prid=0;
 
    vri=(VRecInfo*) New(&gcheap,sizeof(VRecInfo));
@@ -1809,6 +1968,7 @@ VRecInfo *InitVRecInfo(PSetInfo *psi,int
    pri->psi=psi;
    /* pri->psi->sBuf[1].n=((pri->nToks>1)?1:0);  Needed every observation */
    for(i=1,pre=psi->sPre+1;i<=psi->nsp;i++,pre++) pre->id=-1;
+   for(i=1,pre=psi->pPre+1;i<=psi->npp;i++,pre++) pre->id=-1;
    for(i=1,pre=psi->mPre+1;i<=psi->nmp;i++,pre++) pre->id=-1;
 
    pri->stHeap=(MemHeap *) New(&vri->heap,pri->psi->stHeapNum*sizeof(MemHeap));
@@ -1954,10 +2114,10 @@ void ProcessObservation(VRecInfo *vri,Ob
    if (obs->swidth[0]!=pri->psi->hset->swidth[0])
       HError(8571,"ProcessObservation: incompatible number of streams (%d vs %d)",
              obs->swidth[0],pri->psi->hset->swidth[0]);
-   if (pri->psi->mixShared)
+   if (pri->psi->mixShared || pri->psi->streamShared)
       for (j=1;j<=obs->swidth[0];j++)
          if (VectorSize(obs->fv[j])!=pri->psi->hset->swidth[j])
-            HError(8571,"ProcessObservatio: incompatible stream widths for %d (%d vs %d)",
+            HError(8571,"ProcessObservation: incompatible stream widths for %d (%d vs %d)",
                    j,VectorSize(obs->fv[j]),pri->psi->hset->swidth[j]);
 
 
@@ -2375,7 +2535,7 @@ void FormatTranscription(Transcription *
    LabList *ll;
    LLink lab;
    HTime end;
-   char buf[MAXSTRLEN],*p,tail[64];
+   char buf[MAXSTRLEN],*p,tail[MAXSTRLEN];
    int lev,j,frames;
    
    if (killScores) {
@@ -2469,4 +2629,4 @@ void FormatTranscription(Transcription *
    }
 }
 
-/* ------------------------ End of HRec.c ------------------------- */
+/* ------------------------ End of HRec.c -------------------------- */
diff -pbBEwurNa --ignore-matching-lines='.*vc_id.*' HTK-3.4.1/HTKLib/HRec.h HTS-2.2_for_HTK-3.4.1/HTKLib/HRec.h
--- HTK-3.4.1/HTKLib/HRec.h	2009-03-13 03:47:54.000000000 +0900
+++ HTS-2.2_for_HTK-3.4.1/HTKLib/HRec.h	2011-06-16 13:18:29.000000000 +0900
@@ -19,6 +19,51 @@
 /*         File: HRec.h  Viterbi Recognition Engine Library    */
 /* ----------------------------------------------------------- */
 
+/*  *** THIS IS A MODIFIED VERSION OF HTK ***                        */
+/* ----------------------------------------------------------------- */
+/*           The HMM-Based Speech Synthesis System (HTS)             */
+/*           developed by HTS Working Group                          */
+/*           http://hts.sp.nitech.ac.jp/                             */
+/* ----------------------------------------------------------------- */
+/*                                                                   */
+/*  Copyright (c) 2001-2011  Nagoya Institute of Technology          */
+/*                           Department of Computer Science          */
+/*                                                                   */
+/*                2001-2008  Tokyo Institute of Technology           */
+/*                           Interdisciplinary Graduate School of    */
+/*                           Science and Engineering                 */
+/*                                                                   */
+/* All rights reserved.                                              */
+/*                                                                   */
+/* Redistribution and use in source and binary forms, with or        */
+/* without modification, are permitted provided that the following   */
+/* conditions are met:                                               */
+/*                                                                   */
+/* - Redistributions of source code must retain the above copyright  */
+/*   notice, this list of conditions and the following disclaimer.   */
+/* - Redistributions in binary form must reproduce the above         */
+/*   copyright notice, this list of conditions and the following     */
+/*   disclaimer in the documentation and/or other materials provided */
+/*   with the distribution.                                          */
+/* - Neither the name of the HTS working group nor the names of its  */
+/*   contributors may be used to endorse or promote products derived */
+/*   from this software without specific prior written permission.   */
+/*                                                                   */
+/* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND            */
+/* CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,       */
+/* INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF          */
+/* MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE          */
+/* DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS */
+/* BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,          */
+/* EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED   */
+/* TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,     */
+/* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON */
+/* ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,   */
+/* OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY    */
+/* OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE           */
+/* POSSIBILITY OF SUCH DAMAGE.                                       */
+/* ----------------------------------------------------------------- */
+
 /* !HVER!HREC:   3.4.1 [CUED 12/03/09] */
 
 #ifndef _HREC_H_
@@ -124,6 +169,11 @@ void InitRec(void);
    Initialise module
 */
 
+void ResetRec(void);
+/* 
+   Reset module 
+*/
+
 /*
    Functions specific to HMMSet
 
@@ -221,3 +271,5 @@ void TracePath(FILE *file,Path *path);
 #endif
 
 #endif  /* _HREC_H_ */
+
+/* ------------------------ End of HRec.h -------------------------- */
diff -pbBEwurNa --ignore-matching-lines='.*vc_id.*' HTK-3.4.1/HTKLib/HShell.c HTS-2.2_for_HTK-3.4.1/HTKLib/HShell.c
--- HTK-3.4.1/HTKLib/HShell.c	2009-03-13 03:48:03.000000000 +0900
+++ HTS-2.2_for_HTK-3.4.1/HTKLib/HShell.c	2011-06-16 13:18:29.000000000 +0900
@@ -32,8 +32,53 @@
 /*         File: HShell.c:   Interface to the Shell            */
 /* ----------------------------------------------------------- */
 
+/*  *** THIS IS A MODIFIED VERSION OF HTK ***                        */
+/* ----------------------------------------------------------------- */
+/*           The HMM-Based Speech Synthesis System (HTS)             */
+/*           developed by HTS Working Group                          */
+/*           http://hts.sp.nitech.ac.jp/                             */
+/* ----------------------------------------------------------------- */
+/*                                                                   */
+/*  Copyright (c) 2001-2011  Nagoya Institute of Technology          */
+/*                           Department of Computer Science          */
+/*                                                                   */
+/*                2001-2008  Tokyo Institute of Technology           */
+/*                           Interdisciplinary Graduate School of    */
+/*                           Science and Engineering                 */
+/*                                                                   */
+/* All rights reserved.                                              */
+/*                                                                   */
+/* Redistribution and use in source and binary forms, with or        */
+/* without modification, are permitted provided that the following   */
+/* conditions are met:                                               */
+/*                                                                   */
+/* - Redistributions of source code must retain the above copyright  */
+/*   notice, this list of conditions and the following disclaimer.   */
+/* - Redistributions in binary form must reproduce the above         */
+/*   copyright notice, this list of conditions and the following     */
+/*   disclaimer in the documentation and/or other materials provided */
+/*   with the distribution.                                          */
+/* - Neither the name of the HTS working group nor the names of its  */
+/*   contributors may be used to endorse or promote products derived */
+/*   from this software without specific prior written permission.   */
+/*                                                                   */
+/* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND            */
+/* CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,       */
+/* INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF          */
+/* MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE          */
+/* DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS */
+/* BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,          */
+/* EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED   */
+/* TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,     */
+/* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON */
+/* ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,   */
+/* OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY    */
+/* OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE           */
+/* POSSIBILITY OF SUCH DAMAGE.                                       */
+/* ----------------------------------------------------------------- */
+
 char *hshell_version = "!HVER!HShell:   3.4.1 [CUED 12/03/09]";
-char *hshell_vc_id = "$Id: HShell.c,v 1.1.1.1 2006/10/11 09:54:58 jal58 Exp $";
+char *hshell_vc_id = "$Id: HShell.c,v 1.15 2011/06/16 04:18:29 uratec Exp $";
 
 #include "HShell.h"
 
@@ -70,8 +115,8 @@ Boolean vaxOrder = FALSE;
 #define MAXEFS 5                        /* max num ext files to remember */
 
 typedef struct {                        /* extended file name */
-   char logfile[1024];                  /* logical name */
-   char actfile[1024];                  /* actual file name */
+   char logfile[MAXFNAMELEN];           /* logical name */
+   char actfile[MAXFNAMELEN];           /* actual file name */
    long stindex;                        /* start sample to extract */
    long enindex;                        /* end sample to extract */
 }ExtFile;
@@ -86,7 +131,7 @@ static int extFileUsed = 0;             
 char * RegisterExtFileName(char *s)
 {
    char *eq,*rb,*lb,*co;
-   char buf[1024];
+   char buf[MAXFNAMELEN];
    ExtFile *p;
 
    if (!extendedFileNames)
@@ -567,7 +612,10 @@ static int FindConfParm(ConfParam **list
 /* EXPORT->HasConfParm: true if parameter exists with given name */
 Boolean HasConfParm(ConfParam **list, int size, char *name)
 {
-   return (FindConfParm(list,size,name,AnyCKind) != -1);
+   if (FindConfParm(list,size,name,AnyCKind) != -1)
+      return TRUE;
+   else
+      return FALSE;
 }
 
 /* EXPORT->GetConfStr: return string parameter with given name */
@@ -651,7 +699,7 @@ static char *defargs[2]={ "<Uninitialise
 static char **arglist=defargs;/* actual arg list */
 static FILE *script = NULL;   /* script file if any */
 static int scriptcount = 0;   /* num words in script */
-static char scriptBuf[256];   /* buffer for current script arg */
+static char scriptBuf[MAXSTRLEN];   /* buffer for current script arg */
 static Boolean scriptBufLoaded = FALSE;
 static Boolean wasQuoted;     /* true if next arg was quoted */
 static ConfParam *cParm[MAXGLOBS];      /* config parameters */
@@ -905,7 +953,7 @@ static Boolean FilterSet(IOFilter filter
 void SubstFName(char *fname, char *s)
 {
    char *p;
-   char buf[1028];
+   char buf[MAXFNAMELEN+4];
 
    while ((p=strchr(s,'$')) != NULL){
       *p = '\0'; ++p;
@@ -927,7 +975,7 @@ FILE *FOpen(char *fname, IOFilter filter
    FILE *f;
    int i;
    Boolean isInput;
-   char mode[8],cmd[1028];
+   char mode[8],cmd[MAXFNAMELEN+4];
 
    if (filter <= NoFilter){ /* then input */
       isInput = TRUE;
@@ -1060,7 +1108,10 @@ Boolean SkipLine(Source *src)
    
    c = GetCh(src);
    while (c != EOF && c != '\n') c = GetCh(src);
-   return(c!=EOF);
+   if (c!=EOF)
+      return TRUE;
+   else
+      return FALSE;
 }
 
 /* EXPORT->ReadLine: read to next newline in source */
@@ -1071,7 +1122,7 @@ Boolean ReadLine(Source *src,char *s)
    c = GetCh(src);
    while (c != EOF && c != '\n') *s++=c,c=GetCh(src);
    *s=0;
-   return(c!=EOF);
+   return((c!=EOF) ? TRUE:FALSE);
 }
 
 /* EXPORT->ReadUntilLine: read to next occurrence of string */
@@ -1349,7 +1400,19 @@ static Boolean IsVAXOrder(void)
    px = &x;
    pc = (unsigned char *) px;
    *pc = 1; *(pc+1) = 0;         /* store bytes 1 0 */
-   return x==1;          /* does it read back as 1? */
+   return ((x==1) ? TRUE:FALSE);          /* does it read back as 1? */
+}
+
+/* EXPORT->SwapDouble: swap byte order of double data value *p */
+void SwapDouble(double *p)
+{
+   char temp, *q;
+   
+   q = (char *) p;
+   temp = *(q+0); *(q+0) = *(q+7); *(q+7) = temp;
+   temp = *(q+1); *(q+1) = *(q+6); *(q+6) = temp;
+   temp = *(q+2); *(q+2) = *(q+5); *(q+5) = temp;
+   temp = *(q+3); *(q+3) = *(q+4); *(q+4) = temp;
 }
 
 /* SwapInt32: swap byte order of int32 data value *p */
@@ -1455,22 +1518,56 @@ Boolean RawReadFloat(Source *src, float 
    return TRUE;
 }
 
+/* EXPORT->RawReadDouble: read n doubles from src in ascii or binary */
+Boolean RawReadDouble(Source *src, double *x, int n, Boolean bin, Boolean swap)
+{
+   int k,count=0,j;
+   double *p;
+   
+   if (bin){
+      if (fread(x,sizeof(double),n,src->f) != n)
+         return FALSE;
+      if (swap)
+         for(p=x,j=0;j<n;p++,j++)
+            SwapDouble(p);  /* Read in SUNSO unless natReadOrder=T */
+
+      count += n*sizeof(double);     
+   } else {
+      if (src->pbValid) {
+         ungetc(src->putback, src->f); src->pbValid = FALSE;
+      }
+      for (j=1; j<=n; j++){
+         if (fscanf(src->f,"%lf%n",x,&k) != 1)
+            return FALSE;
+         x++; count += k;
+      }
+   }
+   src->chcount += count;
+   return TRUE;
+}
+
 /* EXPORT->ReadShort: read n short's from src in ascii or binary */
 Boolean ReadShort(Source *src, short *s, int n, Boolean binary)
 {
-   return(RawReadShort(src,s,n,binary,(vaxOrder && !natReadOrder)));
+   return(RawReadShort(src,s,n,binary,((vaxOrder && !natReadOrder) ? TRUE:FALSE)));
 }
 
 /* EXPORT->ReadInt: read n ints from src in ascii or binary */
 Boolean ReadInt(Source *src, int *i, int n, Boolean binary)
 {
-   return(RawReadInt(src,i,n,binary,(vaxOrder && !natReadOrder)));
+   return(RawReadInt(src,i,n,binary,((vaxOrder && !natReadOrder) ? TRUE:FALSE)));
 }
 
 /* EXPORT->ReadFloat: read n floats from src in ascii or binary */
 Boolean ReadFloat(Source *src, float *x, int n, Boolean binary)
 {
-   return(RawReadFloat(src,x,n,binary,(vaxOrder && !natReadOrder)));
+   return(RawReadFloat(src,x,n,binary,((vaxOrder && !natReadOrder) ? TRUE:FALSE)));
+}
+
+/* EXPORT->ReadDouble: read n doubles from src in ascii or binary */
+Boolean ReadDouble(Source *src, double *x, int n, Boolean binary)
+{
+   return(RawReadDouble(src,x,n,binary,((vaxOrder && !natReadOrder) ? TRUE:FALSE)));
 }
 
 /* EXPORT->KeyPressed: returns TRUE if input is pending on stdin */
@@ -1658,6 +1755,30 @@ void WriteFloat (FILE *f, float *x, int 
    }
 }
 
+/* EXPORT->WriteDouble: write n doubles to f */
+void WriteDouble (FILE *f, double *x, int n, Boolean binary)
+{
+   int j;
+   double *p;
+   
+   if (binary){
+      if (vaxOrder && !natWriteOrder){
+         for(p=x,j=0;j<n;p++,j++)
+            SwapDouble(p);  /* Write in SUNSO unless natWriteOrder=T */
+      }
+      if (fwrite(x,sizeof(double),n,f) != n)
+         HError(5014,"WriteDouble: cant write to file");
+      if (vaxOrder && !natWriteOrder){
+         for(p=x,j=0;j<n;p++,j++)
+            SwapDouble(p);  /* Swap Back */
+      }
+   } else {
+      for (j=1; j<=n; j++){
+         fprintf(f," %e",*x++);
+      }
+   }
+}
+
 /* -------------------- File Name Handling ------------------- */
 
 /*
@@ -1725,7 +1846,7 @@ char * PathOf(char *fn, char *s)
 /* EXPORT->ExtnOf: extension part of fn */
 char * ExtnOf(char *fn, char *s)
 {
-   char *t,buf[100];
+   char *t,buf[MAXSTRLEN];
    
    NameOf(fn,buf);
    t = strrchr(buf,'.');
@@ -1784,7 +1905,7 @@ char * CounterFN(char *prefix, char* suf
 /* RMatch: recursively match s against pattern p, minplen
    is the min length string that can match p and
    numstars is the number of *'s in p */
-Boolean RMatch(char *s,char *p,int slen,int minplen,int numstars)
+Boolean RMatch(const char *s, const char *p, const int slen, const int minplen, const int numstars)
 {
    if (slen==0 && minplen==0)
       return TRUE;
@@ -1793,9 +1914,9 @@ Boolean RMatch(char *s,char *p,int slen,
    if (minplen>slen)
       return FALSE;
    if (*p == '*')
-      return RMatch(s+1,p+1,slen-1,minplen,numstars-1) ||
+      return ((RMatch(s+1,p+1,slen-1,minplen,numstars-1) ||
          RMatch(s,p+1,slen,minplen,numstars-1) ||
-         RMatch(s+1,p,slen-1,minplen,numstars);
+               RMatch(s+1,p,slen-1,minplen,numstars)) ? TRUE:FALSE);
    if (*p == *s || *p == '?')
       return RMatch(s+1,p+1,slen-1,minplen-1,numstars);
    else
@@ -1812,6 +1933,15 @@ Boolean DoMatch(char *s, char *p)
    minplen = 0; numstars = 0; q = p;
    while ((c=*q++))
       if (c == '*') ++numstars; else ++minplen;
+   if (numstars==2 && *p=='*' && *(q-2)=='*' && strchr(p,'?')==NULL) {
+      char str[PAT_LEN];
+      strncpy(str, p+1, minplen);  str[minplen] = '\0';
+      if (strstr(s, str)!=NULL) 
+         return TRUE; 
+      else 
+         return FALSE;
+   }
+   else   
    return RMatch(s,p,slen,minplen,numstars);
 }
 
@@ -1830,9 +1960,9 @@ static Boolean SpRMatch(char *s,char *p,
    else if ((numstars==0 && minplen!=slen) || minplen>slen)
       match=FALSE;
    else if (*p == '*') {
-      match=(SpRMatch(s+1,p,spkr,slen-1,minplen,numstars) ||
+      match=((SpRMatch(s+1,p,spkr,slen-1,minplen,numstars) ||
 	     SpRMatch(s,p+1,spkr,slen,minplen,numstars-1) ||
-	     SpRMatch(s+1,p+1,spkr,slen-1,minplen,numstars-1));
+	           SpRMatch(s+1,p+1,spkr,slen-1,minplen,numstars-1))) ? TRUE:FALSE;
    }
    else if (*p == '%') {
       *spkr=*s,spkr[1]=0;
@@ -1984,6 +2114,13 @@ ReturnStatus InitShell(int argc, char *a
    return(SUCCESS);
 }
 
+/* EXPORT->ResetShell: reset module */
+void ResetShell (void)
+{
+   free(arglist);
+   
+   return;
+}
 
 /* EXPORT->PrintStdOpts: print standard options */
 void PrintStdOpts(char *opt)
@@ -2017,17 +2154,34 @@ void PrintStdOpts(char *opt)
       printf(" -L dir  Set input label (or net) dir         current\n");
    if (strchr(opt,'M'))
       printf(" -M dir  Dir to write HMM macro files         current\n");
+   if (strchr(opt,'N'))
+      printf(" -N mmf  Load duration macro file mmf\n");
    if (strchr(opt,'O'))
       printf(" -O      Set target data format to fmt        as config\n");
    if (strchr(opt,'P'))
       printf(" -P      Set target label format to fmt       as config\n");
    if (strchr(opt,'Q'))
       printf(" -Q      Print command summary\n");
+   if (strchr(opt,'R'))
+      printf(" -R dir  Dir to write duration macro files                 current\n");
+   if (strchr(opt,'S'))
    printf(" -S f    Set script file to f                 none\n");
    printf(" -T N    Set trace flags to N                 0\n");
    printf(" -V      Print version information            off\n");
+   if (strchr(opt,'W')) {
+      printf(" -W s [s] set dir for duration parent xform to s           off\n");
+      printf("         and optional extension                 \n");
+   }
    if (strchr(opt,'X'))
       printf(" -X ext  Set input label (or net) file ext    lab\n");
+   if (strchr(opt,'Y')) {
+      printf(" -Y s [s] set dir for duration input xform to s            none\n");
+      printf("         and optional extension                            \n");
+   }
+   if (strchr(opt,'Z')) {
+      printf(" -Z s [s] set dir for duration output xform to s           none\n");
+      printf("         and optional extension                            \n");
+   }
 }
 
-/* -------------------------- End of HShell.c ----------------------------- */
+/* ------------------------ End of HShell.c ------------------------ */
diff -pbBEwurNa --ignore-matching-lines='.*vc_id.*' HTK-3.4.1/HTKLib/HShell.h HTS-2.2_for_HTK-3.4.1/HTKLib/HShell.h
--- HTK-3.4.1/HTKLib/HShell.h	2009-03-13 03:48:12.000000000 +0900
+++ HTS-2.2_for_HTK-3.4.1/HTKLib/HShell.h	2011-06-16 13:18:29.000000000 +0900
@@ -32,6 +32,51 @@
 /*         File: HShell.h:   Interface to the Shell            */
 /* ----------------------------------------------------------- */
 
+/*  *** THIS IS A MODIFIED VERSION OF HTK ***                        */
+/* ----------------------------------------------------------------- */
+/*           The HMM-Based Speech Synthesis System (HTS)             */
+/*           developed by HTS Working Group                          */
+/*           http://hts.sp.nitech.ac.jp/                             */
+/* ----------------------------------------------------------------- */
+/*                                                                   */
+/*  Copyright (c) 2001-2011  Nagoya Institute of Technology          */
+/*                           Department of Computer Science          */
+/*                                                                   */
+/*                2001-2008  Tokyo Institute of Technology           */
+/*                           Interdisciplinary Graduate School of    */
+/*                           Science and Engineering                 */
+/*                                                                   */
+/* All rights reserved.                                              */
+/*                                                                   */
+/* Redistribution and use in source and binary forms, with or        */
+/* without modification, are permitted provided that the following   */
+/* conditions are met:                                               */
+/*                                                                   */
+/* - Redistributions of source code must retain the above copyright  */
+/*   notice, this list of conditions and the following disclaimer.   */
+/* - Redistributions in binary form must reproduce the above         */
+/*   copyright notice, this list of conditions and the following     */
+/*   disclaimer in the documentation and/or other materials provided */
+/*   with the distribution.                                          */
+/* - Neither the name of the HTS working group nor the names of its  */
+/*   contributors may be used to endorse or promote products derived */
+/*   from this software without specific prior written permission.   */
+/*                                                                   */
+/* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND            */
+/* CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,       */
+/* INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF          */
+/* MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE          */
+/* DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS */
+/* BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,          */
+/* EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED   */
+/* TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,     */
+/* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON */
+/* ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,   */
+/* OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY    */
+/* OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE           */
+/* POSSIBILITY OF SUCH DAMAGE.                                       */
+/* ----------------------------------------------------------------- */
+
 /* !HVER!HShell:   3.4.1 [CUED 12/03/09] */
 
 #ifndef _HSHELL_H_
@@ -72,9 +117,22 @@ extern "C" {
 #endif
 
 
-#define MAXSTRLEN 256    /* max length of a string */
-#define MAXFNAMELEN 1034 /* max length of a file name */
-#define SMAX      5      /* max num data streams + 1 */
+#ifndef MAXSTRLEN
+#define MAXSTRLEN 1024   /* max length of a string (added for long context) */
+#endif  /* MAXSTRLEN */
+
+#ifndef MAXFNAMELEN
+#define MAXFNAMELEN 1024 /* max length of a file name */
+#endif  /* MAXFNAMELEN */
+
+#ifndef PAT_LEN
+#define PAT_LEN 2048     /* max length of pattern */
+#endif  /* PAT_LEN */
+
+#ifndef SMAX
+#define SMAX 30          /* max num data streams + 1 */
+#endif  /* SMAX */
+
 #define MAXGLOBS  256    /* max num global config parms */
 
 #define SING_QUOTE '\''  /* character used as quote */
@@ -211,6 +269,11 @@ ReturnStatus InitShell(int argc, char *a
    current tool.
 */
 
+void ResetShell(void);
+/* 
+   reset module
+*/
+
 void Register(char *ver, char *sccs);
 /*
    Register module version and sccs info.
@@ -440,16 +503,18 @@ void SkipComment(Source *src);
 Boolean ReadShort(Source *src, short *s, int n, Boolean binary);
 Boolean ReadInt  (Source *src, int *i,   int n, Boolean binary);
 Boolean ReadFloat(Source *src, float *x, int n, Boolean binary);
+Boolean ReadDouble(Source *src, double *x, int n, Boolean binary);
 /*
-   Read n short/int/float(s) from the given source, return 
+   Read n short/int/float/double(s) from the given source, return 
    TRUE if no error.  If binary then binary read is performed - 
    byte swapping is controlled by HShell config variables.
 */
 Boolean RawReadShort(Source *src, short *s, int n, Boolean bin, Boolean swap);
 Boolean RawReadInt(Source *src, int *i, int n, Boolean bin, Boolean swap);
 Boolean RawReadFloat(Source *src, float *x, int n, Boolean bin, Boolean swap);
+Boolean RawReadDouble(Source *src, double *x, int n, Boolean bin, Boolean swap);
 /*
-   Read n short/int/float(s) from the given source, return 
+   Read n short/int/float/double(s) from the given source, return 
    TRUE if no error.  
    If binary then binary read is performed.
    If swap then values are byte swapped after reading.
@@ -457,6 +522,7 @@ Boolean RawReadFloat(Source *src, float 
 
 void SwapShort(short *p);
 void SwapInt32(int32 *p);
+void SwapDouble(double *p);
 /* 
    Byte swap various types
 */
@@ -471,8 +537,9 @@ Boolean KeyPressed(int tWait);
 void WriteShort(FILE *f, short *s, int n, Boolean binary);
 void WriteInt  (FILE *f, int *i,   int n, Boolean binary);
 void WriteFloat(FILE *f, float *x, int n, Boolean binary);
+void WriteDouble(FILE *f, double *x, int n, Boolean binary);
 /*
-   Write n short/int/float(s) to the given file.  
+   Write n short/int/float/double(s) to the given file.  
    If binary then binary Write is performed.
 */
 
@@ -554,4 +621,4 @@ char *RetrieveCommandLine(void);
 
 #endif  /* _HSHELL_H_ */
 
-/* ----------------------- End of HShell.h --------------------------- */
+/* ------------------------ End of HShell.h ------------------------ */
diff -pbBEwurNa --ignore-matching-lines='.*vc_id.*' HTK-3.4.1/HTKLib/HSigP.c HTS-2.2_for_HTK-3.4.1/HTKLib/HSigP.c
--- HTK-3.4.1/HTKLib/HSigP.c	2009-03-13 03:48:26.000000000 +0900
+++ HTS-2.2_for_HTK-3.4.1/HTKLib/HSigP.c	2011-06-16 13:18:29.000000000 +0900
@@ -32,8 +32,53 @@
 /*      File: HSigP.c:   Signal Processing Routines            */
 /* ----------------------------------------------------------- */
 
+/*  *** THIS IS A MODIFIED VERSION OF HTK ***                        */
+/* ----------------------------------------------------------------- */
+/*           The HMM-Based Speech Synthesis System (HTS)             */
+/*           developed by HTS Working Group                          */
+/*           http://hts.sp.nitech.ac.jp/                             */
+/* ----------------------------------------------------------------- */
+/*                                                                   */
+/*  Copyright (c) 2001-2011  Nagoya Institute of Technology          */
+/*                           Department of Computer Science          */
+/*                                                                   */
+/*                2001-2008  Tokyo Institute of Technology           */
+/*                           Interdisciplinary Graduate School of    */
+/*                           Science and Engineering                 */
+/*                                                                   */
+/* All rights reserved.                                              */
+/*                                                                   */
+/* Redistribution and use in source and binary forms, with or        */
+/* without modification, are permitted provided that the following   */
+/* conditions are met:                                               */
+/*                                                                   */
+/* - Redistributions of source code must retain the above copyright  */
+/*   notice, this list of conditions and the following disclaimer.   */
+/* - Redistributions in binary form must reproduce the above         */
+/*   copyright notice, this list of conditions and the following     */
+/*   disclaimer in the documentation and/or other materials provided */
+/*   with the distribution.                                          */
+/* - Neither the name of the HTS working group nor the names of its  */
+/*   contributors may be used to endorse or promote products derived */
+/*   from this software without specific prior written permission.   */
+/*                                                                   */
+/* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND            */
+/* CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,       */
+/* INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF          */
+/* MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE          */
+/* DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS */
+/* BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,          */
+/* EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED   */
+/* TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,     */
+/* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON */
+/* ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,   */
+/* OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY    */
+/* OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE           */
+/* POSSIBILITY OF SUCH DAMAGE.                                       */
+/* ----------------------------------------------------------------- */
+
 char *hsigp_version = "!HVER!HSigP:   3.4.1 [CUED 12/03/09]";
-char *hsigp_vc_id = "$Id: HSigP.c,v 1.1.1.1 2006/10/11 09:54:58 jal58 Exp $";
+char *hsigp_vc_id = "$Id: HSigP.c,v 1.8 2011/06/16 04:18:29 uratec Exp $";
 
 #include "HShell.h"        /* HTK Libraries */
 #include "HMem.h"
@@ -71,6 +116,14 @@ void InitSigP(void)
    CreateHeap(&sigpHeap,"sigpHeap",MSTAK,1,0.0,5000,5000);
 }
 
+/* EXPORT->ResetSigP: reset the module */
+void ResetSigP (void)
+{
+   ResetHeap(&sigpHeap);
+   
+   return;
+}
+
 /* --------------- Windowing and PreEmphasis ---------------------*/
 
 /* ZeroMean: zero mean a complete speech waveform */
diff -pbBEwurNa --ignore-matching-lines='.*vc_id.*' HTK-3.4.1/HTKLib/HSigP.h HTS-2.2_for_HTK-3.4.1/HTKLib/HSigP.h
--- HTK-3.4.1/HTKLib/HSigP.h	2009-03-13 03:48:35.000000000 +0900
+++ HTS-2.2_for_HTK-3.4.1/HTKLib/HSigP.h	2011-06-16 13:18:29.000000000 +0900
@@ -32,6 +32,51 @@
 /*      File: HSigP.h:   Signal Processing Routines            */
 /* ----------------------------------------------------------- */
 
+/*  *** THIS IS A MODIFIED VERSION OF HTK ***                        */
+/* ----------------------------------------------------------------- */
+/*           The HMM-Based Speech Synthesis System (HTS)             */
+/*           developed by HTS Working Group                          */
+/*           http://hts.sp.nitech.ac.jp/                             */
+/* ----------------------------------------------------------------- */
+/*                                                                   */
+/*  Copyright (c) 2001-2011  Nagoya Institute of Technology          */
+/*                           Department of Computer Science          */
+/*                                                                   */
+/*                2001-2008  Tokyo Institute of Technology           */
+/*                           Interdisciplinary Graduate School of    */
+/*                           Science and Engineering                 */
+/*                                                                   */
+/* All rights reserved.                                              */
+/*                                                                   */
+/* Redistribution and use in source and binary forms, with or        */
+/* without modification, are permitted provided that the following   */
+/* conditions are met:                                               */
+/*                                                                   */
+/* - Redistributions of source code must retain the above copyright  */
+/*   notice, this list of conditions and the following disclaimer.   */
+/* - Redistributions in binary form must reproduce the above         */
+/*   copyright notice, this list of conditions and the following     */
+/*   disclaimer in the documentation and/or other materials provided */
+/*   with the distribution.                                          */
+/* - Neither the name of the HTS working group nor the names of its  */
+/*   contributors may be used to endorse or promote products derived */
+/*   from this software without specific prior written permission.   */
+/*                                                                   */
+/* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND            */
+/* CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,       */
+/* INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF          */
+/* MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE          */
+/* DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS */
+/* BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,          */
+/* EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED   */
+/* TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,     */
+/* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON */
+/* ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,   */
+/* OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY    */
+/* OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE           */
+/* POSSIBILITY OF SUCH DAMAGE.                                       */
+/* ----------------------------------------------------------------- */
+
 /* !HVER!HSigP:   3.4.1 [CUED 12/03/09] */
 
 #ifndef _HSIGP_H_
@@ -47,6 +92,11 @@ void InitSigP(void);
    before any other operation
 */
 
+void ResetSigP (void);
+/*
+   Reset the module
+*/
+
 /* --------------- Speech Signal Processing Operations ------------- */
 
 void ZeroMean(short *data, long nSamples);
diff -pbBEwurNa --ignore-matching-lines='.*vc_id.*' HTK-3.4.1/HTKLib/HTrain.c HTS-2.2_for_HTK-3.4.1/HTKLib/HTrain.c
--- HTK-3.4.1/HTKLib/HTrain.c	2009-03-13 03:48:50.000000000 +0900
+++ HTS-2.2_for_HTK-3.4.1/HTKLib/HTrain.c	2011-06-16 13:18:29.000000000 +0900
@@ -32,8 +32,53 @@
 /*         File: HTrain.c   HMM Training Support Routines      */
 /* ----------------------------------------------------------- */
 
+/*  *** THIS IS A MODIFIED VERSION OF HTK ***                        */
+/* ----------------------------------------------------------------- */
+/*           The HMM-Based Speech Synthesis System (HTS)             */
+/*           developed by HTS Working Group                          */
+/*           http://hts.sp.nitech.ac.jp/                             */
+/* ----------------------------------------------------------------- */
+/*                                                                   */
+/*  Copyright (c) 2001-2011  Nagoya Institute of Technology          */
+/*                           Department of Computer Science          */
+/*                                                                   */
+/*                2001-2008  Tokyo Institute of Technology           */
+/*                           Interdisciplinary Graduate School of    */
+/*                           Science and Engineering                 */
+/*                                                                   */
+/* All rights reserved.                                              */
+/*                                                                   */
+/* Redistribution and use in source and binary forms, with or        */
+/* without modification, are permitted provided that the following   */
+/* conditions are met:                                               */
+/*                                                                   */
+/* - Redistributions of source code must retain the above copyright  */
+/*   notice, this list of conditions and the following disclaimer.   */
+/* - Redistributions in binary form must reproduce the above         */
+/*   copyright notice, this list of conditions and the following     */
+/*   disclaimer in the documentation and/or other materials provided */
+/*   with the distribution.                                          */
+/* - Neither the name of the HTS working group nor the names of its  */
+/*   contributors may be used to endorse or promote products derived */
+/*   from this software without specific prior written permission.   */
+/*                                                                   */
+/* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND            */
+/* CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,       */
+/* INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF          */
+/* MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE          */
+/* DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS */
+/* BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,          */
+/* EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED   */
+/* TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,     */
+/* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON */
+/* ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,   */
+/* OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY    */
+/* OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE           */
+/* POSSIBILITY OF SUCH DAMAGE.                                       */
+/* ----------------------------------------------------------------- */
+
 char *htrain_version = "!HVER!HTrain:   3.4.1 [CUED 12/03/09]";
-char *htrain_vc_id = "$Id: HTrain.c,v 1.1.1.1 2006/10/11 09:54:58 jal58 Exp $";
+char *htrain_vc_id = "$Id: HTrain.c,v 1.22 2011/06/16 04:18:29 uratec Exp $";
 
 #include "HShell.h"
 #include "HMem.h"
@@ -91,6 +136,12 @@ void InitTrain(void)
    }
 }
 
+/* EXPORT->ResetTrain: reset module */
+void ResetTrain (void)
+{
+   return;   /* do nothing */
+}
+
 /* -------------------- Generic Sequence Type ------------------- */
 
 /*
@@ -199,8 +250,8 @@ SegStore CreateSegStore(MemHeap *x, Obse
    ss = (SegStore)New(x,sizeof(SegStoreRec));
    ss->mem = x;
    ss->o = obs; ss->segLen = segLen;
-   ss->hasfv = (obs.pk&BASEMASK) != DISCRETE;
-   ss->hasvq = (obs.pk&HASVQ)  || (obs.pk&BASEMASK) == DISCRETE;
+   ss->hasfv = ((obs.pk&BASEMASK) != DISCRETE) ? TRUE : FALSE;
+   ss->hasvq = ((obs.pk&HASVQ)  || (obs.pk&BASEMASK) == DISCRETE) ? TRUE : FALSE;
    if (ss->hasfv) ss->fvSegs = CreateSequence(x,100);
    if (ss->hasvq) ss->vqSegs = CreateSequence(x,100);
    return ss;
@@ -214,8 +265,8 @@ void LoadSegment(SegStore ss, HTime star
    BufferInfo info;
    long i,st,en,len;
    int s,S = ss->o.swidth[0];
-   short *vqItem;
-   Vector *fvItem;
+   short *vqItem, *ovq;
+   Vector *fvItem, *ofv;
    
    GetBufferInfo(pbuf,&info);
    st = (long)(start/info.tgtSampRate);
@@ -236,14 +287,16 @@ void LoadSegment(SegStore ss, HTime star
       ReadAsTable(pbuf,i,&(ss->o));
       if (ss->hasvq) {
          vqItem = (short *)New(ss->mem,sizeof(short)*(S+1));
+         ovq = ss->o.vq;
          for (s=1; s<=S; s++) 
-            vqItem[s] = ss->o.vq[s];
+            vqItem[s] = ovq[s];
          StoreItem(vq, (Ptr) vqItem);
       }
       if (ss->hasfv) {
          fvItem = (Vector *)New(ss->mem,sizeof(Vector)*(S+1));
+         ofv = ss->o.fv;
          for (s=1; s<=S; s++) 
-            fvItem[s] = ss->o.fv[s];
+            fvItem[s] = ofv[s];
          StoreItem(fv, (Ptr) fvItem);
       }
    }
@@ -283,20 +336,22 @@ Observation GetSegObs(SegStore ss, int i
    Sequence vq;
    Sequence fv;
    int s,S = ss->o.swidth[0];
-   short *vqItem;
-   Vector *fvItem;
+   short *vqItem, *ovq;
+   Vector *fvItem, *ofv;
    
    if (ss->hasvq) {
       vq = (Sequence) GetItem(ss->vqSegs,i);
       vqItem = (short *) GetItem(vq,j);
+      ovq = ss->o.vq;
       for (s=1; s<=S; s++) 
-         ss->o.vq[s] = vqItem[s];
+         ovq[s] = vqItem[s];
    }     
    if (ss->hasfv) {
       fv = (Sequence) GetItem(ss->fvSegs,i);
       fvItem = (Vector *) GetItem(fv,j);
+      ofv = ss->o.fv;
       for (s=1; s<=S; s++) 
-         ss->o.fv[s] = fvItem[s];
+         ofv[s] = fvItem[s];
    }     
    return ss->o;
 }
@@ -791,7 +846,7 @@ ClusterSet *FlatCluster(MemHeap *x, Sequ
             printf("   c=%d, iter=%d, cost = %e\n",c,iter,newCost);
             fflush(stdout);
          }
-         converged = (iter>=maxIter) || ((oldCost-newCost) / oldCost < 0.001);
+         converged = ((iter>=maxIter) || ((oldCost-newCost) / oldCost < 0.001)) ? TRUE : FALSE;
          FindCentres(1,curNumCl); oldCost = newCost;
       }
       if (trace & T_DCM) DumpClusterMap();
@@ -961,10 +1016,10 @@ void TMAttachAccs(HMMSet *hset, MemHeap 
    
    nStreams = hset->swidth[0];
    for (s=1;s<=nStreams;s++){
-      size = hset->swidth[s];
       tmRec = hset->tmRecs[s];
       for (m=1;m<=tmRec.nMix;m++){
          mp = tmRec.mixes[m];
+         size = VectorSize(mp->mean);
          SetHook(mp->mean,CreateMuAcc(x,size,nPara));
          SetHook(mp->cov.var,CreateVaAcc(x,size,mp->ckind,nPara));
       }
@@ -978,7 +1033,7 @@ void AttachAccs(HMMSet *hset, MemHeap *x
 void AttachAccsParallel(HMMSet *hset, MemHeap *x, UPDSet uFlags, int nPara)
 {
    HMMScanState hss;
-   StreamElem *ste;
+   StreamInfo *sti;
    HLink hmm;
    int size;
 
@@ -988,13 +1043,14 @@ void AttachAccsParallel(HMMSet *hset, Me
       hmm = hss.hmm;
       hmm->hook = (void *)0;  /* used as numEg counter */
       while (GoNextState(&hss,TRUE)) {
+         hss.si->hook = (void *)0;  /* used as state occ counter */ 
          while (GoNextStream(&hss,TRUE)) {
-            ste = hss.ste;
-            ste->hook = CreateWtAcc(x,hss.M, nPara);
-            if ((uFlags&UPSEMIT) && (strmProj)) size = hset->vecSize; /* handles multiple streams */
-            else size = hset->swidth[hss.s];
+            sti = hss.sti;
+            sti->hook = CreateWtAcc(x,hss.M, nPara);
             if (hss.isCont)                     /* PLAINHS or SHAREDHS */
                while (GoNextMix(&hss,TRUE)) {
+                  if ((uFlags&UPSEMIT) && (strmProj)) size = hset->vecSize; /* handles multiple streams */
+                  else size = VectorSize(hss.mp->mean);
                   if (DoPreComps(hset->hsKind))
                      hss.mp->hook = CreatePreComp(x);
 		  if (!IsSeenV(hss.mp->mean)) {
@@ -1073,7 +1129,7 @@ void ZeroAccs(HMMSet *hset, UPDSet uFlag
 void ZeroAccsParallel(HMMSet *hset, UPDSet uFlags, int nPara)
 {
    HMMScanState hss;
-   StreamElem *ste;
+   StreamInfo *sti;
    HLink hmm;
    TrAcc *ta;
    WtAcc *wa;
@@ -1088,8 +1144,8 @@ void ZeroAccsParallel(HMMSet *hset, UPDS
       hmm->hook = (void *)0;  /* used as numEg counter */
       while (GoNextState(&hss,TRUE)) {
          while (GoNextStream(&hss,TRUE)) {
-            ste = hss.ste;
-            wa = (WtAcc *)ste->hook;
+            sti = hss.sti;
+            wa = (WtAcc *)sti->hook;
             for(i=start;i<=end;i++){
 	      ZeroVector(wa[i].c); wa[i].occ = 0.0;
 	      wa[i].time = -1; wa[i].prob = NULL;
@@ -1196,7 +1252,7 @@ void ShowAccsParallel(HMMSet *hset, UPDS
 {
    const int mw=12;
    HMMScanState hss;
-   StreamElem *ste;
+   StreamInfo *sti;
    HLink hmm;
    TrAcc *ta;
    WtAcc *wa;
@@ -1210,10 +1266,10 @@ void ShowAccsParallel(HMMSet *hset, UPDS
       while (GoNextState(&hss,TRUE)) {
          printf(" state %d\n",hss.i);
          while (GoNextStream(&hss,TRUE)) {
-            ste = hss.ste;
+            sti = hss.sti;
             printf("  stream %d\n",hss.s);
-            if (ste->hook != NULL) {
-               wa = (WtAcc *)ste->hook;
+            if (sti->hook != NULL) {
+               wa = (WtAcc *)sti->hook;
                printf("   wt occ=%f\n",wa[index].occ);
                ShowVector("   wts=",wa[index].c,mw);
             }
@@ -1263,7 +1319,7 @@ void ShowAccsParallel(HMMSet *hset, UPDS
 void AttachPreComps(HMMSet *hset, MemHeap *x)
 {
    HMMScanState hss;
-   StreamElem *ste;
+   StreamInfo *sti;
    HLink hmm;
 
    prC=0; wtC=0;
@@ -1273,8 +1329,8 @@ void AttachPreComps(HMMSet *hset, MemHea
       hmm->hook = (void *)0;  /* used as numEg counter */
       while (GoNextState(&hss,TRUE)) {
          while (GoNextStream(&hss,TRUE)) {
-            ste = hss.ste;
-            ste->hook = CreateWtAcc(x,hss.M, 1);
+            sti = hss.sti;
+            sti->hook = CreateWtAcc(x,hss.M, 1);
             if (hss.isCont)                     /* PLAINHS or SHAREDHS */
                while (GoNextMix(&hss,TRUE)) {
                   if (DoPreComps(hset->hsKind))
@@ -1291,7 +1347,7 @@ void AttachPreComps(HMMSet *hset, MemHea
 /* EXPORT->ResetPreComps: reset the precomputed prob fields in hset */
 void ResetPreComps(HMMSet *hset)
 {
-   StreamElem *ste;
+   StreamInfo *sti;
    HMMScanState hss;
    WtAcc *wa;
    PreComp *p;
@@ -1300,8 +1356,8 @@ void ResetPreComps(HMMSet *hset)
    do {
       while (GoNextState(&hss,TRUE)) {
          while (GoNextStream(&hss,TRUE)) {
-            ste = hss.ste;
-            wa = (WtAcc *)ste->hook;
+            sti = hss.sti;
+            wa = (WtAcc *)sti->hook;
             wa->time = -1; wa->prob = NULL;
             if (hss.isCont)
                while (GoNextMix(&hss,TRUE)) {
@@ -1319,6 +1375,7 @@ void ResetHMMPreComps(HLink hmm, int nSt
 {
    StateElem *se;
    StreamElem *ste;
+   StreamInfo *sti;
    MixtureElem *me;
    WtAcc *wa;
    PreComp *p;
@@ -1329,10 +1386,11 @@ void ResetHMMPreComps(HLink hmm, int nSt
    for (i=2; i<nStates; i++,se++){
       ste = se->info->pdf+1;
       for (s=1;s<=nStreams; s++,ste++){
-         wa = (WtAcc *)ste->hook; nMixes = ste->nMix;
+         sti = ste->info;
+         wa = (WtAcc *)sti->hook; nMixes = sti->nMix;
          if (wa != NULL) {
             wa->time = -1; wa->prob = NULL;
-            me = ste->spdf.cpdf+1;
+            me = sti->spdf.cpdf+1;
             for (m=1; m<=nMixes; m++,me++){
                p = (PreComp *)me->mpdf->hook;
                p->time = -1; p->prob = LZERO;
@@ -1347,6 +1405,7 @@ void ResetHMMWtAccs(HLink hmm, int nStre
 {
    StateElem *se;
    StreamElem *ste;
+   StreamInfo *sti;
    WtAcc *wa;
    int i,s,nStates;
 
@@ -1355,7 +1414,8 @@ void ResetHMMWtAccs(HLink hmm, int nStre
    for (i=2; i<nStates; i++,se++){
       ste = se->info->pdf+1;
       for (s=1;s<=nStreams; s++,ste++){
-         wa = (WtAcc *)ste->hook;
+         sti = ste->info;
+         wa = (WtAcc *)sti->hook;
          if (wa != NULL) {
             wa->time = -1; wa->prob = NULL;
          }
@@ -1370,6 +1430,21 @@ static void DumpPName(FILE *f, char *pna
    fprintf(f,"\n");
 }
 
+/* DumpStateOcc: dump state occ to file f */
+static void DumpStateOcc(FILE *f, HMMSet *hset, StateInfo *si)
+{
+   float occ;
+
+   if (hset->numSharedStreams>0) {
+   	if (si->hook==NULL)
+         occ = 0.0;
+      else
+         memcpy(&occ,&(si->hook),sizeof(float));
+      WriteFloat(f,&occ,1,ldBinary);
+      if (!ldBinary) fprintf(f,"\n");
+   }
+}
+
 /* DumpWtAcc: dump wt acc to file f */
 static void DumpWtAcc(FILE *f, WtAcc *wa)
 {
@@ -1456,7 +1531,7 @@ FILE * DumpAccsParallel(HMMSet *hset, ch
    FILE *f;
    HLink hmm;
    HMMScanState hss;
-   int m,s;
+   int m,s,i;
    MixPDF* mp;
    
    f = GetDumpFile(fname,n);
@@ -1464,10 +1539,12 @@ FILE * DumpAccsParallel(HMMSet *hset, ch
    do {
       hmm = hss.hmm;
       DumpPName(f,hss.mac->id->name);     
-      WriteInt(f,(int *)&hmm->hook,1,ldBinary); 
+      i = (int)((long) hmm->hook);
+      WriteInt(f,&i,1,ldBinary);
       while (GoNextState(&hss,TRUE)) {
+         DumpStateOcc(f,hset,hss.si);
          while (GoNextStream(&hss,TRUE)) {
-            DumpWtAcc(f,((WtAcc *)hss.ste->hook)+index);
+            DumpWtAcc(f,((WtAcc *)hss.sti->hook)+index);
             if (hss.isCont){
                while (GoNextMix(&hss,TRUE)) {
                   if ((uFlags&UPMEANS) && (!IsSeenV(hss.mp->mean))) {
@@ -1504,6 +1581,19 @@ FILE * DumpAccsParallel(HMMSet *hset, ch
    return f;
 }
 
+/* LoadStateOcc: new state occ from file f */
+static void LoadStateOcc(Source *src, HMMSet *hset, StateInfo *si)
+{
+   float tocc, socc;
+
+   if (hset->numSharedStreams>0) {
+      memcpy(&tocc,&(si->hook),sizeof(float));
+      ReadFloat(src,&socc,1,ldBinary);
+      tocc += socc;
+      memcpy(&(si->hook),&tocc,sizeof(float));
+   }
+}
+
 /* LoadWtAcc: new inc of wt acc from file f */
 static void LoadWtAcc(Source *src, WtAcc *wa, int numMixtures)
 {
@@ -1628,7 +1718,8 @@ Source LoadAccsParallel(HMMSet *hset, ch
    Source src;
    HLink hmm;
    HMMScanState hss;
-   int size,negs,m,s;
+   int size,m,s,i;
+   long negs;
    MixPDF* mp;
    
    if (trace & T_ALD)
@@ -1640,15 +1731,18 @@ Source LoadAccsParallel(HMMSet *hset, ch
    do {
       hmm = hss.hmm;
       CheckPName(&src,hss.mac->id->name); 
-      ReadInt(&src,&negs,1,ldBinary);
-      negs += (int)hmm->hook; hmm->hook = (void *)negs;
+      ReadInt(&src,&i,1,ldBinary); negs = (long) i;
+      negs += (long)hmm->hook; hmm->hook = (void *)negs;
       while (GoNextState(&hss,TRUE)) {
+         LoadStateOcc(&src,hset,hss.si);
          while (GoNextStream(&hss,TRUE)) {
-            if ((uFlags&UPSEMIT) && (strmProj)) size = hset->vecSize;
-            else size = hset->swidth[hss.s];
-            LoadWtAcc(&src,((WtAcc *)hss.ste->hook)+index,hss.M);
+            LoadWtAcc(&src,((WtAcc *)hss.sti->hook)+index,hss.M);
             if (hss.isCont){
                while (GoNextMix(&hss,TRUE)) {
+                  if ((uFlags&UPSEMIT) && (strmProj)) 
+                     size = hset->vecSize;
+                  else
+                     size = VectorSize(hss.mp->mean);  /* MSD */
                   if ((uFlags&UPMEANS) && (!IsSeenV(hss.mp->mean))) {
 		     LoadMuAcc(&src,((MuAcc *)GetHook(hss.mp->mean))+index,size);
                      TouchV(hss.mp->mean);
@@ -1675,9 +1769,9 @@ Source LoadAccsParallel(HMMSet *hset, ch
    EndHMMScan(&hss);
    if (hset->hsKind == TIEDHS){
       for (s=1; s<=hset->swidth[0]; s++){
-         size = hset->swidth[s];
          for (m=1;m<=hset->tmRecs[s].nMix; m++){
             mp = hset->tmRecs[s].mixes[m];
+            size = VectorSize(mp->mean);  /* MSD */
             LoadMuAcc(&src,((MuAcc *)GetHook(mp->mean))+index,size);
             LoadVaAcc(&src,((VaAcc *)GetHook(mp->cov.var))+index,size,mp->ckind);
          }
@@ -1713,11 +1807,10 @@ void RestoreAccs(HMMSet *hset){ RestoreA
 void RestoreAccsParallel(HMMSet *hset, int index)
 {
    HMMScanState hss;
-   int s,m,size;
+   int s,m;
 
    if(hset->hsKind==TIEDHS){
       for (s=1; s<=hset->swidth[0]; s++){
-         size = hset->swidth[s];
          for (m=1;m<=hset->tmRecs[s].nMix; m++)
             RestorePDF(hset->tmRecs[s].mixes[m], index);
       }
@@ -1771,14 +1864,15 @@ double ScaleAccsParallel(HMMSet *hset, f
    /* Do gaussians. */
    if(hset->hsKind==TIEDHS){
       for (s=1; s<=hset->swidth[0]; s++){
-         size = hset->swidth[s];
-         for (m=1;m<=hset->tmRecs[s].nMix; m++)
+	 for (m=1;m<=hset->tmRecs[s].nMix; m++) {
+            size = VectorSize(hset->tmRecs[s].mixes[m]->mean);
             ans += ScalePDF(hset->tmRecs[s].mixes[m], size, index, wt);
       }
+      }
    } else {
       NewHMMScan(hset, &hss);
       while (GoNextMix(&hss,FALSE)) {
-         size = hset->swidth[hss.s];
+         size = VectorSize(hss.mp->mean);
          ans += ScalePDF(hss.mp, size, index, wt);
       }
       EndHMMScan(&hss);
@@ -1789,11 +1883,11 @@ double ScaleAccsParallel(HMMSet *hset, f
    NewHMMScan(hset,&hss);
    while(GoNextState(&hss,FALSE)){ /*skip over hmm boundaries.*/
       while(GoNextStream(&hss,TRUE)){ /*Don't skip over state boundaries.*/
-         StreamElem *ste = hss.ste; int m, nMix;
-         WtAcc *wa = ((WtAcc*) hss.ste->hook)+index;
+         StreamInfo *sti = hss.sti; int m, nMix;
+         WtAcc *wa = ((WtAcc*) hss.sti->hook)+index;
          switch(hset->hsKind){
          case PLAINHS: case SHAREDHS:
-            nMix = (ste->nMix>0?ste->nMix:-ste->nMix);
+            nMix = (sti->nMix>0?sti->nMix:-sti->nMix);
             wa->occ*=wt; /*take the value wa->occ to the desired value.*/
             for(m=1;m<=nMix;m++){
                wa->c[m] *= wt; /*scale the WtAcc->c[]*/
@@ -1835,5 +1929,4 @@ double ScaleAccsParallel(HMMSet *hset, f
    return ans;
 }
 
-
-/* ------------------------ End of HTrain.c ----------------------- */
+/* ------------------------ End of HTrain.c ------------------------ */
diff -pbBEwurNa --ignore-matching-lines='.*vc_id.*' HTK-3.4.1/HTKLib/HTrain.h HTS-2.2_for_HTK-3.4.1/HTKLib/HTrain.h
--- HTK-3.4.1/HTKLib/HTrain.h	2009-03-13 03:48:58.000000000 +0900
+++ HTS-2.2_for_HTK-3.4.1/HTKLib/HTrain.h	2011-06-16 13:18:29.000000000 +0900
@@ -32,6 +32,51 @@
 /*         File: HTrain.h   HMM Training Support Routines      */
 /* ----------------------------------------------------------- */
 
+/*  *** THIS IS A MODIFIED VERSION OF HTK ***                        */
+/* ----------------------------------------------------------------- */
+/*           The HMM-Based Speech Synthesis System (HTS)             */
+/*           developed by HTS Working Group                          */
+/*           http://hts.sp.nitech.ac.jp/                             */
+/* ----------------------------------------------------------------- */
+/*                                                                   */
+/*  Copyright (c) 2001-2011  Nagoya Institute of Technology          */
+/*                           Department of Computer Science          */
+/*                                                                   */
+/*                2001-2008  Tokyo Institute of Technology           */
+/*                           Interdisciplinary Graduate School of    */
+/*                           Science and Engineering                 */
+/*                                                                   */
+/* All rights reserved.                                              */
+/*                                                                   */
+/* Redistribution and use in source and binary forms, with or        */
+/* without modification, are permitted provided that the following   */
+/* conditions are met:                                               */
+/*                                                                   */
+/* - Redistributions of source code must retain the above copyright  */
+/*   notice, this list of conditions and the following disclaimer.   */
+/* - Redistributions in binary form must reproduce the above         */
+/*   copyright notice, this list of conditions and the following     */
+/*   disclaimer in the documentation and/or other materials provided */
+/*   with the distribution.                                          */
+/* - Neither the name of the HTS working group nor the names of its  */
+/*   contributors may be used to endorse or promote products derived */
+/*   from this software without specific prior written permission.   */
+/*                                                                   */
+/* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND            */
+/* CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,       */
+/* INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF          */
+/* MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE          */
+/* DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS */
+/* BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,          */
+/* EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED   */
+/* TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,     */
+/* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON */
+/* ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,   */
+/* OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY    */
+/* OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE           */
+/* POSSIBILITY OF SUCH DAMAGE.                                       */
+/* ----------------------------------------------------------------- */
+
 /* !HVER!HTrain:   3.4.1 [CUED 12/03/09] */
 
 #ifndef _HTRAIN_H_
@@ -54,6 +99,11 @@ void InitTrain(void);
    Initialise the module
 */
 
+void ResetTrain(void);
+/*
+   Reset the module
+*/
+
 /* ------------------ Generic Sequence Type --------------- */
 
 typedef struct _ItemBlock *IBLink;
@@ -327,4 +377,4 @@ extern Boolean strmProj;
 
 #endif  /* _HTRAIN_H_ */
 
-/* ---------------------- End of HTrain.h ---------------------- */
+/* ------------------------ End of HTrain.h ------------------------ */
diff -pbBEwurNa --ignore-matching-lines='.*vc_id.*' HTK-3.4.1/HTKLib/HUtil.c HTS-2.2_for_HTK-3.4.1/HTKLib/HUtil.c
--- HTK-3.4.1/HTKLib/HUtil.c	2009-03-13 03:49:06.000000000 +0900
+++ HTS-2.2_for_HTK-3.4.1/HTKLib/HUtil.c	2011-06-16 13:18:29.000000000 +0900
@@ -32,8 +32,53 @@
 /*         File: HUtil.c      HMM utility routines             */
 /* ----------------------------------------------------------- */
 
+/*  *** THIS IS A MODIFIED VERSION OF HTK ***                        */
+/* ----------------------------------------------------------------- */
+/*           The HMM-Based Speech Synthesis System (HTS)             */
+/*           developed by HTS Working Group                          */
+/*           http://hts.sp.nitech.ac.jp/                             */
+/* ----------------------------------------------------------------- */
+/*                                                                   */
+/*  Copyright (c) 2001-2011  Nagoya Institute of Technology          */
+/*                           Department of Computer Science          */
+/*                                                                   */
+/*                2001-2008  Tokyo Institute of Technology           */
+/*                           Interdisciplinary Graduate School of    */
+/*                           Science and Engineering                 */
+/*                                                                   */
+/* All rights reserved.                                              */
+/*                                                                   */
+/* Redistribution and use in source and binary forms, with or        */
+/* without modification, are permitted provided that the following   */
+/* conditions are met:                                               */
+/*                                                                   */
+/* - Redistributions of source code must retain the above copyright  */
+/*   notice, this list of conditions and the following disclaimer.   */
+/* - Redistributions in binary form must reproduce the above         */
+/*   copyright notice, this list of conditions and the following     */
+/*   disclaimer in the documentation and/or other materials provided */
+/*   with the distribution.                                          */
+/* - Neither the name of the HTS working group nor the names of its  */
+/*   contributors may be used to endorse or promote products derived */
+/*   from this software without specific prior written permission.   */
+/*                                                                   */
+/* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND            */
+/* CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,       */
+/* INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF          */
+/* MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE          */
+/* DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS */
+/* BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,          */
+/* EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED   */
+/* TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,     */
+/* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON */
+/* ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,   */
+/* OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY    */
+/* OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE           */
+/* POSSIBILITY OF SUCH DAMAGE.                                       */
+/* ----------------------------------------------------------------- */
+
 char *hutil_version = "!HVER!HUtil:   3.4.1 [CUED 12/03/09]";
-char *hutil_vc_id = "$Id: HUtil.c,v 1.1.1.1 2006/10/11 09:54:59 jal58 Exp $";
+char *hutil_vc_id = "$Id: HUtil.c,v 1.31 2011/06/16 04:18:29 uratec Exp $";
 
 #include "HShell.h"
 #include "HMem.h"
@@ -79,8 +124,17 @@ void InitUtil(void)
    CreateHeap(&setHeap,"HUtil: IntSet Heap",MSTAK,1,1.0,2000,16000);
 }
 
+/* EXPORT->ResetUtil: reset created heaps in InitUtil */
+void ResetUtil(void)
+{
+   ResetHeap(&setHeap);
+   ResetHeap(&itemHeap);
+   
+   return;
+}
+
 /* EXPORT->ResetUtilItemList: frees all the memory from the ItemList heap */
-void ResetUtilItemList()
+void ResetUtilItemList(void)
 {
    DeleteHeap(&itemHeap);
    CreateHeap(&itemHeap,"HUtil: ItemList Heap",MHEAP,sizeof(ItemRec),
@@ -170,30 +224,34 @@ MixPDF *CloneMixPDF(HMMSet *hset, MixPDF
    return t;
 }
 
-/* CloneStream: return a clone of given stream */
-MixtureVector CloneStream(HMMSet *hset, StreamElem *ste, Boolean sharing)
+/* ClonePDF: return a clone of given stream (PDF) */
+StreamInfo *ClonePDF(HMMSet *hset, int s, 
+                     StreamInfo *ssti, Boolean sharing)
 {
    int m,M;
+   StreamInfo *tsti;
    MixtureElem *sme,*tme;
-   MixtureVector mv;
 
-   M = ste->nMix;
-   if (hset->hsKind == PLAINHS || hset->hsKind == SHAREDHS){
+   if (ssti->nUse>0 && sharing) {
+      ++ssti->nUse;
+      return ssti;
+   }
+   M = ssti->nMix;
+   tsti = (StreamInfo *)New(hset->hmem,sizeof(StreamInfo));
+   tsti->nUse = 0;    tsti->nMix = ssti->nMix; 
+   tsti->hook = NULL; tsti->stream = s;
       tme = (MixtureElem *)New(hset->hmem,M*sizeof(MixtureElem));
-      mv.cpdf = tme-1; sme = ste->spdf.cpdf + 1;
+   tsti->spdf.cpdf = tme-1; sme = ssti->spdf.cpdf + 1;
+   
       for (m=1; m<=M; m++,sme++,tme++){
          tme->weight = sme->weight;
-         tme->mpdf = 
-            (MixWeight(hset,tme->weight)>MINMIX)?CloneMixPDF(hset,sme->mpdf,sharing):NULL;
-      }
-   } else if (hset->hsKind == TIEDHS) {
-      mv.tpdf = CreateVector(hset->hmem,M);
-      CopyVector(ste->spdf.tpdf,mv.tpdf);
-   } else {
-      mv.dpdf = CreateShortVec(hset->hmem,M);
-      CopyShortVec(ste->spdf.dpdf,mv.dpdf);
+      if ((MixWeight(hset,tme->weight)>MINMIX) || hset->msdflag[s])
+         tme->mpdf = CloneMixPDF(hset,sme->mpdf,sharing);
+      else 
+         tme->mpdf = NULL;
    }
-   return mv;
+
+   return tsti;
 }
 
 /* CloneState: return a clone of given State */
@@ -213,9 +271,7 @@ StateInfo *CloneState(HMMSet *hset, Stat
    tste = (StreamElem *)New(hset->hmem,S*sizeof(StreamElem));
    tsi->pdf = tste-1; sste = ssi->pdf + 1;
    for (s=1; s<=S; s++,tste++,sste++){
-      tste->nMix = sste->nMix; 
-      tste->hook = NULL;
-      tste->spdf = CloneStream(hset,sste,sharing);
+      tste->info = ClonePDF(hset,s,sste->info,sharing);
    }
    tsi->dur     = CloneSVector(hset->hmem,ssi->dur,sharing);
    tsi->weights = CloneSVector(hset->hmem,ssi->weights,sharing);
@@ -247,7 +303,7 @@ void NewHMMScan(HMMSet *hset, HMMScanSta
 {
    hss->hset = hset;
    hss->S = hset->swidth[0];
-   hss->isCont = (hset->hsKind == PLAINHS) || (hset->hsKind == SHAREDHS);
+   hss->isCont = ((hset->hsKind == PLAINHS) || (hset->hsKind == SHAREDHS)) ? TRUE : FALSE;
    hss->h = -1;
    hss->mac=NULL;
    if (!GoNextHMM(hss))
@@ -259,6 +315,7 @@ void EndHMMScan(HMMScanState *hss)
 {
    ClearSeenFlags(hss->hset,CLR_ALL);
    hss->hmm = NULL; hss->se = NULL; hss->ste = NULL; hss->me = NULL;
+   hss->si = NULL; hss->sti = NULL; hss->mp = NULL;
 }
 
 /* EXPORT->GoNextHMM: Move to next unseen HMM in HMM set */
@@ -267,22 +324,27 @@ Boolean GoNextHMM(HMMScanState *hss)
    int M;
    MLink mac;
 
-   mac = hss->mac ? hss->mac->next : NULL;
+   if (hss->mac!=NULL)
+      mac = hss->mac->next;
+   else
+      mac = NULL;
+
    if (mac==NULL) hss->h++;
    for (;hss->h<MACHASHSIZE;hss->h++)
       for (mac=((mac==NULL)?hss->hset->mtab[hss->h]:mac);
            mac!=NULL;mac=mac->next) {
-         if (mac->type == 'h') {
+         if (mac->type == 'h' && ((HLink)mac->structure)->numStates>1) {
             hss->mac = mac;
             hss->hmm = (HLink)mac->structure;
             hss->N = hss->hmm->numStates;
             hss->se = hss->hmm->svec+2; hss->i=2;
             hss->si = hss->se->info;
             hss->ste = hss->si->pdf+1; hss->s=1;
-            M = hss->ste->nMix;
+            hss->sti = hss->ste->info;
+            M = hss->sti->nMix;
             hss->M = (M<0)?-M:M; hss->m=1;
             if (hss->isCont){
-               hss->me = hss->ste->spdf.cpdf+1;
+               hss->me = hss->sti->spdf.cpdf+1;
                hss->mp = hss->me->mpdf;
             } else if  (hss->hset->hsKind == TIEDHS) {
                hss->mp = hss->hset->tmRecs[hss->s].mixes[hss->m];
@@ -316,10 +378,11 @@ Boolean GoNextState(HMMScanState *hss, B
       Touch(&hss->si->nUse);
       if (stepping){
          hss->ste = hss->si->pdf+1; hss->s=1;
-         M = hss->ste->nMix;
+         hss->sti=hss->ste->info;
+         M = hss->sti->nMix;
          hss->M = (M<0)?-M:M; hss->m=1;
          if (hss->isCont){
-            hss->me = hss->ste->spdf.cpdf+1;
+            hss->me = hss->sti->spdf.cpdf+1;
             hss->mp = hss->me->mpdf;
          } else if  (hss->hset->hsKind == TIEDHS) {
             hss->mp = hss->hset->tmRecs[hss->s].mixes[1];
@@ -332,15 +395,16 @@ Boolean GoNextState(HMMScanState *hss, B
    return FALSE;
 }
 
-/* EXPORT->GoNextStream: move to next unseen stream */
+/* EXPORT->GoNextStream: move to next unseen stream info */
 Boolean GoNextStream(HMMScanState *hss, Boolean noSkip)
 {
    Boolean stepping = FALSE, ok = TRUE;
    int M;
    
-   while (IsSeen(hss->ste->nMix) && ok){
+   while (IsSeen(hss->sti->nUse) && ok) {
       if (hss->s < hss->S) {
          ++hss->s; ++hss->ste; stepping = TRUE;
+         hss->sti = hss->ste->info;
       } else if (noSkip)
          return FALSE;
       else{
@@ -349,12 +413,12 @@ Boolean GoNextStream(HMMScanState *hss, 
       }
    }
    if (ok) {
-      Touch(&hss->ste->nMix);
+      Touch(&hss->sti->nUse);
       if (stepping) {
-         M = hss->ste->nMix;
+         M = hss->sti->nMix;
          hss->M = (M<0)?-M:M; hss->m=1;
          if (hss->isCont){
-            hss->me = hss->ste->spdf.cpdf+1;
+            hss->me = hss->sti->spdf.cpdf+1;
             hss->mp = hss->me->mpdf;
          } else if  (hss->hset->hsKind == TIEDHS) {
             hss->mp = hss->hset->tmRecs[hss->s].mixes[1];
@@ -425,10 +489,10 @@ void ConvDiagC(HMMSet *hset, Boolean con
          if (convData){
             v = hss.mp->cov.var;
             if (! IsSeenV(v)) {
-               for (k=1; k<=hset->swidth[hss.s]; k++) {
+               for (k=1; k<=VectorSize(v); k++) {
                   if (v[k] > MAXVAR) v[k] = MAXVAR;
                   if (v[k] < MINVAR) v[k] = MINVAR;
-                  v[k] = 1/v[k];
+                  v[k] = 1.0/v[k];
                }
                TouchV(v);
             }
@@ -455,10 +519,10 @@ void ForceDiagC(HMMSet *hset)
          hss.mp->ckind = DIAGC;
          v = hss.mp->cov.var;
          if (! IsSeenV(v)) {
-            for (k=1; k<=hset->swidth[hss.s]; k++) {
+            for (k=1; k<=VectorSize(hss.mp->mean); k++) {
                if (v[k] > MAXVAR) v[k] = MAXVAR;
                if (v[k] < MINVAR) v[k] = MINVAR;
-               v[k] = 1/v[k];
+               v[k] = 1.0/v[k];
             }
             TouchV(v);
          }
@@ -473,13 +537,16 @@ void ForceDiagC(HMMSet *hset)
 /* EXPORT->ConvLogWt Converts all mixture weights into log-weights. */
 void ConvLogWt(HMMSet *hset)
 {
+   int m;
    HMMScanState hss;
 
    if (hset->hsKind == DISCRETEHS || hset->hsKind == TIEDHS || hset->logWt == TRUE) 
       return;
    NewHMMScan(hset, &hss);
-   while (GoNextMix(&hss,FALSE))
-      hss.me->weight = MixLogWeight(hset,hss.me->weight);
+   while (GoNextStream(&hss,FALSE)) {
+      for (m=1;m<=hss.M;m++)
+         hss.sti->spdf.cpdf[m].weight = MixLogWeight(hset,hss.sti->spdf.cpdf[m].weight);
+   }
    EndHMMScan(&hss);
    hset->logWt = TRUE;
 }
@@ -487,13 +554,16 @@ void ConvLogWt(HMMSet *hset)
 /* EXPORT->ConvExpWt Converts all mixture log-weights into weights. */
 void ConvExpWt(HMMSet *hset)
 {
+   int m;
    HMMScanState hss;
 
    if (hset->hsKind == DISCRETEHS || hset->hsKind == TIEDHS  || hset->logWt == FALSE) 
       return;
    NewHMMScan(hset, &hss);
-   while (GoNextMix(&hss,FALSE))
-      hss.me->weight = exp(hss.me->weight);
+   while (GoNextStream(&hss,FALSE)) {
+      for (m=1;m<=hss.M;m++)
+         hss.sti->spdf.cpdf[m].weight = MixWeight(hset,hss.sti->spdf.cpdf[m].weight);
+   }
    EndHMMScan(&hss);
    hset->logWt = FALSE;
 }
@@ -508,6 +578,36 @@ char *HMMPhysName(HMMSet *hset,HLink hmm
    return(ml->id->name);
 }
 
+/* search hmm name from stream information */
+char *HMMPhysNameFromStreamInfo(HMMSet *hset, StreamInfo *sti, int *state, int *stream)
+{
+   HMMScanState hss;
+   char *name = NULL;
+
+   NewHMMScan(hset, &hss);
+   do {
+      while (GoNextState(&hss, TRUE)) {
+         while (GoNextStream(&hss, TRUE)) {
+            if (hss.sti == sti) {
+               name = HMMPhysName(hset, hss.hmm);
+               if(state)
+                  *state = hss.i;
+               if(stream)
+                  *stream = hss.s;
+               break;
+            }
+         }
+         if (name)
+            break;
+      }
+      if (name)
+         break;
+   } while (GoNextHMM(&hss));
+   EndHMMScan(&hss);
+
+   return name;
+}
+
 /* --------------------- Item List Handling -------------------- */
 
 /* 
@@ -614,9 +714,29 @@ void SetSet(IntSet s)
       s.set[i] = TRUE;
 }
 
-/* -------------------- Item List Parser -------------------- */
+/* DupSet: duplicate given set to newset*/
+void DupSet(IntSet oldSet, IntSet *newSet)
+{
+   int i;
+
+   *newSet = CreateSet(oldSet.nMembers);   
+   for (i=1;i<=oldSet.nMembers;i++) 
+      newSet->set[i] = oldSet.set[i];
+}
+
+/* CopySet: copy given set to newset*/
+void CopySet(IntSet oldSet, IntSet newSet)
+{
+   int i;
 
-#define PAT_LEN 1024
+   if (newSet.nMembers!=oldSet.nMembers)
+      HError(9999,"CopySet: numbers of members in old and new sets are different");
+   
+   for (i=1;i<=oldSet.nMembers;i++) 
+      newSet.set[i] = oldSet.set[i];
+}
+
+/* -------------------- Item List Parser -------------------- */
 
 static Source *source;         /* Current source for item list */
 static int ch;                 /* Current character from source */
@@ -822,6 +942,7 @@ static void PMix(ILink models, ILink *il
    int s,j,m;
    MixtureElem *me;
    StreamElem *ste;
+   StreamInfo *sti;
    enum {TMIX, TMEAN, TCOV} what;
    
    mixes = CreateSet(maxMixes);
@@ -847,11 +968,12 @@ static void PMix(ILink models, ILink *il
       for (j=2; j<hmm->numStates; j++) 
          if (IsMember(states,j)) {
             ste = hmm->svec[j].info->pdf+1;
-            for (s=1; s<=hset->swidth[0]; s++,ste++)
+            for (s=1; s<=hset->swidth[0]; s++,ste++) {
+               sti = ste->info;
                if (IsMember(streams,s)) {
-                  me = ste->spdf.cpdf+1;
-                  for (m=1; m<=ste->nMix; m++,me++) 
-                     if ((MixWeight(hset,me->weight) > MINMIX) && IsMember(mixes,m)) {
+                  me = sti->spdf.cpdf+1;
+                  for (m=1; m<=sti->nMix; m++,me++) 
+                     if ((hset->msdflag[s] || MixWeight(hset,me->weight)>MINMIX) && IsMember(mixes,m)) {
                         switch (what) {
                         case TMIX: /* tie ->mpdf */
                            if (trace & T_ITM)
@@ -887,38 +1009,59 @@ static void PMix(ILink models, ILink *il
                }
          }
    }
+   }
    FreeSet(mixes);
 }
 
 /* PStatecomp: parse a statecomp */
 static void PStatecomp(ILink models, ILink *ilist, char *type, 
-                       IntSet states, HMMSet *hset)
+                       IntSet states, IntSet *streams, HMMSet *hset)
 {
    HMMDef *hmm;
    ILink h;
    int s,j;
-   IntSet streams;
    Keyword kw;
+   IntSet str;
    
    switch(kw=GetKey()) {
    case MIX_KEY:
+      if (hset->hsKind==TIEDHS || hset->hsKind==DISCRETEHS)
+         HError(7231,"PStatecomp: Cannot specify streams or mixes unless continuous");
+      str = CreateSet(SMAX);
+      SetSet(str);
+      SkipSpaces();
+      if (ch == '[')
+         PMix(models,ilist,type,states,str,hset);
+      else {
+         ChkType('p',type);
+         for (h=models; h!=NULL; h=h->next) {
+            hmm = h->owner;
+            for (j=2; j<hmm->numStates; j++)
+            if (IsMember(states,j))
+               for (s=1; s<=hset->swidth[0];s++)
+                  if (IsMember(str,s)) { /* tie -> spdf */
+                     if (trace & T_ITM)
+                        printf(" %12s.state[%d].stream[%d]\n",
+                               HMMPhysName(hset,hmm),j,s);
+                        AddItem(hmm,hmm->svec[j].info->pdf+s,ilist);
+                  }
+         }
+      }
+      FreeSet(str);
+      break;
    case STREAM_KEY:
       if (hset->hsKind==TIEDHS || hset->hsKind==DISCRETEHS)
          HError(7231,"PStatecomp: Cannot specify streams or mixes unless continuous");
-      streams = CreateSet(SMAX);
-      if(kw==STREAM_KEY) {
-         PIndex(streams);
+         str = CreateSet(SMAX);
+         PIndex(str);
          SkipSpaces();
-         if (ch != '.')
-            EdError(". expected after stream spec");
+         if (ch == '.') {
          ReadCh();
          if (GetKey() != MIX_KEY)
-            EdError("Mix expected after Stream index");
-      } else 
-         AddMember(streams,1);
+            EdError("Mix expected");
       SkipSpaces();
       if (ch=='[')
-         PMix(models,ilist,type,states,streams,hset);
+         PMix(models,ilist,type,states,str,hset);
       else {
          ChkType('p',type);
          for (h=models; h!=NULL; h=h->next) {
@@ -926,7 +1069,7 @@ static void PStatecomp(ILink models, ILi
             for (j=2; j<hmm->numStates; j++)
                if (IsMember(states,j))    
                   for (s=1; s<=hset->swidth[0];s++)   
-                     if (IsMember(streams,s)) { /* tie -> spdf */
+                     if (IsMember(str,s)) { /* tie -> spdf */
                         if (trace & T_ITM)
                            printf(" %12s.state[%d].stream[%d]\n",
                                   HMMPhysName(hset,hmm),j,s);
@@ -934,7 +1077,31 @@ static void PStatecomp(ILink models, ILi
                      }
          }
       }
-      FreeSet(streams);
+	 }
+	 else {
+         ChkType('p',type);
+         for (h=models; h!=NULL; h=h->next) {
+            hmm = h->owner;
+            for (j=2; j<hmm->numStates; j++)
+               if (IsMember(states,j)) {
+                  if (streams!=NULL) {        /* for Tree-based Clustering */
+                     AddItem(hmm,hmm->svec+j,ilist);
+                  }
+                  else
+                     for (s=1; s<=hset->swidth[0];s++)   
+                        if (IsMember(str,s)) { /* tie -> spdf */
+                           if (trace & T_ITM)
+                              printf(" %12s.state[%d].stream[%d]\n",
+                                     HMMPhysName(hset,hmm),j,s);
+                           AddItem(hmm,hmm->svec[j].info->pdf+s,ilist);
+                        }
+               }
+         }
+	 }
+      if (streams != NULL)
+         for (s=1;s<=SMAX;s++)
+            streams->set[s] = str.set[s];
+      FreeSet(str);
       break;
    case DUR_KEY:
       ChkType('d',type);
@@ -968,7 +1135,7 @@ static void PStatecomp(ILink models, ILi
 }
 
 /* PState: parse state and add all matches in models to ilist */
-static void PState(ILink models, ILink *ilist, char *type, HMMSet *hset)
+static void PState(ILink models, ILink *ilist, char *type, IntSet *streams, HMMSet *hset)
 {
    IntSet states;
    int j;
@@ -980,7 +1147,7 @@ static void PState(ILink models, ILink *
    SkipSpaces();
    if (ch == '.') {
       ReadCh();
-      PStatecomp(models,ilist,type,states,hset);
+      PStatecomp(models,ilist,type,states,streams,hset);
    } else {
       ChkType('s',type);
       for (h=models; h!=NULL; h=h->next) {
@@ -1011,7 +1178,7 @@ static void PHIdent(ILink *models, HMMSe
    GetAlpha(pattern);
    p = pattern; h=0;
    while ((*p != '\0') && (h<MAXSTRLEN) && (fullName)) {
-     if ((*p=='*')||(*p=='?')||(*p=='%')) fullName=FALSE;
+     if ((*p=='*')||(*p=='?')) fullName=FALSE;
      h++; 
      p = pattern+h;
    }
@@ -1064,11 +1231,14 @@ static void PHName(ILink *models,HMMSet 
 }
 
 /* PItemSet: parse and item set appending items to ilist */
-static void PItemSet(ILink *ilist, char *type, HMMSet *hset)
+static void PItemSet(ILink *ilist, char *type, IntSet *streams, HMMSet *hset)
 {
    ILink models = NULL;         /* list of hmms in item set */
    ILink p;
    
+   if (ch == '}')   /* no list is specified */
+      return;
+   
    PHName(&models,hset);        /* parse hname and get list of models */
    SkipSpaces();
    if (ch == '.') {             /* look for subcomponents */
@@ -1078,7 +1248,7 @@ static void PItemSet(ILink *ilist, char 
          AddTransP(models,ilist,type); 
          break;
       case STATE_KEY:  
-         PState(models,ilist,type,hset);
+         PState(models,ilist,type,streams,hset);
          break;
       default: 
          EdError("State or TransP expected");
@@ -1097,8 +1267,8 @@ static void PItemSet(ILink *ilist, char 
 }
 
 /* EXPORT->PItemList: parse items in item list setting ilist and type */
-char *PItemList(ILink *ilist, char *type, HMMSet *hset,
-                Source *s, Boolean itrace)
+char *PItemList (ILink *ilist, char *type, HMMSet *hset, Source *s, IntSet *streams, 
+                 const int maxM, const int maxS, const Boolean itrace)
 {
    int rtrace;
 
@@ -1107,22 +1277,23 @@ char *PItemList(ILink *ilist, char *type
    if (itrace)
       trace|=T_ITM;
    source = s;
-   maxMixes = MaxMixInSet(hset);
-   maxStates = MaxStatesInSet(hset);
+   maxMixes  = (maxM==0) ? MaxMixInSet(hset)    : maxM;
+   maxStates = (maxS==0) ? MaxStatesInSet(hset) : maxS;
    position=pattern;
+   ch=GetCh(source);
+   while (isspace(ch)) ch=GetCh(source);
+   *position++=ch;
    *position=0;
 
    /* Parse item set */
-   ReadCh();
-   SkipSpaces();
    if (ch != '{')
       EdError("{ expected");
    ReadCh();
-   PItemSet(ilist,type,hset);
+   PItemSet(ilist,type,streams,hset);
    SkipSpaces();
    while (ch == ',') {
       ReadCh();
-      PItemSet(ilist,type,hset);
+      PItemSet(ilist,type,streams,hset);
       SkipSpaces();
    }
    if (ch != '}')
@@ -1148,6 +1319,8 @@ Ptr GetMacroHook(MLink ml)
       hook=((HLink)(ml->structure))->hook; break;
    case 's': /* StateInfo * */
       hook=((StateInfo *)(ml->structure))->hook; break;
+   case 'p': /* StreamInfo * */
+      hook=((StreamInfo *)(ml->structure))->hook; break;
    case 'm': /* MixPDF * */
       hook=((MixPDF *)(ml->structure))->hook; break;
    case 'c': /* STriMat */
@@ -1178,6 +1351,8 @@ void SetMacroHook(MLink ml,Ptr hook)
       ((HLink)(ml->structure))->hook=hook; break;
    case 's': /* StateInfo * */
       ((StateInfo *)(ml->structure))->hook=hook; break;
+   case 'p': /* StreamInfo * */
+      ((StreamInfo *)(ml->structure))->hook=hook; break;
    case 'm': /* MixPDF * */
       ((MixPDF *)(ml->structure))->hook=hook; break;
    case 'c': /* STriMat */
@@ -1213,6 +1388,8 @@ int GetMacroUse(MLink ml)
       use=((HLink)(ml->structure))->nUse; break;
    case 's': /* StateInfo * */
       use=((StateInfo *)(ml->structure))->nUse; break;
+   case 'p': /* StreamInfo * */
+      use=((StreamInfo *)(ml->structure))->nUse; break;
    case 'm': /* MixPDF * */
       use=((MixPDF *)(ml->structure))->nUse; break;
    case 'j': /* InputXForm * */
@@ -1247,6 +1424,8 @@ void SetMacroUse(MLink ml,int use)
       ((HLink)(ml->structure))->nUse=use; break;
    case 's': /* StateInfo * */
       ((StateInfo *)(ml->structure))->nUse=use; break;
+   case 'p': /* StreamInfo * */
+      ((StreamInfo *)(ml->structure))->nUse=use; break;
    case 'm': /* MixPDF * */
       ((MixPDF *)(ml->structure))->nUse=use; break;
    case 'j': /* InputXForm * */
@@ -1291,9 +1470,9 @@ void ResetHooks(HMMSet *hset,char *what)
 void LoadStatsFile(char *statfile,HMMSet *hset,Boolean otrace)
 {
    Source src;
-   char hname[256];
-   int i,idx,count,N,lnum = 0;
-   float x;
+   char hname[MAXSTRLEN];
+   int i,s,idx,count,N,lnum = 0;
+   float x,tmp;
    HMMDef *hmm;
    MLink ml;
    LabId hmmId;
@@ -1326,6 +1505,16 @@ void LoadStatsFile(char *statfile,HMMSet
          si = hmm->svec[i].info;
          si->stateCounter = count;/* load the # of times the state occurred */
          memcpy(&(si->hook),&x,sizeof(float)); /* !! */
+         
+         for (s=1; s<=hset->swidth[0]; s++) {
+            if (si->pdf[s].info->hook==NULL)
+               tmp = 0.0;
+            else
+               memcpy(&tmp,&(si->pdf[s].info->hook),sizeof(float));
+            tmp += x;
+            memcpy(&(si->pdf[s].info->hook),&tmp,sizeof(float));
+         }
+         
          occSum += x; ++occN;
       }
    }
@@ -1337,4 +1526,124 @@ void LoadStatsFile(char *statfile,HMMSet
    }
 }
 
-/* ---------------------------- End of HUtil.c --------------------------- */
+/* ------------------- Configuration File Parsing  --------------------- */
+
+/* EXPORT->ParseConfIntVec: interpret config string as integer array */
+IntVec ParseConfIntVec (MemHeap *x, char *inbuf, Boolean residual)
+{
+   IntVec ivec = NULL;
+   int size,cnt;
+   char buf[MAXSTRLEN],tbuf[MAXSTRLEN];
+
+   if ((inbuf=ParseString(inbuf,buf))>0) {
+      if (strcmp(buf,"IntVec") != 0)
+         HError(999,"ParseConfIntVec: format is 'IntVec n i1 i2 ... in'");
+      sscanf(inbuf,"%d",&size);
+      inbuf=ParseString(inbuf,tbuf);
+      ivec = CreateIntVec(x,size);
+      cnt = 1;
+      while ((strlen(inbuf)>0) && (cnt<=size) &&
+             (sscanf(inbuf,"%d",&(ivec[cnt])))) {
+         inbuf=ParseString(inbuf,tbuf);
+         cnt++;
+      }
+      if (residual && strlen(inbuf)>0)
+         HError(999,"ParseConfIntVec: residual elements - format is  n i1 ... in");
+   } else
+      HError(999,"ParseConfIntVec: format is  n i1 ... in");
+   return ivec;
+}
+
+/* EXPORT->ParseConfVector: interpret config string as float array */
+Vector ParseConfVector (MemHeap *x, char *inbuf, Boolean residual)
+{
+   Vector vec = NULL;
+   int size,cnt;
+   char buf[MAXSTRLEN],tbuf[MAXSTRLEN];
+
+   if ((inbuf=ParseString(inbuf,buf))>0) {
+      if (strcmp(buf,"Vector") != 0)
+         HError(999,"ParseConfVector: format is 'Vector n f1 f2 ... fn'");
+      sscanf(inbuf,"%d",&size);
+      inbuf=ParseString(inbuf,tbuf);
+      vec = CreateVector(x,size);
+      cnt = 1;
+      while ((strlen(inbuf)>0) && (cnt<=size) &&
+             (sscanf(inbuf,"%f",&(vec[cnt])))) {
+         inbuf=ParseString(inbuf,tbuf);
+         cnt++;
+      }
+      if (residual && strlen(inbuf)>0)
+         HError(999,"ParseConfVector: residual elements - format is  n f1 ... fn");
+   } else
+      HError(999,"ParseConfVector: format is  n f1 ... fn");
+   return vec;
+}
+
+/* EXPORT->ParseConfStrVec: interpret config string as string array */
+char **ParseConfStrVec (MemHeap *x, char *inbuf, Boolean residual)
+{
+   char **str=NULL;
+   int size,cnt;
+   char buf[MAXSTRLEN],tbuf[MAXSTRLEN];
+
+   if ((inbuf=ParseString(inbuf,buf))>0) {
+      if (strcmp(buf,"StrVec") != 0)
+         HError(999,"ParseConfStrVec: format is 'StrVec n s1 s2 ... sn'");
+      sscanf(inbuf,"%d",&size);
+      inbuf=ParseString(inbuf,tbuf);
+
+      str = (char **) New(x, (size+1)*sizeof(char *));
+      str[0] = (char *) New(x, sizeof(char));
+      str[0][0] = (char) size;  /* size should be within char range */
+      for (cnt=1; cnt<=size; cnt++)
+         str[cnt] = (char *) New(x, MAXSTRLEN*sizeof(char));
+
+      cnt = 1;
+      while ((strlen(inbuf)>0) && (cnt<=size) &&
+             (inbuf=ParseString(inbuf,str[cnt]))) {
+         cnt++;
+      }
+      if (residual && strlen(inbuf)>0)
+         HError(999,"ParseConfStrVec: residual elements - format is  n s1 ... sn");
+   } else
+      HError(999,"ParseConfStrVec: format is  n s1 ... sn");
+
+   return str;
+}
+
+/* EXPORT->ParseConfBoolVec: interpret config string as Boolean array */
+Boolean *ParseConfBoolVec (MemHeap *x, char *inbuf, Boolean residual)
+{
+   Boolean *vec=NULL;
+   int size,cnt;
+   char buf[MAXSTRLEN],tbuf[MAXSTRLEN];
+
+   if ((inbuf=ParseString(inbuf,buf))>0) {
+      if (strcmp(buf,"BoolVec") != 0)
+         HError(999,"ParseConfBoolVec: format is 'BoolVec n f1 f2 ... fn'");
+      sscanf(inbuf,"%d",&size);
+      inbuf=ParseString(inbuf,tbuf);
+      vec = (Boolean *) New(x,size*sizeof(Boolean));
+      cnt = 1;
+      while ((strlen(inbuf)>0) && (cnt<=size) && (sscanf(inbuf,"%s",buf))) {
+         /* parse input as Boolean value */
+         if (strcmp(buf,"T")==0 || strcmp(buf,"TRUE")==0)
+            vec[cnt] = TRUE;
+         else if (strcmp(buf,"F")==0 || strcmp(buf,"FALSE")==0)
+            vec[cnt] = FALSE;
+         else
+            HError(9999,"ParseConfBoolVec: %s is not a Boolean value", buf);
+
+         inbuf=ParseString(inbuf,tbuf);
+         cnt++;
+      }
+      if (residual && strlen(inbuf)>0)
+         HError(999,"ParseConfBoolVec: residual elements - format is  n f1 ... fn");
+   } else
+      HError(999,"ParseConfBoolVec: format is  n f1 ... fn");
+
+   return vec;
+}
+
+/* ------------------------ End of HUtil.c ------------------------- */
diff -pbBEwurNa --ignore-matching-lines='.*vc_id.*' HTK-3.4.1/HTKLib/HUtil.h HTS-2.2_for_HTK-3.4.1/HTKLib/HUtil.h
--- HTK-3.4.1/HTKLib/HUtil.h	2009-03-13 03:49:16.000000000 +0900
+++ HTS-2.2_for_HTK-3.4.1/HTKLib/HUtil.h	2011-06-16 13:18:29.000000000 +0900
@@ -19,6 +19,51 @@
 /*         File: HUtil.h      HMM utility routines             */
 /* ----------------------------------------------------------- */
 
+/*  *** THIS IS A MODIFIED VERSION OF HTK ***                        */
+/* ----------------------------------------------------------------- */
+/*           The HMM-Based Speech Synthesis System (HTS)             */
+/*           developed by HTS Working Group                          */
+/*           http://hts.sp.nitech.ac.jp/                             */
+/* ----------------------------------------------------------------- */
+/*                                                                   */
+/*  Copyright (c) 2001-2011  Nagoya Institute of Technology          */
+/*                           Department of Computer Science          */
+/*                                                                   */
+/*                2001-2008  Tokyo Institute of Technology           */
+/*                           Interdisciplinary Graduate School of    */
+/*                           Science and Engineering                 */
+/*                                                                   */
+/* All rights reserved.                                              */
+/*                                                                   */
+/* Redistribution and use in source and binary forms, with or        */
+/* without modification, are permitted provided that the following   */
+/* conditions are met:                                               */
+/*                                                                   */
+/* - Redistributions of source code must retain the above copyright  */
+/*   notice, this list of conditions and the following disclaimer.   */
+/* - Redistributions in binary form must reproduce the above         */
+/*   copyright notice, this list of conditions and the following     */
+/*   disclaimer in the documentation and/or other materials provided */
+/*   with the distribution.                                          */
+/* - Neither the name of the HTS working group nor the names of its  */
+/*   contributors may be used to endorse or promote products derived */
+/*   from this software without specific prior written permission.   */
+/*                                                                   */
+/* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND            */
+/* CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,       */
+/* INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF          */
+/* MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE          */
+/* DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS */
+/* BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,          */
+/* EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED   */
+/* TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,     */
+/* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON */
+/* ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,   */
+/* OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY    */
+/* OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE           */
+/* POSSIBILITY OF SUCH DAMAGE.                                       */
+/* ----------------------------------------------------------------- */
+
 /* !HVER!HUtil:   3.4.1 [CUED 12/03/09] */
 
 #ifndef _HUTIL_H_
@@ -41,6 +86,7 @@ typedef struct{   /* HMMSet Scan State *
    int S;            /* num Streams = hset->swidth[0] */
    int s;            /* current stream index 1..S */
    StreamElem *ste;  /* ->current streamElem */
+   StreamInfo *sti;  /* ->current streamInfo */
    int M;            /* num mixtures */
    int m;            /* current mixture index 1..M */
    /* ------ continuous case only ------------ */
@@ -54,8 +100,13 @@ void InitUtil(void);
    Initialise the module
 */
 
+void ResetUtil (void);
+/*
+   Reset the module
+*/
+
 /* EXPORT->ResetUtilItemList: frees all the memory from the ItelList heap */
-void ResetUtilItemList();
+void ResetUtilItemList(void);
 
 /* EXPORT->SetParsePhysicalHMM: only parse physical HMMs */
 void SetParsePhysicalHMM(Boolean parse);
@@ -67,7 +118,7 @@ SMatrix CloneSMatrix(MemHeap *hmem, SMat
 STriMat CloneSTriMat(MemHeap *hmem, STriMat s, Boolean sharing);
 
 MixPDF *CloneMixPDF(HMMSet *hset, MixPDF *s, Boolean sharing);
-MixtureVector CloneStream(HMMSet *hset, StreamElem *ste, Boolean sharing);
+StreamInfo *ClonePDF(HMMSet *hset, int s, StreamInfo *sti, Boolean sharing);
 StateInfo *CloneState(HMMSet *hset, StateInfo *ssi, Boolean sharing);
 
 void CloneHMM(HLink src, HLink tgt, Boolean sharing);
@@ -162,6 +213,12 @@ char *HMMPhysName(HMMSet *hset,HLink hmm
    Aborts if model does not exist.
 */
 
+char *HMMPhysNameFromStreamInfo(HMMSet *hset, StreamInfo *sti, int *state, int *stream);
+/*
+   Return name, state index, and stream index of given StreamInfo from HMMSet.
+   Return NULL if it does not exist.
+*/
+
 /* --------------------- Item List Handling -------------------- */
 
 /* 
@@ -203,6 +260,8 @@ Boolean IsMember(IntSet s, int x);
 Boolean IsFullSet(IntSet s);
 void ClearSet(IntSet s);
 void SetSet(IntSet s);
+void DupSet(IntSet oldSet, IntSet *newSet);
+void CopySet(IntSet oldSet, IntSet newSet);
 
 /*
    Functions to set and clear IntSet members flags
@@ -239,8 +298,8 @@ void SetSet(IntSet s);
    
 */
 
-char *PItemList(ILink *ilist, char *type, HMMSet *h,
-		Source *s, Boolean itrace);
+char *PItemList(ILink *ilist, char *type, HMMSet *h, Source *s, IntSet *streams, 
+                const int maxM, const int maxS, const Boolean itrace);
 
 /* 
    Parse source s and convert into itemlist ilist and type holding
@@ -272,10 +331,21 @@ void LoadStatsFile(char *statfile,HMMSet
    Load the statistics file output by HERest into state hooks
 */
 
+/* ------------------- Configuration File Parsing  --------------------- */
+
+/*
+   Functions to provide arbitrary vector parsers for configuration file
+*/
+
+IntVec ParseConfIntVec(MemHeap *x, char *inbuf, Boolean residual);
+Vector ParseConfVector(MemHeap *x, char *inbuf, Boolean residual);
+char **ParseConfStrVec(MemHeap *x, char *inbuf, Boolean residual);
+Boolean *ParseConfBoolVec(MemHeap *x, char *inbuf, Boolean residual);
+
 #ifdef __cplusplus
 }
 #endif
 
 #endif  /* _HUTIL_H_ */
 
-/* ------------------------- End of HUtil.h --------------------------- */
+/* ------------------------ End of HUtil.h ------------------------- */
diff -pbBEwurNa --ignore-matching-lines='.*vc_id.*' HTK-3.4.1/HTKLib/HVQ.c HTS-2.2_for_HTK-3.4.1/HTKLib/HVQ.c
--- HTK-3.4.1/HTKLib/HVQ.c	2009-03-13 03:49:26.000000000 +0900
+++ HTS-2.2_for_HTK-3.4.1/HTKLib/HVQ.c	2011-06-16 13:18:29.000000000 +0900
@@ -19,8 +19,53 @@
 /*         File: HVQ.c:   Vector Quantisation                  */
 /* ----------------------------------------------------------- */
 
+/*  *** THIS IS A MODIFIED VERSION OF HTK ***                        */
+/* ----------------------------------------------------------------- */
+/*           The HMM-Based Speech Synthesis System (HTS)             */
+/*           developed by HTS Working Group                          */
+/*           http://hts.sp.nitech.ac.jp/                             */
+/* ----------------------------------------------------------------- */
+/*                                                                   */
+/*  Copyright (c) 2001-2011  Nagoya Institute of Technology          */
+/*                           Department of Computer Science          */
+/*                                                                   */
+/*                2001-2008  Tokyo Institute of Technology           */
+/*                           Interdisciplinary Graduate School of    */
+/*                           Science and Engineering                 */
+/*                                                                   */
+/* All rights reserved.                                              */
+/*                                                                   */
+/* Redistribution and use in source and binary forms, with or        */
+/* without modification, are permitted provided that the following   */
+/* conditions are met:                                               */
+/*                                                                   */
+/* - Redistributions of source code must retain the above copyright  */
+/*   notice, this list of conditions and the following disclaimer.   */
+/* - Redistributions in binary form must reproduce the above         */
+/*   copyright notice, this list of conditions and the following     */
+/*   disclaimer in the documentation and/or other materials provided */
+/*   with the distribution.                                          */
+/* - Neither the name of the HTS working group nor the names of its  */
+/*   contributors may be used to endorse or promote products derived */
+/*   from this software without specific prior written permission.   */
+/*                                                                   */
+/* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND            */
+/* CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,       */
+/* INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF          */
+/* MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE          */
+/* DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS */
+/* BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,          */
+/* EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED   */
+/* TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,     */
+/* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON */
+/* ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,   */
+/* OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY    */
+/* OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE           */
+/* POSSIBILITY OF SUCH DAMAGE.                                       */
+/* ----------------------------------------------------------------- */
+
 char *hvq_version = "!HVER!HVQ:   3.4.1 [CUED 12/03/09]";
-char *hvq_vc_id = "$Id: HVQ.c,v 1.1.1.1 2006/10/11 09:54:59 jal58 Exp $";
+char *hvq_vc_id = "$Id: HVQ.c,v 1.8 2011/06/16 04:18:29 uratec Exp $";
 
 #include "HShell.h"
 #include "HMem.h"
@@ -54,6 +99,14 @@ void InitVQ(void)
    CreateHeap(&vqHeap,"vqHeap",MSTAK,1,0.2,2000,10000);
 }
 
+/* EXPORT->ResetVQ: reset a heap created in InitVQ */
+void ResetVQ (void)
+{
+   ResetHeap(&vqHeap);
+   
+   return;
+}
+
 /* CKCheck: check that ck is one of NULLC,INVDIAGC or FULLC */
 static CovKind CKCheck(CovKind ck)
 {
@@ -494,4 +547,4 @@ void GetVQ(VQTable vqTab, int numS, Vect
    }
 }
 
-/* ------------------------------  HVQ.c ----------------------------- */
+/* ------------------------ End of HVQ.c --------------------------- */
diff -pbBEwurNa --ignore-matching-lines='.*vc_id.*' HTK-3.4.1/HTKLib/HVQ.h HTS-2.2_for_HTK-3.4.1/HTKLib/HVQ.h
--- HTK-3.4.1/HTKLib/HVQ.h	2009-03-13 03:49:35.000000000 +0900
+++ HTS-2.2_for_HTK-3.4.1/HTKLib/HVQ.h	2011-06-16 13:18:29.000000000 +0900
@@ -19,6 +19,51 @@
 /*              File: HVQ.h: Vector Quantisation               */
 /* ----------------------------------------------------------- */
 
+/*  *** THIS IS A MODIFIED VERSION OF HTK ***                        */
+/* ----------------------------------------------------------------- */
+/*           The HMM-Based Speech Synthesis System (HTS)             */
+/*           developed by HTS Working Group                          */
+/*           http://hts.sp.nitech.ac.jp/                             */
+/* ----------------------------------------------------------------- */
+/*                                                                   */
+/*  Copyright (c) 2001-2011  Nagoya Institute of Technology          */
+/*                           Department of Computer Science          */
+/*                                                                   */
+/*                2001-2008  Tokyo Institute of Technology           */
+/*                           Interdisciplinary Graduate School of    */
+/*                           Science and Engineering                 */
+/*                                                                   */
+/* All rights reserved.                                              */
+/*                                                                   */
+/* Redistribution and use in source and binary forms, with or        */
+/* without modification, are permitted provided that the following   */
+/* conditions are met:                                               */
+/*                                                                   */
+/* - Redistributions of source code must retain the above copyright  */
+/*   notice, this list of conditions and the following disclaimer.   */
+/* - Redistributions in binary form must reproduce the above         */
+/*   copyright notice, this list of conditions and the following     */
+/*   disclaimer in the documentation and/or other materials provided */
+/*   with the distribution.                                          */
+/* - Neither the name of the HTS working group nor the names of its  */
+/*   contributors may be used to endorse or promote products derived */
+/*   from this software without specific prior written permission.   */
+/*                                                                   */
+/* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND            */
+/* CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,       */
+/* INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF          */
+/* MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE          */
+/* DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS */
+/* BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,          */
+/* EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED   */
+/* TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,     */
+/* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON */
+/* ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,   */
+/* OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY    */
+/* OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE           */
+/* POSSIBILITY OF SUCH DAMAGE.                                       */
+/* ----------------------------------------------------------------- */
+
 /* !HVER!HVQ:   3.4.1 [CUED 12/03/09] */
 
 /*
@@ -86,6 +131,11 @@ void InitVQ(void);
    Initialise module
 */
 
+void ResetVQ(void);
+/*
+   Reset module 
+*/
+
 VQTable CreateVQTab(char *tabFN, short magic, TreeType type,
                     CovKind ck, short *swidth);
 /*
@@ -138,4 +188,4 @@ void GetVQ(VQTable vqTab, int numS, Vect
 
 #endif  /* _HVQ_H_ */
 
-/* ------------------------ End of HVQ.h ----------------------- */
+/* ------------------------ End of HVQ.h --------------------------- */
diff -pbBEwurNa --ignore-matching-lines='.*vc_id.*' HTK-3.4.1/HTKLib/HWave.c HTS-2.2_for_HTK-3.4.1/HTKLib/HWave.c
--- HTK-3.4.1/HTKLib/HWave.c	2009-03-13 03:49:46.000000000 +0900
+++ HTS-2.2_for_HTK-3.4.1/HTKLib/HWave.c	2011-06-16 13:18:29.000000000 +0900
@@ -32,8 +32,53 @@
 /*         File: HWave.c:   Speech Wave File Input/Output      */
 /* ----------------------------------------------------------- */
 
+/*  *** THIS IS A MODIFIED VERSION OF HTK ***                        */
+/* ----------------------------------------------------------------- */
+/*           The HMM-Based Speech Synthesis System (HTS)             */
+/*           developed by HTS Working Group                          */
+/*           http://hts.sp.nitech.ac.jp/                             */
+/* ----------------------------------------------------------------- */
+/*                                                                   */
+/*  Copyright (c) 2001-2011  Nagoya Institute of Technology          */
+/*                           Department of Computer Science          */
+/*                                                                   */
+/*                2001-2008  Tokyo Institute of Technology           */
+/*                           Interdisciplinary Graduate School of    */
+/*                           Science and Engineering                 */
+/*                                                                   */
+/* All rights reserved.                                              */
+/*                                                                   */
+/* Redistribution and use in source and binary forms, with or        */
+/* without modification, are permitted provided that the following   */
+/* conditions are met:                                               */
+/*                                                                   */
+/* - Redistributions of source code must retain the above copyright  */
+/*   notice, this list of conditions and the following disclaimer.   */
+/* - Redistributions in binary form must reproduce the above         */
+/*   copyright notice, this list of conditions and the following     */
+/*   disclaimer in the documentation and/or other materials provided */
+/*   with the distribution.                                          */
+/* - Neither the name of the HTS working group nor the names of its  */
+/*   contributors may be used to endorse or promote products derived */
+/*   from this software without specific prior written permission.   */
+/*                                                                   */
+/* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND            */
+/* CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,       */
+/* INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF          */
+/* MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE          */
+/* DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS */
+/* BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,          */
+/* EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED   */
+/* TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,     */
+/* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON */
+/* ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,   */
+/* OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY    */
+/* OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE           */
+/* POSSIBILITY OF SUCH DAMAGE.                                       */
+/* ----------------------------------------------------------------- */
+
 char *hwave_version = "!HVER!HWave:   3.4.1 [CUED 12/03/09]";
-char *hwave_vc_id = "$Id: HWave.c,v 1.1.1.1 2006/10/11 09:54:59 jal58 Exp $";
+char *hwave_vc_id = "$Id: HWave.c,v 1.11 2011/06/16 04:18:29 uratec Exp $";
 
 #include "HShell.h"
 #include "HMem.h"
@@ -145,6 +190,12 @@ void InitWave(void)
    }
 }
 
+/* EXPORT->RestWave: reset module */
+void ResetWave(void)
+{
+   return;  /* do nothing */
+}
+
 /* --------------- Wave Record Memory Management ---------------- */
 
 /* CreateWave: create a wave object with given parameters */
@@ -197,10 +248,13 @@ static Boolean MustSwap(SrcOrder so)
    char bos[MAXSTRLEN];
    
    if (GetConfStr(cParm,numParm,"BYTEORDER",bos)) { /* force required order */
-      return (strcmp(bos,"VAX") == 0) ? !vaxOrder : vaxOrder;
+      if (strcmp(bos,"VAX")==0)
+         return((vaxOrder) ? FALSE : TRUE);
+      else
+         return(vaxOrder);
    } else
       switch(so) {
-      case VAXSO:     return !vaxOrder;
+      case VAXSO:     return ((vaxOrder) ? FALSE : TRUE);
       case SUNSO:     return vaxOrder;
       case UNKNOWNSO: return FALSE;
       }
@@ -579,7 +633,7 @@ static void NISTSkipLine(FILE *f)
 /* GetNISTIVal: get int val from f (indicated by -i) */
 static int GetNISTIVal(FILE *f)
 {
-   char buf[100];
+   char buf[MAXSTRLEN];
    
    if (strcmp(GetNISTToken(f,buf),"-i") != 0)
       HError(6251,"GetNISTIVal: NIST type indicator -i expected");
@@ -589,7 +643,7 @@ static int GetNISTIVal(FILE *f)
 /* GetNISTSVal: get string of lenth n into s (indicated by -sn) */
 static void GetNISTSVal(FILE *f, char *s)
 {
-   char buf[100];
+   char buf[MAXSTRLEN];
 
    GetNISTToken(f,buf);
    if (buf[0] != '-' || buf[1] != 's')
@@ -602,7 +656,7 @@ static void GetNISTSVal(FILE *f, char *s
 /* GetNISTHeaderInfo: get the NIST Header info */
 static long GetNISTHeaderInfo(FILE *f, Wave w, InputAction *ia)
 {
-   char token[100],*lab,byteFormat[100],sampCoding[100],buf[100];
+   char token[MAXSTRLEN],*lab,byteFormat[MAXSTRLEN],sampCoding[MAXSTRLEN],buf[MAXSTRLEN];
    Boolean interleaved = FALSE;
    long nS,sR,sS, cC;
    long dataBytes;
@@ -736,7 +790,7 @@ static int GetShortPackBlock(char **inDa
          buf = *(in++);
          numChar++;
       }
-      negative = buf & bitValue[7-charBits];
+      negative = (buf & bitValue[7-charBits]) ? TRUE : FALSE;
       charBits = (charBits+1)%8;
       k = nBits;
       while (k > 0) {
@@ -1003,6 +1057,8 @@ static long GetAIFFHeaderInfo(FILE *f, W
    const long ccid = 0x434f4d4d;  /* 'COMM' */
    const long scid = 0x53534e44;  /* 'SSND' */
    
+   commchunk2.nSamples = 0;  /* to avoid gcc4 warning */
+
    if (w->isPipe){
       HRError(6201,"GetAIFFHeaderInfo: cannot pipe an AIFF file");
       return -1;
@@ -1795,4 +1851,4 @@ ReturnStatus CloseWaveOutput(Wave w, Fil
    return(SUCCESS);
 }
 
-/* --------------------------------  HWave.c ------------------------------- */
+/* ------------------------ End of HWave.c ------------------------- */
diff -pbBEwurNa --ignore-matching-lines='.*vc_id.*' HTK-3.4.1/HTKLib/HWave.h HTS-2.2_for_HTK-3.4.1/HTKLib/HWave.h
--- HTK-3.4.1/HTKLib/HWave.h	2009-03-13 03:49:58.000000000 +0900
+++ HTS-2.2_for_HTK-3.4.1/HTKLib/HWave.h	2011-06-16 13:18:29.000000000 +0900
@@ -20,6 +20,51 @@
 /* ----------------------------------------------------------- */
 /* !HVER!HWave:   3.4.1 [CUED 12/03/09] */
 
+/*  *** THIS IS A MODIFIED VERSION OF HTK ***                        */
+/* ----------------------------------------------------------------- */
+/*           The HMM-Based Speech Synthesis System (HTS)             */
+/*           developed by HTS Working Group                          */
+/*           http://hts.sp.nitech.ac.jp/                             */
+/* ----------------------------------------------------------------- */
+/*                                                                   */
+/*  Copyright (c) 2001-2011  Nagoya Institute of Technology          */
+/*                           Department of Computer Science          */
+/*                                                                   */
+/*                2001-2008  Tokyo Institute of Technology           */
+/*                           Interdisciplinary Graduate School of    */
+/*                           Science and Engineering                 */
+/*                                                                   */
+/* All rights reserved.                                              */
+/*                                                                   */
+/* Redistribution and use in source and binary forms, with or        */
+/* without modification, are permitted provided that the following   */
+/* conditions are met:                                               */
+/*                                                                   */
+/* - Redistributions of source code must retain the above copyright  */
+/*   notice, this list of conditions and the following disclaimer.   */
+/* - Redistributions in binary form must reproduce the above         */
+/*   copyright notice, this list of conditions and the following     */
+/*   disclaimer in the documentation and/or other materials provided */
+/*   with the distribution.                                          */
+/* - Neither the name of the HTS working group nor the names of its  */
+/*   contributors may be used to endorse or promote products derived */
+/*   from this software without specific prior written permission.   */
+/*                                                                   */
+/* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND            */
+/* CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,       */
+/* INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF          */
+/* MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE          */
+/* DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS */
+/* BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,          */
+/* EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED   */
+/* TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,     */
+/* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON */
+/* ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,   */
+/* OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY    */
+/* OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE           */
+/* POSSIBILITY OF SUCH DAMAGE.                                       */
+/* ----------------------------------------------------------------- */
+
 /*  Configuration Parameters:
    NSAMPLES       - num samples in alien file input via a pipe
    HEADERSIZE     - size of header in alien file
@@ -68,6 +113,11 @@ void InitWave(void);
    Initialise module
 */
 
+void ResetWave(void);
+/*
+   Reset module
+*/
+
 Wave OpenWaveInput(MemHeap *x, char *fname, FileFormat fmt, HTime winDur, 
                    HTime frPeriod, HTime *sampPeriod);
 /*
@@ -185,5 +235,4 @@ Boolean ReadEsignalHeader(FILE *f, long 
 
 #endif  /* _HWAVE_H_ */
 
-/* ------------------------ End of HWave.h ----------------------- */
-
+/* ------------------------ End of HWave.h ------------------------- */
diff -pbBEwurNa --ignore-matching-lines='.*vc_id.*' HTK-3.4.1/HTKLib/Makefile.in HTS-2.2_for_HTK-3.4.1/HTKLib/Makefile.in
--- HTK-3.4.1/HTKLib/Makefile.in	2009-03-11 21:50:30.000000000 +0900
+++ HTS-2.2_for_HTK-3.4.1/HTKLib/Makefile.in	2011-06-16 13:15:50.000000000 +0900
@@ -19,6 +19,52 @@
 # ----------------------------------------------------------- 
 # File: @configure_input@
 # ----------------------------------------------------------- 
+
+#  *** THIS IS A MODIFIED VERSION OF HTK ***                        #
+# ----------------------------------------------------------------- #
+#           The HMM-Based Speech Synthesis System (HTS)             #
+#           developed by HTS Working Group                          #
+#           http://hts.sp.nitech.ac.jp/                             #
+# ----------------------------------------------------------------- #
+#                                                                   #
+#  Copyright (c) 2001-2011  Nagoya Institute of Technology          #
+#                           Department of Computer Science          #
+#                                                                   #
+#                2001-2008  Tokyo Institute of Technology           #
+#                           Interdisciplinary Graduate School of    #
+#                           Science and Engineering                 #
+#                                                                   #
+# All rights reserved.                                              #
+#                                                                   #
+# Redistribution and use in source and binary forms, with or        #
+# without modification, are permitted provided that the following   #
+# conditions are met:                                               #
+#                                                                   #
+# - Redistributions of source code must retain the above copyright  #
+#   notice, this list of conditions and the following disclaimer.   #
+# - Redistributions in binary form must reproduce the above         #
+#   copyright notice, this list of conditions and the following     #
+#   disclaimer in the documentation and/or other materials provided #
+#   with the distribution.                                          #
+# - Neither the name of the HTS working group nor the names of its  #
+#   contributors may be used to endorse or promote products derived #
+#   from this software without specific prior written permission.   #
+#                                                                   #
+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND            #
+# CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,       #
+# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF          #
+# MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE          #
+# DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS #
+# BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,          #
+# EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED   #
+# TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,     #
+# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON #
+# ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,   #
+# OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY    #
+# OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE           #
+# POSSIBILITY OF SUCH DAMAGE.                                       #
+# ----------------------------------------------------------------- #
+
 SHELL = /bin/sh
 srcdir = @srcdir@
 top_srcdir = @top_srcdir@
@@ -42,8 +88,11 @@ hlib = .
 HLIBS = ${exec_prefix}/lib/HTKLib.a
 
 CC     = @CC@
+FC     = @F77@
 CFLAGS := $(CFLAGS) @CFLAGS@ -I. -DPHNALG
+FFLAGS := $(FFLAGS) @FFLAGS@ -I. 
 RANLIB = @RANLIB@
+AR     = @AR@
 INSTALL= @INSTALL@
 target = HTKLib.a
 objects = @HGRAF@ esig_asc.o \
@@ -57,6 +106,7 @@ objects = @HGRAF@ esig_asc.o \
 	HExactMPE.o \
 	HFB.o \
 	HFBLat.o \
+	HGen.o \
 	HLabel.o \
 	HLat.o \
 	HLM.o \
@@ -64,6 +114,7 @@ objects = @HGRAF@ esig_asc.o \
 	HMath.o \
 	HMem.o \
 	HModel.o \
+	HMTrain.o \
 	HNet.o \
 	HParm.o \
 	HRec.o \
@@ -73,7 +124,8 @@ objects = @HGRAF@ esig_asc.o \
 	HUtil.o \
 	HVQ.o \
 	HWave.o \
-	strarr.o 
+	strarr.o \
+	@LBFGS@ \
 
 lvobjects = $(basename @HGRAF@).lv.o esig_asc.lv.o \
 	esig_edr.lv.o \
@@ -93,6 +145,7 @@ lvobjects = $(basename @HGRAF@).lv.o esi
 	HMath.lv.o \
 	HMem.lv.o \
 	HModel.lv.o \
+	HMTrain.lv.o \
 	HNet.lv.o \
 	HParm.lv.o \
 	HRec.lv.o \
@@ -104,18 +157,18 @@ lvobjects = $(basename @HGRAF@).lv.o esi
 	HWave.lv.o \
 	strarr.lv.o 
 
-all:    HTKLib.a HTKLiblv.a
+all:	HTKLib.a @LIBLV@
 
 # This is the library used by HTKTools and HLMTools
 HTKLib.a: $(objects)
 	if [ -f $@ ] ; then  /bin/rm $@ ; fi
-	ar rv $@ $^
+	$(AR) rv $@ $^
 	$(RANLIB) $@
 
 # This version is used by HDecode (HTKLVRec)
 HTKLiblv.a: $(lvobjects)
 	if [ -f $@ ] ; then  /bin/rm $@ ; fi
-	ar rv $@ $^
+	$(AR) rv $@ $^
 	$(RANLIB) $@
 
 %.lv.o: %.c
diff -pbBEwurNa --ignore-matching-lines='.*vc_id.*' HTK-3.4.1/HTKLib/lbfgs.f HTS-2.2_for_HTK-3.4.1/HTKLib/lbfgs.f
--- HTK-3.4.1/HTKLib/lbfgs.f	1970-01-01 09:00:00.000000000 +0900
+++ HTS-2.2_for_HTK-3.4.1/HTKLib/lbfgs.f	2007-10-31 15:39:39.000000000 +0900
@@ -0,0 +1,1156 @@
+C     ----------------------------------------------------------------------
+C     This file contains the LBFGS algorithm and supporting routines
+C
+C     ****************
+C     LBFGS SUBROUTINE
+C     ****************
+C
+      SUBROUTINE LBFGS(N,M,X,F,G,DIAGCO,DIAG,IPRINT,EPS,XTOL,W,IFLAG)
+C
+      INTEGER N,M,IPRINT(2),IFLAG
+      DOUBLE PRECISION X(N),G(N),DIAG(N),W(N*(2*M+1)+2*M)
+      DOUBLE PRECISION F,EPS,XTOL
+      LOGICAL DIAGCO
+C
+C        LIMITED MEMORY BFGS METHOD FOR LARGE SCALE OPTIMIZATION
+C                          JORGE NOCEDAL
+C                        *** July 1990 ***
+C
+C 
+C     This subroutine solves the unconstrained minimization problem
+C 
+C                      min F(x),    x= (x1,x2,...,xN),
+C
+C      using the limited memory BFGS method. The routine is especially
+C      effective on problems involving a large number of variables. In
+C      a typical iteration of this method an approximation Hk to the
+C      inverse of the Hessian is obtained by applying M BFGS updates to
+C      a diagonal matrix Hk0, using information from the previous M steps.
+C      The user specifies the number M, which determines the amount of
+C      storage required by the routine. The user may also provide the
+C      diagonal matrices Hk0 if not satisfied with the default choice.
+C      The algorithm is described in "On the limited memory BFGS method
+C      for large scale optimization", by D. Liu and J. Nocedal,
+C      Mathematical Programming B 45 (1989) 503-528.
+C 
+C      The user is required to calculate the function value F and its
+C      gradient G. In order to allow the user complete control over
+C      these computations, reverse  communication is used. The routine
+C      must be called repeatedly under the control of the parameter
+C      IFLAG. 
+C
+C      The steplength is determined at each iteration by means of the
+C      line search routine MCVSRCH, which is a slight modification of
+C      the routine CSRCH written by More' and Thuente.
+C 
+C      The calling statement is 
+C 
+C          CALL LBFGS(N,M,X,F,G,DIAGCO,DIAG,IPRINT,EPS,XTOL,W,IFLAG)
+C 
+C      where
+C 
+C     N       is an INTEGER variable that must be set by the user to the
+C             number of variables. It is not altered by the routine.
+C             Restriction: N>0.
+C 
+C     M       is an INTEGER variable that must be set by the user to
+C             the number of corrections used in the BFGS update. It
+C             is not altered by the routine. Values of M less than 3 are
+C             not recommended; large values of M will result in excessive
+C             computing time. 3<= M <=7 is recommended. Restriction: M>0.
+C 
+C     X       is a DOUBLE PRECISION array of length N. On initial entry
+C             it must be set by the user to the values of the initial
+C             estimate of the solution vector. On exit with IFLAG=0, it
+C             contains the values of the variables at the best point
+C             found (usually a solution).
+C 
+C     F       is a DOUBLE PRECISION variable. Before initial entry and on
+C             a re-entry with IFLAG=1, it must be set by the user to
+C             contain the value of the function F at the point X.
+C 
+C     G       is a DOUBLE PRECISION array of length N. Before initial
+C             entry and on a re-entry with IFLAG=1, it must be set by
+C             the user to contain the components of the gradient G at
+C             the point X.
+C 
+C     DIAGCO  is a LOGICAL variable that must be set to .TRUE. if the
+C             user  wishes to provide the diagonal matrix Hk0 at each
+C             iteration. Otherwise it should be set to .FALSE., in which
+C             case  LBFGS will use a default value described below. If
+C             DIAGCO is set to .TRUE. the routine will return at each
+C             iteration of the algorithm with IFLAG=2, and the diagonal
+C              matrix Hk0  must be provided in the array DIAG.
+C 
+C 
+C     DIAG    is a DOUBLE PRECISION array of length N. If DIAGCO=.TRUE.,
+C             then on initial entry or on re-entry with IFLAG=2, DIAG
+C             it must be set by the user to contain the values of the 
+C             diagonal matrix Hk0.  Restriction: all elements of DIAG
+C             must be positive.
+C 
+C     IPRINT  is an INTEGER array of length two which must be set by the
+C             user.
+C 
+C             IPRINT(1) specifies the frequency of the output:
+C                IPRINT(1) < 0 : no output is generated,
+C                IPRINT(1) = 0 : output only at first and last iteration,
+C                IPRINT(1) > 0 : output every IPRINT(1) iterations.
+C 
+C             IPRINT(2) specifies the type of output generated:
+C                IPRINT(2) = 0 : iteration count, number of function 
+C                                evaluations, function value, norm of the
+C                                gradient, and steplength,
+C                IPRINT(2) = 1 : same as IPRINT(2)=0, plus vector of
+C                                variables and  gradient vector at the
+C                                initial point,
+C                IPRINT(2) = 2 : same as IPRINT(2)=1, plus vector of
+C                                variables,
+C                IPRINT(2) = 3 : same as IPRINT(2)=2, plus gradient vector.
+C 
+C 
+C     EPS     is a positive DOUBLE PRECISION variable that must be set by
+C             the user, and determines the accuracy with which the solution
+C             is to be found. The subroutine terminates when
+C
+C                         ||G|| < EPS max(1,||X||),
+C
+C             where ||.|| denotes the Euclidean norm.
+C 
+C     XTOL    is a  positive DOUBLE PRECISION variable that must be set by
+C             the user to an estimate of the machine precision (e.g.
+C             10**(-16) on a SUN station 3/60). The line search routine will
+C             terminate if the relative width of the interval of uncertainty
+C             is less than XTOL.
+C 
+C     W       is a DOUBLE PRECISION array of length N(2M+1)+2M used as
+C             workspace for LBFGS. This array must not be altered by the
+C             user.
+C 
+C     IFLAG   is an INTEGER variable that must be set to 0 on initial entry
+C             to the subroutine. A return with IFLAG<0 indicates an error,
+C             and IFLAG=0 indicates that the routine has terminated without
+C             detecting errors. On a return with IFLAG=1, the user must
+C             evaluate the function F and gradient G. On a return with
+C             IFLAG=2, the user must provide the diagonal matrix Hk0.
+C 
+C             The following negative values of IFLAG, detecting an error,
+C             are possible:
+C 
+C              IFLAG=-1  The line search routine MCSRCH failed. The
+C                        parameter INFO provides more detailed information
+C                        (see also the documentation of MCSRCH):
+C
+C                       INFO = 0  IMPROPER INPUT PARAMETERS.
+C
+C                       INFO = 2  RELATIVE WIDTH OF THE INTERVAL OF
+C                                 UNCERTAINTY IS AT MOST XTOL.
+C
+C                       INFO = 3  MORE THAN 20 FUNCTION EVALUATIONS WERE
+C                                 REQUIRED AT THE PRESENT ITERATION.
+C
+C                       INFO = 4  THE STEP IS TOO SMALL.
+C
+C                       INFO = 5  THE STEP IS TOO LARGE.
+C
+C                       INFO = 6  ROUNDING ERRORS PREVENT FURTHER PROGRESS. 
+C                                 THERE MAY NOT BE A STEP WHICH SATISFIES
+C                                 THE SUFFICIENT DECREASE AND CURVATURE
+C                                 CONDITIONS. TOLERANCES MAY BE TOO SMALL.
+C
+C 
+C              IFLAG=-2  The i-th diagonal element of the diagonal inverse
+C                        Hessian approximation, given in DIAG, is not
+C                        positive.
+C           
+C              IFLAG=-3  Improper input parameters for LBFGS (N or M are
+C                        not positive).
+C 
+C
+C
+C    ON THE DRIVER:
+C
+C    The program that calls LBFGS must contain the declaration:
+C
+C                       EXTERNAL LB2
+C
+C    LB2 is a BLOCK DATA that defines the default values of several
+C    parameters described in the COMMON section. 
+C
+C 
+C 
+C    COMMON:
+C 
+C     The subroutine contains one common area, which the user may wish to
+C    reference:
+C 
+         COMMON /LB3/MP,LP,GTOL,STPMIN,STPMAX
+C 
+C    MP  is an INTEGER variable with default value 6. It is used as the
+C        unit number for the printing of the monitoring information
+C        controlled by IPRINT.
+C 
+C    LP  is an INTEGER variable with default value 6. It is used as the
+C        unit number for the printing of error messages. This printing
+C        may be suppressed by setting LP to a non-positive value.
+C 
+C    GTOL is a DOUBLE PRECISION variable with default value 0.9, which
+C        controls the accuracy of the line search routine MCSRCH. If the
+C        function and gradient evaluations are inexpensive with respect
+C        to the cost of the iteration (which is sometimes the case when
+C        solving very large problems) it may be advantageous to set GTOL
+C        to a small value. A typical small value is 0.1.  Restriction:
+C        GTOL should be greater than 1.D-04.
+C 
+C    STPMIN and STPMAX are non-negative DOUBLE PRECISION variables which
+C        specify lower and uper bounds for the step in the line search.
+C        Their default values are 1.D-20 and 1.D+20, respectively. These
+C        values need not be modified unless the exponents are too large
+C        for the machine being used, or unless the problem is extremely
+C        badly scaled (in which case the exponents should be increased).
+C 
+C
+C  MACHINE DEPENDENCIES
+C
+C        The only variables that are machine-dependent are XTOL,
+C        STPMIN and STPMAX.
+C 
+C
+C  GENERAL INFORMATION
+C 
+C    Other routines called directly:  DAXPY, DDOT, LB1, MCSRCH
+C 
+C    Input/Output  :  No input; diagnostic messages on unit MP and
+C                     error messages on unit LP.
+C 
+C 
+C     - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+C
+      DOUBLE PRECISION GTOL,ONE,ZERO,GNORM,DDOT,STP1,FTOL,STPMIN,
+     .                 STPMAX,STP,YS,YY,SQ,YR,BETA,XNORM
+      INTEGER MP,LP,ITER,NFUN,POINT,ISPT,IYPT,MAXFEV,INFO,
+     .        BOUND,NPT,CP,I,NFEV,INMC,IYCN,ISCN
+      LOGICAL FINISH
+C
+      SAVE
+      DATA ONE,ZERO/1.0D+0,0.0D+0/
+C
+C     INITIALIZE
+C     ----------
+C
+      IF(IFLAG.EQ.0) GO TO 10
+      GO TO (172,100) IFLAG
+  10  ITER= 0
+      IF(N.LE.0.OR.M.LE.0) GO TO 196
+      IF(GTOL.LE.1.D-04) THEN
+        IF(LP.GT.0) WRITE(LP,245)
+        GTOL=9.D-01
+      ENDIF
+      NFUN= 1
+      POINT= 0
+      FINISH= .FALSE.
+      IF(DIAGCO) THEN
+         DO 30 I=1,N
+ 30      IF (DIAG(I).LE.ZERO) GO TO 195
+      ELSE
+         DO 40 I=1,N
+ 40      DIAG(I)= 1.0D0
+      ENDIF
+C
+C     THE WORK VECTOR W IS DIVIDED AS FOLLOWS:
+C     ---------------------------------------
+C     THE FIRST N LOCATIONS ARE USED TO STORE THE GRADIENT AND
+C         OTHER TEMPORARY INFORMATION.
+C     LOCATIONS (N+1)...(N+M) STORE THE SCALARS RHO.
+C     LOCATIONS (N+M+1)...(N+2M) STORE THE NUMBERS ALPHA USED
+C         IN THE FORMULA THAT COMPUTES H*G.
+C     LOCATIONS (N+2M+1)...(N+2M+NM) STORE THE LAST M SEARCH
+C         STEPS.
+C     LOCATIONS (N+2M+NM+1)...(N+2M+2NM) STORE THE LAST M
+C         GRADIENT DIFFERENCES.
+C
+C     THE SEARCH STEPS AND GRADIENT DIFFERENCES ARE STORED IN A
+C     CIRCULAR ORDER CONTROLLED BY THE PARAMETER POINT.
+C
+      ISPT= N+2*M
+      IYPT= ISPT+N*M     
+      DO 50 I=1,N
+ 50   W(ISPT+I)= -G(I)*DIAG(I)
+      GNORM= DSQRT(DDOT(N,G,1,G,1))
+      STP1= ONE/GNORM
+C
+C     PARAMETERS FOR LINE SEARCH ROUTINE
+C     
+      FTOL= 1.0D-4
+      MAXFEV= 20
+C
+      IF(IPRINT(1).GE.0) CALL LB1(IPRINT,ITER,NFUN,
+     *                     GNORM,N,M,X,F,G,STP,FINISH)
+C
+C    --------------------
+C     MAIN ITERATION LOOP
+C    --------------------
+C
+ 80   ITER= ITER+1
+      INFO=0
+      BOUND=ITER-1
+      IF(ITER.EQ.1) GO TO 165
+      IF (ITER .GT. M)BOUND=M
+C
+         YS= DDOT(N,W(IYPT+NPT+1),1,W(ISPT+NPT+1),1)
+      IF(.NOT.DIAGCO) THEN
+         YY= DDOT(N,W(IYPT+NPT+1),1,W(IYPT+NPT+1),1)
+         DO 90 I=1,N
+   90    DIAG(I)= YS/YY
+      ELSE
+         IFLAG=2
+         RETURN
+      ENDIF
+ 100  CONTINUE
+      IF(DIAGCO) THEN
+        DO 110 I=1,N
+ 110    IF (DIAG(I).LE.ZERO) GO TO 195
+      ENDIF
+C
+C     COMPUTE -H*G USING THE FORMULA GIVEN IN: Nocedal, J. 1980,
+C     "Updating quasi-Newton matrices with limited storage",
+C     Mathematics of Computation, Vol.24, No.151, pp. 773-782.
+C     ---------------------------------------------------------
+C
+      CP= POINT
+      IF (POINT.EQ.0) CP=M
+      W(N+CP)= ONE/YS
+      DO 112 I=1,N
+ 112  W(I)= -G(I)
+      CP= POINT
+      DO 125 I= 1,BOUND
+         CP=CP-1
+         IF (CP.EQ. -1)CP=M-1
+         SQ= DDOT(N,W(ISPT+CP*N+1),1,W,1)
+         INMC=N+M+CP+1
+         IYCN=IYPT+CP*N
+         W(INMC)= W(N+CP+1)*SQ
+         CALL DAXPY(N,-W(INMC),W(IYCN+1),1,W,1)
+ 125  CONTINUE
+C
+      DO 130 I=1,N
+ 130  W(I)=DIAG(I)*W(I)
+C
+      DO 145 I=1,BOUND
+         YR= DDOT(N,W(IYPT+CP*N+1),1,W,1)
+         BETA= W(N+CP+1)*YR
+         INMC=N+M+CP+1
+         BETA= W(INMC)-BETA
+         ISCN=ISPT+CP*N
+         CALL DAXPY(N,BETA,W(ISCN+1),1,W,1)
+         CP=CP+1
+         IF (CP.EQ.M)CP=0
+ 145  CONTINUE
+C
+C     STORE THE NEW SEARCH DIRECTION
+C     ------------------------------
+C
+       DO 160 I=1,N
+ 160   W(ISPT+POINT*N+I)= W(I)
+C
+C     OBTAIN THE ONE-DIMENSIONAL MINIMIZER OF THE FUNCTION 
+C     BY USING THE LINE SEARCH ROUTINE MCSRCH
+C     ----------------------------------------------------
+ 165  NFEV=0
+      STP=ONE
+      IF (ITER.EQ.1) STP=STP1
+      DO 170 I=1,N
+ 170  W(I)=G(I)
+ 172  CONTINUE
+      CALL MCSRCH(N,X,F,G,W(ISPT+POINT*N+1),STP,FTOL,
+     *            XTOL,MAXFEV,INFO,NFEV,DIAG)
+      IF (INFO .EQ. -1) THEN
+        IFLAG=1
+        RETURN
+      ENDIF
+      IF (INFO .NE. 1) GO TO 190
+      NFUN= NFUN + NFEV
+C
+C     COMPUTE THE NEW STEP AND GRADIENT CHANGE 
+C     -----------------------------------------
+C
+      NPT=POINT*N
+      DO 175 I=1,N
+      W(ISPT+NPT+I)= STP*W(ISPT+NPT+I)
+ 175  W(IYPT+NPT+I)= G(I)-W(I)
+      POINT=POINT+1
+      IF (POINT.EQ.M)POINT=0
+C
+C     TERMINATION TEST
+C     ----------------
+C
+      GNORM= DSQRT(DDOT(N,G,1,G,1))
+      XNORM= DSQRT(DDOT(N,X,1,X,1))
+      XNORM= DMAX1(1.0D0,XNORM)
+      IF (GNORM/XNORM .LE. EPS) FINISH=.TRUE.
+C
+      IF(IPRINT(1).GE.0) CALL LB1(IPRINT,ITER,NFUN,
+     *               GNORM,N,M,X,F,G,STP,FINISH)
+      IF (FINISH) THEN
+         IFLAG=0
+         RETURN
+      ENDIF
+      GO TO 80
+C
+C     ------------------------------------------------------------
+C     END OF MAIN ITERATION LOOP. ERROR EXITS.
+C     ------------------------------------------------------------
+C
+ 190  IFLAG=-1
+      IF(LP.GT.0) WRITE(LP,200) INFO
+      RETURN
+ 195  IFLAG=-2
+      IF(LP.GT.0) WRITE(LP,235) I
+      RETURN
+ 196  IFLAG= -3
+      IF(LP.GT.0) WRITE(LP,240)
+C
+C     FORMATS
+C     -------
+C
+ 200  FORMAT(/' IFLAG= -1 ',/' LINE SEARCH FAILED. SEE'
+     .          ' DOCUMENTATION OF ROUTINE MCSRCH',/' ERROR RETURN'
+     .          ' OF LINE SEARCH: INFO= ',I2,/
+     .          ' POSSIBLE CAUSES: FUNCTION OR GRADIENT ARE INCORRECT',/,
+     .          ' OR INCORRECT TOLERANCES')
+ 235  FORMAT(/' IFLAG= -2',/' THE',I5,'-TH DIAGONAL ELEMENT OF THE',/,
+     .       ' INVERSE HESSIAN APPROXIMATION IS NOT POSITIVE')
+ 240  FORMAT(/' IFLAG= -3',/' IMPROPER INPUT PARAMETERS (N OR M',
+     .       ' ARE NOT POSITIVE)')
+ 245  FORMAT(/'  GTOL IS LESS THAN OR EQUAL TO 1.D-04',
+     .       / ' IT HAS BEEN RESET TO 9.D-01')
+      RETURN
+      END
+C
+C     LAST LINE OF SUBROUTINE LBFGS
+C
+C
+      SUBROUTINE LB1(IPRINT,ITER,NFUN,
+     *                     GNORM,N,M,X,F,G,STP,FINISH)
+C
+C     -------------------------------------------------------------
+C     THIS ROUTINE PRINTS MONITORING INFORMATION. THE FREQUENCY AND
+C     AMOUNT OF OUTPUT ARE CONTROLLED BY IPRINT.
+C     -------------------------------------------------------------
+C
+      INTEGER IPRINT(2),ITER,NFUN,LP,MP,N,M
+      DOUBLE PRECISION X(N),G(N),F,GNORM,STP,GTOL,STPMIN,STPMAX
+      LOGICAL FINISH
+      COMMON /LB3/MP,LP,GTOL,STPMIN,STPMAX
+C
+      IF (ITER.EQ.0)THEN
+           WRITE(MP,10)
+           WRITE(MP,20) N,M
+           WRITE(MP,30)F,GNORM
+                 IF (IPRINT(2).GE.1)THEN
+                     WRITE(MP,40)
+                     WRITE(MP,50) (X(I),I=1,N)
+                     WRITE(MP,60)
+                     WRITE(MP,50) (G(I),I=1,N)
+                  ENDIF
+           WRITE(MP,10)
+           WRITE(MP,70)
+      ELSE
+          IF ((IPRINT(1).EQ.0).AND.(ITER.NE.1.AND..NOT.FINISH))RETURN
+              IF (IPRINT(1).NE.0)THEN
+                   IF(MOD(ITER-1,IPRINT(1)).EQ.0.OR.FINISH)THEN
+                         IF(IPRINT(2).GT.1.AND.ITER.GT.1) WRITE(MP,70)
+                         WRITE(MP,80)ITER,NFUN,F,GNORM,STP
+                   ELSE
+                         RETURN
+                   ENDIF
+              ELSE
+                   IF( IPRINT(2).GT.1.AND.FINISH) WRITE(MP,70)
+                   WRITE(MP,80)ITER,NFUN,F,GNORM,STP
+              ENDIF
+              IF (IPRINT(2).EQ.2.OR.IPRINT(2).EQ.3)THEN
+                    IF (FINISH)THEN
+                        WRITE(MP,90)
+                    ELSE
+                        WRITE(MP,40)
+                    ENDIF
+                      WRITE(MP,50)(X(I),I=1,N)
+                  IF (IPRINT(2).EQ.3)THEN
+                      WRITE(MP,60)
+                      WRITE(MP,50)(G(I),I=1,N)
+                  ENDIF
+              ENDIF
+            IF (FINISH) WRITE(MP,100)
+      ENDIF
+C
+ 10   FORMAT('*************************************************')
+ 20   FORMAT('  N=',I5,'   NUMBER OF CORRECTIONS=',I2,
+     .       /,  '       INITIAL VALUES')
+ 30   FORMAT(' F= ',1PD10.3,'   GNORM= ',1PD10.3)
+ 40   FORMAT(' VECTOR X= ')
+ 50   FORMAT(6(2X,1PD10.3))
+ 60   FORMAT(' GRADIENT VECTOR G= ')
+ 70   FORMAT(/'   I   NFN',4X,'FUNC',8X,'GNORM',7X,'STEPLENGTH'/)
+ 80   FORMAT(2(I4,1X),3X,3(1PD10.3,2X))
+ 90   FORMAT(' FINAL POINT X= ')
+ 100  FORMAT(/' THE MINIMIZATION TERMINATED WITHOUT DETECTING ERRORS.',
+     .       /' IFLAG = 0')
+C
+      RETURN
+      END
+C     ******
+C
+C
+C   ----------------------------------------------------------
+C     DATA 
+C   ----------------------------------------------------------
+C
+      BLOCK DATA LB2
+      INTEGER LP,MP
+      DOUBLE PRECISION GTOL,STPMIN,STPMAX
+      COMMON /LB3/MP,LP,GTOL,STPMIN,STPMAX
+      DATA MP,LP,GTOL,STPMIN,STPMAX/6,6,9.0D-01,1.0D-20,1.0D+20/
+      END
+C
+C
+C   ----------------------------------------------------------
+C
+      subroutine daxpy(n,da,dx,incx,dy,incy)
+c
+c     constant times a vector plus a vector.
+c     uses unrolled loops for increments equal to one.
+c     jack dongarra, linpack, 3/11/78.
+c
+      double precision dx(1),dy(1),da
+      integer i,incx,incy,ix,iy,m,mp1,n
+c
+      if(n.le.0)return
+      if (da .eq. 0.0d0) return
+      if(incx.eq.1.and.incy.eq.1)go to 20
+c
+c        code for unequal increments or equal increments
+c          not equal to 1
+c
+      ix = 1
+      iy = 1
+      if(incx.lt.0)ix = (-n+1)*incx + 1
+      if(incy.lt.0)iy = (-n+1)*incy + 1
+      do 10 i = 1,n
+        dy(iy) = dy(iy) + da*dx(ix)
+        ix = ix + incx
+        iy = iy + incy
+   10 continue
+      return
+c
+c        code for both increments equal to 1
+c
+c
+c        clean-up loop
+c
+   20 m = mod(n,4)
+      if( m .eq. 0 ) go to 40
+      do 30 i = 1,m
+        dy(i) = dy(i) + da*dx(i)
+   30 continue
+      if( n .lt. 4 ) return
+   40 mp1 = m + 1
+      do 50 i = mp1,n,4
+        dy(i) = dy(i) + da*dx(i)
+        dy(i + 1) = dy(i + 1) + da*dx(i + 1)
+        dy(i + 2) = dy(i + 2) + da*dx(i + 2)
+        dy(i + 3) = dy(i + 3) + da*dx(i + 3)
+   50 continue
+      return
+      end
+C
+C
+C   ----------------------------------------------------------
+C
+      double precision function ddot(n,dx,incx,dy,incy)
+c
+c     forms the dot product of two vectors.
+c     uses unrolled loops for increments equal to one.
+c     jack dongarra, linpack, 3/11/78.
+c
+      double precision dx(1),dy(1),dtemp
+      integer i,incx,incy,ix,iy,m,mp1,n
+c
+      ddot = 0.0d0
+      dtemp = 0.0d0
+      if(n.le.0)return
+      if(incx.eq.1.and.incy.eq.1)go to 20
+c
+c        code for unequal increments or equal increments
+c          not equal to 1
+c
+      ix = 1
+      iy = 1
+      if(incx.lt.0)ix = (-n+1)*incx + 1
+      if(incy.lt.0)iy = (-n+1)*incy + 1
+      do 10 i = 1,n
+        dtemp = dtemp + dx(ix)*dy(iy)
+        ix = ix + incx
+        iy = iy + incy
+   10 continue
+      ddot = dtemp
+      return
+c
+c        code for both increments equal to 1
+c
+c
+c        clean-up loop
+c
+   20 m = mod(n,5)
+      if( m .eq. 0 ) go to 40
+      do 30 i = 1,m
+        dtemp = dtemp + dx(i)*dy(i)
+   30 continue
+      if( n .lt. 5 ) go to 60
+   40 mp1 = m + 1
+      do 50 i = mp1,n,5
+        dtemp = dtemp + dx(i)*dy(i) + dx(i + 1)*dy(i + 1) +
+     *   dx(i + 2)*dy(i + 2) + dx(i + 3)*dy(i + 3) + dx(i + 4)*dy(i + 4)
+   50 continue
+   60 ddot = dtemp
+      return
+      end
+C    ------------------------------------------------------------------
+C
+C     **************************
+C     LINE SEARCH ROUTINE MCSRCH
+C     **************************
+C
+      SUBROUTINE MCSRCH(N,X,F,G,S,STP,FTOL,XTOL,MAXFEV,INFO,NFEV,WA)
+      INTEGER N,MAXFEV,INFO,NFEV
+      DOUBLE PRECISION F,STP,FTOL,GTOL,XTOL,STPMIN,STPMAX
+      DOUBLE PRECISION X(N),G(N),S(N),WA(N)
+      COMMON /LB3/MP,LP,GTOL,STPMIN,STPMAX
+      SAVE
+C
+C                     SUBROUTINE MCSRCH
+C                
+C     A slight modification of the subroutine CSRCH of More' and Thuente.
+C     The changes are to allow reverse communication, and do not affect
+C     the performance of the routine. 
+C
+C     THE PURPOSE OF MCSRCH IS TO FIND A STEP WHICH SATISFIES
+C     A SUFFICIENT DECREASE CONDITION AND A CURVATURE CONDITION.
+C
+C     AT EACH STAGE THE SUBROUTINE UPDATES AN INTERVAL OF
+C     UNCERTAINTY WITH ENDPOINTS STX AND STY. THE INTERVAL OF
+C     UNCERTAINTY IS INITIALLY CHOSEN SO THAT IT CONTAINS A
+C     MINIMIZER OF THE MODIFIED FUNCTION
+C
+C          F(X+STP*S) - F(X) - FTOL*STP*(GRADF(X)'S).
+C
+C     IF A STEP IS OBTAINED FOR WHICH THE MODIFIED FUNCTION
+C     HAS A NONPOSITIVE FUNCTION VALUE AND NONNEGATIVE DERIVATIVE,
+C     THEN THE INTERVAL OF UNCERTAINTY IS CHOSEN SO THAT IT
+C     CONTAINS A MINIMIZER OF F(X+STP*S).
+C
+C     THE ALGORITHM IS DESIGNED TO FIND A STEP WHICH SATISFIES
+C     THE SUFFICIENT DECREASE CONDITION
+C
+C           F(X+STP*S) .LE. F(X) + FTOL*STP*(GRADF(X)'S),
+C
+C     AND THE CURVATURE CONDITION
+C
+C           ABS(GRADF(X+STP*S)'S)) .LE. GTOL*ABS(GRADF(X)'S).
+C
+C     IF FTOL IS LESS THAN GTOL AND IF, FOR EXAMPLE, THE FUNCTION
+C     IS BOUNDED BELOW, THEN THERE IS ALWAYS A STEP WHICH SATISFIES
+C     BOTH CONDITIONS. IF NO STEP CAN BE FOUND WHICH SATISFIES BOTH
+C     CONDITIONS, THEN THE ALGORITHM USUALLY STOPS WHEN ROUNDING
+C     ERRORS PREVENT FURTHER PROGRESS. IN THIS CASE STP ONLY
+C     SATISFIES THE SUFFICIENT DECREASE CONDITION.
+C
+C     THE SUBROUTINE STATEMENT IS
+C
+C        SUBROUTINE MCSRCH(N,X,F,G,S,STP,FTOL,XTOL, MAXFEV,INFO,NFEV,WA)
+C     WHERE
+C
+C       N IS A POSITIVE INTEGER INPUT VARIABLE SET TO THE NUMBER
+C         OF VARIABLES.
+C
+C       X IS AN ARRAY OF LENGTH N. ON INPUT IT MUST CONTAIN THE
+C         BASE POINT FOR THE LINE SEARCH. ON OUTPUT IT CONTAINS
+C         X + STP*S.
+C
+C       F IS A VARIABLE. ON INPUT IT MUST CONTAIN THE VALUE OF F
+C         AT X. ON OUTPUT IT CONTAINS THE VALUE OF F AT X + STP*S.
+C
+C       G IS AN ARRAY OF LENGTH N. ON INPUT IT MUST CONTAIN THE
+C         GRADIENT OF F AT X. ON OUTPUT IT CONTAINS THE GRADIENT
+C         OF F AT X + STP*S.
+C
+C       S IS AN INPUT ARRAY OF LENGTH N WHICH SPECIFIES THE
+C         SEARCH DIRECTION.
+C
+C       STP IS A NONNEGATIVE VARIABLE. ON INPUT STP CONTAINS AN
+C         INITIAL ESTIMATE OF A SATISFACTORY STEP. ON OUTPUT
+C         STP CONTAINS THE FINAL ESTIMATE.
+C
+C       FTOL AND GTOL ARE NONNEGATIVE INPUT VARIABLES. (In this reverse
+C         communication implementation GTOL is defined in a COMMON
+C         statement.) TERMINATION OCCURS WHEN THE SUFFICIENT DECREASE
+C         CONDITION AND THE DIRECTIONAL DERIVATIVE CONDITION ARE
+C         SATISFIED.
+C
+C       XTOL IS A NONNEGATIVE INPUT VARIABLE. TERMINATION OCCURS
+C         WHEN THE RELATIVE WIDTH OF THE INTERVAL OF UNCERTAINTY
+C         IS AT MOST XTOL.
+C
+C       STPMIN AND STPMAX ARE NONNEGATIVE INPUT VARIABLES WHICH
+C         SPECIFY LOWER AND UPPER BOUNDS FOR THE STEP. (In this reverse
+C         communication implementatin they are defined in a COMMON
+C         statement).
+C
+C       MAXFEV IS A POSITIVE INTEGER INPUT VARIABLE. TERMINATION
+C         OCCURS WHEN THE NUMBER OF CALLS TO FCN IS AT LEAST
+C         MAXFEV BY THE END OF AN ITERATION.
+C
+C       INFO IS AN INTEGER OUTPUT VARIABLE SET AS FOLLOWS:
+C
+C         INFO = 0  IMPROPER INPUT PARAMETERS.
+C
+C         INFO =-1  A RETURN IS MADE TO COMPUTE THE FUNCTION AND GRADIENT.
+C
+C         INFO = 1  THE SUFFICIENT DECREASE CONDITION AND THE
+C                   DIRECTIONAL DERIVATIVE CONDITION HOLD.
+C
+C         INFO = 2  RELATIVE WIDTH OF THE INTERVAL OF UNCERTAINTY
+C                   IS AT MOST XTOL.
+C
+C         INFO = 3  NUMBER OF CALLS TO FCN HAS REACHED MAXFEV.
+C
+C         INFO = 4  THE STEP IS AT THE LOWER BOUND STPMIN.
+C
+C         INFO = 5  THE STEP IS AT THE UPPER BOUND STPMAX.
+C
+C         INFO = 6  ROUNDING ERRORS PREVENT FURTHER PROGRESS.
+C                   THERE MAY NOT BE A STEP WHICH SATISFIES THE
+C                   SUFFICIENT DECREASE AND CURVATURE CONDITIONS.
+C                   TOLERANCES MAY BE TOO SMALL.
+C
+C       NFEV IS AN INTEGER OUTPUT VARIABLE SET TO THE NUMBER OF
+C         CALLS TO FCN.
+C
+C       WA IS A WORK ARRAY OF LENGTH N.
+C
+C     SUBPROGRAMS CALLED
+C
+C       MCSTEP
+C
+C       FORTRAN-SUPPLIED...ABS,MAX,MIN
+C
+C     ARGONNE NATIONAL LABORATORY. MINPACK PROJECT. JUNE 1983
+C     JORGE J. MORE', DAVID J. THUENTE
+C
+C     **********
+      INTEGER INFOC,J
+      LOGICAL BRACKT,STAGE1
+      DOUBLE PRECISION DG,DGM,DGINIT,DGTEST,DGX,DGXM,DGY,DGYM,
+     *       FINIT,FTEST1,FM,FX,FXM,FY,FYM,P5,P66,STX,STY,
+     *       STMIN,STMAX,WIDTH,WIDTH1,XTRAPF,ZERO
+      DATA P5,P66,XTRAPF,ZERO /0.5D0,0.66D0,4.0D0,0.0D0/
+      IF(INFO.EQ.-1) GO TO 45
+      INFOC = 1
+C
+C     CHECK THE INPUT PARAMETERS FOR ERRORS.
+C
+      IF (N .LE. 0 .OR. STP .LE. ZERO .OR. FTOL .LT. ZERO .OR.
+     *    GTOL .LT. ZERO .OR. XTOL .LT. ZERO .OR. STPMIN .LT. ZERO
+     *    .OR. STPMAX .LT. STPMIN .OR. MAXFEV .LE. 0) RETURN
+C
+C     COMPUTE THE INITIAL GRADIENT IN THE SEARCH DIRECTION
+C     AND CHECK THAT S IS A DESCENT DIRECTION.
+C
+      DGINIT = ZERO
+      DO 10 J = 1, N
+         DGINIT = DGINIT + G(J)*S(J)
+   10    CONTINUE
+      IF (DGINIT .GE. ZERO) then
+         write(LP,15)
+   15    FORMAT(/'  THE SEARCH DIRECTION IS NOT A DESCENT DIRECTION')
+         RETURN
+         ENDIF
+C
+C     INITIALIZE LOCAL VARIABLES.
+C
+      BRACKT = .FALSE.
+      STAGE1 = .TRUE.
+      NFEV = 0
+      FINIT = F
+      DGTEST = FTOL*DGINIT
+      WIDTH = STPMAX - STPMIN
+      WIDTH1 = WIDTH/P5
+      DO 20 J = 1, N
+         WA(J) = X(J)
+   20    CONTINUE
+C
+C     THE VARIABLES STX, FX, DGX CONTAIN THE VALUES OF THE STEP,
+C     FUNCTION, AND DIRECTIONAL DERIVATIVE AT THE BEST STEP.
+C     THE VARIABLES STY, FY, DGY CONTAIN THE VALUE OF THE STEP,
+C     FUNCTION, AND DERIVATIVE AT THE OTHER ENDPOINT OF
+C     THE INTERVAL OF UNCERTAINTY.
+C     THE VARIABLES STP, F, DG CONTAIN THE VALUES OF THE STEP,
+C     FUNCTION, AND DERIVATIVE AT THE CURRENT STEP.
+C
+      STX = ZERO
+      FX = FINIT
+      DGX = DGINIT
+      STY = ZERO
+      FY = FINIT
+      DGY = DGINIT
+C
+C     START OF ITERATION.
+C
+   30 CONTINUE
+C
+C        SET THE MINIMUM AND MAXIMUM STEPS TO CORRESPOND
+C        TO THE PRESENT INTERVAL OF UNCERTAINTY.
+C
+         IF (BRACKT) THEN
+            STMIN = MIN(STX,STY)
+            STMAX = MAX(STX,STY)
+         ELSE
+            STMIN = STX
+            STMAX = STP + XTRAPF*(STP - STX)
+            END IF
+C
+C        FORCE THE STEP TO BE WITHIN THE BOUNDS STPMAX AND STPMIN.
+C
+         STP = MAX(STP,STPMIN)
+         STP = MIN(STP,STPMAX)
+C
+C        IF AN UNUSUAL TERMINATION IS TO OCCUR THEN LET
+C        STP BE THE LOWEST POINT OBTAINED SO FAR.
+C
+         IF ((BRACKT .AND. (STP .LE. STMIN .OR. STP .GE. STMAX))
+     *      .OR. NFEV .GE. MAXFEV-1 .OR. INFOC .EQ. 0
+     *      .OR. (BRACKT .AND. STMAX-STMIN .LE. XTOL*STMAX)) STP = STX
+C
+C        EVALUATE THE FUNCTION AND GRADIENT AT STP
+C        AND COMPUTE THE DIRECTIONAL DERIVATIVE.
+C        We return to main program to obtain F and G.
+C
+         DO 40 J = 1, N
+            X(J) = WA(J) + STP*S(J)
+   40       CONTINUE
+         INFO=-1
+         RETURN
+C
+   45    INFO=0
+         NFEV = NFEV + 1
+         DG = ZERO
+         DO 50 J = 1, N
+            DG = DG + G(J)*S(J)
+   50       CONTINUE
+         FTEST1 = FINIT + STP*DGTEST
+C
+C        TEST FOR CONVERGENCE.
+C
+         IF ((BRACKT .AND. (STP .LE. STMIN .OR. STP .GE. STMAX))
+     *      .OR. INFOC .EQ. 0) INFO = 6
+         IF (STP .EQ. STPMAX .AND.
+     *       F .LE. FTEST1 .AND. DG .LE. DGTEST) INFO = 5
+         IF (STP .EQ. STPMIN .AND.
+     *       (F .GT. FTEST1 .OR. DG .GE. DGTEST)) INFO = 4
+         IF (NFEV .GE. MAXFEV) INFO = 3
+         IF (BRACKT .AND. STMAX-STMIN .LE. XTOL*STMAX) INFO = 2
+         IF (F .LE. FTEST1 .AND. DABS(DG) .LE. GTOL*(-DGINIT)) INFO = 1
+C
+C        CHECK FOR TERMINATION.
+C
+         IF (INFO .NE. 0) RETURN
+C
+C        IN THE FIRST STAGE WE SEEK A STEP FOR WHICH THE MODIFIED
+C        FUNCTION HAS A NONPOSITIVE VALUE AND NONNEGATIVE DERIVATIVE.
+C
+         IF (STAGE1 .AND. F .LE. FTEST1 .AND.
+     *       DG .GE. MIN(FTOL,GTOL)*DGINIT) STAGE1 = .FALSE.
+C
+C        A MODIFIED FUNCTION IS USED TO PREDICT THE STEP ONLY IF
+C        WE HAVE NOT OBTAINED A STEP FOR WHICH THE MODIFIED
+C        FUNCTION HAS A NONPOSITIVE FUNCTION VALUE AND NONNEGATIVE
+C        DERIVATIVE, AND IF A LOWER FUNCTION VALUE HAS BEEN
+C        OBTAINED BUT THE DECREASE IS NOT SUFFICIENT.
+C
+         IF (STAGE1 .AND. F .LE. FX .AND. F .GT. FTEST1) THEN
+C
+C           DEFINE THE MODIFIED FUNCTION AND DERIVATIVE VALUES.
+C
+            FM = F - STP*DGTEST
+            FXM = FX - STX*DGTEST
+            FYM = FY - STY*DGTEST
+            DGM = DG - DGTEST
+            DGXM = DGX - DGTEST
+            DGYM = DGY - DGTEST
+C
+C           CALL CSTEP TO UPDATE THE INTERVAL OF UNCERTAINTY
+C           AND TO COMPUTE THE NEW STEP.
+C
+            CALL MCSTEP(STX,FXM,DGXM,STY,FYM,DGYM,STP,FM,DGM,
+     *                 BRACKT,STMIN,STMAX,INFOC)
+C
+C           RESET THE FUNCTION AND GRADIENT VALUES FOR F.
+C
+            FX = FXM + STX*DGTEST
+            FY = FYM + STY*DGTEST
+            DGX = DGXM + DGTEST
+            DGY = DGYM + DGTEST
+         ELSE
+C
+C           CALL MCSTEP TO UPDATE THE INTERVAL OF UNCERTAINTY
+C           AND TO COMPUTE THE NEW STEP.
+C
+            CALL MCSTEP(STX,FX,DGX,STY,FY,DGY,STP,F,DG,
+     *                 BRACKT,STMIN,STMAX,INFOC)
+            END IF
+C
+C        FORCE A SUFFICIENT DECREASE IN THE SIZE OF THE
+C        INTERVAL OF UNCERTAINTY.
+C
+         IF (BRACKT) THEN
+            IF (DABS(STY-STX) .GE. P66*WIDTH1)
+     *         STP = STX + P5*(STY - STX)
+            WIDTH1 = WIDTH
+            WIDTH = DABS(STY-STX)
+            END IF
+C
+C        END OF ITERATION.
+C
+         GO TO 30
+C
+C     LAST LINE OF SUBROUTINE MCSRCH.
+C
+      END
+      SUBROUTINE MCSTEP(STX,FX,DX,STY,FY,DY,STP,FP,DP,BRACKT,
+     *                 STPMIN,STPMAX,INFO)
+      INTEGER INFO
+      DOUBLE PRECISION STX,FX,DX,STY,FY,DY,STP,FP,DP,STPMIN,STPMAX
+      LOGICAL BRACKT,BOUND
+C
+C     SUBROUTINE MCSTEP
+C
+C     THE PURPOSE OF MCSTEP IS TO COMPUTE A SAFEGUARDED STEP FOR
+C     A LINESEARCH AND TO UPDATE AN INTERVAL OF UNCERTAINTY FOR
+C     A MINIMIZER OF THE FUNCTION.
+C
+C     THE PARAMETER STX CONTAINS THE STEP WITH THE LEAST FUNCTION
+C     VALUE. THE PARAMETER STP CONTAINS THE CURRENT STEP. IT IS
+C     ASSUMED THAT THE DERIVATIVE AT STX IS NEGATIVE IN THE
+C     DIRECTION OF THE STEP. IF BRACKT IS SET TRUE THEN A
+C     MINIMIZER HAS BEEN BRACKETED IN AN INTERVAL OF UNCERTAINTY
+C     WITH ENDPOINTS STX AND STY.
+C
+C     THE SUBROUTINE STATEMENT IS
+C
+C       SUBROUTINE MCSTEP(STX,FX,DX,STY,FY,DY,STP,FP,DP,BRACKT,
+C                        STPMIN,STPMAX,INFO)
+C
+C     WHERE
+C
+C       STX, FX, AND DX ARE VARIABLES WHICH SPECIFY THE STEP,
+C         THE FUNCTION, AND THE DERIVATIVE AT THE BEST STEP OBTAINED
+C         SO FAR. THE DERIVATIVE MUST BE NEGATIVE IN THE DIRECTION
+C         OF THE STEP, THAT IS, DX AND STP-STX MUST HAVE OPPOSITE
+C         SIGNS. ON OUTPUT THESE PARAMETERS ARE UPDATED APPROPRIATELY.
+C
+C       STY, FY, AND DY ARE VARIABLES WHICH SPECIFY THE STEP,
+C         THE FUNCTION, AND THE DERIVATIVE AT THE OTHER ENDPOINT OF
+C         THE INTERVAL OF UNCERTAINTY. ON OUTPUT THESE PARAMETERS ARE
+C         UPDATED APPROPRIATELY.
+C
+C       STP, FP, AND DP ARE VARIABLES WHICH SPECIFY THE STEP,
+C         THE FUNCTION, AND THE DERIVATIVE AT THE CURRENT STEP.
+C         IF BRACKT IS SET TRUE THEN ON INPUT STP MUST BE
+C         BETWEEN STX AND STY. ON OUTPUT STP IS SET TO THE NEW STEP.
+C
+C       BRACKT IS A LOGICAL VARIABLE WHICH SPECIFIES IF A MINIMIZER
+C         HAS BEEN BRACKETED. IF THE MINIMIZER HAS NOT BEEN BRACKETED
+C         THEN ON INPUT BRACKT MUST BE SET FALSE. IF THE MINIMIZER
+C         IS BRACKETED THEN ON OUTPUT BRACKT IS SET TRUE.
+C
+C       STPMIN AND STPMAX ARE INPUT VARIABLES WHICH SPECIFY LOWER
+C         AND UPPER BOUNDS FOR THE STEP.
+C
+C       INFO IS AN INTEGER OUTPUT VARIABLE SET AS FOLLOWS:
+C         IF INFO = 1,2,3,4,5, THEN THE STEP HAS BEEN COMPUTED
+C         ACCORDING TO ONE OF THE FIVE CASES BELOW. OTHERWISE
+C         INFO = 0, AND THIS INDICATES IMPROPER INPUT PARAMETERS.
+C
+C     SUBPROGRAMS CALLED
+C
+C       FORTRAN-SUPPLIED ... ABS,MAX,MIN,SQRT
+C
+C     ARGONNE NATIONAL LABORATORY. MINPACK PROJECT. JUNE 1983
+C     JORGE J. MORE', DAVID J. THUENTE
+C
+      DOUBLE PRECISION GAMMA,P,Q,R,S,SGND,STPC,STPF,STPQ,THETA
+      INFO = 0
+C
+C     CHECK THE INPUT PARAMETERS FOR ERRORS.
+C
+      IF ((BRACKT .AND. (STP .LE. MIN(STX,STY) .OR.
+     *    STP .GE. MAX(STX,STY))) .OR.
+     *    DX*(STP-STX) .GE. 0.0D0 .OR. STPMAX .LT. STPMIN) RETURN
+C
+C     DETERMINE IF THE DERIVATIVES HAVE OPPOSITE SIGN.
+C
+      SGND = DP*(DX/DABS(DX))
+C
+C     FIRST CASE. A HIGHER FUNCTION VALUE.
+C     THE MINIMUM IS BRACKETED. IF THE CUBIC STEP IS CLOSER
+C     TO STX THAN THE QUADRATIC STEP, THE CUBIC STEP IS TAKEN,
+C     ELSE THE AVERAGE OF THE CUBIC AND QUADRATIC STEPS IS TAKEN.
+C
+      IF (FP .GT. FX) THEN
+         INFO = 1
+         BOUND = .TRUE.
+         THETA = 3*(FX - FP)/(STP - STX) + DX + DP
+         S = MAX(DABS(THETA),DABS(DX),DABS(DP))
+         GAMMA = S*DSQRT((THETA/S)**2 - (DX/S)*(DP/S))
+         IF (STP .LT. STX) GAMMA = -GAMMA
+         P = (GAMMA - DX) + THETA
+         Q = ((GAMMA - DX) + GAMMA) + DP
+         R = P/Q
+         STPC = STX + R*(STP - STX)
+         STPQ = STX + ((DX/((FX-FP)/(STP-STX)+DX))/2)*(STP - STX)
+         IF (DABS(STPC-STX) .LT. DABS(STPQ-STX)) THEN
+            STPF = STPC
+         ELSE
+           STPF = STPC + (STPQ - STPC)/2
+           END IF
+         BRACKT = .TRUE.
+C
+C     SECOND CASE. A LOWER FUNCTION VALUE AND DERIVATIVES OF
+C     OPPOSITE SIGN. THE MINIMUM IS BRACKETED. IF THE CUBIC
+C     STEP IS CLOSER TO STX THAN THE QUADRATIC (SECANT) STEP,
+C     THE CUBIC STEP IS TAKEN, ELSE THE QUADRATIC STEP IS TAKEN.
+C
+      ELSE IF (SGND .LT. 0.0D0) THEN
+         INFO = 2
+         BOUND = .FALSE.
+         THETA = 3*(FX - FP)/(STP - STX) + DX + DP
+         S = MAX(DABS(THETA),DABS(DX),DABS(DP))
+         GAMMA = S*DSQRT((THETA/S)**2 - (DX/S)*(DP/S))
+         IF (STP .GT. STX) GAMMA = -GAMMA
+         P = (GAMMA - DP) + THETA
+         Q = ((GAMMA - DP) + GAMMA) + DX
+         R = P/Q
+         STPC = STP + R*(STX - STP)
+         STPQ = STP + (DP/(DP-DX))*(STX - STP)
+         IF (DABS(STPC-STP) .GT. DABS(STPQ-STP)) THEN
+            STPF = STPC
+         ELSE
+            STPF = STPQ
+            END IF
+         BRACKT = .TRUE.
+C
+C     THIRD CASE. A LOWER FUNCTION VALUE, DERIVATIVES OF THE
+C     SAME SIGN, AND THE MAGNITUDE OF THE DERIVATIVE DECREASES.
+C     THE CUBIC STEP IS ONLY USED IF THE CUBIC TENDS TO INFINITY
+C     IN THE DIRECTION OF THE STEP OR IF THE MINIMUM OF THE CUBIC
+C     IS BEYOND STP. OTHERWISE THE CUBIC STEP IS DEFINED TO BE
+C     EITHER STPMIN OR STPMAX. THE QUADRATIC (SECANT) STEP IS ALSO
+C     COMPUTED AND IF THE MINIMUM IS BRACKETED THEN THE THE STEP
+C     CLOSEST TO STX IS TAKEN, ELSE THE STEP FARTHEST AWAY IS TAKEN.
+C
+      ELSE IF (DABS(DP) .LT. DABS(DX)) THEN
+         INFO = 3
+         BOUND = .TRUE.
+         THETA = 3*(FX - FP)/(STP - STX) + DX + DP
+         S = MAX(DABS(THETA),DABS(DX),DABS(DP))
+C
+C        THE CASE GAMMA = 0 ONLY ARISES IF THE CUBIC DOES NOT TEND
+C        TO INFINITY IN THE DIRECTION OF THE STEP.
+C
+         GAMMA = S*DSQRT(MAX(0.0D0,(THETA/S)**2 - (DX/S)*(DP/S)))
+         IF (STP .GT. STX) GAMMA = -GAMMA
+         P = (GAMMA - DP) + THETA
+         Q = (GAMMA + (DX - DP)) + GAMMA
+         R = P/Q
+         IF (R .LT. 0.0D0 .AND. GAMMA .NE. 0.0D0) THEN
+            STPC = STP + R*(STX - STP)
+         ELSE IF (STP .GT. STX) THEN
+            STPC = STPMAX
+         ELSE
+            STPC = STPMIN
+            END IF
+         STPQ = STP + (DP/(DP-DX))*(STX - STP)
+         IF (BRACKT) THEN
+            IF (DABS(STP-STPC) .LT. DABS(STP-STPQ)) THEN
+               STPF = STPC
+            ELSE
+               STPF = STPQ
+               END IF
+         ELSE
+            IF (DABS(STP-STPC) .GT. DABS(STP-STPQ)) THEN
+               STPF = STPC
+            ELSE
+               STPF = STPQ
+               END IF
+            END IF
+C
+C     FOURTH CASE. A LOWER FUNCTION VALUE, DERIVATIVES OF THE
+C     SAME SIGN, AND THE MAGNITUDE OF THE DERIVATIVE DOES
+C     NOT DECREASE. IF THE MINIMUM IS NOT BRACKETED, THE STEP
+C     IS EITHER STPMIN OR STPMAX, ELSE THE CUBIC STEP IS TAKEN.
+C
+      ELSE
+         INFO = 4
+         BOUND = .FALSE.
+         IF (BRACKT) THEN
+            THETA = 3*(FP - FY)/(STY - STP) + DY + DP
+            S = MAX(DABS(THETA),DABS(DY),DABS(DP))
+            GAMMA = S*DSQRT((THETA/S)**2 - (DY/S)*(DP/S))
+            IF (STP .GT. STY) GAMMA = -GAMMA
+            P = (GAMMA - DP) + THETA
+            Q = ((GAMMA - DP) + GAMMA) + DY
+            R = P/Q
+            STPC = STP + R*(STY - STP)
+            STPF = STPC
+         ELSE IF (STP .GT. STX) THEN
+            STPF = STPMAX
+         ELSE
+            STPF = STPMIN
+            END IF
+         END IF
+C
+C     UPDATE THE INTERVAL OF UNCERTAINTY. THIS UPDATE DOES NOT
+C     DEPEND ON THE NEW STEP OR THE CASE ANALYSIS ABOVE.
+C
+      IF (FP .GT. FX) THEN
+         STY = STP
+         FY = FP
+         DY = DP
+      ELSE
+         IF (SGND .LT. 0.0D0) THEN
+            STY = STX
+            FY = FX
+            DY = DX
+            END IF
+         STX = STP
+         FX = FP
+         DX = DP
+         END IF
+C
+C     COMPUTE THE NEW STEP AND SAFEGUARD IT.
+C
+      STPF = MIN(STPMAX,STPF)
+      STPF = MAX(STPMIN,STPF)
+      STP = STPF
+      IF (BRACKT .AND. BOUND) THEN
+         IF (STY .GT. STX) THEN
+            STP = MIN(STX+0.66D0*(STY-STX),STP)
+         ELSE
+            STP = MAX(STX+0.66D0*(STY-STX),STP)
+            END IF
+         END IF
+      RETURN
+C
+C     LAST LINE OF SUBROUTINE MCSTEP.
+C
+      END
+
diff -pbBEwurNa --ignore-matching-lines='.*vc_id.*' HTK-3.4.1/HTKLib/lbfgs.h HTS-2.2_for_HTK-3.4.1/HTKLib/lbfgs.h
--- HTK-3.4.1/HTKLib/lbfgs.h	1970-01-01 09:00:00.000000000 +0900
+++ HTS-2.2_for_HTK-3.4.1/HTKLib/lbfgs.h	2011-06-16 13:18:29.000000000 +0900
@@ -0,0 +1,96 @@
+/* ----------------------------------------------------------------- */
+/*           The HMM-Based Speech Synthesis System (HTS)             */
+/*           developed by HTS Working Group                          */
+/*           http://hts.sp.nitech.ac.jp/                             */
+/* ----------------------------------------------------------------- */
+/*                                                                   */
+/*  Copyright (c) 2001-2011  Nagoya Institute of Technology          */
+/*                           Department of Computer Science          */
+/*                                                                   */
+/*                2001-2008  Tokyo Institute of Technology           */
+/*                           Interdisciplinary Graduate School of    */
+/*                           Science and Engineering                 */
+/*                                                                   */
+/* All rights reserved.                                              */
+/*                                                                   */
+/* Redistribution and use in source and binary forms, with or        */
+/* without modification, are permitted provided that the following   */
+/* conditions are met:                                               */
+/*                                                                   */
+/* - Redistributions of source code must retain the above copyright  */
+/*   notice, this list of conditions and the following disclaimer.   */
+/* - Redistributions in binary form must reproduce the above         */
+/*   copyright notice, this list of conditions and the following     */
+/*   disclaimer in the documentation and/or other materials provided */
+/*   with the distribution.                                          */
+/* - Neither the name of the HTS working group nor the names of its  */
+/*   contributors may be used to endorse or promote products derived */
+/*   from this software without specific prior written permission.   */
+/*                                                                   */
+/* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND            */
+/* CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,       */
+/* INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF          */
+/* MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE          */
+/* DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS */
+/* BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,          */
+/* EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED   */
+/* TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,     */
+/* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON */
+/* ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,   */
+/* OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY    */
+/* OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE           */
+/* POSSIBILITY OF SUCH DAMAGE.                                       */
+/* ----------------------------------------------------------------- */
+/*         File: lbfgs.h: L-BFGS routine                             */
+/* ----------------------------------------------------------------- */
+
+/* 
+
+ This L-BFGS FORTRAN source code is originally distributed in
+
+   http://www.ece.northwestern.edu/~nocedal/lbfgs.html
+
+ We thank Prof. Jorge Nocedal of Northwestern University for permission to 
+ redistribute this LBFGS code in the HTS releases.
+
+
+ L-BFGS: Software for Large-scale Unconstrained Optimization
+   
+   L-BFGS is a limited-memory quasi-Newton code for unconstrained optimization. 
+   The code has been developed at the Optimization Technology Center, a joint 
+   venture of Argonne National Laboratory and Northwestern University.
+
+ Condition for Use: 
+
+   This software is freely available for educational or commercial purposes. We 
+   expect that all publications describing work using this software quote at 
+   least one of the references given below.
+
+ References
+
+   * J. Nocedal, "Updating Quasi-Newton Matrices with Limited Storage," 
+     Mathematics of Computation 35, pp. 773-782, 1980.
+
+   * D.C. Liu and J. Nocedal, "On the Limited Memory BFGS Method for Large Scale 
+     Optimization," Mathematical Programming B, 45, 3, pp. 503-528, 1989.
+
+*/
+
+#ifndef _LBFGS_H_
+#define _LBFGS_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif 
+
+void lbfgs_(int* n, int* m, double* x, double* f, double* g,
+            int* diagco, double* diag, int* iprint, double* eps,
+            double* xtol, double* w, int* iflag);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif  /* _LBFGS_H_ */
+
+/* ------------------------ End of lbfgs.h ------------------------- */
diff -pbBEwurNa --ignore-matching-lines='.*vc_id.*' HTK-3.4.1/HTKTools/HBuild.c HTS-2.2_for_HTK-3.4.1/HTKTools/HBuild.c
--- HTK-3.4.1/HTKTools/HBuild.c	2009-03-13 03:51:28.000000000 +0900
+++ HTS-2.2_for_HTK-3.4.1/HTKTools/HBuild.c	2011-06-16 13:18:29.000000000 +0900
@@ -19,8 +19,53 @@
 /*     File: HBuild.c:  Word-Lattice Building                  */
 /* ----------------------------------------------------------- */
 
+/*  *** THIS IS A MODIFIED VERSION OF HTK ***                        */
+/* ----------------------------------------------------------------- */
+/*           The HMM-Based Speech Synthesis System (HTS)             */
+/*           developed by HTS Working Group                          */
+/*           http://hts.sp.nitech.ac.jp/                             */
+/* ----------------------------------------------------------------- */
+/*                                                                   */
+/*  Copyright (c) 2001-2011  Nagoya Institute of Technology          */
+/*                           Department of Computer Science          */
+/*                                                                   */
+/*                2001-2008  Tokyo Institute of Technology           */
+/*                           Interdisciplinary Graduate School of    */
+/*                           Science and Engineering                 */
+/*                                                                   */
+/* All rights reserved.                                              */
+/*                                                                   */
+/* Redistribution and use in source and binary forms, with or        */
+/* without modification, are permitted provided that the following   */
+/* conditions are met:                                               */
+/*                                                                   */
+/* - Redistributions of source code must retain the above copyright  */
+/*   notice, this list of conditions and the following disclaimer.   */
+/* - Redistributions in binary form must reproduce the above         */
+/*   copyright notice, this list of conditions and the following     */
+/*   disclaimer in the documentation and/or other materials provided */
+/*   with the distribution.                                          */
+/* - Neither the name of the HTS working group nor the names of its  */
+/*   contributors may be used to endorse or promote products derived */
+/*   from this software without specific prior written permission.   */
+/*                                                                   */
+/* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND            */
+/* CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,       */
+/* INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF          */
+/* MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE          */
+/* DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS */
+/* BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,          */
+/* EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED   */
+/* TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,     */
+/* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON */
+/* ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,   */
+/* OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY    */
+/* OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE           */
+/* POSSIBILITY OF SUCH DAMAGE.                                       */
+/* ----------------------------------------------------------------- */
+
 char *hbuild_version = "!HVER!HBuild:   3.4.1 [CUED 12/03/09]";
-char *hbuild_vc_id = "$Id: HBuild.c,v 1.1.1.1 2006/10/11 09:54:59 jal58 Exp $";
+char *hbuild_vc_id = "$Id: HBuild.c,v 1.12 2011/06/16 04:18:29 uratec Exp $";
 
 /* The HBuild program takes input files in a number of different
    formats and constructs suitable HTK word lattice files.
@@ -85,6 +130,7 @@ void SetConfParms(void)
 
 void ReportUsage(void)
 {
+   printf("\nModified for HTS\n");
    printf("\nUSAGE: HBuild [options] wordList latFile\n\n");
    printf(" Option                                       Default\n\n");
    printf(" -b      binary lattice output                ASCII\n");
@@ -261,6 +307,15 @@ int main(int argc, char *argv[])
    default:
       HError(3001,"Only Bigram LMs / multiLats currently implemented");
    }
+
+   ResetLM();
+   ResetNet();
+   ResetDict();
+   ResetMath();
+   ResetLabel();
+   ResetMem();
+   ResetShell();
+
    Exit(0);
    return (0);          /* never reached -- make compiler happy */
 }
@@ -415,7 +470,7 @@ Lattice *ProcessBoBiGram(MemHeap *latHea
                 nLM->wdlist[i]->name);
       ln = lat->lnodes+j;
       ln->word = wd; ln->n=0; ln->v=0;
-      wd->aux = (Ptr) j;
+      wd->aux = (Ptr)((long) j);
       if (nLM->wdlist[i] != enterId) {
          la = lat->larcs+k;
          la->start = lat->lnodes;
@@ -436,7 +491,7 @@ Lattice *ProcessBoBiGram(MemHeap *latHea
       ndx[0] = i;
       ne = GetNEntry(nLM,ndx,FALSE);
       fromWd =  GetWord(voc,nLM->wdlist[i],FALSE);
-      fromNode =  lat->lnodes+((int) fromWd->aux);
+      fromNode =  lat->lnodes+((long) fromWd->aux);
       la->start = fromNode;    /* backoff weight */
       la->end = lat->lnodes;
       if (ne==NULL) la->lmlike = 0.0;
@@ -447,7 +502,7 @@ Lattice *ProcessBoBiGram(MemHeap *latHea
             if ((nLM->wdlist[se->word] == unknownId) && zapUnknown)
                continue;
             toWd = GetWord(voc,nLM->wdlist[se->word],FALSE);
-            toNode = lat->lnodes+((int) toWd->aux);
+            toNode = lat->lnodes+((long) toWd->aux);
             if (nLM->wdlist[se->word] != enterId) {
                la->start = fromNode;
                la->end = toNode;
@@ -493,7 +548,7 @@ Lattice *ProcessMatBiGram(MemHeap *latHe
                 bg->wdlist[i]->name);
       ln = lat->lnodes+j;
       ln->word = wd; ln->n=0; ln->v=0;
-      wd->aux = (Ptr) j;
+      wd->aux = (Ptr)((long) j);
       j++;
    }
    lat->nn = j;
@@ -502,12 +557,12 @@ Lattice *ProcessMatBiGram(MemHeap *latHe
    for (i=1,j=0; i < bg->numWords; i++) {
       row = bg->bigMat[i];
       fromWd =  GetWord(voc,bg->wdlist[i],FALSE);
-      fromNode =  lat->lnodes+((int) fromWd->aux);
+      fromNode =  lat->lnodes+((long) fromWd->aux);
       if (i == skipWord) continue;
       for (j=2; j <= (i==1?bg->numWords-1:bg->numWords); j++) {
          if (j == skipWord) continue;
          toWd = GetWord(voc,bg->wdlist[j],FALSE);
-         toNode = lat->lnodes+((int) toWd->aux);
+         toNode = lat->lnodes+((long) toWd->aux);
          la->start = fromNode;
          la->end = toNode;
          la->lmlike = row[j];
@@ -578,7 +633,7 @@ Boolean SkipHeader(FILE *f)
       ch = getc(f);
    if (ch == '/') {
       ch = getc(f);      
-      inComment = (ch == '*');
+      inComment = (ch == '*') ? TRUE:FALSE;
       if (!inComment)
          HError(3040,"SkipHeader: / char illegal if not in comment or delimiter");  
       else
@@ -586,7 +641,7 @@ Boolean SkipHeader(FILE *f)
             ch = getc(f);
             if (ch == '*') {
                ch = getc(f);
-               inComment = (ch != '/');
+               inComment = (ch != '/') ? TRUE:FALSE;
             }
          }
    }     
@@ -632,7 +687,7 @@ void NumberEntries(WPGrammar *wpg, Word 
 void ReadWPGrammar(WPGrammar *wpg, Vocab * voc, char *gramFn)
 {
    FILE *gf;
-   char buf[255];
+   char buf[MAXSTRLEN];
    int ch;
    Word newWord;
    GramEntry *newGram = NULL;
@@ -650,7 +705,7 @@ void ReadWPGrammar(WPGrammar *wpg, Vocab
       HError(3040,"ReadWPGrammar: Unexpected eof while reading %s", gramFn);
    do {
       ch = getc(gf);
-      newEntry = (ch == '>');
+      newEntry = (ch == '>') ? TRUE:FALSE;
       if (wpg->nwords == 0 && !newEntry)
          HError(3040,"ReadWPGrammar: > expected while reading %s", gramFn);
       if (!ReadLabel(gf,buf)) {
@@ -747,8 +802,6 @@ Lattice *ProcessWordPair(MemHeap *latHea
    return lat;
 }
 
-
-/* ------------------- End of HBuild.c --------------------------------- */
-
-
-
+/* ----------------------------------------------------------- */
+/*                      END:  HBuild.c                         */
+/* ----------------------------------------------------------- */
diff -pbBEwurNa --ignore-matching-lines='.*vc_id.*' HTK-3.4.1/HTKTools/HCompV.c HTS-2.2_for_HTK-3.4.1/HTKTools/HCompV.c
--- HTK-3.4.1/HTKTools/HCompV.c	2009-03-13 03:51:37.000000000 +0900
+++ HTS-2.2_for_HTK-3.4.1/HTKTools/HCompV.c	2011-06-16 13:18:29.000000000 +0900
@@ -32,8 +32,53 @@
 /*  File: HCompV.c: HMM global mean/variance initialisation    */
 /* ----------------------------------------------------------- */
 
+/*  *** THIS IS A MODIFIED VERSION OF HTK ***                        */
+/* ----------------------------------------------------------------- */
+/*           The HMM-Based Speech Synthesis System (HTS)             */
+/*           developed by HTS Working Group                          */
+/*           http://hts.sp.nitech.ac.jp/                             */
+/* ----------------------------------------------------------------- */
+/*                                                                   */
+/*  Copyright (c) 2001-2011  Nagoya Institute of Technology          */
+/*                           Department of Computer Science          */
+/*                                                                   */
+/*                2001-2008  Tokyo Institute of Technology           */
+/*                           Interdisciplinary Graduate School of    */
+/*                           Science and Engineering                 */
+/*                                                                   */
+/* All rights reserved.                                              */
+/*                                                                   */
+/* Redistribution and use in source and binary forms, with or        */
+/* without modification, are permitted provided that the following   */
+/* conditions are met:                                               */
+/*                                                                   */
+/* - Redistributions of source code must retain the above copyright  */
+/*   notice, this list of conditions and the following disclaimer.   */
+/* - Redistributions in binary form must reproduce the above         */
+/*   copyright notice, this list of conditions and the following     */
+/*   disclaimer in the documentation and/or other materials provided */
+/*   with the distribution.                                          */
+/* - Neither the name of the HTS working group nor the names of its  */
+/*   contributors may be used to endorse or promote products derived */
+/*   from this software without specific prior written permission.   */
+/*                                                                   */
+/* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND            */
+/* CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,       */
+/* INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF          */
+/* MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE          */
+/* DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS */
+/* BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,          */
+/* EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED   */
+/* TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,     */
+/* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON */
+/* ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,   */
+/* OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY    */
+/* OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE           */
+/* POSSIBILITY OF SUCH DAMAGE.                                       */
+/* ----------------------------------------------------------------- */
+
 char *hcompv_version = "!HVER!HCompV:   3.4.1 [CUED 12/03/09]";
-char *hcompv_vc_id = "$Id: HCompV.c,v 1.1.1.1 2006/10/11 09:54:59 jal58 Exp $";
+char *hcompv_vc_id = "$Id: HCompV.c,v 1.13 2011/06/16 04:18:29 uratec Exp $";
 
 
 /* 
@@ -87,10 +132,11 @@ static FileFormat lff=UNDEFF;       /* l
 static char *hmmfn=NULL;            /* HMM definition file name */
 static char *outfn=NULL;            /* output HMM file name (name only) */
 static char *outDir=NULL;           /* HMM output directory */
-static long totalCount=0;           /* total number of vector samples*/
 static Boolean meanUpdate = FALSE;  /* update means  */
 static Boolean saveBinary = FALSE;  /* save output in binary  */
 static float vFloorScale = 0.0;     /* if >0.0 then vFloor scaling */
+static Vector vFloorScaleStr = NULL; /* vFloorScale for each stream */
+static int nShowElem = 12;           /* # of elements to be shown */
 
 /* Major Data Structures */
 static MLink macroLink;             /* Link to specific HMM macro */
@@ -101,9 +147,11 @@ static MemHeap iStack;
 
 /* Storage for mean and covariance accumulators */
 typedef struct {
-   Vector       meanSum;            /* acc for mean vector value */
-   Covariance   squareSum;          /* acc for sum of squares */
+   DVector      meanSum;            /* acc for mean vector value */
+   DMatrix      inv;                /* acc for sum of squares (full) */
+   DVector      var;                /* acc for sum of squares (diag) */
    Covariance   fixed;              /* fixed (co)variance values */
+   long         totalCount;         /* total number of vector samples */
 } CovAcc;
 static CovAcc accs[SMAX];           /* one CovAcc for each stream */
 static Boolean fullcNeeded[SMAX];   /* true for each stream that needs full
@@ -143,18 +191,24 @@ void SetConfParms(void)
    Boolean b,c;
    int i;
    double d;
+   char buf[MAXSTRLEN];
    
    nParm = GetConfig("HCOMPV", TRUE, cParm, MAXGLOBS);
    if (nParm>0) {
       if (GetConfInt(cParm,nParm,"TRACE",&i)) trace = i;
       if (GetConfBool(cParm,nParm,"UPDATEMEANS",&b)) meanUpdate = b;
       if (GetConfBool(cParm,nParm,"SAVEBINARY",&c)) saveBinary = c;
+      if (GetConfInt(cParm,nParm,"NSHOWELEM",&i)) nShowElem = i;
       if (GetConfFlt(cParm,nParm,"MINVARFLOOR",&d)) minVar = d;
+      if (GetConfFlt(cParm,nParm,"VFLOORSCALE",&d)) vFloorScale = d;
+      if (GetConfStr(cParm,nParm,"VFLOORSCALESTR",buf))
+         vFloorScaleStr = ParseConfVector(&gstack,buf,TRUE);
    }
 }
 
 void ReportUsage(void)
 {
+   printf("\nModified for HTS\n");
    printf("\nUSAGE: HCompV [options] [hmmFile] trainFiles...\n" );
    printf(" Option                                       Default\n\n");
    printf(" -c dir  Set output directiry for CMV         none\n");
@@ -179,16 +233,19 @@ void CheckVarianceKind(void)
    int i,s,m;
    StateElem *se;
    StreamElem *ste;
+   StreamInfo *sti;
    MixtureElem *me;
    
    for (s=1;s<=hset.swidth[0];s++)
       fullcNeeded[s]=FALSE;
    for (i=2,se=hmmLink->svec+2; i < hmmLink->numStates; i++,se++)
-      for (s=1,ste=se->info->pdf+1; s <= hset.swidth[0]; s++,ste++)
-         for (m=1,me = ste->spdf.cpdf+1; m<=ste->nMix; m++, me++)
+      for (s=1,ste=se->info->pdf+1; s <= hset.swidth[0]; s++,ste++) {
+         sti = ste->info;
+         for (m=1,me = sti->spdf.cpdf+1; m<=sti->nMix; m++, me++)
             if (me->mpdf->ckind == FULLC) 
                fullcNeeded[s] = TRUE;
 }
+}
 
 /* Initialise: load HMMs and create accumulators */
 void Initialise(void)
@@ -224,18 +281,19 @@ void Initialise(void)
    /* Create accumulators for the mean and variance */
    for (s=1;s<=hset.swidth[0]; s++){
       V = hset.swidth[s];
-      accs[s].meanSum=CreateVector(&gstack,V);
-      ZeroVector(accs[s].meanSum);
+      accs[s].meanSum=CreateDVector(&gstack,V);
+      ZeroDVector(accs[s].meanSum);
       if (fullcNeeded[s]) {
-         accs[s].squareSum.inv=CreateSTriMat(&gstack,V);
-         accs[s].fixed.inv=CreateSTriMat(&gstack,V);
-         ZeroTriMat(accs[s].squareSum.inv);
+         accs[s].inv=CreateDMatrix(&gstack,V,V);
+         accs[s].fixed.inv=CreateTriMat(&gstack,V);
+         ZeroDMatrix(accs[s].inv);
       }
       else {
-         accs[s].squareSum.var=CreateSVector(&gstack,V);
-         accs[s].fixed.var=CreateSVector(&gstack,V);
-         ZeroVector(accs[s].squareSum.var);
+         accs[s].var=CreateDVector(&gstack,V);
+         accs[s].fixed.var=CreateVector(&gstack,V);
+         ZeroDVector(accs[s].var);
       }
+      accs[s].totalCount = 0;
    }
 
    /* Create an object to hold the input parameters */
@@ -245,6 +303,13 @@ void Initialise(void)
       segId = GetLabId(segLab,TRUE);
    }
 
+   /* Check threshold */
+   if (vFloorScaleStr==NULL) {
+      vFloorScaleStr = CreateVector(&gstack, hset.swidth[0]);
+      for (s=1; s<=hset.swidth[0]; s++)
+         vFloorScaleStr[s] = vFloorScale;
+   }
+   
    if (trace&T_TOP) {
       printf("Calculating Fixed Variance\n");
       printf("  HMM Prototype: %s\n",hmmfn);
@@ -260,16 +325,17 @@ void Initialise(void)
 /* CalcCovs: calculate covariance of speech data */
 void CalcCovs(void)
 {
-   int x,y,s,V;
-   float meanx,meany,varxy,n;
+   int i,j,x,y,s,V;
+   double meanx,meany,varxy,n;
    Matrix fullMat;
+   TriMat triMat;
    
-   if (totalCount<2)
-      HError(2021,"CalcCovs: Only %d speech frames accumulated",totalCount);
-   if (trace&T_TOP)
-      printf("%ld speech frames accumulated\n", totalCount);
-   n = (float)totalCount;     /* to prevent rounding to integer below */
    for (s=1; s<=hset.swidth[0]; s++){  /* For each stream   */
+      if (accs[s].totalCount<2)
+         HError(2021,"CalcCovs: Only %ld speech frames accumulated for stream %d", accs[s].totalCount, s);
+      if (trace&T_TOP)
+         printf("%ld speech frames accumulated for stream %d\n", accs[s].totalCount, s);
+      n = (double)accs[s].totalCount; /* to prevent rounding to integer below */
       V = hset.swidth[s];
       for (x=1; x<=V; x++)            /* For each coefficient ... */
          accs[s].meanSum[x] /= n;         /* ... calculate mean */
@@ -278,31 +344,43 @@ void CalcCovs(void)
          if (fullcNeeded[s]) {
             for (y=1; y<=x; y++) {
                meany = accs[s].meanSum[y];
-               varxy = accs[s].squareSum.inv[x][y]/n - meanx*meany;
-               accs[s].squareSum.inv[x][y] =
-                  (x != y || varxy > minVar) ? varxy : minVar;    
+               varxy = accs[s].inv[x][y]/n - meanx*meany;
+               accs[s].inv[x][y] =
+                  (x != y || varxy > (double)minVar) ? varxy : (double)minVar;    
             }
          }
          else {
-            varxy = accs[s].squareSum.var[x]/n - meanx*meanx;
-            accs[s].fixed.var[x] = (varxy > minVar) ? varxy :minVar;
+            varxy = accs[s].var[x]/n - meanx*meanx;
+            accs[s].fixed.var[x] = (varxy > (double)minVar) ? (float)varxy : minVar;
          }
       }
       if (fullcNeeded[s]) { /* invert covariance matrix */
+         /* prepare temporaly full & triangle matrices */
+         triMat=CreateTriMat(&gstack,V);
          fullMat=CreateMatrix(&gstack,V,V);
          ZeroMatrix(fullMat); 
-         CovInvert(accs[s].squareSum.inv,fullMat);
+         
+         /* copy full double matrix to triangular float matrix */
+         for (i=1; i<=V; i++)
+            for (j=1; j<=i; j++) 
+               triMat[i][j] = (float)accs[s].inv[i][j];
+
+         /* Covariance -> InvCov */
+         CovInvert(triMat,fullMat);
          Mat2Tri(fullMat,accs[s].fixed.inv);
+         
+         /* Free temporaly full & triangle matrices */
          FreeMatrix(&gstack,fullMat);
+         FreeTriMat(&gstack,triMat);
       }
       if (trace&T_COVS) {
          printf("Stream %d\n",s);
          if (meanUpdate)
-            ShowVector(" Mean Vector ", accs[s].meanSum,12);
+            ShowDVector(" Mean Vector ", accs[s].meanSum, nShowElem);
          if (fullcNeeded[s]) {
-            ShowTriMat(" Covariance Matrix ",accs[s].squareSum.inv,12,12);
+            ShowTriMat(" Inverse Covariance Matrix ",accs[s].fixed.inv,nShowElem,nShowElem);
          } else
-            ShowVector(" Variance Vector ", accs[s].fixed.var,12);
+            ShowVector(" Variance Vector ", accs[s].fixed.var,nShowElem);
       }
    }
 }
@@ -322,9 +400,10 @@ void TriDiag2Vector(TriMat m, Vector v)
 /* SetCovs: set covariance values in hmm */
 void SetCovs(void)
 {
-   int i,s,m;
+   int i,k,s,m;
    StateElem *se;
    StreamElem *ste;
+   StreamInfo *sti;
    MixtureElem *me;
    MixPDF *mp;
 
@@ -335,23 +414,33 @@ void SetCovs(void)
       printf("Covariances\n");
    }
    for (i=2,se=hmmLink->svec+2; i < hmmLink->numStates; i++,se++)
-      for (s=1,ste=se->info->pdf+1; s <= hset.swidth[0]; s++,ste++)
-         for (m=1,me = ste->spdf.cpdf+1; m<=ste->nMix; m++, me++) {
+      for (s=1,ste=se->info->pdf+1; s <= hset.swidth[0]; s++,ste++) {
+         sti = ste->info;
+         for (m=1,me = sti->spdf.cpdf+1; m<=sti->nMix; m++, me++) {
             mp = me->mpdf;
             if (meanUpdate && !IsSeenV(mp->mean)){      /* meanSum now holds mean */
-               CopyVector(accs[s].meanSum,mp->mean); 
+               if ( VectorSize(mp->mean)==DVectorSize(accs[s].meanSum) )
+                  for (k=1;k<=VectorSize(mp->mean);k++)
+                     mp->mean[k] = (float)accs[s].meanSum[k];
                TouchV(mp->mean);
             }
             if (!IsSeenV(mp->cov.var)){
-               if (mp->ckind==FULLC)
+               if (mp->ckind==FULLC) {
+                  if ( TriMatSize(accs[s].fixed.inv)==TriMatSize(mp->cov.inv) )
                   CopyMatrix(accs[s].fixed.inv,mp->cov.inv);
-               else if (fullcNeeded[s])  /* dont need full cov, but its all we have */                
+               }
+               else if (fullcNeeded[s]) {  /* dont need full cov, but its all we have */                
+                  if ( TriMatSize(accs[s].fixed.inv)==VectorSize(mp->cov.var) )
                   TriDiag2Vector(accs[s].fixed.inv,mp->cov.var);
-               else
+               }
+               else {
+                  if ( VectorSize(mp->cov.var)==VectorSize(accs[s].fixed.var) )
                   CopyVector(accs[s].fixed.var,mp->cov.var);
+               }
                TouchV(mp->cov.var);
             }
          }
+      }
    ClearSeenFlags(&hset,CLR_ALL);
 }
 
@@ -372,11 +461,12 @@ void PutVFloor(void)
       strcpy(vName,"varFloor"); strcat(vName,num);
       fprintf(f,"~v %s\n",vName);
       if (fullcNeeded[s])              
-         TriDiag2Vector(accs[s].squareSum.inv,v);
+         for (i=1;i<=hset.swidth[s];i++)
+            v[i] = (float)accs[s].inv[i][i];
       else
          CopyVector(accs[s].fixed.var,v);
       for (i=1; i<=hset.swidth[s]; i++)
-         v[i] *= vFloorScale;
+         v[i] *= vFloorScaleStr[s];
       fprintf(f,"<Variance> %d\n",hset.swidth[s]);
       WriteVector(f,v,FALSE);
       FreeVector(&gstack,v);
@@ -392,21 +482,23 @@ void PutVFloor(void)
 void AccVar(Observation obs)
 {
    int x,y,s,V;
-   float val;
+   double val;
    Vector v;
 
-   totalCount++;
    for (s=1; s<=hset.swidth[0]; s++){
       v = obs.fv[s]; V = hset.swidth[s];
+      if (SpaceOrder(v)==V) {
       for (x=1;x<=V;x++) { 
-         val=v[x];            
+            val=(double)v[x];            
          accs[s].meanSum[x] += val;     /* accumulate mean */                             
          if (fullcNeeded[s]) {          /* accumulate covar */ 
-            accs[s].squareSum.inv[x][x] += val*val;
+               accs[s].inv[x][x] += val*val;
             for (y=1;y<x;y++) 
-               accs[s].squareSum.inv[x][y] += val*v[y];
+                  accs[s].inv[x][y] += val*(double)v[y];
          } else                         /* accumulate var */
-            accs[s].squareSum.var[x] += val*val;
+               accs[s].var[x] += val*val;
+         }
+         accs[s].totalCount++;   /* accumulate occ */
       }
    }
 }
@@ -427,7 +519,7 @@ void LoadFile(char *fn)
 {
    ParmBuf pbuf;
    BufferInfo info;
-   char labfn[80];
+   char labfn[MAXSTRLEN];
    Transcription *trans;
    long segStIdx,segEnIdx;  
    int i,j,ncas,nObs;
@@ -758,6 +850,7 @@ int main(int argc, char *argv[])
    InitVQ();    InitModel();
    if(InitParm()<SUCCESS)  
       HError(2000,"HCompV: InitParm failed");
+   InitUtil();
 
    if (!InfoPrinted() && NumArgs() == 0)
       ReportUsage();
@@ -884,8 +977,8 @@ int main(int argc, char *argv[])
       SaveModel(outfn);   
       if (trace&T_TOP)
          printf("Output written to directory %s\n",(outDir==NULL)?"./":outDir);
-      if (vFloorScale>0.0)
          PutVFloor();
+      FreeVector(&gstack,vFloorScaleStr);
    }
    else {
       /* report export data type */
@@ -909,6 +1002,17 @@ int main(int argc, char *argv[])
       ExportNMV(salist,cmDir,TargetPKStr);
    }
 
+   ResetParm();
+   ResetModel();
+   ResetVQ();
+   ResetAudio();
+   ResetWave();
+   ResetSigP();
+   ResetMath();
+   ResetLabel();
+   ResetMem();
+   ResetShell();   
+   
    Exit(0);
    return (0);          /* never reached -- make compiler happy */
 }
diff -pbBEwurNa --ignore-matching-lines='.*vc_id.*' HTK-3.4.1/HTKTools/HCopy.c HTS-2.2_for_HTK-3.4.1/HTKTools/HCopy.c
--- HTK-3.4.1/HTKTools/HCopy.c	2009-03-13 03:51:45.000000000 +0900
+++ HTS-2.2_for_HTK-3.4.1/HTKTools/HCopy.c	2011-06-16 13:18:29.000000000 +0900
@@ -19,8 +19,53 @@
 /*      File: HCopy.c: Copy one Speech File to another         */
 /* ----------------------------------------------------------- */
 
+/*  *** THIS IS A MODIFIED VERSION OF HTK ***                        */
+/* ----------------------------------------------------------------- */
+/*           The HMM-Based Speech Synthesis System (HTS)             */
+/*           developed by HTS Working Group                          */
+/*           http://hts.sp.nitech.ac.jp/                             */
+/* ----------------------------------------------------------------- */
+/*                                                                   */
+/*  Copyright (c) 2001-2011  Nagoya Institute of Technology          */
+/*                           Department of Computer Science          */
+/*                                                                   */
+/*                2001-2008  Tokyo Institute of Technology           */
+/*                           Interdisciplinary Graduate School of    */
+/*                           Science and Engineering                 */
+/*                                                                   */
+/* All rights reserved.                                              */
+/*                                                                   */
+/* Redistribution and use in source and binary forms, with or        */
+/* without modification, are permitted provided that the following   */
+/* conditions are met:                                               */
+/*                                                                   */
+/* - Redistributions of source code must retain the above copyright  */
+/*   notice, this list of conditions and the following disclaimer.   */
+/* - Redistributions in binary form must reproduce the above         */
+/*   copyright notice, this list of conditions and the following     */
+/*   disclaimer in the documentation and/or other materials provided */
+/*   with the distribution.                                          */
+/* - Neither the name of the HTS working group nor the names of its  */
+/*   contributors may be used to endorse or promote products derived */
+/*   from this software without specific prior written permission.   */
+/*                                                                   */
+/* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND            */
+/* CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,       */
+/* INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF          */
+/* MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE          */
+/* DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS */
+/* BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,          */
+/* EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED   */
+/* TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,     */
+/* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON */
+/* ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,   */
+/* OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY    */
+/* OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE           */
+/* POSSIBILITY OF SUCH DAMAGE.                                       */
+/* ----------------------------------------------------------------- */
+
 char *hcopy_version = "!HVER!HCopy:   3.4.1 [CUED 12/03/09]";
-char *hcopy_vc_id = "$Id: HCopy.c,v 1.1.1.1 2006/10/11 09:54:59 jal58 Exp $";
+char *hcopy_vc_id = "$Id: HCopy.c,v 1.10 2011/06/16 04:18:29 uratec Exp $";
 
 #include "HShell.h"
 #include "HMem.h"
@@ -90,7 +135,7 @@ static Wave wv;                 /* main 
 static ParmBuf pb;              /* main parmBuf; cat input, xform wv to this */
 static Transcription *trans=NULL;/* main labels; cat all input to this */
 static Transcription *tr;       /* current transcription */
-static char labFile[255];       /* current source of trans */
+static char labFile[MAXSTRLEN]; /* current source of trans */
 static HTime off = 0.0;         /* length of files appended so far */
 
 /* ---------------- Memory Management ------------------------- */
@@ -108,6 +153,7 @@ static MemHeap tStack;          /* trace
 
 void ReportUsage(void)
 {
+   printf("\nModified for HTS\n");
    printf("\nUSAGE: HCopy [options] src [ + src ...] tgt ...\n\n");
    printf(" Option                                       Default\n\n");
    printf(" -a i     Use level i labels                  1\n");
@@ -119,7 +165,7 @@ void ReportUsage(void)
    printf(" -s t     Start copy at time t                0\n");
    printf(" -t n     Set trace line width to n           70\n");
    printf(" -x s [n] Extract [n'th occ of] label  s      off\n");
-   PrintStdOpts("FGILPOX");
+   PrintStdOpts("FGILPOXS");
 }
 
 /* SetConfParms: set conf parms relevant to this tool */
@@ -317,6 +363,27 @@ int main(int argc, char *argv[])
    }
    if(useMLF) CloseMLFSaveFile();
    if (NumArgs() != 0) HError(-1019,"HCopy: Unused args ignored");
+   
+   if(InitShell(argc,argv,hcopy_version,hcopy_vc_id)<SUCCESS)
+      HError(1000,"HCopy: InitShell failed");
+   InitMem();   InitLabel();
+   InitMath();  InitSigP();
+   InitWave();  InitAudio();
+   InitVQ();    InitModel();
+   if(InitParm()<SUCCESS)  
+      HError(1000,"HCopy: InitParm failed");
+   
+   ResetParm();
+   ResetModel();
+   ResetVQ();
+   ResetAudio();
+   ResetWave();
+   ResetSigP();
+   ResetMath();
+   ResetLabel();
+   ResetMem();
+   ResetShell();
+   
    Exit(0);
    return (0);          /* never reached -- make compiler happy */
 }
@@ -550,7 +617,7 @@ Boolean IsWave(char *srcFile)
    short sampS,kind;
    Boolean isPipe,bSwap,isWave;
    
-   isWave = tgtPK == WAVEFORM;
+   isWave = (tgtPK == WAVEFORM) ? TRUE:FALSE;
    if (tgtPK == ANON){
       if ((srcFF == HTK || srcFF == ESIG) && srcFile != NULL){
          if ((f=FOpen(srcFile,WaveFilter,&isPipe)) == NULL)
@@ -568,7 +635,7 @@ Boolean IsWave(char *srcFile)
                       srcFile);             
             break;
          }
-         isWave = kind == WAVEFORM;
+         isWave = (kind == WAVEFORM) ? TRUE:FALSE;
          FClose(f,isPipe);
       } else
          isWave = TRUE;
diff -pbBEwurNa --ignore-matching-lines='.*vc_id.*' HTK-3.4.1/HTKTools/HDMan.c HTS-2.2_for_HTK-3.4.1/HTKTools/HDMan.c
--- HTK-3.4.1/HTKTools/HDMan.c	2009-03-13 03:51:53.000000000 +0900
+++ HTS-2.2_for_HTK-3.4.1/HTKTools/HDMan.c	2011-06-16 13:18:29.000000000 +0900
@@ -32,8 +32,53 @@
 /*    File: HDMan:   pronunciation dictionary manager          */
 /* ----------------------------------------------------------- */
 
+/*  *** THIS IS A MODIFIED VERSION OF HTK ***                        */
+/* ----------------------------------------------------------------- */
+/*           The HMM-Based Speech Synthesis System (HTS)             */
+/*           developed by HTS Working Group                          */
+/*           http://hts.sp.nitech.ac.jp/                             */
+/* ----------------------------------------------------------------- */
+/*                                                                   */
+/*  Copyright (c) 2001-2011  Nagoya Institute of Technology          */
+/*                           Department of Computer Science          */
+/*                                                                   */
+/*                2001-2008  Tokyo Institute of Technology           */
+/*                           Interdisciplinary Graduate School of    */
+/*                           Science and Engineering                 */
+/*                                                                   */
+/* All rights reserved.                                              */
+/*                                                                   */
+/* Redistribution and use in source and binary forms, with or        */
+/* without modification, are permitted provided that the following   */
+/* conditions are met:                                               */
+/*                                                                   */
+/* - Redistributions of source code must retain the above copyright  */
+/*   notice, this list of conditions and the following disclaimer.   */
+/* - Redistributions in binary form must reproduce the above         */
+/*   copyright notice, this list of conditions and the following     */
+/*   disclaimer in the documentation and/or other materials provided */
+/*   with the distribution.                                          */
+/* - Neither the name of the HTS working group nor the names of its  */
+/*   contributors may be used to endorse or promote products derived */
+/*   from this software without specific prior written permission.   */
+/*                                                                   */
+/* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND            */
+/* CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,       */
+/* INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF          */
+/* MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE          */
+/* DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS */
+/* BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,          */
+/* EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED   */
+/* TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,     */
+/* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON */
+/* ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,   */
+/* OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY    */
+/* OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE           */
+/* POSSIBILITY OF SUCH DAMAGE.                                       */
+/* ----------------------------------------------------------------- */
+
 char *hdman_version = "!HVER!HDMan:   3.4.1 [CUED 12/03/09]";
-char *hdman_vc_id = "$Id: HDMan.c,v 1.2 2006/12/07 11:09:08 mjfg Exp $";
+char *hdman_vc_id = "$Id: HDMan.c,v 1.12 2011/06/16 04:18:29 uratec Exp $";
 
 #include "HShell.h"
 #include "HMem.h"
@@ -206,6 +251,7 @@ void Summary(void)
 
 void ReportUsage(void)
 {
+   printf("\nModified for HTS\n");
    printf("\nUSAGE: HDMan [options] newDict srcDict1 srcDict2 ... \n\n");
    printf(" Option                                       Default\n\n");
    printf(" -a s    chars in s start comment lines       #\n");
@@ -222,7 +268,7 @@ void ReportUsage(void)
    printf(" -p f    load phone list stored in f\n");
    printf(" -t      tag output words with source         off\n");
    printf(" -w f    load word list stored in f\n");
-   PrintStdOpts("Q");
+   PrintStdOpts("QS");
    printf("\n\n");
 }
 
@@ -343,6 +389,13 @@ int main(int argc, char *argv[])
    EditAndMerge();
    if (isLogging)
       PrintLog();
+
+   ResetLabel();
+   ResetWave();
+   ResetMath();
+   ResetMem();
+   ResetShell();
+   
    Exit(0);
    return (0);          /* never reached -- make compiler happy */
 }
@@ -400,23 +453,23 @@ void PutPhone(LabId id)
    char buf[80];
    LabId baseId;
 
-   if (((int)id->aux == 0 || (int)id->aux == -1) && newPhones != NULL) {
+   if (((long)id->aux == 0 || (long)id->aux == -1) && newPhones != NULL) {
       fprintf(newPhones,"%s\n",ReWriteString(id->name,NULL,ESCAPE_CHAR));
       /* avoid printing it again */
-      id->aux = (Ptr)((int)id->aux - 2);
+      id->aux = (Ptr)((long)id->aux - 2);
    }
    strcpy(buf,id->name);
    TriStrip(buf);
    baseId=GetLabId(buf,TRUE);
-   if ((int)baseId->aux <= 0 ) {  /* not seen this label before */
-      if ((int)baseId->aux == 0 || (int)baseId->aux == -2){
+   if ((long)baseId->aux <= 0 ) {  /* not seen this label before */
+      if ((long)baseId->aux == 0 || (long)baseId->aux == -2){
          if (nNewPhones == MAXPVOC)
             HError(1430,"PutPhone: MAXPVOC exceeded");
          newList[nNewPhones++] = baseId;
       }
       baseId->aux = (Ptr)0;            
    }
-   baseId->aux = (Ptr)((int)baseId->aux + 1);
+   baseId->aux = (Ptr)((long)baseId->aux + 1);
 }
 
 /* ListNewPhones: list new phones to log file along with counts */
@@ -428,7 +481,7 @@ void ListNewPhones(void)
       fprintf(logF,"Def Phone Usage Counts\n");
       fprintf(logF,"---------------------\n");
       for (i=0; i<nDefPhones; i++) {
-         c = (int)defList[i]->aux;
+         c = (long)defList[i]->aux;
          if (c<0) c=0;
          fprintf(logF," %2d. %-5s : %5d\n",i+1,defList[i]->name,c);
       }
@@ -437,7 +490,7 @@ void ListNewPhones(void)
       fprintf(logF,"New Phone Usage Counts\n");
       fprintf(logF,"---------------------\n");
       for (i=0; i<nNewPhones; i++){
-         c = (int)newList[i]->aux;
+         c = (long)newList[i]->aux;
          if (c<0) c=0;
          fprintf(logF," %2d. %-5s : %5d\n",i+1, newList[i]->name,c);
       }
@@ -709,7 +762,7 @@ void SkipHeader(Source *src, int skipHea
 void CreateBuffer(char *dName, Boolean isInput)
 {
    DBuffer *db;
-   char buf[256],scriptFN[256],*src;
+   char buf[MAXSTRLEN],scriptFN[MAXFNAMELEN],*src;
    Boolean ReadNextWord(DBuffer *db);
 
    if (isInput) {
@@ -786,7 +839,7 @@ void LoadWordList(void)
       ReadString(&src,buf);
       wList[i] = GetLabId(buf,TRUE);
       if (!mustSort && i>0)  /* check in sort order */
-         mustSort = strcmp(wList[i-1]->name,buf) > 0;
+         mustSort = (strcmp(wList[i-1]->name,buf) > 0) ? TRUE:FALSE;
       SkipLine(&src);
    }
    CloseSource(&src);
@@ -800,7 +853,7 @@ void LoadWordList(void)
 /* UCase: convert id to upper case and return new id */
 LabId UCase(LabId id)
 {
-   static char s[255];
+   static char s[MAXSTRLEN];
    int len,i;
 
    strcpy(s,id->name);
@@ -813,7 +866,7 @@ LabId UCase(LabId id)
 /* LCase: convert id to lower case and return new id */
 LabId LCase(LabId id)
 {
-   static char s[255];
+   static char s[MAXSTRLEN];
    int len,i;
 
    strcpy(s,id->name);
@@ -946,7 +999,7 @@ Boolean ReadNextWord(DBuffer *db)
 void WriteEntry(FILE *f, LabId word, LabId outsym, Pronunciation *p, int margin, Boolean findNew)
 {
    int i,st,en;
-   char buf[256],m[20];
+   char buf[MAXSTRLEN],m[20];
    
    if (p->nPhone == 0) return;
    if (!nullOutput) {
@@ -1122,7 +1175,7 @@ void DelDefOp(WordBuf *wb, LabId *args)
    Boolean found = FALSE;
    Pronunciation *p;
    LabId *ph;
-   char buf[256];
+   char buf[MAXSTRLEN];
 
    if (wb->word == *args){
       for (i=0; !found && i<wb->nPron; i++){
@@ -1158,7 +1211,7 @@ void DelDefOp(WordBuf *wb, LabId *args)
 void FunctionWordOp(WordBuf *wb, LabId *args)
 {
    int i,j;
-   static char s[255];
+   static char s[MAXSTRLEN];
    Pronunciation *p;
    
    if (IsInIdList(wb->word,args)) 
@@ -1227,12 +1280,12 @@ void ContextRep(Pronunciation *p, LabId 
          if (lcList != NULL)
             ltrue = IsInIdList(p->phone[i-1],lcList);
          else
-            ltrue = (lc == asterix || lc == p->phone[i-1] );
+            ltrue = (lc == asterix || lc == p->phone[i-1] ) ? TRUE:FALSE;
          if (ltrue){
             if (rcList != NULL)
                replace = IsInIdList(p->phone[i+1],rcList);
             else
-               replace = (rc == asterix || rc == p->phone[i+1] );
+               replace = (rc == asterix || rc == p->phone[i+1] ) ? TRUE:FALSE;
          }
       }
       if (replace) p->phone[i] = *args;
@@ -1389,7 +1442,7 @@ void AppendSilenceOp(WordBuf *wb, LabId 
 /* MakeTriId:  concatenate args separated by - and +'s and return its id */
 LabId MakeTriId(LabId l, LabId c, LabId r)
 {
-   char buf[100];
+   char buf[MAXSTRLEN];
    LabId item;
    
    if (l!=NULL && l!=wdBnd && c!=wdBnd){
@@ -1662,7 +1715,7 @@ Boolean ScanDict(DBuffer *db, LabId reqd
    }
    if (scmp==0)
       ReadDictProns(db);
-   return scmp==0;
+   return ((scmp==0) ? TRUE:FALSE);
 }
 
 /* FillInputs: scan inputs until current word in each is >= required word.
@@ -1847,6 +1900,6 @@ void EditAndMerge(void)
    }
 }
 
-/* ---------------------------------------------------------------- */
+/* ----------------------------------------------------------- */
 /*                         END:  HDMan.c                            */
-/* ---------------------------------------------------------------- */
+/* ----------------------------------------------------------- */
diff -pbBEwurNa --ignore-matching-lines='.*vc_id.*' HTK-3.4.1/HTKTools/HERest.c HTS-2.2_for_HTK-3.4.1/HTKTools/HERest.c
--- HTK-3.4.1/HTKTools/HERest.c	2009-03-13 03:52:01.000000000 +0900
+++ HTS-2.2_for_HTK-3.4.1/HTKTools/HERest.c	2011-06-16 13:18:29.000000000 +0900
@@ -32,8 +32,53 @@
 /*         File: HERest.c: Embedded B-W ReEstimation           */
 /* ----------------------------------------------------------- */
 
+/*  *** THIS IS A MODIFIED VERSION OF HTK ***                        */
+/* ----------------------------------------------------------------- */
+/*           The HMM-Based Speech Synthesis System (HTS)             */
+/*           developed by HTS Working Group                          */
+/*           http://hts.sp.nitech.ac.jp/                             */
+/* ----------------------------------------------------------------- */
+/*                                                                   */
+/*  Copyright (c) 2001-2011  Nagoya Institute of Technology          */
+/*                           Department of Computer Science          */
+/*                                                                   */
+/*                2001-2008  Tokyo Institute of Technology           */
+/*                           Interdisciplinary Graduate School of    */
+/*                           Science and Engineering                 */
+/*                                                                   */
+/* All rights reserved.                                              */
+/*                                                                   */
+/* Redistribution and use in source and binary forms, with or        */
+/* without modification, are permitted provided that the following   */
+/* conditions are met:                                               */
+/*                                                                   */
+/* - Redistributions of source code must retain the above copyright  */
+/*   notice, this list of conditions and the following disclaimer.   */
+/* - Redistributions in binary form must reproduce the above         */
+/*   copyright notice, this list of conditions and the following     */
+/*   disclaimer in the documentation and/or other materials provided */
+/*   with the distribution.                                          */
+/* - Neither the name of the HTS working group nor the names of its  */
+/*   contributors may be used to endorse or promote products derived */
+/*   from this software without specific prior written permission.   */
+/*                                                                   */
+/* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND            */
+/* CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,       */
+/* INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF          */
+/* MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE          */
+/* DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS */
+/* BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,          */
+/* EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED   */
+/* TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,     */
+/* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON */
+/* ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,   */
+/* OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY    */
+/* OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE           */
+/* POSSIBILITY OF SUCH DAMAGE.                                       */
+/* ----------------------------------------------------------------- */
+
 char *herest_version = "!HVER!HERest:   3.4.1 [CUED 12/03/09]";
-char *herest_vc_id = "$Id: HERest.c,v 1.2 2006/12/07 11:09:08 mjfg Exp $";
+char *herest_vc_id = "$Id: HERest.c,v 1.49 2011/06/16 04:18:29 uratec Exp $";
 
 /*
    This program is used to perform a single reestimation of
@@ -88,19 +133,22 @@ static char * labDir = NULL;     /* labe
 static char * labExt = "lab";    /* label file extension */
 static char * hmmDir = NULL;     /* directory to look for hmm def files */
 static char * hmmExt = NULL;     /* hmm def file extension */
-static char * newDir = NULL;     /* directory to store new hmm def files */
-static char * newExt = NULL;     /* extension of new reestimated hmm files */
+static char * newhmmDir = NULL;  /* directory to store new hmm def files */
+static char * newhmmExt = NULL;  /* extension of new reestimated hmm files */
 static char * statFN;            /* stats file, if any */
 static float minVar  = 0.0;      /* minimum variance (diagonal only) */
 static float mixWeightFloor=0.0; /* Floor for mixture weights */
 static int minEgs    = 3;        /* min examples to train a model */
-static UPDSet uFlags = (UPDSet) (UPMEANS|UPVARS|UPTRANS|UPMIXES); /* update flags */
+static UPDSet uFlags_hmm = (UPDSet) (UPMEANS|UPVARS|UPTRANS|UPMIXES); /* update flags for HMMs */
+static UPDSet uFlags_dur = (UPDSet) 0; /* update flags for duration models */
 static int parMode   = -1;       /* enable one of the // modes */
 static Boolean stats = FALSE;    /* enable statistics reports */
 static char * mmfFn  = NULL;     /* output MMF file, if any */
 static int trace     = 0;        /* Trace level */
 static Boolean saveBinary = FALSE;  /* save output in binary  */
 static Boolean ldBinary = TRUE;        /* load/dump in binary */
+static Boolean applyVFloor = FALSE;  /* variance flooring */
+static Boolean useAlign = FALSE;     /* use model alignment from label */
 static FileFormat dff=UNDEFF;       /* data file format */
 static FileFormat lff=UNDEFF;       /* label file format */
 static int updateMode = UPMODE_UPDATE; /* dump summed accs, update models or do both? */
@@ -108,6 +156,7 @@ static int updateMode = UPMODE_UPDATE; /
 
 static ConfParam *cParm[MAXGLOBS];   /* configuration parameters */
 static int nParm = 0;               /* total num params */
+Boolean keepOccm = FALSE;
 
 static Boolean al_hmmUsed = FALSE;   /* Set for 2-model ReEstimation */
 static char al_hmmDir[MAXFNAMELEN];  /* dir to look for alignment hmm defs */
@@ -115,7 +164,7 @@ static char al_hmmExt[MAXSTRLEN];  	 /* 
 static char al_hmmMMF[MAXFNAMELEN];  /* alignment hmm MMF */
 static char al_hmmLst[MAXFNAMELEN];  /* alignment hmm list */
 static char up_hmmMMF[MAXFNAMELEN];  /* alignment hmm list */
-static HMMSet al_hset ;      	 /* Option 2nd set of models for alignment */
+static HMMSet al_hset;               /* Option 2nd set of HMMs for alignment */
 
 /* Global Data Structures - valid for all training utterances */
 static LogDouble pruneInit = NOPRUNE;    /* pruning threshold initially */
@@ -123,26 +172,44 @@ static LogDouble pruneInc = 0.0;        
 static LogDouble pruneLim = NOPRUNE;     /* pruning threshold limit */
 static float minFrwdP = NOPRUNE;         /* mix prune threshold */
 
-
-static Boolean firstTime = TRUE;    /* Flag used to enable creation of ot */
 static Boolean twoDataFiles = FALSE; /* Enables creation of ot2 for FB
                                         training using two data files */
 static int totalT=0;       /* total number of frames in training data */
 static LogDouble totalPr=0;   /* total log prob upto current utterance */
 static Vector vFloor[SMAX]; /* variance floor - default is all zero */
 
-static MemHeap hmmStack;   /*For Storage of all dynamic structures created...*/
+static MemHeap hmmStack;   /* For storage of all dynamic structures created... */
 static MemHeap uttStack;
 static MemHeap fbInfoStack;
 static MemHeap accStack;
 
 /* information about transforms */
-static XFInfo xfInfo;
+static XFInfo xfInfo_hmm;
 static int maxSpUtt = 0;
 static float varFloorPercent = 0;
 
 static char *labFileMask = NULL;
 
+/* for duration model generation */
+static char * durDir = NULL;     /* directory to look for duration model def files */
+static char * durExt = NULL;     /* duration model def file extension */
+static char * newdurDir = NULL;  /* directory to store new duration model def files */
+static char * newdurExt = NULL;  /* extension of new reestimated duration model files */
+static MemHeap durStack;   /* For storage of all dynamic structures created... */
+static float durminVar = 0.0;           /* variance floor value */
+static float durvarFloorPercent = 0.0;  /* variance flooring percent */
+static float durmapTau = 0.0;           /* map tau for duration models */
+static Boolean applydurVFloor = FALSE;  /* apply variance flooring */
+static Boolean al_durUsed = FALSE;      /* Set for 2-model ReEstimation */
+static Boolean up_durLoaded = FALSE;    /* Set semi-Markov training */
+static char al_durDir[MAXFNAMELEN];     /* dir to look for alignment duration model defs */
+static char al_durExt[MAXSTRLEN];       /* alignment duration model def file extension */
+static char al_durMMF[MAXFNAMELEN];     /* alignment duration model MMF */
+static char al_durLst[MAXFNAMELEN];     /* alignment duration model list */
+static char up_durMMF[MAXFNAMELEN];     /* alignment duration model list */
+static HMMSet al_dset;                  /* Option 2nd set of duration models for alignment */
+static XFInfo xfInfo_dur;
+
 /* ------------------ Process Command Line -------------------------- */
    
 /* SetConfParms: set conf parms relevant to HCompV  */
@@ -159,6 +226,7 @@ void SetConfParms(void)
       if (GetConfFlt(cParm,nParm,"VARFLOORPERCENTILE",&f)) varFloorPercent = f;
       if (GetConfBool(cParm,nParm,"SAVEBINARY",&b)) saveBinary = b;
       if (GetConfBool(cParm,nParm,"BINARYACCFORMAT",&b)) ldBinary = b;
+      if (GetConfBool(cParm,nParm,"APPLYVFLOOR", &b)) applyVFloor = b;  
       /* 2-model reestimation alignment model set */
       if (GetConfStr(cParm,nParm,"ALIGNMODELMMF",buf)) {
           strcpy(al_hmmMMF,buf); al_hmmUsed = TRUE;
@@ -174,21 +242,62 @@ void SetConfParms(void)
           strcpy(al_hmmExt,buf); al_hmmUsed = TRUE;
       }
       if (GetConfStr(cParm,nParm,"ALIGNXFORMEXT",buf)) {
-         xfInfo.alXFormExt = CopyString(&hmmStack,buf);
+         xfInfo_hmm.al_inXFormExt = CopyString(&hmmStack,buf);
       }
       if (GetConfStr(cParm,nParm,"ALIGNXFORMDIR",buf)) {
-         xfInfo.alXFormDir = CopyString(&hmmStack,buf);
+         xfInfo_hmm.al_inXFormDir = CopyString(&hmmStack,buf);
+         xfInfo_hmm.use_alInXForm = TRUE;
       }
       if (GetConfStr(cParm,nParm,"INXFORMMASK",buf)) {
-         xfInfo.inSpkrPat = CopyString(&hmmStack,buf);
+         xfInfo_hmm.inSpkrPat = CopyString(&hmmStack,buf);
       }
       if (GetConfStr(cParm,nParm,"PAXFORMMASK",buf)) {
-         xfInfo.paSpkrPat = CopyString(&hmmStack,buf);
+         xfInfo_hmm.paSpkrPat = CopyString(&hmmStack,buf);
       }
       if (GetConfStr(cParm,nParm,"LABFILEMASK",buf)) {
          labFileMask = (char*)malloc(strlen(buf)+1); 
          strcpy(labFileMask, buf);
       }
+      /* duration model */
+      if (GetConfFlt(cParm,nParm,"DURMINVAR",&f)) {
+         durminVar = f;
+      }
+      if (GetConfFlt(cParm,nParm,"DURVARFLOORPERCENTILE",&f)) {
+         durvarFloorPercent = f;
+      }
+      if (GetConfBool(cParm,nParm,"APPLYDURVARFLOOR",&b)) {
+         applydurVFloor = b;
+      }
+      if (GetConfFlt(cParm,nParm,"DURMAPTAU",&f)) {
+         durmapTau = f;
+      }
+      /* 2-model reestimation alignment model set */
+      if (GetConfStr(cParm,nParm,"ALIGNDURMMF",buf)) {
+         strcpy(al_durMMF,buf); al_durUsed = TRUE;
+      }
+      if (GetConfStr(cParm,nParm,"ALIGNDURLIST",buf)) {
+         strcpy(al_durLst,buf); al_durUsed = TRUE;
+      }
+      /* allow multiple individual model files */
+      if (GetConfStr(cParm,nParm,"ALIGNDURDIR",buf)) {
+         strcpy(al_durDir,buf); al_durUsed = TRUE;
+      }
+      if (GetConfStr(cParm,nParm,"ALIGNDUREXT",buf)) {
+         strcpy(al_durExt,buf); al_durUsed = TRUE;
+      }
+      if (GetConfStr(cParm,nParm,"ALIGNDURXFORMEXT",buf)) {
+         xfInfo_dur.al_inXFormExt = CopyString(&durStack,buf);
+      }
+      if (GetConfStr(cParm,nParm,"ALIGNDURXFORMDIR",buf)) {
+         xfInfo_dur.al_inXFormDir = CopyString(&durStack,buf);
+         xfInfo_dur.use_alInXForm = TRUE;
+      }
+      if (GetConfStr(cParm,nParm,"DURINXFORMMASK",buf)) {
+         xfInfo_dur.inSpkrPat = CopyString(&durStack,buf);
+      }
+      if (GetConfStr(cParm,nParm,"DURPAXFORMMASK",buf)) {
+         xfInfo_dur.paSpkrPat = CopyString(&durStack,buf);
+      }
 
       if (GetConfStr(cParm,nParm,"UPDATEMODE",buf)) {
          if (!strcmp (buf, "DUMP")) updateMode = UPMODE_DUMP;
@@ -201,47 +310,59 @@ void SetConfParms(void)
 
 void ReportUsage(void)
 {
-   printf("\nUSAGE: HERest [options] hmmList dataFiles...\n\n");
+   printf("\nModified for HTS\n");
+   printf("\nUSAGE: HERest [options] hmmList [durList] dataFiles...\n\n");
    printf(" Option                                       Default\n\n");
-   printf(" -a      Use an input linear transform        off\n");
+   printf(" -a      Use an input linear transform for hmms            off\n");
+   printf(" -b      Use an input linear transform for dur models      off\n");
    printf(" -c f    Mixture pruning threshold            10.0\n");
    printf(" -d s    dir to find hmm definitions          current\n");
+   printf(" -e      use model alignment from label for pruning        off\n");
+   printf(" -f s    extension for new duration model files            as src\n");
+   printf(" -g s    output duration model to file s                   none\n");
    printf(" -h s    set output speaker name pattern   *.%%%%%%\n");
    printf("         to s, optionally set input and parent patterns\n");
+   printf(" -k f    set temperature parameter for DAEM training       1.0\n");
    printf(" -l N    set max files per speaker            off\n");
    printf(" -m N    set min examples needed per model    3\n");
+   printf(" -n s    dir to find duration model definitions            current\n");
    printf(" -o s    extension for new hmm files          as src\n");
    printf(" -p N    set parallel mode to N               off\n");
+   printf(" -q s    Save all xforms for duration to TMF file s        TMF\n");
    printf(" -r      Enable Single Pass Training...       \n");
    printf("         ...using two parameterisations       off\n");
    printf(" -s s    print statistics to file s           off\n");
    printf(" -t f [i l] set pruning to f [inc limit]      inf\n");
-   printf(" -u tmvwaps  update t)rans m)eans v)ars w)ghts tmvw\n");
+   printf(" -u tmvwapsd update t)rans m)eans v)ars w)ghts             tmvw\n");
    printf("                a)daptation xform p)rior used     \n");
    printf("                s)semi-tied xform                 \n");
+   printf("                d) switch to duration model update flag    \n");
    printf(" -v f    set minimum variance to f            0.0\n");
    printf(" -w f    set mix weight floor to f*MINMIX     0.0\n");
+   printf(" -y s    extension for duration model files                none\n");
    printf(" -x s    extension for hmm files              none\n");
    printf(" -z s    Save all xforms to TMF file s        TMF\n");
-   PrintStdOpts("BEFGHIJKLMSTX");
+   PrintStdOpts("BEFGHIJKLMNRSTWXYZ");
    printf("\n\n");
 }
 
 void SetuFlags(void)
 {
    char *s;
+   UPDSet *uFlags=&uFlags_hmm;
    
    s=GetStrArg();
-   uFlags=(UPDSet) 0;        
+   *uFlags=(UPDSet) 0;        
    while (*s != '\0')
       switch (*s++) {
-      case 't': uFlags = (UPDSet) (uFlags+UPTRANS); break;
-      case 'm': uFlags = (UPDSet) (uFlags+UPMEANS); break;
-      case 'v': uFlags = (UPDSet) (uFlags+UPVARS); break;
-      case 'w': uFlags = (UPDSet) (uFlags+UPMIXES); break;
-      case 's': uFlags = (UPDSet) (uFlags+UPSEMIT); break;
-      case 'a': uFlags = (UPDSet) (uFlags+UPXFORM); break;
-      case 'p': uFlags = (UPDSet) (uFlags+UPMAP); break;
+      case 't': *uFlags = (UPDSet) (*uFlags+UPTRANS); break;
+      case 'm': *uFlags = (UPDSet) (*uFlags+UPMEANS); break;
+      case 'v': *uFlags = (UPDSet) (*uFlags+UPVARS); break;
+      case 'w': *uFlags = (UPDSet) (*uFlags+UPMIXES); break;
+      case 'a': *uFlags = (UPDSet) (*uFlags+UPXFORM); break;
+      case 'p': *uFlags = (UPDSet) (*uFlags+UPMAP); break;
+      case 's': *uFlags = (UPDSet) (*uFlags+UPSEMIT); break;
+      case 'd':  uFlags = &uFlags_dur; *uFlags=(UPDSet)0; break;
       default: HError(2320,"SetuFlags: Unknown update flag %c",*s);
          break;
       }
@@ -282,8 +403,17 @@ void CheckUpdateSetUp()
 {
   AdaptXForm *xf;
 
-  xf = xfInfo.paXForm;
-  if ((xfInfo.paXForm != NULL) && !(uFlags&UPXFORM)) {
+   xf = xfInfo_hmm.paXForm;
+   if ((xfInfo_hmm.paXForm != NULL) && !(uFlags_hmm&UPXFORM)) {
+      while (xf != NULL) {
+         if ((xf->xformSet->xkind != CMLLR) && (xf->xformSet->xkind != SEMIT))
+            HError(999,"SAT only supported with SEMIT/CMLLR transforms");
+         xf = xf->parentXForm;
+      }
+   }
+   
+   xf = xfInfo_dur.paXForm;
+   if ((xfInfo_dur.paXForm != NULL) && !(uFlags_dur&UPXFORM)) {
     while (xf != NULL) {
        if ((xf->xformSet->xkind != CMLLR) && (xf->xformSet->xkind != SEMIT))
 	HError(999,"SAT only supported with SEMIT/CMLLR transforms");
@@ -296,22 +426,24 @@ int main(int argc, char *argv[])
 {
    char *datafn=NULL;
    char *datafn2=NULL;
+   char *hmmListFn=NULL, *durListFn=NULL;
    char *s;
-   char *scriptFile;
    char datafn1[MAXSTRLEN];
    char newFn[MAXSTRLEN];
    FILE *f;
    UttInfo *utt;            /* utterance information storage */
    FBInfo *fbInfo;          /* forward-backward information storage */
    HMMSet hset;             /* Set of HMMs to be re-estimated */
+   HMMSet dset;             /* Set of duration models to be generated */
    Source src;
    float tmpFlt;
    int tmpInt;
    int numUtt,spUtt=0;
 
-   void Initialise(FBInfo *fbInfo, MemHeap *x, HMMSet *hset, char *hmmListFn);
+   void Initialise(FBInfo *fbInfo, MemHeap *x, HMMSet *hset, HMMSet *dset, char *hmmListFn, char *durListFn);
    void DoForwardBackward(FBInfo *fbInfo, UttInfo *utt, char *datafn, char *datafn2);
-   void UpdateModels(HMMSet *hset, ParmBuf pbuf2);
+   void UpdateVFloors (HMMSet *hset, const double minVar, const double percent);
+   void UpdateModels(HMMSet *hset, XFInfo *xfinfo, ParmBuf pbuf2, UPDSet uFlags);
    void StatReport(HMMSet *hset);
    
    if(InitShell(argc,argv,herest_version,herest_vc_id)<SUCCESS)
@@ -324,7 +456,7 @@ int main(int argc, char *argv[])
       HError(2300,"HERest: InitParm failed");
    InitTrain();
    InitUtil();   InitFB();
-   InitAdapt(&xfInfo); InitMap();
+   InitAdapt(&xfInfo_hmm,&xfInfo_dur); InitMap();
 
    if (!InfoPrinted() && NumArgs() == 0)
       ReportUsage();
@@ -332,9 +464,14 @@ int main(int argc, char *argv[])
    al_hmmDir[0] = '\0'; al_hmmExt[0] = '\0'; 
    al_hmmMMF[0] = '\0'; al_hmmLst[0] = '\0'; 
    up_hmmMMF[0] = '\0';
+   al_durDir[0] = '\0'; al_durExt[0] = '\0'; 
+   al_durMMF[0] = '\0'; al_durLst[0] = '\0'; 
+   up_durMMF[0] = '\0';
    CreateHeap(&hmmStack,"HmmStore", MSTAK, 1, 1.0, 50000, 500000);
+   CreateHeap(&durStack,"DurStore", MSTAK, 1, 1.0, 50000, 500000);
    SetConfParms(); 
    CreateHMMSet(&hset,&hmmStack,TRUE);
+   CreateHMMSet(&dset,&durStack,TRUE);
    CreateHeap(&uttStack,   "uttStore",    MSTAK, 1, 0.5, 100,   1000);
    utt = (UttInfo *) New(&uttStack, sizeof(UttInfo));
    CreateHeap(&fbInfoStack,   "FBInfoStore",  MSTAK, 1, 0.5, 100 ,  1000 );
@@ -346,25 +483,23 @@ int main(int argc, char *argv[])
       if (strlen(s)!=1) 
          HError(2319,"HERest: Bad switch %s; must be single letter",s);
       switch(s[0]){
-      case 'b':
-         if (NextArg()!=STRINGARG)
-            HError(2319,"HERest: script file expected");
-         scriptFile = GetStrArg(); break;
       case 'c':
-         minFrwdP = GetChkedFlt(0.0,1000.0,s);
+         minFrwdP = GetChkedFlt(0.0,100000.0,s);
          break;
       case 'd':
          if (NextArg()!=STRINGARG)
             HError(2319,"HERest: HMM definition directory expected");
          hmmDir = GetStrArg(); break;   
+      case 'e':
+         useAlign = TRUE; break;
       case 'm':
          minEgs = GetChkedInt(0,1000,s); break;
       case 'o':
          if (NextArg()!=STRINGARG)
             HError(2319,"HERest: HMM file extension expected");
-         newExt = GetStrArg(); break;
+         newhmmExt = GetStrArg(); break;
       case 'p':
-         parMode = GetChkedInt(0,500,s); break;
+         parMode = GetChkedInt(0,2000,s); break;
       case 'r':
          twoDataFiles = TRUE; break;
       case 's':
@@ -388,7 +523,7 @@ int main(int argc, char *argv[])
       case 'u':
          SetuFlags(); break;
       case 'v':
-         minVar = GetChkedFlt(0.0,10.0,s); break;
+         minVar = GetChkedFlt(0.0,10.0,s); applyVFloor = TRUE; break;
       case 'w':
          mixWeightFloor = MINMIX * GetChkedFlt(0.0,10000.0,s); 
          break;
@@ -429,7 +564,7 @@ int main(int argc, char *argv[])
       case 'M':
          if (NextArg()!=STRINGARG)
             HError(2319,"HERest: Output macro file directory expected");
-         newDir = GetStrArg();
+         newhmmDir = GetStrArg();
          break;     
       case 'T':
          trace = GetChkedInt(0,0100000,s);
@@ -440,11 +575,11 @@ int main(int argc, char *argv[])
          labExt = GetStrArg(); break;
 	 /* additional options for transform support */
       case 'a':
- 	xfInfo.useInXForm = TRUE; break;
+        xfInfo_hmm.useInXForm = TRUE; break;
       case 'h':
 	if (NextArg()!=STRINGARG)
 	  HError(1,"Speaker name pattern expected");
-	xfInfo.outSpkrPat = GetStrArg();
+        xfInfo_hmm.outSpkrPat = xfInfo_dur.outSpkrPat = GetStrArg();
 	break;
       case 'l':
          maxSpUtt = GetChkedInt(0,0100000,s);
@@ -452,10 +587,10 @@ int main(int argc, char *argv[])
       case 'E':
          if (NextArg()!=STRINGARG)
             HError(2319,"HERest: parent transform directory expected");
-	 xfInfo.usePaXForm = TRUE;
-         xfInfo.paXFormDir = GetStrArg(); 
+         xfInfo_hmm.usePaXForm = TRUE;
+         xfInfo_hmm.paXFormDir = GetStrArg(); 
          if (NextArg()==STRINGARG)
-	   xfInfo.paXFormExt = GetStrArg(); 
+           xfInfo_hmm.paXFormExt = GetStrArg(); 
 	 if (NextArg() != SWITCHARG)
 	   HError(2319,"HERest: cannot have -E as the last option");	  
          break;              
@@ -464,8 +599,8 @@ int main(int argc, char *argv[])
             HError(2319,"HERest: input transform directory expected");
          AddInXFormDir(&hset,GetStrArg());
          if (NextArg()==STRINGARG) {
-            if (xfInfo.inXFormExt == NULL)
-               xfInfo.inXFormExt = GetStrArg(); 
+            if (xfInfo_hmm.inXFormExt == NULL)
+               xfInfo_hmm.inXFormExt = GetStrArg(); 
             else
                HError(2319,"HERest: only one input transform extension may be specified");
          }
@@ -475,16 +610,91 @@ int main(int argc, char *argv[])
       case 'K':
          if (NextArg()!=STRINGARG)
             HError(2319,"HERest: output transform directory expected");
-         xfInfo.outXFormDir = GetStrArg(); 
+         xfInfo_hmm.outXFormDir = GetStrArg(); 
          if (NextArg()==STRINGARG)
-	   xfInfo.outXFormExt = GetStrArg(); 
+           xfInfo_hmm.outXFormExt = GetStrArg(); 
 	 if (NextArg() != SWITCHARG)
 	   HError(2319,"HERest: cannot have -K as the last option");	  
          break;              
       case 'z':
          if (NextArg() != STRINGARG)
             HError(2319,"HERest: output TMF file expected");
-         xfInfo.xformTMF = GetStrArg(); break;
+         xfInfo_hmm.xformTMF = GetStrArg(); break;
+      /* for state duration model */
+      case 'b':
+         xfInfo_dur.useInXForm = TRUE; break;
+      case 'f':
+         if (NextArg()!=STRINGARG)
+            HError(2319,"HERest: duration model file extension expected");
+         newdurExt = GetStrArg(); break;
+      case 'g':
+         if (NextArg()!=STRINGARG)
+            HError(2319,"HERest: duration model file name expected");
+         strcpy(up_durMMF,GetStrArg());
+         AddMMF(&dset,up_durMMF);
+         uFlags_dur = (UPDSet)(UPMEANS|UPVARS);
+         break;
+      case 'n':
+         if (NextArg()!=STRINGARG)
+            HError(2319,"HERest: duration model definition directory expected");
+         durDir = GetStrArg();
+         up_durLoaded = TRUE;
+         break;
+      case 'y':
+         if (NextArg()!=STRINGARG)
+            HError(2319,"HERest: duration model file extension expected");
+         durExt = GetStrArg(); break;
+      case 'N':
+         if (NextArg() != STRINGARG)
+            HError(2319,"HERest: duration model macro file name expected");
+         strcpy(up_durMMF,GetStrArg());
+         AddMMF(&dset,up_durMMF);
+         up_durLoaded = TRUE;
+         break;
+      case 'R':
+         if (NextArg()!=STRINGARG)
+            HError(2319,"HERest: Output duration macro file directory expected");
+         newdurDir = GetStrArg();
+         break;
+      case 'W':
+         if (NextArg()!=STRINGARG)
+            HError(2319,"HERest: parent duration transform directory expected");
+         xfInfo_dur.usePaXForm = TRUE;
+         xfInfo_dur.paXFormDir = GetStrArg(); 
+         if (NextArg()==STRINGARG)
+            xfInfo_dur.paXFormExt = GetStrArg(); 
+         if (NextArg() != SWITCHARG)
+            HError(2319,"HERest: cannot have -W as the last option");      
+         break;
+      case 'Y':
+         if (NextArg()!=STRINGARG)
+            HError(2319,"HERest: input duration transform directory expected");
+         AddInXFormDir(&dset,GetStrArg());
+         if (NextArg()==STRINGARG) {
+            if (xfInfo_dur.inXFormExt == NULL)
+               xfInfo_dur.inXFormExt = GetStrArg(); 
+            else
+               HError(2319,"HERest: only one input duration transform extension may be specified");
+         }
+         if (NextArg() != SWITCHARG)
+           HError(2319,"HERest: cannot have -Y as the last option");      
+         break;              
+      case 'Z':
+         if (NextArg()!=STRINGARG)
+            HError(2319,"HERest: output duration transform directory expected");
+         xfInfo_dur.outXFormDir = GetStrArg(); 
+         if (NextArg()==STRINGARG)
+            xfInfo_dur.outXFormExt = GetStrArg(); 
+         if (NextArg() != SWITCHARG)
+            HError(2319,"HERest: cannot have -Z as the last option");      
+         break;
+      case 'q':
+         if (NextArg() != STRINGARG)
+            HError(2319,"HERest: output duration TMF file expected");
+         xfInfo_dur.xformTMF = GetStrArg(); break;
+      case 'k':
+         SetDAEMTemp(GetChkedFlt(0.0,1.0,s));
+         break;
       default:
          HError(2319,"HERest: Unknown switch %s",s);
       }
@@ -492,7 +702,8 @@ int main(int argc, char *argv[])
    if (NextArg() != STRINGARG)
       HError(2319,"HERest: file name of vocabulary list expected");
 
-   Initialise(fbInfo, &fbInfoStack, &hset, GetStrArg());
+   hmmListFn = GetStrArg(); durListFn = (up_durLoaded) ? GetStrArg() : NULL;
+   Initialise(fbInfo, &fbInfoStack, &hset, &dset, hmmListFn, durListFn);
    InitUttInfo(utt, twoDataFiles);
    numUtt = 1;
 
@@ -507,78 +718,180 @@ int main(int argc, char *argv[])
             HError(2319,"HERest: Must be even num of training files for single pass training");
          strcpy(datafn1,GetStrArg());
          datafn = datafn1;
-         
          datafn2 = GetStrArg();
-      }else
+      }
+      else if (parMode==0 && up_durLoaded && uFlags_dur) {
+         if ((NumArgs() % 2) != 0)
+            HError(2319,"HERest: Must be even num of dump files for HSMM training");
+         strcpy(datafn1,GetStrArg());
+         datafn = datafn1;     
+         datafn2 = GetStrArg();
+         if (strstr(datafn,"hmm")==NULL)
+            HError(-9999,"dump file for HMM include \"hmm\"",datafn);
+         if (strstr(datafn2,"dur")==NULL)
+            HError(-9999,"dump file for duration model include \"dur\"",datafn2);
+      }
+      else
          datafn = GetStrArg();
       if (parMode==0){
-         src=LoadAccs(&hset, datafn,uFlags);
+         src=LoadAccs(&hset, datafn, uFlags_hmm);
          ReadFloat(&src,&tmpFlt,1,ldBinary);
          totalPr += (LogDouble)tmpFlt;
          ReadInt(&src,&tmpInt,1,ldBinary);
          totalT += tmpInt;
          CloseSource( &src );
+         if (up_durLoaded && uFlags_dur) {
+            src=LoadAccs(&dset, datafn2, uFlags_dur);
+            CloseSource( &src );
+         }
       }
       else {
          /* track speakers */	 
-         if (UpdateSpkrStats(&hset,&xfInfo, datafn)) spUtt=0;
+         if (UpdateSpkrStats(&hset,&xfInfo_hmm,datafn)) {
+            spUtt=0;
+         }
+         if (up_durLoaded) {
+            if (UpdateSpkrStats(&dset,&xfInfo_dur,datafn) && xfInfo_dur.useInXForm)
+               ResetDMMPreComps(&dset);   /* reset all pre-calculated duration probs */
+         }
 	 /* Check to see whether set-up is valid */
 	 CheckUpdateSetUp();
-         fbInfo->inXForm = xfInfo.inXForm;
-         fbInfo->al_inXForm = xfInfo.al_inXForm;
-         fbInfo->paXForm = xfInfo.paXForm;
+
+         fbInfo->xfinfo_hmm     = &xfInfo_hmm;
+         fbInfo->xfinfo_dur     = &xfInfo_dur;
+         fbInfo->inXForm_hmm    = xfInfo_hmm.inXForm;
+         fbInfo->inXForm_dur    = xfInfo_dur.inXForm;
+         fbInfo->al_inXForm_hmm = xfInfo_hmm.al_inXForm;
+         fbInfo->al_inXForm_dur = xfInfo_dur.al_inXForm;
+         fbInfo->paXForm_hmm    = xfInfo_hmm.paXForm;
+         fbInfo->paXForm_dur    = xfInfo_dur.paXForm;
+
          if ((maxSpUtt==0) || (spUtt<maxSpUtt))
             DoForwardBackward(fbInfo, utt, datafn, datafn2) ;
-         numUtt += 1; spUtt++;
+         numUtt++; spUtt++;
       }
    } while (NumArgs()>0);
 
-   if (uFlags&UPXFORM) {/* ensure final speaker correctly handled */ 
-      UpdateSpkrStats(&hset,&xfInfo, NULL); 
+   if (uFlags_hmm&UPXFORM || uFlags_dur&UPXFORM) {
+      /* ensure final speaker correctly handled */
+      if (uFlags_hmm&UPXFORM)  
+         UpdateSpkrStats(&hset,&xfInfo_hmm,NULL);
+      if (uFlags_dur&UPXFORM && up_durLoaded)
+         UpdateSpkrStats(&dset,&xfInfo_dur,NULL);
       if (trace&T_TOP) {
          printf("Reestimation complete - average log prob per frame = %e (%d frames)\n",
                 totalPr/totalT, totalT);
       }
    } else {
       if (parMode>0  || (parMode==0 && (updateMode&UPMODE_DUMP))){
-         MakeFN("HER$.acc",newDir,NULL,newFn);
-         f=DumpAccs(&hset,newFn,uFlags,parMode);
+         /* dump HMM accs */
+         MakeFN("HER$.hmm.acc",newhmmDir,NULL,newFn);
+         f=DumpAccs(&hset,newFn,uFlags_hmm,parMode);
+         tmpFlt = (float)totalPr;
+         WriteFloat(f,&tmpFlt,1,ldBinary);
+         WriteInt(f,(int*)&totalT,1,ldBinary);
+         fclose( f );
+
+         /* dump dur accs */
+         if (up_durLoaded && uFlags_dur) {
+            MakeFN("HER$.dur.acc",newhmmDir,NULL,newFn);
+            f=DumpAccs(&dset,newFn,uFlags_dur,parMode);
          tmpFlt = (float)totalPr;
          WriteFloat(f,&tmpFlt,1,ldBinary);
          WriteInt(f,(int*)&totalT,1,ldBinary);
          fclose( f );
       }
+      }
       if (parMode <= 0) {
          if (stats) {
             StatReport(&hset);
          }
-         if (updateMode&UPMODE_UPDATE)
-            UpdateModels(&hset,utt->pbuf2);
+         /* update HMMs */
+         if (updateMode&UPMODE_UPDATE) {
+            UpdateModels(&hset,&xfInfo_hmm,utt->pbuf2, uFlags_hmm);
+            if (trace&T_TOP) {
+               if (mmfFn == NULL)
+                  printf("Saving hmm's to dir %s\n",(newhmmDir==NULL)?"Current":newhmmDir); 
+               else
+                  printf("Saving hmm's to MMF %s\n",mmfFn);
+               fflush(stdout);
+            }
+            SaveHMMSet(&hset,newhmmDir,newhmmExt,NULL,saveBinary);
+         }
+         /* update duration models */
+         if (up_durLoaded && (updateMode&UPMODE_UPDATE) && uFlags_dur) {
+            /* first estimate variance floor */
+            if (durvarFloorPercent>0.0 && uFlags_dur&UPVARS)
+               UpdateVFloors(&dset, durminVar, durvarFloorPercent);
+            if (durmapTau>0.0)
+               SetMapTau(durmapTau);
+            if (durminVar>0.0)
+               SetMinVar(durminVar);
+            /* replace minVar & applyVFloor using these for duration models */
+            minVar = durminVar; applyVFloor = applydurVFloor;
+            /* estimate duration models */
+            UpdateModels(&dset,&xfInfo_dur,utt->pbuf2,uFlags_dur);
+            if (trace&T_TOP) {
+               if (newdurDir!=NULL)
+                  printf("Saving duration models to dir %s\n",(newdurDir==NULL)?"Current":newdurDir); 
+               else
+                  printf("Saving duration models to MMF %s\n",up_durMMF);
+               fflush(stdout);
       }
+            SaveHMMSet(&dset,newdurDir,newhmmExt,NULL,saveBinary);
    }
-   ResetHeap(&uttStack);
+         
+         if (trace&T_TOP) {
+            printf("Reestimation complete - average log prob per frame = %e\n", totalPr/totalT);
+            printf("     - total frames seen          = %e\n", (double)totalT);
+         }
+      }
+   }
+
+   ResetHeap(&accStack);
+   Dispose(&fbInfoStack, fbInfo);
    ResetHeap(&fbInfoStack);
+   Dispose(&uttStack, utt);
+   ResetHeap(&uttStack);
    ResetHeap(&hmmStack);
-   ResetHeap(&accStack);
+   
+   ResetMap();
+   ResetAdapt(&xfInfo_hmm,&xfInfo_dur);
+   ResetFB();
+   ResetUtil();
+   ResetTrain();
+   ResetParm();
+   ResetModel();
+   ResetLabel();
+   ResetVQ();
+   ResetWave();
+   ResetAudio();
+   ResetSigP();
+   ResetMath();
+   ResetMem();
+   ResetShell();
+
    Exit(0);
    return (0);          /* never reached -- make compiler happy */
 }
 
 /* -------------------------- Initialisation ----------------------- */
 
-void Initialise(FBInfo *fbInfo, MemHeap *x, HMMSet *hset, char *hmmListFn)
+void Initialise(FBInfo *fbInfo, MemHeap *x, HMMSet *hset, HMMSet *dset, char *hmmListFn, char *durListFn)
 {   
    HSetKind hsKind;
    int L,P,S,vSize,maxM; 
 
+   void GenDurMMF (HMMSet *hset, char *durfn);
+
    /* Load HMMs and init HMMSet related global variables */
    if(MakeHMMSet( hset, hmmListFn )<SUCCESS)
       HError(2321,"Initialise: MakeHMMSet failed");
    if(LoadHMMSet( hset,hmmDir,hmmExt)<SUCCESS)
       HError(2321,"Initialise: LoadHMMSet failed");
-   if (uFlags&UPSEMIT) uFlags = uFlags|UPMEANS|UPVARS;
-   AttachAccs(hset, &accStack, uFlags);
-   ZeroAccs(hset, uFlags);
+   if (uFlags_hmm&UPSEMIT) uFlags_hmm = (UPDSet) (uFlags_hmm|UPMEANS|UPVARS);
+   AttachAccs(hset, &accStack, uFlags_hmm);
+   ZeroAccs(hset, uFlags_hmm);
    P = hset->numPhyHMM;
    L = hset->numLogHMM;
    vSize = hset->vecSize;
@@ -587,21 +900,22 @@ void Initialise(FBInfo *fbInfo, MemHeap 
 
    hsKind = hset->hsKind;
    if (hsKind==DISCRETEHS)
-     uFlags = (UPDSet) (uFlags & (~(UPMEANS|UPVARS|UPXFORM|UPSEMIT)));
+     uFlags_hmm = (UPDSet) (uFlags_hmm & (~(UPMEANS|UPVARS|UPXFORM|UPSEMIT)));
 
    if (parMode != 0) {
       ConvDiagC(hset,TRUE);
    }
    if (trace&T_TOP) {
-      if (uFlags&UPMAP)  printf("HERest  MAP Updating: ");
+      printf("HMM:\n");
+      if (uFlags_hmm&UPMAP)  printf(" HERest  MAP Updating: ");
       else printf("HERest  ML Updating: ");
-      if (uFlags&UPTRANS) printf("Transitions "); 
-      if (uFlags&UPMEANS) printf("Means "); 
-      if (uFlags&UPVARS)  printf("Variances "); 
-      if (uFlags&UPSEMIT)  printf("SemiTied "); 
-      if (uFlags&UPXFORM)  printf("XForms "); 
-      if (uFlags&UPMIXES && maxM>1)  printf("MixWeights "); 
-      printf("\n\n ");
+      if (uFlags_hmm&UPTRANS) printf("Transitions "); 
+      if (uFlags_hmm&UPMEANS) printf("Means "); 
+      if (uFlags_hmm&UPVARS)  printf("Variances ");
+      if (uFlags_hmm&UPSEMIT) printf("SemiTied ");
+      if (uFlags_hmm&UPXFORM) printf("XForms ");
+      if (uFlags_hmm&UPMIXES && maxM>1)  printf("MixWeights ");
+      printf("\n ");
     
       if (parMode>=0) printf("Parallel-Mode[%d] ",parMode);
 
@@ -620,25 +934,96 @@ void Initialise(FBInfo *fbInfo, MemHeap 
          printf("Output to MMF file:  %s\n",mmfFn); 
       fflush(stdout);
    }
-   SetVFloor( hset, vFloor, minVar);
    totalPr = 0.0;
 
-   if (xfInfo.inSpkrPat == NULL) xfInfo.inSpkrPat = xfInfo.outSpkrPat; 
-   if (xfInfo.paSpkrPat == NULL) xfInfo.paSpkrPat = xfInfo.outSpkrPat; 
-   if (uFlags&UPXFORM) {
+   if (xfInfo_hmm.inSpkrPat == NULL) xfInfo_hmm.inSpkrPat = xfInfo_hmm.outSpkrPat; 
+   if (xfInfo_hmm.paSpkrPat == NULL) xfInfo_hmm.paSpkrPat = xfInfo_hmm.outSpkrPat; 
+   if (uFlags_hmm&UPXFORM) {
       if ((hsKind != PLAINHS) && (hsKind != SHAREDHS))
          HError(999,"Can only estimated transforms with PLAINHS and SHAREDHS!");
-      if (uFlags != UPXFORM)
+      if (uFlags_hmm != UPXFORM)
          HError(999,"Can only update linear transforms OR model parameters!");
-      xfInfo.useOutXForm = TRUE;
+      xfInfo_hmm.useOutXForm = TRUE;
+      /* This initialises things - temporary hack - THINK!! */
+      CreateAdaptXForm(hset, &xfInfo_hmm, "tmp");
+   } 
+
+   if ((uFlags_hmm&UPXFORM) || (uFlags_hmm&UPSEMIT))
+      CheckAdaptSetUp(hset,&xfInfo_hmm); 
+
+   /* duration model initialization */
+   if (up_durLoaded || up_durMMF[0]!='\0') {
+      if (!up_durLoaded)
+         GenDurMMF(hset,up_durMMF);  /* generate duration model mmf according to hset */
+      if (MakeHMMSet(dset,((!up_durLoaded)?hmmListFn:durListFn))<SUCCESS)
+         HError(2321,"Initialise: MakeHMMSet failed");
+      if (LoadHMMSet(dset,durDir,durExt)<SUCCESS)
+         HError(2321,"Initialise: LoadHMMSet failed");
+      AttachAccs(dset,&accStack,uFlags_dur);
+      ZeroAccs(dset,uFlags_dur);
+      
+      uFlags_dur = (UPDSet) uFlags_dur & (~UPTRANS);  /* turn off transition update flag */ 
+      if (dset->hsKind==DISCRETEHS)
+        uFlags_dur = (UPDSet) (uFlags_dur & (~(UPMEANS|UPVARS|UPXFORM|UPSEMIT)));
+      
+      if (parMode != 0)
+         ConvDiagC(dset,TRUE);
+
+      if (trace&T_TOP) {
+         printf("Duration model:\n");
+         if (uFlags_dur&UPMAP)  printf(" HERest  MAP Updating: ");
+         else printf(" HERest  ML Updating: ");
+         if (uFlags_dur&UPTRANS) printf("Transitions "); 
+         if (uFlags_dur&UPMEANS) printf("Means "); 
+         if (uFlags_dur&UPVARS)  printf("Variances ");
+         if (uFlags_dur&UPSEMIT) printf("SemiTied ");
+         if (uFlags_dur&UPXFORM) printf("XForms ");
+         if (uFlags_dur&UPMIXES && maxM>1)  printf("MixWeights ");
+         printf("\n ");
+
+         if (parMode>=0) printf("Parallel-Mode[%d] ",parMode);
+         printf("System is ");
+         switch (dset->hsKind){
+         case PLAINHS:  printf("PLAIN\n");  break;
+         case SHAREDHS: printf("SHARED\n"); break;
+         case TIEDHS:   printf("TIED\n"); break;
+         case DISCRETEHS: printf("DISCRETE\n"); break;
+         }
+         
+         printf(" %d Logical/%d Physical Models Loaded, #States=%d\n",dset->numLogHMM,dset->numPhyHMM,dset->vecSize);
+         if (dset->numFiles>0)
+            printf(" %d MMF input files\n",dset->numFiles);
+         if (mmfFn != NULL)
+            printf(" Output to MMF file:  %s\n",up_durMMF);
+         fflush(stdout);
+      }
+      
+      if (xfInfo_dur.inSpkrPat == NULL) xfInfo_dur.inSpkrPat = xfInfo_dur.outSpkrPat; 
+      if (xfInfo_dur.paSpkrPat == NULL) xfInfo_dur.paSpkrPat = xfInfo_dur.outSpkrPat; 
+      if (uFlags_dur&UPXFORM) {
+         if ((hsKind != PLAINHS) && (hsKind != SHAREDHS))
+            HError(999,"Can only estimated transforms with PLAINHS and SHAREDHS!");
+         xfInfo_dur.useOutXForm = TRUE;
       /* This initialises things - temporary hack - THINK!! */
-      CreateAdaptXForm(hset, "tmp");
+         CreateAdaptXForm(dset, &xfInfo_dur, "tmp");
+      }
+      if ((uFlags_dur&UPXFORM) || (uFlags_dur&UPSEMIT))
+         CheckAdaptSetUp(dset,&xfInfo_dur);
+      
    } 
 
+   if (trace&T_TOP) {
+      printf("\n");
+      fflush(stdout);
+   }
    
    /* initialise and  pass information to the forward backward library */
-   InitialiseForBack(fbInfo, x, hset, uFlags, pruneInit, pruneInc,
-                     pruneLim, minFrwdP);
+   if (!up_durLoaded && up_durMMF[0]=='\0')
+      InitialiseForBack(fbInfo, x, hset, uFlags_hmm, NULL, (UPDSet)0, 
+                        pruneInit, pruneInc, pruneLim, minFrwdP, useAlign, FALSE);
+   else
+      InitialiseForBack(fbInfo, x, hset, uFlags_hmm, dset, uFlags_dur, 
+                        pruneInit, pruneInc, pruneLim, minFrwdP, useAlign, ((up_durLoaded)?FALSE:TRUE));
 
    if (parMode != 0) {
       ConvLogWt(hset);
@@ -646,18 +1031,18 @@ void Initialise(FBInfo *fbInfo, MemHeap 
    /* 2-model reestimation */
    if (al_hmmUsed){
        if (trace&T_TOP)
-           printf("2-model re-estimation enabled\n");
+           printf("2-model re-estimation enabled (HMM) \n");
        /* load alignment HMM set */
        CreateHMMSet(&al_hset,&hmmStack,TRUE);
-       xfInfo.al_hset = &al_hset;
-       if (xfInfo.alXFormExt == NULL) xfInfo.alXFormExt = xfInfo.inXFormExt;
+       xfInfo_hmm.al_hset = &al_hset;
+       if (xfInfo_hmm.al_inXFormExt == NULL) xfInfo_hmm.al_inXFormExt = xfInfo_hmm.inXFormExt;
        /* load multiple MMFs */
        if (strlen(al_hmmMMF) > 0 ) {
            char *p,*q;
            Boolean eos;
            p=q=al_hmmMMF;
            for(;;) {
-               eos = (*p=='\0');
+              eos = (*p=='\0') ? TRUE:FALSE;
                if ( ( isspace((int) *p) || *p == '\0' ) && (q!=p) ) {
                    *p='\0';
                    if (trace&T_TOP) { 
@@ -680,8 +1065,6 @@ void Initialise(FBInfo *fbInfo, MemHeap 
        else
            LoadHMMSet(&al_hset,NULL,NULL);
 
-       /* switch model set */
-       UseAlignHMMSet(fbInfo,x,&al_hset);
        if (parMode != 0) {
 	  ConvDiagC(&al_hset,TRUE);
 	  ConvLogWt(&al_hset);
@@ -693,32 +1076,98 @@ void Initialise(FBInfo *fbInfo, MemHeap 
                printf(" HMM Dir %s",al_hmmDir);
            if (strlen(al_hmmExt) > 0 )
                printf(" Ext %s",al_hmmExt);
-           printf("\n");
+           /* printf("\n"); */
            if (strlen(al_hmmLst) > 0 )
                printf("HMM List %s\n",al_hmmLst);
            printf(" %d Logical/%d Physical Models Loaded, VecSize=%d\n",
                   al_hset.numLogHMM,al_hset.numPhyHMM,al_hset.vecSize);
        }
    }
+   
+   if (al_durUsed){
+      if (trace&T_TOP)
+         printf("\n2-model re-estimation enabled (duration model)\n");
+      /* load alignment duration model set */
+      CreateHMMSet(&al_dset,&durStack,TRUE);
+      xfInfo_dur.al_hset = &al_dset;
+      if (xfInfo_dur.al_inXFormExt == NULL) xfInfo_dur.al_inXFormExt = xfInfo_dur.inXFormExt;
+      /* load multiple MMFs */
+      if (strlen(al_durMMF) > 0 ) {
+         char *p,*q;
+          Boolean eos;
+          p=q=al_durMMF;
+          for (;;) {
+             eos = (*p=='\0') ? TRUE:FALSE;
+             if ( ( isspace((int) *p) || *p == '\0' ) && (q!=p) ) {
+                *p='\0';
+                if (trace&T_TOP) { 
+                   printf("Loading alignment duration model set %s\n",q);
+                }
+                AddMMF(&al_dset,q);
+                if (eos) break;
+                q=p+1;
+             }
+             p++;
+          }
+      }
+      if (strlen(al_durLst) > 0 ) 
+         MakeHMMSet(&al_dset, al_durLst );
+      else /* use same durList */
+         MakeHMMSet(&al_dset, durListFn );
+      if (strlen(al_durDir) > 0 )
+         LoadHMMSet(&al_dset,al_durDir,al_durExt);
+      else
+         LoadHMMSet(&al_dset,NULL,NULL);
+
+      if (parMode != 0) {
+         ConvDiagC(&al_dset,TRUE);
+         ConvLogWt(&al_dset);
+      }
+       
+      /* and echo status */
+      if (trace&T_TOP) { 
+         if (strlen(al_durDir) > 0 )
+            printf(" Duration Model Dir %s",al_durDir);
+         if (strlen(al_durExt) > 0 )
+            printf(" Ext %s",al_durExt);
+         /* printf("\n"); */
+         if (strlen(al_durLst) > 0 )
+            printf("Duration Model List %s\n",al_durLst);
+         printf(" %d Logical/%d Physical Models Loaded, VecSize=%d\n",
+                al_dset.numLogHMM,al_dset.numPhyHMM,al_dset.vecSize);
+      }
+   }
+   
+   if (trace&T_TOP) {
+      printf("\n");
+      fflush(stdout);
+   }
+   
+   /* switch model set */
+   if (al_durUsed || al_hmmUsed)
+      UseAlignHMMSet(fbInfo,x,((al_hmmUsed)?&al_hset:NULL),((al_durUsed)?&al_dset:NULL));
 }
 
 /* ------------------- Statistics Reporting  -------------------- */
 
 /* PrintStats: for given hmm */
-void PrintStats(HMMSet *hset,FILE *f, int n, HLink hmm, int numEgs)
+void PrintStats(HMMSet *hset,FILE *f, int n, HLink hmm, long numEgs)
 {
-   WtAcc *wa;
    char buf[MAXSTRLEN];
    StateInfo *si;
    int i,N;
+   float occ;
     
    N = hmm->numStates;
    ReWriteString(HMMPhysName(hset,hmm),buf,DBL_QUOTE);
-   fprintf(f,"%4d %14s %4d ",n,buf,numEgs);
+   fprintf(f,"%4d %14s %4ld ",n,buf,numEgs);
    for (i=2;i<N;i++) {
       si = hmm->svec[i].info;
-      wa = (WtAcc *)((si->pdf+1)->hook);
-      fprintf(f," %10f",wa->occ);
+      if (hset->numSharedStreams>0)  /* if streams are shared, using wa->occ is not appropriate */
+         memcpy(&occ,&(si->hook),sizeof(float));
+      else
+         occ = ((WtAcc *)((si->pdf+1)->info->hook))->occ;
+      fprintf(f," %10f",occ);
    }
    fprintf(f,"\n");
 }
@@ -739,17 +1188,139 @@ void StatReport(HMMSet *hset)
    px=1;
    do {
       hmm = hss.hmm;
-      PrintStats(hset,f,px,hmm,(int)hmm->hook);
+      PrintStats(hset,f,px,hmm,(long)hmm->hook);
       px++;
    } while (GoNextHMM(&hss));
    EndHMMScan(&hss);
    fclose(f);
 }
 
+/* ------------------- Duration model related operations  -------------------- */
+void GenDurMMF (HMMSet *hset, char *durfn)
+{
+   FILE *fp;
+   char buf[MAXSTRLEN];
+   int h,i,N,MaxN;
+   Boolean isPipe;
+   MLink mac;
+   HLink hmm;
+   
+   /* vSize of dur MMF */
+   MaxN  = MaxStatesInSet(hset)-2;
+   
+   /* ------- Output duration model ------- */
+   if (trace & T_TOP)
+      printf("Generatnig dur MMF from HMM MMF...\n");
+      
+   if ((fp = FOpen(durfn,NoOFilter,&isPipe)) == NULL)
+      HError(7360,"GenDurMMF: Cannot create dur MMF file %s", durfn);
+   
+   /* output model definition and dummy state-transition matrix */   
+   fprintf(fp,"~o\n");
+   fprintf(fp,"<STREAMINFO> %d", MaxN);
+   for (i=1; i<=MaxN; i++)
+      fprintf(fp," 1");
+   fprintf(fp,"\n<MSDINFO> %d", MaxN);
+   for (i=1; i<=MaxN; i++)
+      fprintf(fp," 0");
+   fprintf(fp,"\n<VECSIZE> %d <NULLD><DIAGC><%s>\n",MaxN,ParmKind2Str(hset->pkind,buf));
+   fprintf(fp,"~t \"trP_1\"\n<TRANSP> 3\n");
+   fprintf(fp,"0 1 0\n0 0 1\n0 0 0\n");
+
+   /* output vfloor macro */
+   for (i=1; i<=MaxN; i++) {
+      fprintf(fp,"~v \"varFloor%d\" \n",i);
+      fprintf(fp,"<VARIANCE> 1\n");
+      fprintf(fp,"%e\n",minVar);
+   }
+
+   /* output dummy state duration PDFs */
+   for (h=0; h<MACHASHSIZE; h++) {
+      for (mac=hset->mtab[h]; mac!=NULL; mac=mac->next) {
+         if (mac->type=='h') {
+            hmm = mac->structure;
+            N = hmm->numStates-2;
+            if (N!=MaxN)
+               HError(7399,"GenDurMMF: Number of states is inconsistent in %s", mac->id->name);
+
+            fprintf(fp,"~h \"%s\"\n",mac->id->name);
+            fprintf(fp,"<BEGINHMM>\n<NUMSTATES> 3\n<STATE> 2\n");
+            
+            /* output dummy mean & variance */
+            for (i=1; i<=N; i++) {
+               fprintf(fp,"<STREAM> %d\n", i);
+               fprintf(fp,"<MEAN> 1\n");
+               fprintf(fp," 0.0\n");
+               fprintf(fp,"<VARIANCE> 1\n");
+               fprintf(fp," 1.0\n");
+            }
+
+            /* output link to the dummy transition matrix macro */
+            fprintf(fp,"~t \"trP_1\"\n<ENDHMM>\n");
+         }
+      }
+   }
+   
+   FClose(fp,isPipe);
+   
+   if (trace&T_TOP) {
+      printf("done");
+      fflush(stdout);
+   }
+   
+   return;
+}
+
+/* UpdateVFloors: use acc values to calc new estimate of variance floors */
+void UpdateVFloors (HMMSet *hset, const double minVar, const double percent)
+{
+   int s;
+   float mean;
+   double occ,sum,sqr;
+   HMMScanState hss;
+   MuAcc *ma=NULL;
+   VaAcc *va=NULL;
+   Vector varFloor[SMAX];
+   
+   /* get current variance floor */
+   SetVFloor(hset,varFloor,minVar);
+   
+   for (s=1; s<=hset->swidth[0]; s++) {
+      /* initialization */
+      occ = sum = sqr = 0.0;
+      
+      /* acc statistics for variance flooring */
+      NewHMMScan(hset,&hss);
+      while (GoNextMix(&hss,FALSE)) {
+         if ((hss.s==s) && (VectorSize(hss.mp->mean)==hset->swidth[s])) {  /* MSD check */
+            /* get mean & variance accumulators */
+            va = (VaAcc *) GetHook(hss.mp->cov.var);
+            ma = (MuAcc *) GetHook(hss.mp->mean);
+            mean = hss.mp->mean[1];
+            
+            /* accumulate */
+            occ += va->occ;
+            sum += ma->mu[1] + ma->occ*mean;
+            sqr += va->cov.var[1] + 2*mean*(ma->mu[1]+ma->occ*mean) - va->occ*mean*mean; 
+         }
+      }
+      EndHMMScan(&hss);
+
+      /* update vfloor */
+      varFloor[s][1] = (sqr/occ - sum/occ*sum/occ) * percent/100.0;
+   }
+                    
+   /* Reset vfloor */
+   ResetVFloor(hset,varFloor);
+   
+   return;
+}
+
+
 /* -------------------- Top Level of F-B Updating ---------------- */
 
 
-/* Load data and call FBFile: apply forward-backward to given utterance */
+/* Load data and call FBUtt: apply forward-backward to given utterance */
 void DoForwardBackward(FBInfo *fbInfo, UttInfo *utt, char * datafn, char * datafn2)
 {
    char datafn_lab[MAXFNAMELEN];
@@ -768,13 +1340,10 @@ void DoForwardBackward(FBInfo *fbInfo, U
    /* Load the data */
    LoadData(fbInfo->al_hset, utt, dff, datafn, datafn2);
 
-   if (firstTime) {
       InitUttObservations(utt, fbInfo->al_hset, datafn, fbInfo->maxMixInS);
-      firstTime = FALSE;
-   }
   
    /* fill the alpha beta and otprobs (held in fbInfo) */
-   if (FBFile(fbInfo, utt, datafn)) {
+   if (FBUtt(fbInfo, utt)) {
       /* update totals */
       totalT += utt->T ;
       totalPr += utt->pr ;
@@ -782,8 +1351,9 @@ void DoForwardBackward(FBInfo *fbInfo, U
       if (fbInfo->al_hset->xf != NULL) {
          totalPr += utt->T*0.5*fbInfo->al_hset->xf->xform->det;
       }
-
    }
+   ResetHeap(&fbInfo->ab->abMem);
+   ResetUttObservations(utt, fbInfo->al_hset);
 }
 
 /* --------------------------- Model Update --------------------- */
@@ -825,7 +1395,7 @@ void FloorMixes(HMMSet *hset, MixtureEle
    if (hset->logWt == TRUE) HError(999,"FloorMixes requires linear weights");
    sum = fsum = 0.0;
    for (m=1,me=mixes; m<=M; m++,me++) {
-      if (MixWeight(hset,me->weight)>floor)
+      if (me->weight>floor)
          sum += me->weight;
       else {
          fsum += floor; me->weight = floor;
@@ -836,7 +1406,7 @@ void FloorMixes(HMMSet *hset, MixtureEle
    if (sum == 0.0) HError(2328,"FloorMixes: No mixture weights above floor");
    scale = (1.0-fsum)/sum;
    for (m=1,me=mixes; m<=M; m++,me++)
-      if (me->weight>floor) me->weight *= scale;
+      if (MixWeight(hset,me->weight)>floor) me->weight *= scale;
 }
 
 /* FloorTMMixes: apply floor to given tied mix set */
@@ -901,6 +1471,7 @@ void UpdateWeights(HMMSet *hset, int px,
    WtAcc *wa;
    StateElem *se;
    StreamElem *ste;
+   StreamInfo *sti;
    MixtureElem *me;
    HSetKind hsKind;
 
@@ -911,7 +1482,8 @@ void UpdateWeights(HMMSet *hset, int px,
    for (i=2; i<N; i++,se++){
       ste = se->info->pdf+1;
       for (s=1;s<=S; s++,ste++){
-         wa = (WtAcc *)ste->hook;
+         sti = ste->info;
+         wa = (WtAcc *)sti->hook;
          switch (hsKind){
          case TIEDHS:
             M=hset->tmRecs[s].nMix;
@@ -919,7 +1491,7 @@ void UpdateWeights(HMMSet *hset, int px,
          case DISCRETEHS:
          case PLAINHS:
          case SHAREDHS:
-            M=ste->nMix;
+            M=sti->nMix;
             break;
          }
          if (wa != NULL) {
@@ -935,14 +1507,14 @@ void UpdateWeights(HMMSet *hset, int px,
                   }
                   switch (hsKind){
                   case TIEDHS:
-                     ste->spdf.tpdf[m] = (x>MINMIX) ? x : 0.0;
+                     sti->spdf.tpdf[m] = (x>MINMIX) ? x : 0.0;
                      break;
                   case DISCRETEHS:
-                     ste->spdf.dpdf[m]=(x>MINMIX) ? DProb2Short(x) : DLOGZERO;
+                     sti->spdf.dpdf[m]=(x>MINMIX) ? DProb2Short(x) : DLOGZERO;
                      break;
                   case PLAINHS:
                   case SHAREDHS:
-                     me=ste->spdf.cpdf+m;
+                     me=sti->spdf.cpdf+m;
                      me->weight = (x>MINMIX) ? x : 0.0;
                      break;
                   }
@@ -950,21 +1522,21 @@ void UpdateWeights(HMMSet *hset, int px,
                if (mixWeightFloor>0.0){
                   switch (hsKind){
                   case DISCRETEHS:
-                     FloorDProbs(ste->spdf.dpdf,M,mixWeightFloor);
+                     FloorDProbs(sti->spdf.dpdf,M,mixWeightFloor);
                      break;
                   case TIEDHS:
-                     FloorTMMixes(ste->spdf.tpdf,M,mixWeightFloor);
+                     FloorTMMixes(sti->spdf.tpdf,M,mixWeightFloor);
                      break;
                   case PLAINHS:
                   case SHAREDHS:
-                     FloorMixes(hset,ste->spdf.cpdf+1,M,mixWeightFloor);
+                     FloorMixes(hset,sti->spdf.cpdf+1,M,mixWeightFloor);
                      break;
                   }
                }
             }else
                HError(-2330,"UpdateWeights: Model %d[%s]: no use of mixtures in %d.%d",
                       px,HMMPhysName(hset,hmm),i,s);
-            ste->hook = NULL;
+            sti->hook = NULL;
          }
       }
    }
@@ -978,8 +1550,9 @@ void UpdateMeans(HMMSet *hset, int px, H
    MuAcc *ma;
    StateElem *se;
    StreamElem *ste;
+   StreamInfo *sti;
    MixtureElem *me;
-   Vector mean;
+   Vector mean, mu;
    
    N = hmm->numStates;
    se = hmm->svec+2;
@@ -987,23 +1560,24 @@ void UpdateMeans(HMMSet *hset, int px, H
    for (i=2; i<N; i++,se++){
       ste = se->info->pdf+1;
       for (s=1;s<=S;s++,ste++){
-         /* nuisance dimensions not updated */
-         vSize = hset->swidth[s]-hset->projSize;
-         me = ste->spdf.cpdf + 1; M = ste->nMix;
+         sti = ste->info; 
+         me = sti->spdf.cpdf + 1; M = sti->nMix;
          for (m=1;m<=M;m++,me++)
             if (me->weight > MINMIX){
                mean = me->mpdf->mean;
+               /* nuisance dimensions not updated */   
+               vSize = VectorSize(mean) - hset->projSize;
                ma = (MuAcc *) GetHook(mean);
                if (ma != NULL){
                   occim = ma->occ;
+                  mu    = ma->mu;
                   if (occim > 0.0)
+                     /* if you use Intel C compiler, following loop will be vectorized */
                      for (k=1; k<=vSize; k++) 
-                       mean[k] += ma->mu[k]/occim;
-                  else{
-                     M = ste->nMix;
+                        mean[k] += mu[k]/occim;
+                  else if (trace&T_UPD)
                      HError(-2330,"UpdateMeans: Model %d[%s]: no use of mean %d.%d.%d",
                             px,HMMPhysName(hset,hmm),i,s,m);
-                  }
                   SetHook(mean,NULL);
                }
             }
@@ -1051,6 +1625,7 @@ void UpdateVars(HMMSet *hset, int px, HL
    MuAcc *ma;
    StateElem *se;
    StreamElem *ste;
+   StreamInfo *sti;
    MixtureElem *me;
    Vector mean;
    Covariance cov;
@@ -1062,9 +1637,9 @@ void UpdateVars(HMMSet *hset, int px, HL
    for (i=2; i<N; i++,se++){
       ste = se->info->pdf+1;
       for (s=1;s<=S;s++,ste++){
-         vSize = hset->swidth[s]-hset->projSize;
+         sti = ste->info;
          minV = vFloor[s];
-         me = ste->spdf.cpdf + 1; M = ste->nMix;
+         me = sti->spdf.cpdf + 1; M = sti->nMix;
          for (m=1;m<=M;m++,me++)
             if (me->weight > MINMIX){
                if (me->mpdf->vFloor == NULL) mpV=minV;
@@ -1072,17 +1647,18 @@ void UpdateVars(HMMSet *hset, int px, HL
                cov = me->mpdf->cov;
                va = (VaAcc *) GetHook(cov.var);
                mean = me->mpdf->mean;
+               vSize = VectorSize(mean) - hset->projSize;
                ma = (MuAcc *) GetHook(mean);
                if (va != NULL){
                   occim = va->occ;
                   mixFloored = FALSE;
                   if (occim > 0.0){
-                     shared=(GetUse(cov.var)>1 || ma==NULL || ma->occ<=0.0);
+                     shared=((GetUse(cov.var)>1 || ma==NULL || ma->occ<=0.0)) ? TRUE:FALSE;
                      if (me->mpdf->ckind==DIAGC) {
                         for (k=1; k<=vSize; k++){
                            muDiffk=(shared)?0.0:ma->mu[k]/ma->occ;
                            x = va->cov.var[k]/occim - muDiffk*muDiffk;
-                           if (x<mpV[k]) {
+                           if (applyVFloor && x<mpV[k]) {
                               x = mpV[k];
                               nFloorVar++;
                               mixFloored = TRUE;
@@ -1096,7 +1672,7 @@ void UpdateVars(HMMSet *hset, int px, HL
                            for (l=1; l<=k; l++){
                               muDiffl=(shared)?0.0:ma->mu[l]/ma->occ;
                               x = va->cov.inv[k][l]/occim - muDiffk*muDiffl; 
-                              if (k==l && x<mpV[k]) {
+                              if (applyVFloor && k==l && x<mpV[k]) {
                                  x = mpV[k];
                                  nFloorVar++;
                                  mixFloored = TRUE;
@@ -1107,18 +1683,17 @@ void UpdateVars(HMMSet *hset, int px, HL
                         CovInvert(cov.inv,cov.inv);
                      }
                   }
-                  else{
-                    MixtureElem *me2;
-                    me2 = ste->spdf.cpdf + 1; M = ste->nMix;
+                  else if (trace&T_UPD)    /* PLAINHS & MSD, this warning often happen */
                     HError(-2330,"UpdateVars: Model %d[%s]: no use of variance %d.%d.%d",
                            px,HMMPhysName(hset,hmm),i,s,m);
-                  }
                   if (mixFloored == TRUE) nFloorVarMix++;
                   SetHook(cov.var,NULL);
                }
             }
       }
    }
+   
+   return;
 }
 
 /* UpdateTMVars: use acc values to calc new estimate of vars for TIEDHS */
@@ -1149,12 +1724,12 @@ void UpdateTMVars(HMMSet *hset)
             occim = va->occ;
             mixFloored = FALSE;
             if (occim > 0.0){
-               shared=(GetUse(cov.var)>1 || ma==NULL || ma->occ<=0.0);
+               shared=((GetUse(cov.var)>1 || ma==NULL || ma->occ<=0.0)) ? TRUE:FALSE;
                if (mpdf->ckind==DIAGC) {
                   for (k=1; k<=vSize; k++){
                      muDiffk=(shared)?0.0:ma->mu[k]/ma->occ;
                      x = va->cov.var[k]/occim - muDiffk*muDiffk;
-                     if (x<minV[k]) {
+                     if (applyVFloor && x<minV[k]) {
                         x = minV[k];
                         nFloorVar++;
                         mixFloored = TRUE;
@@ -1168,7 +1743,7 @@ void UpdateTMVars(HMMSet *hset)
                      for (l=1; l<=k; l++){
                         muDiffl=(shared)?0.0:ma->mu[l]/ma->occ;
                         x = va->cov.inv[k][l]/occim - muDiffk*muDiffl;
-                        if (k==l && x<minV[k]) {
+                        if (applyVFloor && k==l && x<minV[k]) {
                            x = minV[k];
                            nFloorVar++;
                            mixFloored = TRUE;
@@ -1186,6 +1761,8 @@ void UpdateTMVars(HMMSet *hset)
          }
       }
    }
+     
+   return;
 }
 
 static  int fltcompare(const void *_i, const void *_j)
@@ -1199,8 +1776,8 @@ static  int fltcompare(const void *_i, c
   return (0);
 }
 
-
-void FloorVars(HMMSet *hset1, int s){
+void FloorVars(HMMSet *hset1, int s)
+{
   HMMScanState hss1;
   int vsize;
   int i;
@@ -1213,16 +1792,18 @@ void FloorVars(HMMSet *hset1, int s){
      
      NewHMMScan(hset1,&hss1); 
      while(GoNextMix(&hss1,FALSE)){
-        if (hss1.s == s) M++;
+         if ((hss1.s==s) && (VectorSize(hss1.mp->mean)==vsize))  /* MSD */
+            M++;
      }
      EndHMMScan(&hss1); 
 
      varray = New(&gstack, sizeof(float*) * (vsize+1));
-     for(i=1;i<=vsize;i++) varray[i] = New(&gstack, sizeof(float) * M);
+      for (i=1; i<=vsize; i++) 
+         varray[i] = New(&gstack, sizeof(float) * M);
 
      NewHMMScan(hset1,&hss1); 
      while(GoNextMix(&hss1,FALSE)){
-        if (hss1.s == s) {
+         if ((hss1.s==s) && (VectorSize(hss1.mp->mean)==vsize)) {  /* MSD */
            int k;
            if(hss1.mp->ckind != DIAGC ) HError(1, "FloorVars expects DIAGC covariances. ");
            
@@ -1243,7 +1824,7 @@ void FloorVars(HMMSet *hset1, int s){
 
      NewHMMScan(hset1,&hss1); 
      while(GoNextMix(&hss1,FALSE)){
-        if (hss1.s == s) {
+        if ((hss1.s==s) && (VectorSize(hss1.mp->mean)==vsize)) {  /* MSD */
            int k, Pos = (int)(varFloorPercent*0.01*M);
            for(k=1;k<=vsize;k++){
               if(hss1.mp->cov.var[k] < varray[k][Pos]){
@@ -1255,8 +1836,15 @@ void FloorVars(HMMSet *hset1, int s){
      }
      EndHMMScan(&hss1); 
      printf("Floored %d (expected to floor %d)\n", floored, (int)( varFloorPercent * 0.01 * M * vsize));
+
+      for (i=vsize; i>=1; i--)
+         Dispose(&gstack, varray[i]);
+      Dispose(&gstack, varray);
   }
+
   FixAllGConsts(hset1);
+ 
+   return;
 }
 
 void MLUpdateModels(HMMSet *hset, UPDSet uFlags)
@@ -1264,8 +1852,10 @@ void MLUpdateModels(HMMSet *hset, UPDSet
    HSetKind hsKind;
    HMMScanState hss;
    HLink hmm;
-   int px,n,maxM;
+   int px,maxM;
+   long n;
 
+   SetVFloor(hset,vFloor,minVar);
    hsKind = hset->hsKind;
    maxM = MaxMixInSet(hset);
 
@@ -1282,16 +1872,16 @@ void MLUpdateModels(HMMSet *hset, UPDSet
    px=1;
    do {   
       hmm = hss.hmm;
-      n = (int)hmm->hook;
+      n = (long)hmm->hook;
       if (n<minEgs && !(trace&T_UPD))
-         HError(-2331,"UpdateModels: %s[%d] copied: only %d egs\n",
+         HError(-2331,"UpdateModels: %s[%d] copied: only %ld egs\n",
                 HMMPhysName(hset,hmm),px,n);
       if (trace&T_UPD) {
          if (n<minEgs)
-            printf("Model %s[%d] copied: only %d examples\n",
+            printf("Model %s[%d] copied: only %ld examples\n",
                    HMMPhysName(hset,hmm),px,n);
          else
-            printf("Model %s[%d] to be updated with %d examples\n",
+            printf("Model %s[%d] to be updated with %ld examples\n",
                    HMMPhysName(hset,hmm),px,n);
          fflush(stdout);
       }
@@ -1318,18 +1908,21 @@ void MLUpdateModels(HMMSet *hset, UPDSet
                 nFloorVar,nFloorVarMix);
       fflush(stdout);
    }
+   ResetVFloor(hset,vFloor);
 }
 
-
 /* UpdateModels: update all models and save them in newDir if set,
-   new files have newExt if set */
-void UpdateModels(HMMSet *hset, ParmBuf pbuf2)
+   new files have newhmmExt if set */
+void UpdateModels (HMMSet *hset, XFInfo *xfinfo, ParmBuf pbuf2, UPDSet uFlags)
 {
    int maxM;
-   static char str[100];
+   static char str[MAXSTRLEN];
    BufferInfo info2;
    char macroname[MAXSTRLEN];
 
+   nFloorVar = 0;     /* # of floored variance comps */
+   nFloorVarMix = 0;  /* # of mix comps with floored vars */
+
    if (trace&T_UPD){
       printf("Starting Model Update\n"); fflush(stdout);
    }
@@ -1345,15 +1938,14 @@ void UpdateModels(HMMSet *hset, ParmBuf 
       not updated 
    */
    if (uFlags & UPSEMIT) {
-      UpdateSemiTiedModels(hset, &xfInfo);
-      uFlags = uFlags & ~(UPMEANS|UPVARS);
+      UpdateSemiTiedModels(hset, xfinfo);
+      uFlags = (UPDSet)(uFlags & ~(UPMEANS|UPVARS));
    }
 
    if (uFlags & UPMAP)
      MAPUpdateModels(hset, uFlags);
-   else {
+   else
      MLUpdateModels(hset, uFlags);     
-   }
    
    if(varFloorPercent){
       int s;
@@ -1362,13 +1954,6 @@ void UpdateModels(HMMSet *hset, ParmBuf 
          FloorVars(hset,s);
    }
 
-   if (trace&T_TOP){
-      if (mmfFn == NULL)
-         printf("Saving hmm's to dir %s\n",(newDir==NULL)?"Current":newDir); 
-      else
-         printf("Saving hmm's to MMF %s\n",mmfFn);
-      fflush(stdout);
-   }
    ClearSeenFlags(hset,CLR_ALL);
    if (twoDataFiles){
       if (parMode == 0){
@@ -1386,11 +1971,11 @@ void UpdateModels(HMMSet *hset, ParmBuf 
 	 hset->xf = info2.xform;
       }
    }
-   SaveHMMSet(hset,newDir,newExt,NULL,saveBinary);
-   if (trace&T_TOP) {
-      printf("Reestimation complete - average log prob per frame = %e\n",
-             totalPr/totalT);
-      printf("     - total frames seen          = %e\n", (double)totalT);
+
+   if (xfinfo->outFullC && (uFlags&UPSEMIT)) {
+      SetXForm(hset,xfinfo,xfinfo->outXForm);
+      ApplyHMMSetXForm(hset, xfinfo->outXForm, TRUE);
+      hset->semiTied = NULL;
    }
 }
 
diff -pbBEwurNa --ignore-matching-lines='.*vc_id.*' HTK-3.4.1/HTKTools/HHEd.c HTS-2.2_for_HTK-3.4.1/HTKTools/HHEd.c
--- HTK-3.4.1/HTKTools/HHEd.c	2009-03-13 03:52:09.000000000 +0900
+++ HTS-2.2_for_HTK-3.4.1/HTKTools/HHEd.c	2011-06-16 14:18:47.000000000 +0900
@@ -32,8 +32,53 @@
 /*         File: HHEd:  HMM Source Definition Editor           */
 /* ----------------------------------------------------------- */
 
+/*  *** THIS IS A MODIFIED VERSION OF HTK ***                        */
+/* ----------------------------------------------------------------- */
+/*           The HMM-Based Speech Synthesis System (HTS)             */
+/*           developed by HTS Working Group                          */
+/*           http://hts.sp.nitech.ac.jp/                             */
+/* ----------------------------------------------------------------- */
+/*                                                                   */
+/*  Copyright (c) 2001-2011  Nagoya Institute of Technology          */
+/*                           Department of Computer Science          */
+/*                                                                   */
+/*                2001-2008  Tokyo Institute of Technology           */
+/*                           Interdisciplinary Graduate School of    */
+/*                           Science and Engineering                 */
+/*                                                                   */
+/* All rights reserved.                                              */
+/*                                                                   */
+/* Redistribution and use in source and binary forms, with or        */
+/* without modification, are permitted provided that the following   */
+/* conditions are met:                                               */
+/*                                                                   */
+/* - Redistributions of source code must retain the above copyright  */
+/*   notice, this list of conditions and the following disclaimer.   */
+/* - Redistributions in binary form must reproduce the above         */
+/*   copyright notice, this list of conditions and the following     */
+/*   disclaimer in the documentation and/or other materials provided */
+/*   with the distribution.                                          */
+/* - Neither the name of the HTS working group nor the names of its  */
+/*   contributors may be used to endorse or promote products derived */
+/*   from this software without specific prior written permission.   */
+/*                                                                   */
+/* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND            */
+/* CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,       */
+/* INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF          */
+/* MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE          */
+/* DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS */
+/* BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,          */
+/* EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED   */
+/* TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,     */
+/* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON */
+/* ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,   */
+/* OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY    */
+/* OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE           */
+/* POSSIBILITY OF SUCH DAMAGE.                                       */
+/* ----------------------------------------------------------------- */
+
 char *hhed_version = "!HVER!HHEd:   3.4.1 [CUED 12/03/09]";
-char *hhed_vc_id = "$Id: HHEd.c,v 1.2 2006/12/07 11:09:08 mjfg Exp $";
+char *hhed_vc_id = "$Id: HHEd.c,v 1.105 2011/06/16 05:18:47 uratec Exp $";
 
 /*
    This program is used to read in a set of HMM definitions
@@ -90,6 +135,7 @@ char *hhed_vc_id = "$Id: HHEd.c,v 1.2 20
 static MemHeap questHeap;   /* Heap holds all questions */
 static MemHeap hmmHeap;     /* Heap holds all hmm related info */
 static MemHeap tmpHeap;     /* Temporary (duration of command or less) heap */
+static Vector vf[SMAX];     /* variance flooring */
 
 /* Global Settings */
 
@@ -97,6 +143,7 @@ static char * hmmDir = NULL;     /* dire
 static char * hmmExt = NULL;     /* hmm def file extension */
 static char * newDir = NULL;     /* directory to store new hmm def files */
 static char * newExt = NULL;     /* extension of new edited hmm files */
+static char * hmmListFn = NULL;  /* HMM list file */
 static Boolean noAlias = FALSE;  /* set to zap all aliases in hmmlist */
 static Boolean inBinary = FALSE; /* set to save models in binary */
 static char * mmfFn  = NULL;     /* output MMF file, if any */
@@ -121,29 +168,46 @@ static Boolean badGC = FALSE;          /
 static float meanGC,stdGC;             /* mean and stdev of GConst */
 static Boolean occStatsLoaded = FALSE; /* set when RO/LS has loaded occ stats */
 static float outlierThresh = -1.0;     /* outlier threshold set by RO cmd */
+static IntSet streams;                 /* information for tree-based clustering */
 
 static int thisCommand;                /* index of current command */
 static int lastCommand=0;              /* index of previous command */
 static Boolean equivState = TRUE;      /* TRUE if states can be equivalent */
                                        /*  but not identical */
 static Boolean useModelName = TRUE;    /* Use base-phone name as tree name */
+static Boolean usePattern   = FALSE;   /* Use pattern as tree name */
+static int useRefTree = -1;            /* Use reference tree for tree-based clustering */
 static Boolean saveHMMSet   = TRUE;    /* Save the HMMSet */
 
+/* information about transforms */
+static XFInfo xfInfo;                  /* for AX command */
+
 /* ---------------- Configuration Parameters --------------------- */
 
 static ConfParam *cParm[MAXGLOBS];
 static int nParm = 0;            /* total num params */
 static Boolean treeMerge = TRUE; /* After tree spltting merge leaves */
 static char tiedMixName[MAXSTRLEN] = "TM"; /* Tied mixture base name */
-static char mmfIdMask[MAXSTRLEN] = "*"; /* MMF Id Mask for baseclass */
 static Boolean useLeafStats = TRUE; /* Use leaf stats to init macros */
+static char mmfIdMask[MAXSTRLEN] = "*";       /* MMF Id Mask for baseclass */
 static Boolean applyVFloor = TRUE; /* apply modfied varFloors to vars in model set */ 
+static Boolean singleTree = FALSE;            /* construct a tree for each state position */
+static Boolean applyMDL = FALSE;              /* apply MDL principle for clustering */
+static float MDLfactor = 1.0;                 /* MDL control factor */
+static Boolean ignoreStrW = FALSE;            /* ignore stream weight */
+static float minVar = 1.0E-6;                 /* minimum variance for clusterd item */
+static int reduceMem = 0;                     /* reduce memory requirement for decision-tree clustering (0: no reduction, 1: mid reduction but fast, 2: large reduction but slow */
+static float minLeafOcc = 0.0;                /* minimum occ for each leaf node */
+static float minMixOcc = 0.0;                 /* minimum occ for each mix */
+static Vector shrinkOccThresh=NULL;           /* occupancy threshold for shrinking decision trees */
 
 /* ------------------ Process Command Line -------------------------- */
 
 void SetConfParms(void)
 {
+   char buf[MAXSTRLEN];
    Boolean b;
+   double f;
    int i;
 
    nParm = GetConfig("HHED", TRUE, cParm, MAXGLOBS);
@@ -153,6 +217,17 @@ void SetConfParms(void)
       if (GetConfBool(cParm,nParm,"USELEAFSTATS",&b)) useLeafStats = b;
       if (GetConfBool(cParm,nParm,"APPLYVFLOOR",&b)) applyVFloor = b;
       if (GetConfBool(cParm,nParm,"USEMODELNAME",&b)) useModelName = b;
+      if (GetConfBool(cParm,nParm,"USEPATTERN",&b)) usePattern = b;
+      if (GetConfBool(cParm,nParm,"SINGLETREE",&b)) singleTree = b;
+      if (GetConfBool(cParm,nParm,"APPLYMDL",&b)) applyMDL = b;
+      if (GetConfBool(cParm,nParm,"IGNORESTRW",&b)) ignoreStrW = b;
+      if (GetConfInt(cParm,nParm,"REDUCEMEM",&i)) reduceMem = i;
+      if (GetConfFlt(cParm,nParm,"MINVAR",&f)) minVar = f;
+      if (GetConfFlt(cParm,nParm,"MDLFACTOR",&f)) MDLfactor = f;
+      if (GetConfFlt(cParm,nParm,"MINLEAFOCC",&f)) minLeafOcc = f;
+      if (GetConfFlt(cParm,nParm,"MINMIXOCC",&f)) minMixOcc = f;
+      if (GetConfStr (cParm,nParm,"SHRINKOCCTHRESH",buf))
+         shrinkOccThresh = ParseConfVector(&gstack,buf,TRUE);
       GetConfStr(cParm,nParm,"TIEDMIXNAME",tiedMixName);
       GetConfStr(cParm,nParm,"MMFIDMASK",mmfIdMask);
    }
@@ -160,35 +235,50 @@ void SetConfParms(void)
 
 void Summary(void)
 {
+   printf("\nModified for HTS\n");
    printf("\nHHEd Command Summary\n\n");
    printf("AT i j prob itemlist - Add Transition from i to j in given mats\n");
    printf("AU hmmlist           - Add Unseen triphones in given hmmlist to\n");
    printf("                       currently loaded HMM list using previously\n");
    printf("                       built decision trees.\n");
+   printf("AX filename          - Set the Adapt XForm to filename\n");
+   printf("AX filename smtable L2.mmf L2.list out.mmf\n");
+   printf("                     - Set filename xform to L2 model using state mapping table\n");
    printf("CL hmmList           - CLone hmms to give new hmmList\n");
+   printf("CM directory         - Convert models to pdf for speech synthesizer\n");
    printf("CO newHmmList        - COmpact identical HMM's by sharing same phys model\n");
+   printf("CT directory         - Convert trees/questions for speech synthesizer\n");
+   printf("DM type macroname    - Delete macro from model-set\n");
    printf("DP s n id ...        - Duplicate the hmm set n times using id to differentiate\n");
    printf("                       the new hmms and macros.  Only macros the type of which\n");
    printf("                       appears in s will be duplicated, others will be shared.\n");
+   printf("DR id                - Convert decision trees to a regression tree.\n");
+   printf("DV                   - Convert full covariance to diagonal variances\n"); 
    printf("FA f                 - Set variance floor to average within state variance * f\n");
    printf("FV vFloorfile        - Load variance floor from file\n");
    printf("FC                   - Convert diagonal variances to full covariances\n");
-   printf("HK hsetkind          - change current set to hsetkind\n");
-   printf("JO size floor        - set size and min mix weight for a JOin\n");
-   printf("LS statsfile         - load named statsfile\n");
+   printf("HK hsetkind          - Change current set to hsetkind\n");
+   printf("IT filename          - Clustering while imposing loaded tree structure\n");
+   printf("                       If any empty leaf nodes exist, loaded trees are pruned \n");
+   printf("                       and then saved to filename\n");
+   printf("IX filename          - Set the Input Xform to filename\n");
+   printf("JO size floor        - Set size and min mix weight for a JOin\n");
+   printf("JM hmmFile itemlist  - Join Models on stream or state level\n");
+   printf("LS statsfile         - Load named statsfile\n");
    printf("LT filename          - Load Questions and Trees from filename\n");
    printf("MD n itemlist        - MixDown command, change mixtures in itemlist to n\n");
-   printf("MM s itemlist        - make each item in list into a macro with usage==1\n");
+   printf("MM s itemlist        - Make each item in list into a macro with usage==1\n");
    printf("MT triHmmList        - Make Triphones from loaded biphones\n");
    printf("MU n itemlist        - MixUp command, change mixtures in itemlist to n\n");
    printf("NC n macro itemlist  - N-Cluster specified components and tie\n");
-   printf("QS name itemlist     - define a question as a list of model names\n");
-   printf("RC n id [itemList]   - Build n regression classes (for adaptation purposes)\n");
-   printf("                       this disables the storing of the models\n");  
    printf("PR                   - Convert model-set with PROJSIZE to compact form\n");
    printf("                       also supplying a regression tree identifier/label name\n");
    printf("                       Optional itemList to specify non-speech sounds\n");
-   printf("RM hmmfile           - rem mean in state 2, mix 1 of hmmfile from all \n");
+   printf("PX filename          - Set the Parent Xform to filename\n");
+   printf("QS name itemlist     - Define a question as a list of model names\n");
+   printf("RC n id [itemList]   - Build n regression classes (for adaptation purposes)\n");
+   printf("                       this disables the storing of the models\n");  
+   printf("RM hmmfile           - Rem mean in state 2, mix 1 of hmmfile from all \n");
    printf("                       loaded models nb. whole mean is removed incl. dels\n");
    printf("RN hmmSetIdentifier  - Rename the hmm mmf with a new identifier name\n");
    printf("                       If omitted and MMF contains no identifier, then\n");
@@ -197,8 +287,9 @@ void Summary(void)
    printf("                       final phase in the TC/NC commands.  If statsfile\n");
    printf("                       is omitted, it must be already loaded (see LS)\n");
    printf("RT i j itemlist      - Rem Transition from i to j in given mats\n");
-   printf("SH                   - show the current HMM set (for debugging)\n");
+   printf("SH                   - Show the current HMM set (for debugging)\n");
    printf("SK sk                - Set sample kind of all models to sk\n");
+   printf("SM smtable mmf hlist - Output KLD-based state mapping table\n");
    printf("SS n                 - Split into n data Streams\n");
    printf("ST filename          - Save Questions and Trees to filename\n");
    printf("SU n w1 .. wn        - Split into user defined stream widths\n");
@@ -207,18 +298,36 @@ void Summary(void)
    printf("                       based clustering criterion.\n");
    printf("TC f macro itemlist  - Thresh Cluster specified comps to thresh f and tie\n");
    printf("TI macro itemlist    - TIe the specified components\n");
-   printf("TR n                 - set trace level to n (overrides -T option)\n");
+   printf("TR n                 - Set trace level to n (overrides -T option)\n");
    printf("UT itemlist          - UnTie the specified components\n");
-   printf("XF filename          - Set the Input Xform to filename\n");
+   printf("// comment           - Comment line (ignored)\n");
    Exit(0);
 }
 
 void ReportUsage(void)
 {
+   printf("\nModified for HTS\n");
    printf("\nUSAGE: HHEd [options] editF hmmList\n\n");
    printf(" Option                                       Default\n\n");
+   printf(" -a f    factor to control the second term in the MDL      1.0\n");
    printf(" -d s    dir to find hmm definitions          current\n");
+   printf(" -i      ignore stream weight                              off\n");
+   printf(" -m      apply MDL principle for clustering                off\n");
    printf(" -o s    extension for new hmm files          as source\n");
+   printf(" -p      use pattern instead of base phone                 off\n");
+   printf(" -q n    use reference tree for clustering                 off\n");
+   printf("          0: clustering is stopped by threshold\n");
+   printf("          1: clustering is stopped when leaf don't have occ\n");
+   printf("          2: clustering is stopped by threshold\n");
+   printf("             After that, standard clustering is not performed\n");
+   printf("          3: clustering is stopped when leaf don't have occ\n");
+   printf("             After that, standard clustering is not performed\n");
+   printf(" -r n    reduce memory usage on clustering                 0\n");
+   printf("          0: no memory reduction                           \n");
+   printf("          1: mid reduction but fast                        \n");
+   printf("          2: large reduction but slow                      \n");
+   printf(" -s      construct single tree                             off\n");
+   printf(" -v f    Set minimum variance to f                         1.0E-6\n");
    printf(" -w mmf  Save all HMMs to macro file mmf s    as source\n");
    printf(" -x s    extension for hmm files              none\n");
    printf(" -z      zap aliases in hmmList\n");
@@ -241,13 +350,14 @@ int main(int argc, char *argv[])
    if(InitParm()<SUCCESS)  
       HError(2600,"HHEd: InitParm failed");
    InitUtil();
+   InitAdapt(&xfInfo,NULL);
 
    if (!InfoPrinted() && NumArgs() == 0)
       ReportUsage();
    if (NumArgs() == 0) Exit(0);
    SetConfParms();
  
-   CreateHeap(&hmmHeap,"Model Heap",MSTAK,1,1.0,40000,400000);
+   CreateHeap(&hmmHeap,"Model Heap",MSTAK,1,1.0,40000,1600000);
    CreateHMMSet(&hSet,&hmmHeap,TRUE);hset=&hSet;fidx=0;
 
    while (NextArg() == SWITCHARG) {
@@ -255,14 +365,30 @@ int main(int argc, char *argv[])
       if (strlen(s)!=1) 
          HError(2619,"HHEd: Bad switch %s; must be single letter",s);
       switch(s[0]) {
+      case 'a':
+         MDLfactor = GetChkedFlt(0.0,100000000.0,s); break;
       case 'd':
          if (NextArg()!=STRINGARG)
             HError(2619,"HHEd: Input HMM definition directory expected");
          hmmDir = GetStrArg(); break;  
+      case 'i':
+         ignoreStrW = TRUE; break;
+      case 'm':
+         applyMDL = TRUE; break;
       case 'o':
          if (NextArg()!=STRINGARG)
             HError(2619,"HHEd: Output HMM file extension expected");
          newExt = GetStrArg(); break;
+      case 'p':
+         usePattern = TRUE; break;
+      case 'q':
+         useRefTree = GetChkedInt(0,3,s); break;
+      case 'r':
+         reduceMem = GetChkedInt(0,2,s); break;
+      case 's':
+         singleTree = TRUE; break;
+      case 'v':
+         minVar = GetChkedFlt(0.0,100.0,s); break;
       case 'w':
          if (NextArg()!=STRINGARG)
             HError(2619,"HHEd: Output MMF file name expected");
@@ -306,10 +432,32 @@ int main(int argc, char *argv[])
    if (NumArgs()>1)
       HError(2619,"HHEd: Unexpected extra args on command line");
 
-   Initialise(GetStrArg());
+   hmmListFn = GetStrArg();
+   Initialise(hmmListFn);
 
    if (hset->logWt == TRUE) HError(999,"HHEd requires linear weights");
+
    DoEdit(editFn);
+
+   /* reset heaps */
+   ResetHeap(&hmmHeap);
+   ResetHeap(&tmpHeap);
+   ResetHeap(&questHeap);
+   
+   /* reset modules */
+   ResetAdapt(&xfInfo,NULL);
+   ResetUtil();   
+   ResetParm();
+   ResetModel();
+   ResetVQ();
+   ResetAudio();
+   ResetWave();
+   ResetSigP();
+   ResetMath();
+   ResetLabel();
+   ResetMem();
+   ResetShell();
+   
    Exit(0);
    return (0);          /* never reached -- make compiler happy */
 }
@@ -347,31 +495,37 @@ char *ChkedAlpha(char *what,char *buf)
 
 /* ------------- Question Handling for Tree Building ----------- */
 
-typedef struct _IPat{
+static int nQuestions=0;
+static int nPatterns=0;
+static char **QMTable=NULL;
+static Boolean setQMTable=FALSE;
+
+typedef struct {
    char *pat;
-   struct _IPat *next;
+   int index;
 }IPat;
 
-typedef struct _QEnt *QLink;   /* Linked list of Questions */
-typedef struct _QEnt{           /* each question stored as both pattern and  */
+typedef struct _Question{      /* each question stored as both pattern and  */
    LabId qName;                 /* an expanded list of model names */
-   IPat *patList;               
+   ILink patList;               
    ILink ilist;
-   QLink next;
-}QEnt;
+   char pattern[PAT_LEN];
+   int index;
+   Boolean used;
+} Question;
 
-static QLink qHead = NULL;      /* Head of question list */
-static QLink qTail = NULL;      /* Tail of question list */
+static ILink pList = NULL;      /* pattern list */
+static ILink qList = NULL;      /* question list */
 
 /* TraceQuestion: output given questions */
-void TraceQuestion(char *cmd, QLink q)
+void TraceQuestion(char *cmd, Question *q)
 {
-   IPat *ip;
+   ILink ip;
    
    printf("   %s %s: defines %d % d models\n       ",
           cmd,q->qName->name,NumItems(q->ilist),hset->numLogHMM);
    for (ip=q->patList; ip!=NULL; ip=ip->next)
-      printf("%s ",ip->pat); 
+      printf("%s ",((IPat *)ip->item)->pat);
    printf("\n");
    fflush(stdout);
 }
@@ -413,57 +567,101 @@ char *ParseAlpha(char *src, char *s)
    return NULL;
 }
 
-/* LoadQuestion: store given question in question list */
-void LoadQuestion(char *qName, ILink ilist, char *pattern)
+/* ParsePattern: parse given string and return pattern list */
+void ParsePattern (ILink *patList, char *pattern)
 {
-   QLink q,c;
-   LabId labid;
-   IPat *ip;
-   char *p,*r,buf[MAXSTRLEN];
+   char *p,*r,buf[PAT_LEN];
+   IPat *ip=NULL;
+   ILink i;
    
-   q=(QLink) New(&questHeap,sizeof(QEnt));
-   q->ilist=ilist;
-   labid=GetLabId(qName,TRUE);
-   for (c=qHead;c!=NULL;c=c->next) if (c->qName==labid) break;
-   if (c!=NULL)
-      HError(2661,"LoadQuestion: Question name %s invalid",qName);
-   q->qName=labid; labid->aux=q;
-   q->next = NULL; q->patList = NULL;
-   if (qHead==NULL) {
-      qHead = q; qTail = q;
-   } else {
-      qTail->next = q; qTail = q;
-   }
    for (p=pattern;*p && isspace((int) *p);p++);
+   
+   /* parse head '{' and '(' */
    if (*p!='{')
-      if (p==NULL) HError(2660,"LoadQuestion: no { in itemlist");
+      if (p==NULL) HError(2660,"ParsePattern: no { in itemlist");
    ++p;
+   if (*p=='(')
+      ++p;
+   
+   /* parse tail '}' and ')' */
    for (r=pattern+strlen(pattern)-1;r>=pattern && isspace((int) *r);r--);
-   if (*r!='}') HError(2660,"LoadQuestion: no } in itemlist"); 
+   if (*r!='}') HError(2660,"ParsePattern: no } in itemlist");
+   if (pattern<r && *(r-1)==')') 
+      --r;
    *r = ',';
-   do {                         /* pick up model patterns from item list */
+   
+   /* parse model patterns from item list */
+   do { 
       p=ParseAlpha(p,buf);
       while(isspace((int) *p)) p++;
       if (*p!=',')
-         HError(2660,"LoadQuestion: missing , in itemlist"); 
+         HError(2660,"ParsePattern: missing , in itemlist"); 
       p++;
+      for (i=pList; i!=NULL; i=i->next)
+	if (strcmp(((IPat *)i->item)->pat,buf)==0)
+           break;
+      if (i==NULL) {
       ip=(IPat*) New(&questHeap,sizeof(IPat));
       ip->pat = NewString(&questHeap,strlen(buf));
+      ip->index = nPatterns++;
       strcpy(ip->pat,buf);
-      ip->next = q->patList; q->patList = ip;
+      AddItem(NULL,ip,&pList);
+      }
+      else {
+         ip=(IPat *)i->item;
+      }
+      AddItem(NULL,ip,patList);
    } while (p<r);
+   
+   return;
 }
 
-/* QMatch: return true if given name matches question */
-Boolean QMatch(char *name, QLink q)
+/* LoadQuestion: store given question in question list */
+void LoadQuestion(char *qName, ILink ilist, char *pattern)
 {
-   IPat *ip;
+   ILink i;
+   Question *q,*c=NULL;
+   LabId labid;
    
-   for (ip=q->patList;ip!=NULL;ip=ip->next)
-      if (DoMatch(name,ip->pat)) return TRUE;
+   labid=GetLabId(qName,TRUE);
+   for (i=qList;i!=NULL;i=i->next) {
+      c = (Question *)i->item;
+      if (c->qName==labid) break;
+   }
+   
+   if (i!=NULL) {
+      if (strcmp(c->pattern,pattern)!=0 && useRefTree < 0)
+         HError(2661,"LoadQuestion: Question name %s invalid",qName);
+      else
+         return;
+   }
+   
+   q=(Question *) New(&questHeap,sizeof(Question));
+   q->used=FALSE; q->qName=labid; q->patList=NULL; q->index=nQuestions++;
+   q->ilist = ilist;
+   labid->aux=q; 
+   strcpy(q->pattern, pattern);
+   AddItem(NULL,q,&qList);
+
+   ParsePattern(&q->patList,pattern);
+}
+
+/* IPatMatch: return true if given name matches pattern list */
+Boolean IPatMatch (char *name, ILink patList)
+{
+   ILink ip;
+   
+   for (ip=patList; ip!=NULL; ip=ip->next)
+      if (DoMatch(name, ((IPat *)(ip->item))->pat)) return TRUE;
    return FALSE;
 }
 
+/* QMatch: return true if given name matches question */
+Boolean QMatch(char *name, Question *q)
+{
+   return IPatMatch(name, q->patList);
+}
+
 /* ----------------------- HMM Management ---------------------- */
 
 typedef enum { baseNorm=0, baseLeft, baseRight, baseMono } baseType;
@@ -473,7 +671,7 @@ typedef enum { baseNorm=0, baseLeft, bas
    baseMono (monophone); baseRight (right biphone); baseLeft (left biphone) */
 HLink FindBaseModel(HMMSet *hset,LabId id,baseType type)
 {
-   char baseName[255],buf[255],*p;
+   char baseName[MAXSTRLEN],buf[MAXSTRLEN],*p;
    LabId baseId;
    MLink ml;
    
@@ -485,7 +683,7 @@ HLink FindBaseModel(HMMSet *hset,LabId i
    }
    if (type==baseMono || type==baseLeft) { /* strip Right context */
       strcpy(buf,baseName);
-      if ((p = strrchr(buf,'+')) != NULL) {
+      if ((p = strchr(buf,'+')) != NULL) {
          *p = '\0';
          strcpy(baseName,buf);
       }
@@ -537,6 +735,7 @@ void ShowMacros(HMMDef *hmm)
    StateInfo *si;
    MixtureElem *me;
    StreamElem *ste;
+   StreamInfo *sti;
    MixPDF *mp;
    Ptr strct;
    int i,j,s;
@@ -565,9 +764,10 @@ void ShowMacros(HMMDef *hmm)
 
       if (hset->hsKind==PLAINHS || hset->hsKind==SHAREDHS)
          for (s=1; s<=hset->swidth[0]; s++,ste++) {
-            me = ste->spdf.cpdf + 1;
-            for (j=1; j<=ste->nMix;j++,me++) {
-               if (me->weight > MINMIX) {
+            sti = ste->info;
+            me = sti->spdf.cpdf + 1;
+            for (j=1; j<=sti->nMix;j++,me++) {
+               if (me->weight > MINMIX || hset->msdflag[s]) {
                   mp = me->mpdf;
                   if (mp->nUse>0) {
                      ShowWhere(i,s,j); OutMacro('m',mp);
@@ -638,7 +838,7 @@ void ZapAliases(void)
          }
 }
 
-/* EquivMix: return TRUE if both states are identical */
+/* EquivMix: return TRUE if both mixtures are identical */
 Boolean EquivMix(MixPDF *a, MixPDF *b)
 {
    if (a->mean != b->mean ||
@@ -647,7 +847,7 @@ Boolean EquivMix(MixPDF *a, MixPDF *b)
 }
 
 /* EquivStream: return TRUE if both streams are identical */
-Boolean EquivStream(StreamElem *a, StreamElem *b)
+Boolean EquivStream(StreamInfo *a, StreamInfo *b)
 {
    int m,M;
    MixtureElem *mea,*meb;
@@ -672,10 +872,10 @@ Boolean EquivState(StateInfo *a, StateIn
    int s;
    StreamElem *stea,*steb;
    
-   
    stea = a->pdf+1; steb = b->pdf+1;
    for (s=1; s<=S; s++,stea++,steb++) {
-      if ((stea->nMix!=steb->nMix) || !EquivStream(stea,steb))
+      if ((stea->info->nMix!=steb->info->nMix) || 
+          !EquivStream(stea->info,steb->info))
          return FALSE;
    }
    return TRUE;
@@ -687,8 +887,8 @@ Boolean EquivHMM(HMMDef *a, HMMDef *b)
    int i;
    StateInfo *ai,*bi;
    
-   if (a->numStates!=b->numStates ||
-       a->transP!=b->transP) return FALSE;
+   if (a->numStates!=b->numStates) return FALSE;
+
    for (i=2;i<a->numStates;i++) {
       ai=a->svec[i].info; bi=b->svec[i].info;
       if (ai!=bi && (!equivState ||
@@ -899,6 +1099,7 @@ void SplitStreams(HMMSet *hset,StateInfo
 {
    int j,s,S,m,M,width,V,next;
    StreamElem *ste,*oldste;
+   StreamInfo *sti,*oldsti;
    MixtureElem *me,*oldme;
    MixPDF *mp, *oldmp;
    Boolean hasN;
@@ -914,12 +1115,16 @@ void SplitStreams(HMMSet *hset,StateInfo
    eposIdx = 0;
    for (j=0; j<3; j++) epos[j] = 0;
    for (s=1;s<=S;s++,ste++) {
+      ste->info = (StreamInfo *)New(hset->hmem,sizeof(StreamInfo));
+      sti = ste->info;
+      oldsti = oldste->info;
+      sti->nUse = oldsti->nUse;  sti->hook = NULL; sti->stream = s;
       width = hset->swidth[s];
-      M = ste->nMix = oldste->nMix;
-      ste->hook = NULL;
+      M = sti->nMix = oldsti->nMix;
+      sti->hook = NULL;
       me = (MixtureElem *) New(hset->hmem,M*sizeof(MixtureElem));
-      ste->spdf.cpdf = me-1;
-      oldme=oldste->spdf.cpdf+1;
+      sti->spdf.cpdf = me-1;
+      oldme=oldsti->spdf.cpdf+1;
       for (m=1; m<=M; m++, me++,oldme++) {
          oldmp = oldme->mpdf;
          if (oldmp->nUse>0)
@@ -993,17 +1198,17 @@ ILink TypicalState(ILink ilist, LabId ma
    LogFloat gsum,gmax;
    int m,M;
    StateInfo *si;
-   StreamElem *ste;
+   StreamInfo *sti;
    
    gmax = LZERO; imax = NULL;
    for (i=ilist; i!=NULL; i=i->next) {
       si = ((StateElem *)(i->item))->info;
-      ste = si->pdf+1;
-      M = ste->nMix;
-      gsum = 0;
+      sti = si->pdf[1].info;
+      M = sti->nMix;
+      gsum = 0.0;
       for (m=1; m<=M; m++)
-         if (ste->spdf.cpdf[m].weight>MINMIX)
-            gsum += ste->spdf.cpdf[m].mpdf->gConst;
+         if (sti->spdf.cpdf[m].weight>MINMIX)
+            gsum += sti->spdf.cpdf[m].mpdf->gConst;
          else
             gsum -= 200.0;      /* arbitrary penaltly */
       if (gsum>gmax) {
@@ -1034,17 +1239,39 @@ void TieState(ILink ilist, LabId macId)
       ti = TypicalState(ilist,macId);
    se = (StateElem *) ti->item;
    tsi = se->info;
+   if (tsi->nUse>0)
+      DeleteMacroStruct(hset,'s',tsi);
+   else
    tsi->nUse = 1;
    NewMacro(hset,fidx,'s',macId,tsi);
    for (i=ilist; i!=NULL; i=i->next) {
       se = (StateElem *)i->item; si = se->info;
       if (si != tsi) {
+         if (si->nUse>0) si->nUse--;
          se->info = tsi;
          ++tsi->nUse;
       }
    }
 }
 
+void TieLeafStream(ILink ilist, LabId macId, int stream)
+{
+   ILink i;
+   StreamInfo *sti;
+   
+   if (badGC) {
+      FixAllGConsts(hset);         /* in case any bad gConsts around */
+      badGC=FALSE;
+   }
+   sti = ((StateElem *)ilist->item)->info->pdf[stream].info;
+   sti->nUse = 1;
+   NewMacro(hset,fidx,'p',macId,sti);
+   for (i=ilist->next; i!=NULL; i=i->next) {
+      ((StateElem *)i->item)->info->pdf[stream].info = sti;
+      ++sti->nUse;
+   }
+}
+
 /* TieTrans: tie all transition matrices in ilist to 1st */
 void TieTrans(ILink ilist, LabId macId)
 {
@@ -1054,11 +1281,15 @@ void TieTrans(ILink ilist, LabId macId)
    
    hmm = ilist->owner;
    tran = hmm->transP;
+   if (GetUse(tran)>0)
+      DeleteMacroStruct(hset,'t',tran);
+   else
    SetUse(tran,1); 
    NewMacro(hset,fidx,'t',macId,tran);
-   for (i=ilist; i!=NULL; i=i->next) {
+   for (i=ilist->next; i!=NULL; i=i->next) {
       hmm = i->owner;
       if (hmm->transP != tran) {
+         if (GetUse(hmm->transP)>0) DecUse(hmm->transP);
          hmm->transP = tran;
          IncUse(tran);
       }
@@ -1076,6 +1307,9 @@ void TieDur(ILink ilist, LabId macId)
    if ((v=si->dur)==NULL)
       HError(2630,"TieDur: Attempt to tie null duration as macro %s",
              macId->name);
+   if (GetUse(v)>0)
+      DeleteMacroStruct(hset,'d',v);
+   else
    SetUse(v,1);
    NewMacro(hset,fidx,'d',macId,v);
    for (i=ilist->next; i!=NULL; i=i->next) {
@@ -1084,6 +1318,7 @@ void TieDur(ILink ilist, LabId macId)
          HError(-2630,"TieDur: Attempt to tie null duration to macro %s",
                 macId->name);
       if (si->dur != v) {
+         if (GetUse(si->dur)>0) DecUse(si->dur);
          si->dur = v;
          IncUse(v);
       }
@@ -1102,6 +1337,9 @@ void TieWeights(ILink ilist, LabId macId
    if (v==NULL)
       HError(2630,"TieWeights: Attempt to tie null stream weights as macro %s",
              macId->name);
+   if (GetUse(v)>0)
+      DeleteMacroStruct(hset,'w',v);
+   else
    SetUse(v,1);
    NewMacro(hset,fidx,'w',macId,v);
    for (i=ilist->next; i!=NULL; i=i->next) {
@@ -1109,6 +1347,7 @@ void TieWeights(ILink ilist, LabId macId
       if (si->weights==NULL)
          HError(-2630,"TieWeights: Attempt to tie null stream weights to macro %s",macId->name);
       if (si->weights != v) {
+         if (GetUse(si->weights)>0) DecUse(si->weights); 
          si->weights = v;
          IncUse(v);
       }
@@ -1124,6 +1363,15 @@ void VAdd(Vector a, Vector b)
    for (k=1; k<=V; k++) a[k] += b[k];
 }
 
+/* VMult: multiply vector a by n */
+void VMult(Vector a, int n)
+{
+   int k,V;
+   
+   V = VectorSize(a);
+   for (k=1; k<=V; k++) a[k] *= n;
+}
+
 /* VMax: max vector b to vector a */
 void VMax(Vector a, Vector b)
 {
@@ -1153,6 +1401,11 @@ void TieMean(ILink ilist, LabId macId)
    
    mp = (MixPDF *)ilist->item; tmean = mp->mean;
    tSize = VectorSize(tmean);
+   if (GetUse(tmean)>0) {
+      DeleteMacroStruct(hset,'u',tmean);
+      VMult(tmean,GetUse(tmean));
+   }
+   else
    SetUse(tmean,1);
    NewMacro(hset,fidx,'u',macId,tmean);
    for (i=ilist->next; i!=NULL; i=i->next) {
@@ -1163,6 +1416,7 @@ void TieMean(ILink ilist, LabId macId)
             HError(2630,"TieMean: Vector size mismatch %d vs %d",
                    tSize, vSize);
          VAdd(tmean,mp->mean);
+         if (GetUse(mp->mean)>0) DecUse(mp->mean);
          mp->mean = tmean;
          IncUse(tmean);
       }
@@ -1180,6 +1434,9 @@ void TieVar(ILink ilist, LabId macId)
    
    mp = (MixPDF *)ilist->item; tvar = mp->cov.var;
    tSize = VectorSize(tvar);
+   if (GetUse(tvar)>0)
+      DeleteMacroStruct(hset,'v',tvar);
+   else
    SetUse(tvar,1);
    NewMacro(hset,fidx,'v',macId,tvar);
    for (i=ilist->next; i!=NULL; i=i->next) {
@@ -1190,6 +1447,7 @@ void TieVar(ILink ilist, LabId macId)
             HError(2630,"TieVar: Vector size mismatch %d vs %d",
                    tSize, vSize);
          VMax(tvar,mp->cov.var);
+         if (GetUse(mp->cov.var)>0) DecUse(mp->cov.var);
          mp->cov.var = tvar; IncUse(tvar);
       }
    }
@@ -1206,6 +1464,9 @@ void TieInv(ILink ilist, LabId macId)
    
    mp = (MixPDF *)ilist->item; tinv = mp->cov.inv;
    tSize = NumRows(mp->cov.inv);
+   if (GetUse(tinv)>0)
+      DeleteMacroStruct(hset,'i',tinv);
+   else
    SetUse(tinv,1);
    NewMacro(hset,fidx,'i',macId,tinv);
    for (i=ilist->next; i!=NULL; i=i->next) {
@@ -1215,6 +1476,7 @@ void TieInv(ILink ilist, LabId macId)
          if (tSize != mSize)
             HError(2630,"TieInv: Matrix size mismatch %d vs %d",
                    tSize, mSize);
+         if (GetUse(mp->cov.inv)>0) DecUse(mp->cov.inv);
          mp->cov.inv = tinv; IncUse(tinv);
       }
    }
@@ -1231,6 +1493,9 @@ void TieXform(ILink ilist, LabId macId)
    
    mp = (MixPDF *)ilist->item; txform = mp->cov.xform;
    tr = NumRows(mp->cov.xform); tc = NumCols(mp->cov.xform);
+   if (GetUse(txform)>0)
+      DeleteMacroStruct(hset,'x',txform);
+   else
    SetUse(txform,1);
    NewMacro(hset,fidx,'x',macId,txform);
    for (i=ilist->next; i!=NULL; i=i->next) {
@@ -1239,6 +1504,7 @@ void TieXform(ILink ilist, LabId macId)
          mr = NumRows(mp->cov.xform); mc = NumCols(mp->cov.xform);
          if (tc != mc || tr != mr)
             HError(2630,"TieXform: Matrix size mismatch");
+         if (GetUse(mp->cov.xform)>0) DecUse(mp->cov.xform);
          mp->cov.xform = txform; IncUse(txform);
       }
    }
@@ -1254,11 +1520,15 @@ void TieMix(ILink ilist, LabId macId)
    
    me = (MixtureElem *)ilist->item; /* should choose max(Sigma) for */
    tmpdf = me ->mpdf;           /* consistency with tie states */
+   if (tmpdf->nUse>0)
+      DeleteMacroStruct(hset,'m',tmpdf);
+   else
    tmpdf->nUse = 1;
    NewMacro(hset,fidx,'m',macId,tmpdf);
    for (i=ilist->next; i!=NULL; i=i->next) {
       me = (MixtureElem *)i->item;
       if (me->mpdf!=tmpdf) {
+         if (me->mpdf->nUse>0) me->mpdf->nUse--;
          me->mpdf = tmpdf;
          ++tmpdf->nUse;
       }
@@ -1318,11 +1588,12 @@ MixtureElem RemTop(void)
 void SplitMix(MixtureElem *mi,MixtureElem *m01,MixtureElem *m02,int vSize)
 {
    const float pertDepth = 0.2;
-   int k,splitcount;
+   int k;
+   long splitcount;
    float x;
    TriMat mat=NULL;
    
-   splitcount = (int) mi->mpdf->hook + 1;
+   splitcount = (long) mi->mpdf->hook + 1;
    m01->mpdf = CloneMixPDF(hset,mi->mpdf,FALSE); 
    m02->mpdf = CloneMixPDF(hset,mi->mpdf,FALSE);
    m01->weight = m02->weight = mi->weight/2.0;
@@ -1343,7 +1614,7 @@ void SplitMix(MixtureElem *mi,MixtureEle
 }
 
 /* FixWeights: Fix the weights of me using the old stream info */
-void FixWeights(MixtureElem *me, HMMDef *owner, StreamElem *ste)
+void FixWeights(MixtureElem *me, HMMDef *owner, StreamInfo *sti)
 {
    MixtureElem *sme;
    double w,p,wSum,fSum,maxW,floor,lFloor;
@@ -1354,7 +1625,7 @@ void FixWeights(MixtureElem *me, HMMDef 
    maxW = LZERO;
    for (m=1;m<=joinSize;m++) {  /* set weights to SOutP(owner) */
       w=LZERO;
-      for (sm=1,sme=ste->spdf.cpdf+1;sm<=ste->nMix;sm++,sme++) {
+      for (sm=1,sme=sti->spdf.cpdf+1;sm<=sti->nMix;sm++,sme++) {
          Untouch(&me[m].mpdf->nUse);
          p = MOutP(me[m].mpdf->mean,sme->mpdf);
          w = LAdd(w,log(sme->weight)+p);
@@ -1398,7 +1669,7 @@ void FixWeights(MixtureElem *me, HMMDef 
 void CreateJMacros(LabId rootMacId)
 {
    int m;
-   char buf[255];
+   char buf[MAXSTRLEN];
    MixPDF *mp;
    
    for (m=1;m<=joinSize;m++) {
@@ -1413,32 +1684,50 @@ void CreateJMacros(LabId rootMacId)
    }
 }
 
-/* TiePDF: join mixtures for set of 'joinSize' tied pdfs in ilist
-   This is standard 'tied mixture' case. Min mix weight
-   is joinFloor * MINMIX   */
+/* TiePDF: tie stream if joinSize==0. otherwise join mixtures for set of 'joinSize' tied pdfs in ilist
+   This is standard 'tied mixture' case. Min mix weight is joinFloor * MINMIX   */
 void TiePDF(ILink ilist, LabId macId)
 {
    ILink i;
    int m,nSplit,vs,vSize=0;
    StreamElem *ste;
+   StreamInfo *sti,*tsti;
    MixtureElem *me, mix,mix1,mix2;
    
    if (badGC) {
       FixAllGConsts(hset);         /* in case any bad gConsts around */
       badGC=FALSE;
    }
-   if (joinSize==0)
-      HError(2634,"TiePDF: Join size and floor not set - use JO command");
+
+   if (joinSize==0) {  /* Tie StreamInfo */
+      ste = (StreamElem *) ilist->item;
+      tsti = ste->info;
+      if (tsti->nUse>0)
+         DeleteMacroStruct(hset,'p',tsti);
+      else
+         tsti->nUse = 1;
+      NewMacro(hset,fidx,'p',macId,tsti);
+      for (i=ilist->next; i!=NULL; i=i->next) {
+         ste = (StreamElem *)i->item; sti = ste->info;
+         if (sti != tsti) {
+            if (sti->nUse>0) sti->nUse--;
+            ste->info = tsti;
+            ++tsti->nUse;
+         }
+      }
+   }
+   else {  /* Create Tied Mixture */
    nJoins = 0; joinSet = CreateJMixSet();
    for (i=ilist; i!=NULL; i=i->next) {
       ste = (StreamElem *) i->item;
-      vs = VectorSize(ste->spdf.cpdf[1].mpdf->mean);
+         sti = ste->info;
+         vs = VectorSize(sti->spdf.cpdf[1].mpdf->mean);
       if (vSize==0)
          vSize = vs;
       else if (vs != vSize)
          HError(2630,"TiePDF: incompatible vector sizes %d vs %d",vs,vSize);
-      for (m=1;m<=ste->nMix;m++) {
-         me = ste->spdf.cpdf+m;
+         for (m=1;m<=sti->nMix;m++) {
+            me = sti->spdf.cpdf+m;
          if (IsSeen(me->mpdf->nUse)) continue;
          Touch(&me->mpdf->nUse); /* Make sure we don't add twice */
          AddJMix(me);
@@ -1463,22 +1752,25 @@ void TiePDF(ILink ilist, LabId macId)
    CreateJMacros(macId);
    for (i=ilist; i!=NULL; i=i->next) { /* replace pdfs */
       ste = (StreamElem *) i->item;
-      if (IsSeen(ste->nMix)) continue;
+         sti = ste->info;
+         if (IsSeen(sti->nUse)) continue;
       me = CreateJMixSet();
       for (m=1;m<=joinSize;m++) {
          me[m].mpdf = joinSet[m].mpdf;
          ++(joinSet[m].mpdf->nUse);
       }
-      FixWeights(me,i->owner,ste);
-      ste->spdf.cpdf = me; ste->nMix = joinSize;
-      Touch(&ste->nMix);
+         FixWeights(me,i->owner,sti);
+         sti->spdf.cpdf = me; sti->nMix = joinSize;
+         Touch(&sti->nUse);
    }
    for (i=ilist; i!=NULL; i=i->next) { /* reset nMix flags */
       ste = (StreamElem *) i->item;
-      Untouch(&ste->nMix);
+         sti = ste->info;
+         Untouch(&sti->nUse);
    }
    if (joinSize>maxMixes) maxMixes=joinSize;
 }
+}
 
 /* TieHMMs: tie all hmms in ilist to 1st */
 void TieHMMs(ILink ilist,LabId macId)
@@ -1568,6 +1860,29 @@ void UntieState(ILink ilist)
    }
 }
 
+/* UntiePDF: untie (ie clone) all items in ilist */
+void UntiePDF(ILink ilist)
+{
+   ILink i;
+   StreamElem *ste;
+   StreamInfo *sti;
+   int nu,s;
+   
+   for (i=ilist; i!=NULL; i=i->next) {
+      ste = (StreamElem *)i->item;
+      sti = ste->info;
+      s = ste->info->stream;
+      nu = sti->nUse; 
+      sti->nUse = 0;
+      if (nu==1)
+         DeleteMacroStruct(hset,'p',sti);
+      else if (nu>1) {
+         ste->info = ClonePDF(hset,s,sti,FALSE);
+         sti->nUse = nu-1;
+      }
+   }
+}
+
 /* UntieMix: untie (ie clone) all items in ilist */
 void UntieMix(ILink ilist)
 {
@@ -1710,18 +2025,19 @@ typedef struct _CRec{
    int idx;                     /* index of this item */
    Boolean ans;                 /* answer to current question */
    short state;                 /* state of clink */
+   Ptr owner;                   /* owner of clink */
    CLink next;                  /* next item in group */
 }CRec;
 
 /* TDistance: return mean sq diff between Tied Mix weights */
-float TDistance(StreamElem *s1, StreamElem *s2)
+float TDistance(StreamInfo *sti1, StreamInfo *sti2)
 {
    int m,M;
    float *mw1,*mw2;
    float x,sum=0.0;
    
-   mw1 = s1->spdf.tpdf+1; mw2 = s2->spdf.tpdf+1; 
-   M = s1->nMix;
+   mw1 = sti1->spdf.tpdf+1; mw2 = sti2->spdf.tpdf+1; 
+   M = sti1->nMix;
    for (m=1; m<=M; m++, mw1++, mw2++) {
       x = (*mw1 - *mw2);
       sum += x*x;
@@ -1730,14 +2046,14 @@ float TDistance(StreamElem *s1, StreamEl
 }
 
 /* DDistance: return mean sq log diff between Discrete Probabilities */
-float DDistance(StreamElem *s1, StreamElem *s2)
+float DDistance(StreamInfo *sti1, StreamInfo *sti2)
 {
    int m,M;
    short *mw1,*mw2;
    float x,sum=0.0;
    
-   mw1 = s1->spdf.dpdf+1; mw2 = s2->spdf.dpdf+1; 
-   M = s1->nMix;
+   mw1 = sti1->spdf.dpdf+1; mw2 = sti2->spdf.dpdf+1; 
+   M = sti1->nMix;
    for (m=1; m<=M; m++, mw1++, mw2++) {
       x = (*mw1 - *mw2);
       sum += x*x;
@@ -1746,13 +2062,13 @@ float DDistance(StreamElem *s1, StreamEl
 }
 
 /* Divergence: return divergence between two Gaussians */
-float Divergence(StreamElem *s1, StreamElem *s2)
+float Divergence(StreamInfo *sti1, StreamInfo *sti2)
 {
    int k,V;
    MixPDF *m1,*m2;
    float x,v1,v2,sum=0.0;
    
-   m1 = (s1->spdf.cpdf+1)->mpdf; m2 = (s2->spdf.cpdf+1)->mpdf;
+   m1 = (sti1->spdf.cpdf+1)->mpdf; m2 = (sti2->spdf.cpdf+1)->mpdf;
    V = VectorSize(m1->mean);
    for (k=1; k<=V; k++) {
       x = m1->mean[k] - m2->mean[k];
@@ -1768,22 +2084,22 @@ float Divergence(StreamElem *s1, StreamE
 /* GDistance: return general distance between two arbitrary pdfs
    by summing the log probabilities of each mixture mean with
    respect to the other pdf  */
-float GDistance(int s, StreamElem *s1, StreamElem *s2)
+float GDistance(int s, StreamInfo *sti1, StreamInfo *sti2)
 {
    int m,M;
    MixtureElem *me;
    Observation dummy;
    float sum=0.0;
    
-   M = s1->nMix;
-   for (m=1,me = s1->spdf.cpdf+1; m<=M; m++, me++) {
+   M = sti1->nMix;
+   for (m=1,me = sti1->spdf.cpdf+1; m<=M; m++, me++) {
       dummy.fv[s]=me->mpdf->mean;
-      sum += SOutP(hset,s,&dummy,s2);
+      sum += SOutP(hset,s,&dummy,sti2);
    }
-   M = s2->nMix;
-   for (m=1,me = s2->spdf.cpdf+1; m<=M; m++, me++) {
+   M = sti2->nMix;
+   for (m=1,me = sti2->spdf.cpdf+1; m<=M; m++, me++) {
       dummy.fv[s]=me->mpdf->mean;
-      sum += SOutP(hset,s,&dummy,s1);
+      sum += SOutP(hset,s,&dummy,sti1);
    }
    return -(sum/M);
 }
@@ -1794,6 +2110,7 @@ float StateDistance(ILink i1, ILink i2)
    StateElem *se1, *se2;
    StateInfo *si1, *si2;
    StreamElem *ste1,*ste2;
+   StreamInfo *sti1,*sti2;
    float x = 0.0;
    int s,S;
    
@@ -1801,16 +2118,19 @@ float StateDistance(ILink i1, ILink i2)
    se2 = (StateElem *)i2->item; si2 = se2->info;
    S = hset->swidth[0];
    ste1 = si1->pdf+1; ste2 = si2->pdf+1;
-   for (s=1;s<=S;s++,ste1++,ste2++)
+   for (s=1;s<=S;s++,ste1++,ste2++) {
+      sti1 = ste1->info;
+      sti2 = ste2->info;
       if (hset->hsKind == TIEDHS)
-         x += TDistance(ste1,ste2);
+         x += TDistance(sti1,sti2);
       else if (hset->hsKind==DISCRETEHS)
-         x += DDistance(ste1,ste2);
-      else if (maxMixes == 1 && ste1->spdf.cpdf[1].mpdf->ckind==DIAGC && 
-               ste2->spdf.cpdf[1].mpdf->ckind==DIAGC) 
-         x += Divergence(ste1,ste2);
+         x += DDistance(sti1,sti2);
+      else if (maxMixes == 1 && sti1->spdf.cpdf[1].mpdf->ckind==DIAGC && 
+               sti2->spdf.cpdf[1].mpdf->ckind==DIAGC) 
+         x += Divergence(sti1,sti2);
       else
-         x += GDistance(s,ste1,ste2);
+         x += GDistance(s,sti1,sti2);
+   }
    return x/S;
 }
 
@@ -2071,6 +2391,8 @@ void Clustering(ILink ilist, int *numReq
       FreeItems(&l);                    /* free items in sub list */
    }
 
+   FreeMatrix(&tmpHeap, gdist);
+   FreeMatrix(&tmpHeap, idist);
    Dispose(&tmpHeap,cvec);
 }
 
@@ -2089,10 +2411,12 @@ void SetGCStats(void)
    
    NewHMMScan(hset,&hss);
    while(GoNextMix(&hss,FALSE)) {
+      if (VectorSize(hss.me->mpdf->mean)>0) {  /* check MSD */
       x = hss.me->mpdf->gConst;
       sum += x; sumsq += x*x;
       count++;
    }
+   }
    EndHMMScan(&hss);
    meanGC = sum / count;
    stdGC = sqrt(sumsq / count - meanGC*meanGC);
@@ -2109,90 +2433,145 @@ void SetGCStats(void)
    but if the mix gConst is less than 4 x stddev below average
    then the score is reduced by 5000 making it very unlikely to 
    be selected */
-int HeaviestMix(char *hname, MixtureElem *me, int M)
+int HeaviestMix(char *hname, MixtureElem *me, const int M, Vector mixOcc)
 {
    float max,w,gThresh;
    int m,maxm;
    MixPDF *mp;
    
+   /* find first continuous space mixture component */
+   for (m=1; m<=M; m++)
+      if (VectorSize(me[m].mpdf->mean)>0) /* MSD check */
+         break;
+   if (m>M)  /* no continuous space in this MixtureElem */
+      HError(9999, "HeaviestMix: there is no continuous mixtures");
+
+   /* find first mixture component whose occ count is larger than the threshold */
+   for (m=m; m<=M; m++)
+      if (VectorSize(me[m].mpdf->mean)>0 && mixOcc[m]>minMixOcc) 
+         break;
+   if (m>M)  /* no mixture */
+      return 0;
+
    gThresh = meanGC - 4.0*stdGC;
-   maxm = 1;  mp = me[1].mpdf;
-   max = me[1].weight - (int)mp->hook;
-   if ((int)mp->hook < 5000 && mp->gConst < gThresh) {
+   maxm = m;  mp = me[m].mpdf;
+   max = me[m].weight - (long)mp->hook;
+   if ((long)mp->hook < 5000 && mp->gConst < gThresh) {
       max -= 5000.0; mp->hook = (void *)5000;
-      HError(-2637,"HeaviestMix: mix 1 in %s has v.small gConst [%f]",
-             hname,mp->gConst);
+      HError(-2637,"HeaviestMix: mix %d in %s has v.small gConst [%f]",
+             m,hname,mp->gConst);
    }
-   for (m=2; m<=M; m++) {   
+   for (m=maxm+1; m<=M; m++) {
       mp = me[m].mpdf;
-      w = me[m].weight - (int)mp->hook;
-      if ((int)mp->hook < 5000 && mp->gConst < gThresh) {
+      w = me[m].weight - (long)mp->hook;
+      if (VectorSize(mp->mean) > 0) {  /* MSD check */
+         if ((long)mp->hook < 5000 && mp->gConst < gThresh) {
          w -= 5000.0; mp->hook = (void *)5000;
          HError(-2637,"HeaviestMix: mix %d in %s has v.small gConst [%f]",
                 m,hname,mp->gConst);
       }
-      if (w>max) {
+         if (w>max && mixOcc[m]>minMixOcc) {
          max = w; maxm = m;
       }
    }
+   }
    if (me[maxm].weight<=MINMIX)
       HError(2697,"HeaviestMix:  heaviest mix is defunct!");
    if (trace & T_DET) {
-      printf("               : Split %d (weight=%.3f, count=%d, score=%.3f)\n",
-             maxm, me[maxm].weight, (int)me[maxm].mpdf->hook, max);
+      printf("               : Split %d (weight=%.3f, count=%ld, score=%.3f)\n",
+             maxm, me[maxm].weight, (long)me[maxm].mpdf->hook, max);
       fflush(stdout);
    }
    return maxm;
 }
 
+/* SetMixOcc: set mixture-level occupancy counts */
+void SetMixOcc(StreamInfo *sti, Vector mixOcc)
+{
+   int m;
+   float occ;
+
+   ZeroVector(mixOcc);
+
+   for (m=1; m<=sti->nMix; m++) {
+      if (occStatsLoaded) {
+         memcpy(&occ,&(sti->hook),sizeof(float));
+      }
+      else {
+         if (minMixOcc>0.0)
+            HError(9999,"SetMixOcc: No stats loaded - use LS command");
+         occ = 1.0;
+      }
+      mixOcc[m] = MixWeight(hset,sti->spdf.cpdf[m].weight) * occ;
+   }
+   
+   return;
+}
+
 /* UpMix: increase number of mixes in stream from oldM to newM */
-void UpMix(char *hname, StreamElem *ste, int oldM, int newM)
+void UpMix(char *hname, StreamInfo *sti, int oldM, int newM)
 {
    MixtureElem *me,m1,m2;
    int m,count,vSize;
+   Vector mixOcc;
+   
+   mixOcc = CreateVector(&gstack, newM);
+   SetMixOcc(sti,mixOcc);
    
    me = (MixtureElem*) New(&hmmHeap,sizeof(MixtureElem)*newM);
    --me;
-   vSize = VectorSize(ste->spdf.cpdf[1].mpdf->mean);
+   vSize = VectorSize(sti->spdf.cpdf[1].mpdf->mean);
    for (m=1;m<=oldM;m++)
-      me[m] = ste->spdf.cpdf[m];
+      me[m] = sti->spdf.cpdf[m];
    count=oldM;
    while (count<newM) {
-      m = HeaviestMix(hname,me,count);
+      m = HeaviestMix(hname,me,count,mixOcc);
+      if (m==0) break;
       ++count;
       SplitMix(me+m,&m1,&m2,vSize);
       me[m] = m1; me[count] = m2;
+      mixOcc[m] = mixOcc[count] = mixOcc[m] / 2;
    }
-   ste->spdf.cpdf = me; ste->nMix = newM;
+   sti->spdf.cpdf = me; sti->nMix = count;
+   
+   FreeVector(&gstack,mixOcc);
 }
 
 /* CountDefunctMix: return number of defunct mixtures in given stream */
-int CountDefunctMix(StreamElem *ste)
+int CountDefunctMix(StreamInfo *sti)
 {
    int m,defunct;
    
-   for (m=1,defunct=0; m<=ste->nMix; m++)
-      if (ste->spdf.cpdf[m].weight <= MINMIX)
+   for (m=1,defunct=0; m<=sti->nMix; m++)
+      if (sti->spdf.cpdf[m].weight <= MINMIX)
          ++defunct;
    return defunct;
 }
 
-/* FixDefunctMix: restore n defunct mixtures by successive mixture splitting */
-void FixDefunctMix(char *hname,StreamElem *ste, int n)
+/* FixDefunctMix: restore n defunct mixtures */
+void FixDefunctMix(char *hname,StreamInfo *sti, int n)
 {
    MixtureElem *me,m1,m2;
    int m,M,l,count,vSize;
+   Vector mixOcc;
 
-   me = ste->spdf.cpdf; M = ste->nMix;
-   vSize = VectorSize(me[1].mpdf->mean);
+   mixOcc = CreateVector(&gstack, sti->nMix);
+   SetMixOcc(sti,mixOcc);
+
+   me = sti->spdf.cpdf; M = sti->nMix;
    for (count = 0; count<n; ++count) {
       for (l=1; l<=M; l++)
          if (me[l].weight <= MINMIX)
             break;
-      m = HeaviestMix(hname,me,M);
+      m = HeaviestMix(hname,me,M,mixOcc);
+      if(m < 1) HError(1,"FixDefunctMix: Wrong mixture weight.\n");
+      vSize = VectorSize(me[m].mpdf->mean);
       SplitMix(me+m,&m1,&m2,vSize);
       me[m] = m1; me[l] = m2;
+      mixOcc[m] = mixOcc[l] = mixOcc[m] / 2;
    }
+
+   FreeVector(&gstack,mixOcc);
 }
 
 /* ------------------- MixDown Operations --------------------- */
@@ -2225,26 +2604,26 @@ float MixMergeCost(MixtureElem *me1,Mixt
    
 /* MergeMix: merge components p and q from given stream elem.  If inPlace
    overwrite existing components, otherwise create new mix component */
-void MergeMix(StreamElem *ste,int p,int q, Boolean inPlace)
+void MergeMix(StreamInfo *sti,int p,int q, Boolean inPlace)
 {
    float w1,w2,m,v,p0,p1,p2,v1k,v2k;
    int vs,k;
    Vector m1,m2,v1,v2,mt,vt;
    MixtureElem me, *meq, *mep;
 
-   if (q!=ste->nMix) {
-      if (p==ste->nMix) {
-         p=q; q=ste->nMix;
+   if (q!=sti->nMix) {
+      if (p==sti->nMix) {
+         p=q; q=sti->nMix;
       }
       else {
-         me=ste->spdf.cpdf[q];
-         ste->spdf.cpdf[q]=ste->spdf.cpdf[ste->nMix];
-         ste->spdf.cpdf[ste->nMix]=me;
-         q=ste->nMix;
+         me=sti->spdf.cpdf[q];
+         sti->spdf.cpdf[q]=sti->spdf.cpdf[sti->nMix];
+         sti->spdf.cpdf[sti->nMix]=me;
+         q=sti->nMix;
       }
    }
    /* the mixuture components */ 
-   meq = ste->spdf.cpdf + q;                   mep = ste->spdf.cpdf + p;
+   meq = sti->spdf.cpdf + q;                   mep = sti->spdf.cpdf + p;
    w1=mep->weight/(mep->weight+meq->weight);   w2=meq->weight/(mep->weight+meq->weight);
    m1=mep->mpdf->mean;                         m2=meq->mpdf->mean;
    v1=mep->mpdf->cov.var;                      v2=meq->mpdf->cov.var;
@@ -2281,7 +2660,7 @@ void MergeMix(StreamElem *ste,int p,int 
 /* DownMixSingle
    replace the mixture with a single Gaussian
  */
-void DownMixSingle(StreamElem *ste,Boolean inPlace)
+void DownMixSingle(StreamInfo *sti,Boolean inPlace)
 {
     int k,i,vs;
     float w;
@@ -2289,14 +2668,14 @@ void DownMixSingle(StreamElem *ste,Boole
     MixPDF *m;
     MixtureElem *me;
     
-    me = ste->spdf.cpdf; m=(me+1)->mpdf;
+    me = sti->spdf.cpdf; m=(me+1)->mpdf;
     vs=VectorSize(m->mean);
     mt=CreateSVector(&hmmHeap,vs);
     vt=CreateSVector(&hmmHeap,vs);
     for (k=1;k<=vs;k++) {
        /* mean */
        mt[k] = 0.0; 
-       for (i=1; i<=ste->nMix; i++) {
+       for (i=1; i<=sti->nMix; i++) {
           m=(me+i)->mpdf;w=(me+i)->weight;
           if ( m->ckind != DIAGC ) /* only support DIAGC */
              HError(2640,"DownMix: covariance type not supported");
@@ -2304,13 +2683,13 @@ void DownMixSingle(StreamElem *ste,Boole
        }
        /* variance */
        vt[k] = 0.0;
-       for (i=1; i<=ste->nMix; i++) { 
+       for (i=1; i<=sti->nMix; i++) { 
           m=(me+i)->mpdf; w=(me+i)->weight;
           vt[k] +=w*m->cov.var[k]-w*m->mean[k]*(mt[k]-m->mean[k]);
        }
     }
     /* decrement use of mean and var */
-    for(i=2;i<=ste->nMix;i++) {
+    for(i=2;i<=sti->nMix;i++) {
        m=(me+i)->mpdf;
        DecUse(m->mean); DecUse(m->cov.var);
     }
@@ -2328,41 +2707,41 @@ void DownMixSingle(StreamElem *ste,Boole
        m->mean = mt; m->cov.var = vt; 
     }
     (me+1)->weight=1.0;
-    ste->nMix=1;
+    sti->nMix=1;
 }
 
 /* DownMix: merge mixtures in stream to maxMix. If inPlace then existing
    mean and variance vectors will be overwritten.  Otherwise, new vectors
    are created for changed components */
-void DownMix(char *hname, StreamElem *ste, int maxMix, Boolean inPlace)
+void DownMix(char *hname, StreamInfo *sti, int maxMix, Boolean inPlace)
 {
    int i,j,m,p,q,oldM,k,V;
    float bc,mc;
    MixPDF *m1,*m2;
    float x,v1,v2,sum=0.0;
     
-   oldM=m=ste->nMix;
+   oldM=m=sti->nMix;
    if (trace & T_IND)
       printf("   Mix Down for %s\n",hname);
 
    /* special case mixdown to single Gaussian */
    if (maxMix==1)
-      DownMixSingle(ste,inPlace);
+      DownMixSingle(sti,inPlace);
 
-   while(ste->nMix>maxMix) { /* merge pairs until maxMix */
+   while(sti->nMix>maxMix) { /* merge pairs until maxMix */
       p=q=0;
       bc = LZERO;
       /* find paur with lowest cost */ 
-      for (i=1; i<=ste->nMix; i++) {
+      for (i=1; i<=sti->nMix; i++) {
          /* only support for CovKind  DIAGC */
-         if ( (MixtureElem*)(ste->spdf.cpdf+i)->mpdf->ckind != DIAGC )
+         if ( (MixtureElem*)(sti->spdf.cpdf+i)->mpdf->ckind != DIAGC )
             HError(2640,"DownMix: covariance type not supported");
-         for (j=i+1; j<=ste->nMix; j++) {
-            mc=MixMergeCost(ste->spdf.cpdf+i,ste->spdf.cpdf+j);
+         for (j=i+1; j<=sti->nMix; j++) {
+            mc=MixMergeCost(sti->spdf.cpdf+i,sti->spdf.cpdf+j);
             if (trace & T_MD) {
                printf("Could merge %d (%.2f) with %d (%.2f) for %f\n",
-                      i,ste->spdf.cpdf[i].weight,j,ste->spdf.cpdf[j].weight,mc);
-               m1 = (ste->spdf.cpdf+i)->mpdf; m2 = (ste->spdf.cpdf+j)->mpdf;
+                      i,sti->spdf.cpdf[i].weight,j,sti->spdf.cpdf[j].weight,mc);
+               m1 = (sti->spdf.cpdf+i)->mpdf; m2 = (sti->spdf.cpdf+j)->mpdf;
                V = VectorSize(m1->mean);
                for (k=1; k<=V; k++){
                   x = m1->mean[k] - m2->mean[k];
@@ -2378,30 +2757,47 @@ void DownMix(char *hname, StreamElem *st
       }
       if (trace & T_DET)
          printf("    Merging %d with %d for %f\n",p,q,bc);
-      MergeMix(ste,p,q,inPlace);
-      ste->nMix--;
+      MergeMix(sti,p,q,inPlace);
+      sti->nMix--;
    }
-   if ((trace & T_DET) && (ste->nMix!=oldM))
-      printf("    %s: mixdown %d -> %d\n",hname,oldM,ste->nMix);
+   if ((trace & T_DET) && (sti->nMix!=oldM))
+      printf("    %s: mixdown %d -> %d\n",hname,oldM,sti->nMix);
 }
 
 /* ------------------- Tree Building Routines ------------------- */
 
+typedef struct _AccSumMixE {
+   DVector sum;
+   DVector sqr;
+   double occ;
+   int vSize;
+} AccSumMixE;
+
+typedef struct _AccSumStrE {
+   int nMix;
+   double weight;
+   AccSumMixE *accme;
+} AccSumStrE;
+
 typedef struct _AccSum {        /* Accumulator Record for storing */
-   Vector sum;                  /* the sum, sqr and occupation  */
-   Vector sqr;                  /* count statistics             */
-   float  occ;
+   DVector sum;                 /* the sum, sqr and occupation  */
+   DVector sqr;                 /* count statistics             */
+   double  occ;
+   int nStream;
+   AccSumStrE *accse;
 } AccSum;
 
 typedef struct _Node {          /* Tree Node */
    CLink clist;                 /* list of cluster items */
-   float occ;                   /* total occupation count */
-   float tProb;                 /* likelihood of total cluster */
-   float sProb;                 /* likelihood of split cluster */
-   QLink quest;                 /* question used to do split */
+   double occ;                  /* total occupation count */
+   double tProb;                /* likelihood of total cluster */
+   double sProb;                /* likelihood of split cluster */
+   Question *quest;             /* question used to do split */
+   ILink qlist;                 /* questions can be applied to this node */
    Boolean ans;                 /* TRUE = yes, FALSE = no */
-   short snum;
-   MLink macro;                 /* macro used for tie */
+   int snum;
+   MLink *macro;                /* macro used for tie */
+   LabId id;                    /* name of this node */
    struct _Node *parent;        /* parent of this node */
    struct _Node *yes;           /* yes subtree */
    struct _Node *no;            /* no subtree */
@@ -2411,22 +2807,26 @@ typedef struct _Node {          /* Tree 
 
 typedef struct _Tree{           /* A tree */
    LabId baseId;                /* base phone name */
+   ILink patList;               /* pattern list */
    int state;                   /* state (or 0 if hmm tree) */
    int size;                    /* number of non terminal nodes */
+   int nLeaves;                 /* number of terminal(leaf) nodes */
    Node *root;                  /* root of tree */
    Node *leaf;                  /* chain of leaf nodes */
    struct _Tree *next;          /* next tree in list */
+   IntSet streams;              /* active stream */
+   int nActiveStr;              /* number of Active Streams of this tree */
 }Tree;
 
 static Tree *treeList = NULL;   /* list of trees */
 static AccSum yes,no;           /* global accs for yes - no branches */
-static float occs[2];           /* array[Boolean]of occupation counts */
-static float  cprob;            /* complete likelihood at current node */
+static double occs[2];          /* array[Boolean]of occupation counts */
+static double cprob;            /* complete likelihood at current node */
 static int numTreeClust;        /* number of clusters in tree */
 
 /* -------------------- Tree Name Mapping routines ----------------------- */
 
-static char treeName[256] = "";
+static char treeName[PAT_LEN] = "";
 static void SetTreeName(char *name) {
    strcpy(treeName,name);
    strcat(treeName,"tree");   
@@ -2445,7 +2845,8 @@ void MapTreeName(char *buf) {
 Tree *CreateTree(ILink ilist,LabId baseId,int state)
 {
    Tree *tree,*t;
-   char buf[256];
+   char buf[PAT_LEN];
+   int j;
    LabId id;
    HMMDef *hmm;
    ILink i;
@@ -2458,18 +2859,42 @@ Tree *CreateTree(ILink ilist,LabId baseI
       t->next=tree;
    }
    else treeList=tree;
+   
+   /* pattern or baseId */ 
+   if (usePattern) {
+      strcpy(buf,baseId->name);
+      ParsePattern(&tree->patList,buf);
+   }
    tree->baseId = baseId;
    tree->state = state;
+
+   /* set active stream of this tree */
+   tree->streams = CreateSet(hset->swidth[0]);
+   tree->nActiveStr = 0;
+   for (j=1;j<=hset->swidth[0];j++) {
+      if (streams.set[j]) {
+         tree->nActiveStr++;
+         tree->streams.set[j] = TRUE;
+      }
+   }
+
+   /* check model pattern of this tree */
    if (ilist!=NULL) {
       hmm = ilist->owner;
       n=hmm->numStates;
       for (i=ilist; i!=NULL; i=i->next) {
-         hmm = i->owner; strcpy(buf,HMMPhysName(hset,hmm)); TriStrip(buf);
+         hmm = i->owner; strcpy(buf,HMMPhysName(hset,hmm));
+         if (usePattern) {
+            if (!IPatMatch(buf, tree->patList))
+               HError(9999,"CreateTree: different model %s which does not match %s in item list", buf, baseId->name);
+         }
+         else {
+            TriStrip(buf);
          MapTreeName(buf);
          id = GetLabId(buf,FALSE);
-         if (tree->baseId != id)
-            HError(-2663,"CreateTree: different base phone %s in item list",
-                   buf);
+            if (!singleTree && tree->baseId != id)
+               HError(-2663,"CreateTree: different base phone %s in item list", buf);
+         }
          if (state>0) {
             if (hmm->svec+state != (StateElem *)i->item)
                HError(2663,"CreateTree: attempt to cluster different states");
@@ -2494,95 +2919,240 @@ Node *CreateTreeNode(CLink clist, Node *
    n->parent = parent;
    n->macro = NULL;
    n->quest = NULL;
+   n->qlist = NULL;
    n->snum = -1;
+   n->occ = 0.0;
+   n->id = NULL;
+   n->tProb = n->sProb = LZERO;
    return n;
 }
 
+/* MakeAccSum: make AccSum structure referring to item */
+void MakeAccSum(AccSum *acc, ILink obj)
+{
+   int s,m;
+   HMMDef *hmm;
+   StateElem *se;
+   StateInfo *si;
+   StreamInfo *sti;
+   AccSumStrE *astr;
+   AccSumMixE *amix;
+
+   if ((hmm = obj->owner)==NULL)
+      HError(2690,"MakeAccSum: null hmm owner");
+
+   acc->nStream = hmm->owner->swidth[0];
+   acc->accse = (AccSumStrE *)New(&tmpHeap,acc->nStream*sizeof(AccSumStrE));
+   --acc->accse;
+   se = (obj->item == obj->owner)? hmm->svec+2:(StateElem *)obj->item;
+   if (se == NULL)
+      HError(2690,"MakeAccSum: null state elem ptr");
+   si = se->info;
+
+   for(s = 1;s <= acc->nStream;s++){
+      if (streams.set[s]){
+         sti = si->pdf[s].info;
+         astr = acc->accse+s;
+         astr->nMix = sti->nMix;
+         astr->weight = (si->weights!=NULL)?si->weights[s]:1.0;
+         astr->accme = (AccSumMixE *)New(&tmpHeap,sti->nMix*sizeof(AccSumMixE));
+         --astr->accme;
+         for(m = 1;m <= astr->nMix;m++){
+            amix = astr->accme+m;
+            amix->vSize = VectorSize(sti->spdf.cpdf[m].mpdf->mean);
+            amix->occ = 0.0;
+            amix->sum = CreateDVector(&tmpHeap, amix->vSize);
+            amix->sqr = CreateDVector(&tmpHeap, amix->vSize);
+            ZeroDVector(amix->sum);
+            ZeroDVector(amix->sqr);
+         }
+      }
+   }
+}
+
 /* ChkTreeObject: check that item is a valid state or hmm, 
    and make sure that MixPDF hooks are NULL */
-void ChkTreeObject(ILink obj)
+void ChkTreeObject (ILink obj, AccSum *acc)
 {
    HMMDef *hmm;
    StateElem *se;
-   int j;
+   int j,s,m,vSize;
 
    hmm = obj->owner;
    if (hmm==NULL)
       HError(2690,"ChkTreeObject: null hmm owner");
+   if (hmm->owner->swidth[0] != acc->nStream)
+      HError(2663,"ChkTreeObject: Number of stream is differ");
    if (obj->item == obj->owner) {
       for (j=2;j<hmm->numStates;j++) {
          se = hmm->svec+j;
-         if (se->info->pdf[1].nMix!=1 || 
-             se->info->pdf[1].spdf.cpdf[1].mpdf->ckind!=DIAGC)
-            HError(2663,"ChkTreeObject: TB only valid for 1 mix diagonal covar models");
-         se->info->pdf[1].spdf.cpdf[1].mpdf->hook = NULL;
+         for (s=1; s<=acc->nStream; s++) {
+            if (streams.set[s]) {
+               if (se->info->pdf[s].info->nMix != acc->accse[s].nMix)
+                  HError(2663,"ChkTreeObject: Number of mixture is differ");
+               for (m=1; m<=acc->accse[s].nMix; m++) {
+                  if (se->info->pdf[1].info->spdf.cpdf[1].mpdf->ckind!=DIAGC)
+                     HError(2663,"ChkTreeObject: TB only valid for diagonal covariace");
+                  se->info->pdf[s].info->spdf.cpdf[m].mpdf->hook = NULL;
+                  vSize = VectorSize(se->info->pdf[s].info->spdf.cpdf[m].mpdf->mean);
+                  if (vSize != acc->accse[s].accme[m].vSize)
+                     HError(2663,"ChkTreeObject: Vector Size is differ");
+               }
+            }
+         }
       }
    }
    else {
       se = (StateElem *)obj->item;
       if (se == NULL)
          HError(2690,"ChkTreeObject: null state elem ptr");
-      if (se->info->pdf[1].nMix!=1 || 
-          se->info->pdf[1].spdf.cpdf[1].mpdf->ckind!=DIAGC)
-         HError(2663,"ChkTreeObject: TB only valid for 1 mix diagonal covar models");
-      se->info->pdf[1].spdf.cpdf[1].mpdf->hook = NULL;
+      for (s=1;s<=acc->nStream;s++) {
+         if (streams.set[s]) {
+            if (se->info->pdf[s].info->nMix != acc->accse[s].nMix)
+               HError(2663,"ChkTreeObject: Number of mixture is differ");
+            for(m=1;m<=acc->accse[s].nMix;m++) {
+               if (se->info->pdf[1].info->spdf.cpdf[1].mpdf->ckind!=DIAGC)
+                  HError(2663,"ChkTreeObject: TB only valid for diagonal covariace");
+               se->info->pdf[s].info->spdf.cpdf[m].mpdf->hook = NULL;
+               vSize = VectorSize(se->info->pdf[s].info->spdf.cpdf[m].mpdf->mean);
+               if(vSize != acc->accse[s].accme[m].vSize)
+                  HError(2663,"ChkTreeObject: Vector Size is differ %d/%d",
+               acc->accse[s].accme[m].vSize,vSize);
+            }
+         }
+      }
    }
 }
 
 /* InitTreeAccs:  attach and AccSum record to the MixPDF hook and
    initialise with sum and sqr calculated from the 
    occupation counts deposited in the StateInfo hook */
-void InitTreeAccs(StateElem *se, int l)
+void InitTreeAccs(StateElem *se)
 {
    StateInfo *si;
+   StreamInfo *sti;
    MixPDF *mp;
-   int j, k;
+   int j, k, s, vSize;
    short nMix;
    float x, w;
    AccSum *acc;
 
    si=se->info ;
-   nMix = si->pdf[1].nMix ;
+   for (s=1; s<=hset->swidth[0]; s++) {
+      if (streams.set[s]) {
+         sti = si->pdf[s].info;
+         nMix = sti->nMix;
    for (j = 1; j <= nMix; j++) {
-      mp=si->pdf[1].spdf.cpdf[j].mpdf;
-      w = si->pdf[1].spdf.cpdf[j].weight;
-      memcpy(&x,&(si->hook),sizeof(float));
+            mp = sti->spdf.cpdf[j].mpdf;
+            w  = sti->spdf.cpdf[j].weight;
+            vSize = VectorSize(mp->mean);
+            memcpy(&x,&(sti->hook),sizeof(float));
       if (mp->hook==NULL && x>0.0) {
          acc=(AccSum*) New(&tmpHeap,sizeof(AccSum));
          mp->hook=acc;
-         acc->sum=CreateVector(&tmpHeap,l);
-         acc->sqr=CreateVector(&tmpHeap,l);
+               acc->sum = CreateDVector(&tmpHeap,vSize);
+               acc->sqr = CreateDVector(&tmpHeap,vSize);
          x *= w;
-         acc->occ=x;
-         for (k=1;k<=l;k++) {
+               acc->occ = (double)x;
+               acc->accse = NULL;
+               
+               for (k=1; k<=vSize; k++) {
             acc->sum[k]=mp->mean[k]*x;
             acc->sqr[k]=(mp->cov.var[k]+mp->mean[k]*mp->mean[k])*x;
          }
       }
    }
 }
+   }
+}
 
 /* ZeroAccSum: zero given accumulator */
 void ZeroAccSum(AccSum *acc)
 {
-   ZeroVector(acc->sum);
-   ZeroVector(acc->sqr);
+   int s,m;
+   AccSumStrE *astr;
+   AccSumMixE *amix;
+
+   ZeroDVector(acc->sum);
+   ZeroDVector(acc->sqr);
    acc->occ=0.0;
+
+   if(acc->accse != NULL) {
+      for(s=1;s<=acc->nStream;s++) {
+         if (streams.set[s]) {
+            astr = acc->accse+s;
+            for(m=1;m<=astr->nMix;m++) {
+               amix = astr->accme+m;
+               ZeroDVector(amix->sum);
+               ZeroDVector(amix->sqr);
+               amix->occ=0.0;
+            } 
+         }
+      }
+   }
+}
+
+/* DisposeAccSum: dispose AccSum */
+void DisposeAccSum(MemHeap *mem, AccSum *acc)
+{
+   int s,m;
+   AccSumStrE *astr;
+   AccSumMixE *amix;
+
+   if(acc->sum != NULL)
+      FreeDVector(mem,acc->sum);
+
+   if(acc->accse != NULL) {
+      for(s=1;s<=acc->nStream;s++) {
+         if (streams.set[s]) {
+            astr = acc->accse+s;
+            for(m=1;m<=astr->nMix;m++) {
+               amix = astr->accme+m;
+               FreeDVector(mem,amix->sum);
+            }
+         }
+      }
+   }
 }
 
 /* AccSumProb: return log likelihood for given statistics */
-float AccSumProb(AccSum *acc)
+double AccSumProb(AccSum *acc)
 {
-   double variance,prob;
-   int k,l;
+   double variance,occ,weight;
+   double prob, x;
+   int s,m,k;
+   int vSize;
+   DVector sqr,sum;
+   AccSumStrE *astr;
+   AccSumMixE *amix;
+
+   const int S = acc->nStream;
+
+   if (acc->occ<minLeafOcc)  /* minimum occ for each leaf node */
+      return LZERO;
 
    prob=0.0;
-   if (acc->occ > 0.0) {
-      l=VectorSize(acc->sum);
-      for (k=1;k<=l;k++) {
-         variance=(acc->sqr[k]-(acc->sum[k]*acc->sum[k]/acc->occ))/acc->occ;
+   for (s=1; s<=S; s++) {
+      if (streams.set[s]) {
+         astr = acc->accse+s;
+         for (m=1; m<=astr->nMix; m++) {
+            amix = astr->accme+m;
+            weight = (ignoreStrW) ? 1.0 : astr->weight;
+            vSize = amix->vSize;
+            sum = amix->sum;
+            sqr = amix->sqr;
+            occ = amix->occ;
+            if (occ>0.0) {
+               x = 0.0;
+               for (k=1; k<=vSize; k++) {
+                  variance=(sqr[k]-(sum[k]*sum[k]/occ))/occ;
          if (variance<=MINLARG) return(LZERO);
-         prob+=-0.5*acc->occ*(1.0+log(TPI*variance));
+                  if (applyVFloor && variance<vf[s][k]) variance=vf[s][k];
+                  x+=-0.5*occ*(1.0+log(TPI*variance));
+               }
+               prob+=weight*(x+occ*log(occ/acc->occ));
+            }
+         }
       }
    }
    return(prob);
@@ -2590,32 +3160,48 @@ float AccSumProb(AccSum *acc)
 
 /* IncSumSqr: add sums and sqrs from given state into yes or no depending
    on value of ans */
-void IncSumSqr(StateInfo *si, Boolean ans, AccSum *no, AccSum *yes, int l)
+void IncSumSqr(StateInfo *si, Boolean ans, AccSum *no, AccSum *yes)
 {
    AccSum *acc,*tacc;
-   int k;
+   int s,m,k;
+   int vSize;
+   DVector tsum, tsqr, asum, asqr;
+   Boolean first=TRUE; 
+
+   const int S = no->nStream;
    
-   acc = (AccSum *) si->pdf[1].spdf.cpdf[1].mpdf->hook;
+   for (s=1,first=TRUE; s<=S; s++) {
+      if (streams.set[s]) {
+         for(m=1; m<=no->accse[s].nMix; m++){
+            acc = (AccSum *) si->pdf[s].info->spdf.cpdf[m].mpdf->hook;
    if (!acc) return;
    tacc =  (ans && yes != NULL) ? yes : no;
-   tacc->occ+=acc->occ;
-   for (k=1;k<=l;k++) {
-      tacc->sum[k] += acc->sum[k];
-      tacc->sqr[k] += acc->sqr[k];
+            if(first) tacc->occ+=acc->occ;
+            tacc->accse[s].accme[m].occ+=acc->occ;
+            vSize = tacc->accse[s].accme[m].vSize;
+            tsum = tacc->accse[s].accme[m].sum;  tsqr = tacc->accse[s].accme[m].sqr;
+            asum = acc->sum;                     asqr = acc->sqr;
+            
+            for (k=1; k<=vSize; k++) {
+               tsum[k] += asum[k];
+               tsqr[k] += asqr[k];
+            }
+         }
+         first=FALSE;
+      }
    }   
 }
 
 /* ClusterLogL: return log likelihood of given cluster, this is used for both
    the complete and split clusters.  In the former case, the yes accumulator
    will be NULL and only the no accumulator is used */
-float ClusterLogL(CLink clist,AccSum *no,AccSum *yes,float *occs)
+double ClusterLogL(CLink clist, AccSum *no, AccSum *yes, double *occs)
 {
    CLink p;
-   float prob;
+   double prob;
    StateElem *se;
-   int l,i;
+   int i;
 
-   l=VectorSize(no->sum);
    if (clist->item->item == clist->item->owner) {
       prob=0.0;
       occs[FALSE]=0.0;occs[TRUE]=0.0;
@@ -2623,7 +3209,7 @@ float ClusterLogL(CLink clist,AccSum *no
          ZeroAccSum(no);
          if (yes != NULL) ZeroAccSum(yes);
          for(p=clist;p!=NULL;p=p->next) {
-            IncSumSqr(p->item->owner->svec[i].info,p->ans,no,yes,l);
+            IncSumSqr(p->item->owner->svec[i].info,p->ans,no,yes);
          }
          prob += AccSumProb(no);
          if (yes != NULL) prob += AccSumProb(yes);
@@ -2639,7 +3225,7 @@ float ClusterLogL(CLink clist,AccSum *no
       if (yes != NULL) ZeroAccSum(yes);
       for(p=clist;p!=NULL;p=p->next) {
          se=(StateElem*)p->item->item;
-         IncSumSqr(se->info,p->ans,no,yes,l);
+         IncSumSqr(se->info,p->ans,no,yes);
       }
       prob = AccSumProb(no);
       if (yes != NULL) prob += AccSumProb(yes);
@@ -2651,49 +3237,171 @@ float ClusterLogL(CLink clist,AccSum *no
    return(prob);
 }
 
-/* AnswerQuestion: set ans field in each cluster item in preparation for
-   a possible split */
-void AnswerQuestion(CLink clist,QLink q)
+/* SetQMTable: Set Question x Model bit table */
+void SetQMTable (void)
 {
-   CLink p;
-   ILink i;
+   char *name,**PMTable;
+   int i,j,h;
+   MLink m;
+   ILink p,q;
+   Boolean answer;
+   IPat *ip;
+   Question *question;
   
-   for (p=clist;p!=NULL;p=p->next) 
-      p->ans = FALSE;
-   if (q!=NULL)
-      for (i=q->ilist;i!=NULL;i=i->next)
-         if ((p=(CLink) i->item)!=NULL)
-            p->ans=TRUE;
+   const int size=(hset->numPhyHMM>>3)+1;
+
+   if (trace&T_BAS) {
+      printf("   setting question*model table...");
+      fflush(stdout);
 }
 
-/* ValidProbNode: set tProb and sProb of given node according to best
-   possible question which is stored in quest field.  */
-void ValidProbNode(Node *node,float thresh)
-{
-   QLink q,qbest;
-   float best,sProb;
+   /* set pattern * model table */
+   PMTable = (char **) New(&tmpHeap, nPatterns*sizeof(char *));
    
-   node->tProb = ClusterLogL(node->clist,&no,NULL,occs);
-   node->occ = occs[FALSE];
-   if (trace & T_TREE_BESTQ) {
-      char buf[20];
-      if (node->parent==NULL)
-         sprintf(buf," ROOT ");
-      else
-         sprintf(buf,"%3d[%c]",node->parent->snum,
-                 (node->parent->yes==node?'Y':'N'));
+   for (i=0; i<nPatterns; i++) {
+      PMTable[i] = (char *) New(&tmpHeap, size*sizeof(char));
+      memset(PMTable[i], 0, size);
+   }
       
-      printf("    Node %s:                  LogL=%5.3f (%.1f)\n",
-             buf,node->tProb/node->occ,node->occ);
-      fflush(stdout);
+#pragma omp parallel for private(m,h,i,j,name,p,ip,answer)
+   for (h=0; h<MACHASHSIZE; h++) {
+      for (m=hset->mtab[h]; m!=NULL; m=m->next) {
+         if (m->type == 'h') {
+            /* index and name of current hmm */
+            i = ((HLink)(m->structure))->hIdx >> 3;  /* division by 8 */
+            j = ((HLink)(m->structure))->hIdx &  7;  /* residue by 8 */
+            name = m->id->name;
+
+            /* check answers */
+            for (p=pList; p!=NULL; p=p->next) {
+               ip = (IPat *)p->item;
+               answer = DoMatch(name, ip->pat);
+               if (answer)
+                  PMTable[ip->index][i] |= (1<<j);  /* set j-th bit */
+            }
+         }
+      }
+   }
+
+   /* set question * model table */
+   QMTable = (char **) New(&questHeap, nQuestions*sizeof(char *));
+
+   for (i=0; i<nQuestions; i++) {
+      QMTable[i] = (char *) New(&questHeap, size*sizeof(char));
+      memset(QMTable[i], 0, size);
+   }
+
+#pragma omp parallel for private(h,i,j,q,question,p,ip)
+   for (h=0; h<hset->numPhyHMM; h++) {
+      i = h>>3;  j = h&7;
+      for (q=qList; q!=NULL; q=q->next) {
+         question = (Question *)q->item;
+         for (p=question->patList; p!=NULL; p=p->next) {
+	    ip = (IPat *)p->item;
+	    if (PMTable[ip->index][i] & (1<<j)) {
+	       QMTable[question->index][i] |= (1<<j);  /* set j-th bit */
+	       break;
+	    }
+         }
+      }
+   }
+
+   /* free PMTable */
+   Dispose(&tmpHeap, PMTable);
+
+   if (trace&T_BAS) {
+      printf("done\n");
+      fflush(stdout);
+   }
+
+   setQMTable = TRUE;
+
+   return;
+}
+
+/* AnswerQuestion: set ans field in each cluster item in preparation for
+   a possible split */
+Boolean AnswerQuestion(Node *node, Question *q)
+{
+   CLink p;
+   ILink i;
+   int yes=0, no=0, index, j;
+   MLink m;
+        
+   switch(reduceMem) {
+   case 2:
+      for (p=node->clist;p!=NULL;p=p->next) {
+         m = (MLink)p->item->owner->hook;
+         p->ans = QMatch(m->id->name, q);
+         if (p->ans) yes++;
+         else        no++;
+      }
+      break;
+   case 1:
+      index = q->index;
+      if (!setQMTable) SetQMTable();
+      for (p=node->clist; p!=NULL; p=p->next) {
+         j = p->item->owner->hIdx & 7;  /* residue by 8 */
+         p->ans = (QMTable[index][p->item->owner->hIdx>>3] & (1<<j)) ? TRUE : FALSE;
+         if (p->ans) yes++;
+         else        no++;
+      }
+      break;
+   case 0:
+   default: 
+      /* set ans=FALSE for items in this cluster */
+      for (p=node->clist;p!=NULL;p=p->next) {
+         p->ans = FALSE;
+         p->owner = node;
+         no++;
+      }
+         
+      /* set ans=TRUE for all items matching this question */
+      for (i=q->ilist;i!=NULL;i=i->next)
+         if ((p=(CLink) i->item)!=NULL && p->owner==node) {
+            p->ans=TRUE;
+            yes++;
+            no--;
+         }
+   }
+   
+   if (yes>0 && no>0)
+      return TRUE;
+   else
+      return FALSE;
+}
+
+/* ValidProbNode: set tProb and sProb of given node according to best
+   possible question which is stored in quest field.  */
+void ValidProbNode(Node *node, const double thresh, const Boolean ref)
+{
+   ILink i;
+   Question *q, *qbest;
+   double best,sProb;
+   char buf[20];
+   
+   node->tProb = ClusterLogL(node->clist,&no,NULL,occs);
+   node->occ = occs[FALSE];
+   if (trace & T_TREE_BESTQ) {
+      if (node->parent==NULL)
+         sprintf(buf," ROOT ");
+      else
+         sprintf(buf,"%3d[%c]",node->parent->snum,
+                 ((node->parent->yes==node)?'Y':'N'));
+      
+      printf("    Node %s:                  LogL=%5.3f (%.1f)\n",
+             buf,node->tProb/node->occ,node->occ);
+      fflush(stdout);
    }
    qbest = NULL;
    best = node->tProb;
-   for (q=qHead;q!=NULL;q=q->next) {
-      AnswerQuestion(node->clist,q);
+   
+   if (!ref || node->quest!=NULL) {
+      for (i=(node->parent==NULL || ref) ? qList : node->parent->qlist; i!=NULL; i=i->next) {
+         q = (ref) ? node->quest : (Question *)i->item;
+         if (AnswerQuestion(node, q)) {
       sProb = ClusterLogL(node->clist,&no,&yes,occs);
-      if (node->occ<=0.0 || (outlierThresh >= 0.0 &&  
-                             (occs[FALSE]<outlierThresh || occs[TRUE]<outlierThresh)))
+            if (node->occ<=0.0 || (outlierThresh >= 0.0 && (occs[FALSE]<outlierThresh || occs[TRUE]<outlierThresh)))
          sProb=node->tProb;
 
       if (trace & T_TREE_ALLQ || 
@@ -2704,42 +3412,59 @@ void ValidProbNode(Node *node,float thre
          fflush(stdout);
       }
       if (sProb>best) {
+               if (qbest!=NULL && !ref) AddItem(NULL,qbest,&node->qlist);
          best=sProb;
          qbest=q;
       }
+            else if (sProb>LSMALL && !ref) 
+               AddItem(NULL,q,&node->qlist);
+         }
+	 if (ref)
+	    break;
    }
    if (trace & T_TREE_BESTQ) {
       if (qbest != NULL)
-         printf("    BestQ %20s    q LogL %6.3f Imp %8.2f\n",
+            printf("    BestQ %20s   LogL %6.3f Imp %8.2f\n",
                 qbest->qName->name,best/node->occ,best-node->tProb);
       else
          printf("    BestQ [ NULL ]\n");
       fflush(stdout);
    }
+   }
    node->sProb=best; node->quest=qbest;
 }
 
 /* SplitTreeNode: split the given node */
-void SplitTreeNode(Tree *tree, Node *node)
+void SplitTreeNode(Tree *tree, Node *node, const Boolean ref)
 {
    CLink cl,nextcl;
 
    if (node->quest == NULL) return;
    cprob += node->sProb - node->tProb;
 
-   AnswerQuestion(node->clist,node->quest);
+   AnswerQuestion(node,node->quest);
+   if (ref) {
+      node->yes->next = NULL;
+      node->yes->prev = NULL;
+      node->no->next = NULL;
+      node->no->prev = NULL;
+   }
+   else {
    node->yes = CreateTreeNode(NULL,node);
-   node->yes->ans= TRUE;
    node->no = CreateTreeNode(NULL,node);
-   node->no->ans=TRUE;
+   }
+   node->yes->ans = TRUE;
+   node->no->ans = FALSE;
 
    for(cl=node->clist;cl!=NULL;cl=nextcl) {
       nextcl=cl->next;
       switch(cl->ans) {
-      case FALSE: cl->next=node->no->clist;
+      case FALSE: 
+         cl->next=node->no->clist;
          node->no->clist=cl;
          break;
-      case TRUE:  cl->next=node->yes->clist;
+      case TRUE:  
+         cl->next=node->yes->clist;
          node->yes->clist=cl;
          break;
       default:
@@ -2748,43 +3473,64 @@ void SplitTreeNode(Tree *tree, Node *nod
    }
    node->clist = NULL;
 
-   /* unlink node from leaf chain and link in yes and no */
-   node->yes->next = node->no;
-   node->no->prev = node->yes;
-
-   node->no->next = node->next;
-   node->yes->prev = node->prev;
-
-   if (node->next!=NULL) node->next->prev=node->no;
-   if (node->prev==NULL) 
-      tree->leaf = node->yes;
-   else
-      node->prev->next=node->yes;
-
    numTreeClust++;
 }
 
-/* FindBestSplit: find best node to split */
-Node *FindBestSplit(Node *first, float threshold)
+/* AddLeafList: add given node into leaf list in the order of likelihood improvement */
+void AddLeafList(Node *node, Tree *tree, double threshold, const Boolean parent)
 {
-   Node *best,*node;
-   float sProb,imp;
+   Node *p,*n;
+   double imp = node->sProb - node->tProb;
 
-   best=NULL;imp=0.0;
-   for (node=first;node!=NULL;node=node->next) {
-      sProb = node->sProb - node->tProb;
-      if (sProb>imp && sProb>threshold) { 
-         best=node;imp=sProb;
+   /* delete node->parent from leaves */
+   if (parent) {
+      p = node->parent;
+      if (p!=NULL) {
+         if (p==tree->leaf)
+            tree->leaf = p->next;
+         if (p->prev!=NULL)
+            p->prev->next = p->next;
+         if (p->next!=NULL)
+            p->next->prev = p->prev;
+         p->prev = p->next = NULL;
       }
    }
-   return(best);
+
+   /* search insert location of given node */
+   p=NULL; n=tree->leaf;
+   while (n != NULL && imp < n->sProb-n->tProb) {
+      if (n->sProb-n->tProb < threshold) break;
+      p=n; n=n->next;
+   }
+   
+   if (p==NULL) tree->leaf = node;
+   if (p!=NULL) p->next = node;
+   if (n!=NULL) n->prev = node;
+   
+   node->prev = p;
+   node->next = n;  
+      
+   /* Free question list of given node if imp. is less than thresh. */
+   if (imp<threshold)
+      FreeItems(&node->qlist);
+   
+   return;
+}
+
+/* FindBestSplit: find best node to split */
+Node *FindBestSplit(Node *first, const double threshold)
+{
+   if (first->sProb - first->tProb > threshold) 
+      return first;
+   else
+      return NULL;
 }
 
 /* MergeCost: return logL reduction if node b is merged with node a.
    On entry, atail points to last cluster item in node a clist. */
-float MergeCost(Node *a, Node *b, CLink atail)
+double MergeCost(Node *a, Node *b, CLink atail)
 {
-   float combProb;              /* combined logL */
+   double combProb;              /* combined logL */
    
    atail->next = b->clist;
    combProb = ClusterLogL(a->clist,&no,NULL,occs);
@@ -2795,11 +3541,11 @@ float MergeCost(Node *a, Node *b, CLink 
 /* MergeNode: find the as yet unseen node which when merged with
    given node gives smallest reduction in LogL.  If this reduction
    is less than threshold, merge the nodes and return TRUE */
-Boolean MergeNode(Node *node, float threshold)
+Boolean MergeNode(Node *node, const double threshold)
 {
    Node *p, *min;
    CLink ctail;
-   float minCost,cost;
+   double minCost,cost;
 
    ctail = node->clist;         /* set ctail to last cluster item */
    if (ctail == NULL)
@@ -2814,10 +3560,10 @@ Boolean MergeNode(Node *node, float thre
          char buf1[20],buf2[20];
          if (node->parent==NULL) sprintf(buf1," ROOT ");
          else sprintf(buf1,"%3d[%c]",node->parent->snum,
-                      (node->parent->yes==node?'Y':'N'));
+                      ((node->parent->yes==node)?'Y':'N'));
          if (min->parent==NULL) sprintf(buf2," ROOT ");
          else sprintf(buf2,"%3d[%c]",min->parent->snum,
-                      (min->parent->yes==min?'Y':'N'));
+                      ((min->parent->yes==min)?'Y':'N'));
          printf("       M  %s (%.3f,%.1f) + %s (%.3f,%.1f)   Imp %.1f\n",
                 buf1,node->tProb/node->occ,node->occ,
                 buf2,min->tProb/min->occ,min->occ,-minCost);
@@ -2831,10 +3577,10 @@ Boolean MergeNode(Node *node, float thre
          char buf1[20],buf2[20];
          if (node->parent==NULL) sprintf(buf1," ROOT ");
          else sprintf(buf1,"%3d[%c]",node->parent->snum,
-                      (node->parent->yes==node?'Y':'N'));
+                      ((node->parent->yes==node)?'Y':'N'));
          if (min->parent==NULL) sprintf(buf2," ROOT ");
          else sprintf(buf2,"%3d[%c]",min->parent->snum,
-                      (min->parent->yes==min?'Y':'N'));
+                      ((min->parent->yes==min)?'Y':'N'));
          printf("    BestM  %s (%.3f,%.1f) + %s (%.3f,%.1f)   Imp -%4.1f\n",
                 buf1,node->tProb/node->occ,node->occ,
                 buf2,min->tProb/min->occ,min->occ,minCost);
@@ -2859,7 +3605,7 @@ Boolean MergeNode(Node *node, float thre
 /* MergeLeaves: merge any pair of leaf nodes in given tree for which 
    reduction in combined LogL is less than threshold.  Note that 
    after this call, the parent links are no longer valid. */
-void MergeLeaves(Tree *tree, float threshold)
+void MergeLeaves(Tree *tree, const double threshold)
 {
    Node *node;
    
@@ -2867,39 +3613,101 @@ void MergeLeaves(Tree *tree, float thres
       MergeNode(node,threshold);
 }
 
+/* GetCentroidStr: set centroid of given StreamInfo according to AccSumStrE */
+void GetCentroidStr (StreamInfo *sti, AccSumStrE *astr, Vector vfloor)
+{
+   double v, occ, tocc=0.0;
+   int m, k, vSize;
+   MixPDF *mp;
+   DVector sum, sqr;
+   AccSumMixE *amix;
+   
+   for (m=1; m<=astr->nMix; m++) {
+      mp = sti->spdf.cpdf[m].mpdf;
+      amix = astr->accme+m;
+      sum = amix->sum;
+      sqr = amix->sqr;
+      occ = amix->occ;
+      vSize = amix->vSize;
+
+      if (occ > 0.0) {
+         for (k=1; k<=vSize; k++) {
+            mp->mean[k] = (float)(sum[k]/occ);
+            v = (sqr[k]-(sum[k]*sum[k]/occ))/occ;
+            if (applyVFloor && v<vfloor[k])
+               v = (double)vfloor[k];
+            mp->cov.var[k] = (float)v;
+         }
+         tocc += occ; 
+
+         FixDiagGConst(mp);  /* fix gConst */
+      }
+   }
+   
+   for (m=1; m<=astr->nMix; m++)
+      sti->spdf.cpdf[m].weight = (float)(astr->accme[m].occ/tocc);
+      
+   return;
+}
+            
+/* GetCentroid: set centroid of given statistics */
+void GetCentroid (MLink macro, CLink clist, AccSum *acc, const int stream)
+{
+   int j,s;
+   CLink p;
+   HLink hmm;
+   StateInfo *si;
+   
+   switch(macro->type) {
+   case 'h':   /* HMM-level clustering */
+      hmm = (HLink) macro->structure;
+      for (j=2; j<hmm->numStates; j++) {
+         /* acc should be re-calculated */
+         ZeroAccSum(acc);
+         for (p=clist; p!=NULL; p=p->next)
+            IncSumSqr(p->item->owner->svec[j].info, FALSE, acc, NULL);
+         
+         si = hmm->svec[j].info;
+         for (s=1; s<=acc->nStream; s++)
+            GetCentroidStr(si->pdf[s].info, acc->accse+s, vf[s]);
+      }
+      break;
+   case 's':   /* state-level clustering */
+      si = (StateInfo *)macro->structure;
+      for (s=1; s<=acc->nStream; s++)
+         GetCentroidStr(si->pdf[s].info, acc->accse+s, vf[s]);
+      break;
+   case 'p':  /* stream-level clustering */
+      GetCentroidStr((StreamInfo *)macro->structure, acc->accse+stream, vf[stream]);
+      break;
+   default:
+      HError(2640,"GetCentroid: macro type %c not supported", macro->type);
+   }
+
+   return;
+}
+
 /* TieLeafNodes: tie all items in the leaf nodes of given tree */
 void TieLeafNodes(Tree *tree, char *macRoot)
 {
-   float occ;
+   double occ;
    ILink ilist,i;
    CLink cl;
    char clnum[20];              /* cluster number */
    int clidx;                   /* cluster index */
-   char buf[255];               /* construct mac name in this */
+   char buf[MAXSTRLEN],str[MAXSTRLEN];  /* construct mac name in this */
    Node *node;
-   int numItems = 0;
-   LabId id;
-   SVector vf[SMAX];
-   SVector mean, var;
-   int l=0;
-   Boolean vfSet=FALSE; 
+   int s,j,numItems = 0;
+   LabId id = NULL;
 
    if (trace & T_CLUSTERS) printf("\n Nodes for %s\n",macRoot);
-   if (useLeafStats) { 
-      int k;
-      /* get vFloor vectors and flag if present in hset */
-      SetVFloor(hset,vf,-1.0);
-      vfSet=TRUE;
-      l=VectorSize(vf[1]);
-      for (k=1;k<=l;k++)
-         if (vf[1][k]<0.0)
-            vfSet = FALSE;
-   }
    cprob=0.0; occ=0.0;
    clidx = numTreeClust;
    for (node=tree->leaf;node!=NULL;node=node->next) {
+      if (node->clist!=NULL) {
       cprob += ClusterLogL(node->clist,&no,NULL,occs); /*==node->tProb;*/
       occ += occs[FALSE];
+         node->macro = (node->macro==NULL) ? (MLink *) New(&hmmHeap,tree->nActiveStr*sizeof(MLink)) : node->macro;
       sprintf(clnum,"%d",clidx--); /* construct macro name */
       strcpy(buf,macRoot);
       strcat(buf,clnum);
@@ -2907,7 +3715,7 @@ void TieLeafNodes(Tree *tree, char *macR
          char buf[20];
          if (node->parent==NULL) sprintf(buf,"ROOT");
          else sprintf(buf,"%d[%c]",node->parent->snum,
-                      (node->parent->yes==node?'Y':'N'));
+                         ((node->parent->yes==node)?'Y':'N'));
          printf("  %-6s== %-3d LogL %6.3f (%.1f) ==",buf,clidx,
                 node->tProb/node->occ,node->occ);
       }
@@ -2923,72 +3731,110 @@ void TieLeafNodes(Tree *tree, char *macR
       numItems += NumItems(ilist);
       if (trace & T_CLUSTERS)
           printf("\n");
-      if ((ilist->item != ilist->owner) && useLeafStats) {
-         /* get cluster stats */
-         l = VectorSize(no.sum);
-         ZeroAccSum(&no);
-         for(cl=node->clist;cl!=NULL;cl=cl->next) 
-            IncSumSqr(((StateElem*)cl->item->item)->info,FALSE,&no,NULL,l);
+         if (hset->swidth[0] == tree->nActiveStr) {  /* not stream clustering */
+            if (node->id!=NULL)
+               strcpy(buf,node->id->name);
+            ApplyTie(ilist,buf,((ilist->item==ilist->owner)?'h':'s'));
+            id = (node->id==NULL) ? GetLabId(buf,FALSE) : node->id;
+            node->macro[0] = FindMacroName(hset,((ilist->item==ilist->owner)?'h':'s'),id);
+            if (useLeafStats)
+               GetCentroid(node->macro[0], node->clist, &no, 0);
+         }
+         else {
+            for (s=1,j=0;s<=hset->swidth[0];s++) {
+               if (tree->streams.set[s]) {
+                  if (node->id==NULL) 
+                     strcpy(str,buf);
+                  else
+                     strcpy(str,node->id->name);
+                  if (tree->nActiveStr>1) {
+                     sprintf(clnum,"%d",s);   /* construct macro name for each stream */
+                     strcat(str,"-");
+                     strcat(str,clnum);
+                  }
+                  id=GetLabId(str,TRUE);
+                  TieLeafStream(ilist,id,s);
+                  node->macro[j] = FindMacroName(hset,'p',id);
+                  if (useLeafStats)
+                     GetCentroid(node->macro[j], cl, &no, s);
+                  j++;
       }
-      ApplyTie(ilist,buf,(ilist->item==ilist->owner?'h':'s'));
-      id=GetLabId(buf,FALSE);
-      node->macro = FindMacroName(hset,((ilist->item==ilist->owner)?'h':'s'),id);
-      if ((ilist->item != ilist->owner) && useLeafStats) {
-         int k;
-         StreamElem *ste;
-         MixPDF *mp;
-         ste = (((StateElem *)ilist->item)->info->pdf)+1;
-         mp = ste->spdf.cpdf[1].mpdf;
-         mean = mp->mean;
-         var  = mp->cov.var;
-         for (k=1;k<=l;k++) {
-            mean[k] = no.sum[k]/no.occ;
-            var[k] = no.sqr[k]/no.occ - mean[k]*mean[k];
-            /* floor variances */
-            if (vfSet && (var[k] < vf[1][k]) )
-               var[k] = vf[1][k];
          }
+            if (tree->nActiveStr>1)
+               id=GetLabId(buf,TRUE);
       }
+         if (node->id==NULL)
+            node->id = id;
+   
       FreeItems(&ilist);        /* free items at this node */
       node->clist=NULL;
    }
+      else
+         HError(-9999,"TieLeafNodes: no HMMs/states are assigned to node %d", -node->snum);
+   }
+}
+
+static Node *GetNode(Node *node,int n)
+{
+   Node *ret;
+  
+   ret=NULL;
+   if (node->snum==n) return(node);
+   else {
+      if (node->yes) {
+         ret=GetNode(node->yes,n);
+         if (ret) return(ret);
+      }
+      if (node->no) {
+         ret=GetNode(node->no,n);
+         if (ret) return(ret);
+      }
+   }
+   return(NULL);
 }
 
 /* BuildTree: build a tree for objects stored in ilist and return
    the actual clusters in rlist, the number of clusters
    in numCl.  The value of threshold determines when to stop.
    macRoot is the root prefix of the name to use in the tie  */
-void BuildTree(ILink ilist,float threshold, char *macRoot)
+void BuildTree (ILink ilist, double threshold, char *macRoot, char *pattern)
 {
-   int i,j,l,N,snum,state,numItems;
-   char buf[256];
+   int i,j,l,s,m,N,snum,state,numItems,numParam,count;
+   char buf[PAT_LEN];
    HMMDef *hmm;
    CLink clHead,cl;
-   ILink p;
-   QLink q;
+   ILink p, k;
+   Question *q;
    LabId labid;
-   Node *node;
-   Tree *tree;
+   Node *node,*n;
+   Tree *tree = NULL,*t;
    static int totalItems = 0;   /* for overall statistics */
    static int totalClust = 0;
    
    SetTreeName(macRoot);
-   l = hset->swidth[1];
+   l = hset->vecSize;
    /* Initialise Global AccSums for yes - no branches */
-   yes.sum=CreateVector(&tmpHeap,l);  yes.sqr=CreateVector(&tmpHeap,l);
-   no.sum=CreateVector(&tmpHeap,l);   no.sqr=CreateVector(&tmpHeap,l);
+   yes.sum=CreateDVector(&tmpHeap,l);  yes.sqr=CreateDVector(&tmpHeap,l);
+   no.sum=CreateDVector(&tmpHeap,l);   no.sqr=CreateDVector(&tmpHeap,l);
+   MakeAccSum(&yes,ilist);
+   MakeAccSum(&no,ilist);
 
    /* Check object consistency */
    hmm = ilist->owner;          /* any HMM will do */
    N = hmm->numStates;
    for(p=ilist;p!=NULL;p=p->next) 
-      ChkTreeObject(p);
+      ChkTreeObject(p,&no);
 
    /* Create a new tree in tree list */
    /* Find base name and state if any */
    hmm = ilist->owner;
-   strcpy(buf,HMMPhysName(hset,hmm)); TriStrip(buf);
+   if (usePattern)
+      strcpy(buf,pattern);
+   else {
+      strcpy(buf,HMMPhysName(hset,hmm)); 
+      TriStrip(buf);
    MapTreeName(buf);
+   }
    labid = GetLabId(buf,TRUE);
 
    if (ilist->owner==ilist->item)
@@ -3000,16 +3846,34 @@ void BuildTree(ILink ilist,float thresho
          }
    if (state==0)
       HError(2663,"BuildTree: cannot find state index");
+
+   if (useRefTree >= 0) {
+     for (t=treeList;t!=NULL;t=t->next) {
+       if (strcmp(t->baseId->name,labid->name)==0 && t->state==state) {
+         tree = t;
+         if (trace & T_BID) {
+	   printf("(using reference tree %3s.state[%d]) ",tree->baseId->name,state);
+	   fflush(stdout);
+         }
+	 break;
+       }
+     }
+     if (t==NULL)
+       HError(2663,"BuildTree: cannot find reference tree");
+   }
+   else
    tree = CreateTree(ilist,labid,state);
 
    /* Create a single cluster, owner->hook links to cluster record */
-   i = 1; clHead = NULL;
+   i=1; clHead=NULL; count=0;
    for (p=ilist;p!=NULL;p=p->next,i++) {
-      if (p->owner == p->item)
+      if (p->owner == p->item) {
+         count += p->owner->svec[2].info->stateCounter;
          for (j=2;j<p->owner->numStates;j++)
-            InitTreeAccs(p->owner->svec+j, l);
+            InitTreeAccs(p->owner->svec+j);
+      }
       else
-         InitTreeAccs((StateElem*)p->item, l);
+         InitTreeAccs((StateElem*)p->item);
       cl=(CLink) New(&tmpHeap,sizeof(CRec));
       p->owner->hook = cl; /* HMM hook links to CRec */
       cl->item = p;  cl->ans = FALSE;
@@ -3019,40 +3883,133 @@ void BuildTree(ILink ilist,float thresho
    
    /* For each question make each hmm (item) point to its */
    /*  corresponding cluster member (CREC) via hmm->hook */
-   for (q=qHead; q!=NULL; q=q->next)
+   for (k=qList; k!=NULL; k=k->next) {
+      q = (Question *)k->item;
       for (p=q->ilist; p!=NULL; p=p->next)
          p->item = p->owner->hook;
+   }
    for (p=ilist;p!=NULL;p=p->next,i++)
-      p->owner->hook=NULL;
+      p->owner->hook = FindMacroStruct(hset,'h',p->owner); /* hook MLink */
 
    /* Create the root of the tree */
-   node = tree->leaf = tree->root = CreateTreeNode(clHead,NULL);
+   if (useRefTree >= 0) {
+     tree->root->clist = clHead;
+     tree->root->next  = NULL;
+     tree->root->prev  = NULL;
+   }
+   else
+     tree->root = CreateTreeNode(clHead,NULL);
+   node = tree->leaf = tree->root;
    cprob = node->tProb = ClusterLogL(node->clist,&no,NULL,occs);
    node->occ = occs[FALSE];
    numTreeClust=1; numItems=NumItems(ilist);
+
+   if (applyMDL) {
+      numParam=0;
+      for (s=1; s<=hset->swidth[0]; s++) {
+         if (streams.set[s]) {
+            for (m=1; m<=no.accse[s].nMix; m++)
+               numParam += 2 * no.accse[s].accme[m].vSize;
+            numParam += no.accse[s].nMix-1;
+         }
+      }
+      
+      if (ilist->owner == ilist->item)  /* HMM-level clustering */
+         threshold = MDLfactor * 0.5 * (double)numParam * (N-2) * log(count);
+      else  /* state-level or stream-level clustering */
+         threshold = MDLfactor * 0.5 * (double)numParam * log(node->occ);
+
+      if (threshold<0.0)
+         threshold = 0.0;
+
+      if (trace & T_BID) { 
+         printf("based on MDL criterion, threshold=%e", threshold);
+         fflush(stdout);
+      }
+   }
+   
+   if (trace & T_BID) {
+      printf("\n");
+      fflush(stdout);
+   }
+
    if (trace & T_IND) {
       if (state<0) 
          printf(" Start  %4s : %d  have LogL=%6.3f occ=%4.1f\n",
                 tree->baseId->name,
                 numItems,cprob/node->occ,node->occ);
       else
-         printf(" Start %3s[%d] : %d  have LogL=%6.3f occ=%4.1f\n",
+         printf(" Start %3s.state[%d] : %d  have LogL=%6.3f occ=%4.1f\n",
                 tree->baseId->name,state,numItems,cprob/node->occ,node->occ);
       fflush(stdout);
    }
-   ValidProbNode(node,threshold);
-   node->prev = NULL;
+   ValidProbNode(node,threshold,(useRefTree>=0)?TRUE:FALSE);
 
    /* Now build the actual tree by repeated node splitting */
    snum=0;
+   if (useRefTree >= 0) {
+      node=FindBestSplit(tree->leaf,(useRefTree==1||useRefTree==3)?0.0:threshold);
+      while(node != NULL && snum < tree->size) {
+	 node->id=NULL;
+	 node->snum=snum++; node->quest->used=TRUE;
+         if (trace & T_DET) {
+            char buf[20];
+            if (node->parent==NULL) sprintf(buf," ROOT ");
+            else sprintf(buf,"%3d[%c]",node->parent->snum,
+                         ((node->parent->yes==node)?'Y':'N'));
+            printf("\n  Split %s == %-3d (%.1f)\n",
+                   buf,node->snum,node->occ);
+            printf("          %20s   LogL %7.3f -> %7.3f  Imp %.2f\n",
+                   node->quest->qName->name,node->tProb/node->occ,
+                   node->sProb/node->occ,node->sProb-node->tProb);
+            fflush(stdout);
+         }
+         SplitTreeNode(tree,node,TRUE);
+         ValidProbNode(node->yes,(useRefTree==1||useRefTree==3)?0.0:threshold,TRUE);
+         ValidProbNode(node->no, (useRefTree==1||useRefTree==3)?0.0:threshold,TRUE);
+   
+         AddLeafList(node->yes,tree,(useRefTree==1||useRefTree==3)?0.0:threshold,TRUE);
+         AddLeafList(node->no, tree,(useRefTree==1||useRefTree==3)?0.0:threshold,TRUE);
+
+         if (trace & T_TREE_BESTQ) {
+            printf("   Node %-3d  [Y] LogL %.3f (%.1f)    [N] LogL %.3f (%.1f)\n",
+                   node->snum,node->yes->tProb/node->yes->occ,node->yes->occ,
+                   node->no->tProb/node->no->occ,node->no->occ);
+            fflush(stdout);
+         }
+         node = FindBestSplit(tree->leaf,(useRefTree==1||useRefTree==3)?0.0:threshold);
+      }
+   }
+
+   if (useRefTree>=0) {
+      if (useRefTree>=2)
+         node=NULL;
+      else {
+         for (node=tree->leaf,j=1;node!=NULL;node=n,j++) {
+            n = node->next;
+            if (node->parent != NULL)
+   	       node->parent->qlist = qList;
+            ValidProbNode(node,threshold,FALSE);
+            node->yes = NULL;
+            node->no  = NULL;
+            node->next= NULL;
+            node->prev= NULL;
+            node->id  = NULL;
+            if (j>1)
+   	       AddLeafList(node,tree,threshold,FALSE);
+         }
+	 node=FindBestSplit(tree->leaf,threshold);
+      }
+   }
+   else
    node=FindBestSplit(tree->leaf,threshold);
    while(node != NULL) {
-      node->snum=snum++;
+      node->snum=snum++; node->quest->used=TRUE;
       if (trace & T_DET) {
          char buf[20];
          if (node->parent==NULL) sprintf(buf," ROOT ");
          else sprintf(buf,"%3d[%c]",node->parent->snum,
-                      (node->parent->yes==node?'Y':'N'));
+                      ((node->parent->yes==node)?'Y':'N'));
          printf("\n  Split %s == %-3d (%.1f)\n",
                 buf,node->snum,node->occ);
          printf("          %20s   LogL %7.3f -> %7.3f  Imp %.2f\n",
@@ -3060,26 +4017,36 @@ void BuildTree(ILink ilist,float thresho
                 node->sProb/node->occ,node->sProb-node->tProb);
          fflush(stdout);
       }
-      SplitTreeNode(tree,node);
-      ValidProbNode(node->yes,threshold);
-      ValidProbNode(node->no,threshold);
-      if (trace & T_TREE_BESTQ)
+      SplitTreeNode(tree,node,FALSE);
+      ValidProbNode(node->yes,threshold,FALSE);
+      ValidProbNode(node->no, threshold,FALSE);
+
+      FreeItems(&node->qlist);
+      
+      AddLeafList(node->yes,tree,threshold,TRUE);
+      AddLeafList(node->no, tree,threshold,TRUE);
+      
+      if (trace & T_TREE_BESTQ) {
          printf("   Node %-3d  [Y] LogL %.3f (%.1f)    [N] LogL %.3f (%.1f)\n",
                 node->snum,node->yes->tProb/node->yes->occ,node->yes->occ,
                 node->no->tProb/node->no->occ,node->no->occ);
+         fflush(stdout);
+      }
       node=FindBestSplit(tree->leaf,threshold);
    }
    tree->size=snum;
+   for (p=ilist;p!=NULL;p=p->next,i++)
+      p->owner->hook = NULL;
    
    /* Merge any similar leaf nodes */
-   if (treeMerge) {
+   if (!applyMDL && treeMerge) {
       if (trace & T_IND) {
          if (state<0) 
             printf("\n Via    %4s : %d gives LogL=%6.3f occ=%4.1f\n",
                    tree->baseId->name,numTreeClust,
                    cprob/tree->root->occ,tree->root->occ);
          else
-            printf("\n Via   %3s[%d] : %d gives LogL=%6.3f occ=%4.1f\n",
+            printf("\n Via   %3s.state[%d] : %d gives LogL=%6.3f occ=%4.1f\n",
                    tree->baseId->name,state,numTreeClust,cprob/tree->root->occ,
                    tree->root->occ);
          fflush(stdout);
@@ -3089,19 +4056,20 @@ void BuildTree(ILink ilist,float thresho
    
    /* Finally assign a macro to each leaf node and do tie */
    totalItems += numItems; totalClust += numTreeClust;
+   tree->nLeaves = numTreeClust;
    if (trace & T_IND) {
       if (state<0) 
          printf("\n End    %4s : %d gives LogL=%6.3f occ=%4.1f\n",
                 tree->baseId->name,numTreeClust,
                 cprob/tree->root->occ,tree->root->occ);
       else
-         printf("\n End   %3s[%d] : %d gives LogL=%6.3f occ=%4.1f\n",
+         printf("\n End   %3s.state[%d] : %d gives LogL=%6.3f occ=%4.1f\n",
                 tree->baseId->name,state,numTreeClust,cprob/tree->root->occ,
                 tree->root->occ);
       fflush(stdout);
    }
    TieLeafNodes(tree,macRoot);
-   Dispose(&tmpHeap,yes.sum);
+   FreeDVector(&tmpHeap,yes.sum);
    if (trace & T_BID) {
       printf("\n TB: Stats %d->%d [%.1f%%]  { %d->%d [%.1f%%] total }\n",
              numItems,numTreeClust,(float)numTreeClust*100.0/(float)numItems,
@@ -3111,29 +4079,55 @@ void BuildTree(ILink ilist,float thresho
    SetTreeName("");
 }
 
-/* AssignState: find shared state info for given id and state idx */
-Ptr AssignStructure(LabId id, int state)
+/* AssignStructure: find shared state/stream info for given id and state/stream idx */
+Ptr AssignStructure(LabId id, const int state)
 {
-   int len=0;
-   char buf[256];
-   LabId tid;
+   int len=0,stream,nTree,s,j;
+   char buf[PAT_LEN];
+   LabId tid = NULL;
    Tree *tree;
    Node *node;
    Boolean isYes;
-   MLink m;
+   ILink tlist=NULL,i;
+   MLink m = NULL;
+   StateInfo *si = NULL;
+   StreamElem *ste;
    
    /* First find Tree to use */
-   strcpy(buf,id->name); TriStrip(buf);
+   strcpy(buf,id->name);
+   if (!usePattern) {
+      if (strchr(buf,'*')!=NULL || strchr(buf,'?')!=NULL)
+         HError(9999,"AssignStructure: baseId %s includes pattern character", buf);
+      TriStrip(buf); 
    MapTreeName(buf);
    tid = GetLabId(buf,FALSE);
-   for (tree=treeList;tree!=NULL;tree=tree->next) {
-      if (tree->baseId == tid && tree->state == state) break;
    }
-   if (tree==NULL && state<0) return(NULL);
-   if (tree==NULL)
+   
+   for (tree=treeList,stream=0;tree!=NULL;tree=tree->next) {
+      if ( ((usePattern && IPatMatch(buf, tree->patList)) || singleTree || (!singleTree && !usePattern && tree->baseId == tid))
+           && tree->state == state ) {
+         AddItem(NULL,tree,&tlist);
+         stream += tree->nActiveStr;
+      }
+   }
+   if (tlist==NULL && state<0) return(NULL);
+   if (tlist==NULL)
       HError(2662,"AssignStructure: cannot find tree for %s state %d",
              id->name,state);
+   if (stream!=hset->swidth[0]) 
+      HError(9999,"AssignStructure: incompatible tree");
+
+   nTree = NumItems(tlist);
+   if (nTree>1) {
+      si  = (StateInfo  *) New(&hmmHeap,sizeof(StateInfo));
+      ste = (StreamElem *) New(&hmmHeap,hset->swidth[0]*sizeof(StreamElem));
+      ste--;
+      si->nUse=0; si->hook=NULL; si->stateCounter=0; si->dur=NULL; si->weights=NULL; 
+      si->pdf = ste;
+   }
       
+   for (i=tlist;i!=NULL;i=i->next) {
+      tree = (Tree *)i->item;
    /* Then move down tree until state is found */
    node = tree->root;
    if (trace & T_DET) {
@@ -3144,36 +4138,54 @@ Ptr AssignStructure(LabId id, int state)
    }
    while (node->yes != NULL) {
       isYes = QMatch(id->name,node->quest);
-      if (trace & T_TREE_ANS) printf("%s ",isYes?"yes":" no"),len+=4;
+         if (trace & T_TREE_ANS) printf("%s ",(isYes)?"yes":" no"),len+=4;
       node = (isYes)?node->yes:node->no;
    }
-   m = (MLink)node->macro;
+      if (nTree==1)   /* state-based clustering */
+         m = (MLink)node->macro[0];
+      else            /* stream-based clustering */
+         for (s=1,j=0;s<=hset->swidth[0];s++)
+            if (tree->streams.set[s])
+               si->pdf[s].info = (StreamInfo *)node->macro[j++]->structure;
+
    if (trace & T_DET) {
       if (trace & T_TREE_ANS) printf("%*s",48-len," ");
-      printf("=~%c %-10s ",(state>0?'s':'h'),node->macro->id->name);
+            printf("=~%c %-10s ",((state>0)?((nTree>1)?'p':'s'):'h'),node->id->name);
       fflush(stdout);
    }
-   return(m->structure);
+   }
+   return((nTree>1)?si:m->structure);
 }
 
 /* FindProtoModel: find an allophone of given model in hList */
 HLink FindProtoModel(LabId model)
 {
-   char phone[256], buf[256];
+   char phone[MAXSTRLEN], buf[MAXSTRLEN];
    int h;
    MLink q;
+   HLink hmm=NULL;
 
+   /* find an allophone of given model in hlist */
    strcpy(phone,model->name);
    TriStrip(phone);
    for (h=0; h<MACHASHSIZE; h++)
       for (q=hset->mtab[h]; q!=NULL; q=q->next) 
          if (q->type=='h') {
+            hmm = (HLink) q->structure;
             strcpy(buf,q->id->name);
             TriStrip(buf);
-            if (strcmp(phone,buf)==0) return ((HLink) q->structure);
+            if (strcmp(phone,buf)==0)
+               return (hmm);
          }
+
+   /* if no model matches to given model and usePatten or singleTree is set, 
+    * return the last model in hlist */
+   if (usePattern || singleTree)
+      return (hmm);
+   
+   /* no model matches to given model */
    HError(2662,"FindProtoModel: no proto for %s in hSet",model->name);
-   return NULL;
+   return hmm;
 }
 
 /* SynthStates: synthesise a HMM from state based trees */
@@ -3181,7 +4193,8 @@ HMMDef *SynthModel(LabId id)
 {
    HMMDef *hmm,*proto;
    StateElem *se;
-   int i,N;
+   int i,s,N;
+   Boolean strShare;
    
    if (trace & T_DET) {
       printf("   Synth %-11s",id->name);
@@ -3194,16 +4207,32 @@ HMMDef *SynthModel(LabId id)
       N=hmm->numStates=proto->numStates;
       se=(StateElem*) New(&hmmHeap,sizeof(StateElem)*N);
       hmm->svec=se-2;hmm->owner=hset;
-      hmm->dur=proto->dur;
+      hmm->dur=CloneSVector(hset->hmem,proto->dur,TRUE);
       hmm->nUse=0; hmm->hook=NULL;
       hmm->transP=CloneSMatrix(hset->hmem,proto->transP,TRUE);
       hmm->nUse = 1; hmm->hook = NULL; N = hmm->numStates;
       hmm->svec = se - 2;
       for (i=2; i<N; i++,se++) {
          se->info = (StateInfo *) AssignStructure(id,i);
-         if (se->info->nUse==0)
-            HError(2695,"SynthModel: untied state found for state %d",i);
-         se->info->nUse++;
+         if (se->info->nUse==0) {
+            strShare = FALSE;
+            for (s=1; s<=hset->swidth[0]; s++) {
+               if (se->info->pdf[s].info->nUse==0) 
+                  HError(2695,"SynthModel: untied stream found for state %d stream %d",i,s);
+               else {
+                  strShare = TRUE;
+                  se->info->pdf[s].info->nUse++;
+               }
+            }
+            if (!strShare)
+               HError(2695,"SynthModel: untied state found for state %d",i);
+            else {
+               se->info->dur = CloneSVector(hset->hmem, proto->svec[i].info->dur, TRUE);
+               se->info->weights = CloneSVector(hset->hmem, proto->svec[i].info->weights, TRUE);
+            }
+         }
+         else
+            se->info->nUse++;
       }
       NewMacro(hset,fidx,'h',id,hmm);
    }
@@ -3259,42 +4288,34 @@ void DownTree(Node *node,Node **array) 
    }
 }
 
-/* ShowTrees: print a summary of currently constructed trees */
-void ShowTreesCommand(void)
+/* PrintQuestions: print questions for Tree-based clustering */
+void PrintQuestions(FILE *file)
 {
-   Tree *tree;
-   Node *node,**array;
-   QLink q;
-   IPat *p;
-   int i;
-   FILE *file;
-   char fn[256];
+   Question *q;
+   ILink i,p;
   
-   ChkedAlpha("ST trees file name",fn);         /* get name of trees file */
-   if (trace & T_BID) {
-      printf("\nST %s\n Writing current questions/trees to file\n",fn);
-      fflush(stdout);
-   }
-   if ((file=fopen(fn,"w"))==NULL)
-      HError(2611,"ShowTreesCommand: Cannot open trees file %s",fn);
-   for (q=qHead;q;q=q->next) {
-      fprintf(file,"QS %s ",ReWriteString(q->qName->name,NULL,SING_QUOTE));
-      fprintf(file,"{ %s",ReWriteString(q->patList->pat,NULL,DBL_QUOTE));
-      for (p=q->patList->next;p;p=p->next)
-         fprintf(file,",%s",ReWriteString(p->pat,NULL,DBL_QUOTE));
+   for (i=qList;i!=NULL;i=i->next) {
+      q = (Question *)i->item;
+      if (q->used) {
+         fprintf(file,"QS %s ",q->qName->name);
+         fprintf(file,"{ %s",ReWriteString(((IPat *)q->patList->item)->pat,NULL,DBL_QUOTE));
+         for (p=q->patList->next;p!=NULL;p=p->next)
+            fprintf(file,",%s",ReWriteString(((IPat *)p->item)->pat,NULL,DBL_QUOTE));
       fprintf(file," }\n");
    }
+   }
    fprintf(file,"\n");
-   for (tree=treeList;tree!=NULL;tree=tree->next) {
-      if (tree->state>0)
-         fprintf(file,"%s[%d]\n",
-                 ReWriteString(tree->baseId->name,NULL,ESCAPE_CHAR),
-                 tree->state);
-      else
-         fprintf(file,"%s\n",tree->baseId->name);
+}
+
+/* PrintTree: print decision-tree */
+void PrintTree(Tree *tree, FILE *file)
+{
+   Node *node, **array;
+   int i;
+   
       if (tree->size==0) {
-         fprintf(file,"   %s\n\n",
-                 ReWriteString(tree->root->macro->id->name,NULL,DBL_QUOTE));
+      fprintf(file,"   %-45s\n\n", 
+              ReWriteString(tree->root->id->name,NULL,DBL_QUOTE));
       }
       else {
          array=(Node**) New(&tmpHeap,sizeof(Node*)*tree->size);
@@ -3307,52 +4328,93 @@ void ShowTreesCommand(void)
                HError(2695,"ShowTreesCommand: Cannot find node %d",i);
             if (node->yes==NULL || node->no==NULL) 
                HError(2695,"ShowTreesCommand: Node %d has no children",i);
-            fprintf(file," %3d %24s ",-i,
-                    ReWriteString(node->quest->qName->name,NULL,SING_QUOTE));
+         fprintf(file," %3d %-45s ",-i,
+                 node->quest->qName->name);
             if (node->no->yes) fprintf(file,"  %5d    ",-node->no->snum);
-            else fprintf(file," %9s ",
-                         ReWriteString(node->no->macro->id->name,NULL,DBL_QUOTE));
+         else fprintf(file," %15s ",
+                      ReWriteString(node->no->id->name,NULL,DBL_QUOTE));
             if (node->yes->yes) fprintf(file,"  %5d    ",-node->yes->snum);
-            else fprintf(file," %9s ",
-                         ReWriteString(node->yes->macro->id->name,NULL,DBL_QUOTE));
+         else fprintf(file," %15s ",
+                      ReWriteString(node->yes->id->name,NULL,DBL_QUOTE));
             fprintf(file,"\n");
+         fflush(file);
          }
          fprintf(file,"}\n\n");
          Dispose(&tmpHeap,array);
       }
    }
-   fclose(file);
-}
 
-static Node *GetNode(Node *node,int n)
+/* ShowTrees: print a summary of currently constructed trees */
+void ShowTreesCommand(void)
 {
-   Node *ret;
+   Tree *tree;
+   int i,s;
+   FILE *file;
+   char fn[MAXFNAMELEN];
+   Boolean isPipe;
   
-   ret=NULL;
-   if (node->snum==n) return(node);
+   ChkedAlpha("ST trees file name",fn);         /* get name of trees file */
+   if (trace & T_BID) {
+      printf("\nST %s\n Writing current questions/trees to file\n",fn);
+      fflush(stdout);
+   }
+   if ((file=FOpen(fn,NoOFilter,&isPipe))==NULL)
+      HError(2611,"ShowTreesCommand: Cannot open trees file %s",fn);
+   
+   PrintQuestions(file);
+ 
+   for (tree=treeList;tree!=NULL;tree=tree->next) {
+      if (tree->state>0)                       
+         fprintf(file,"%s[%d]",
+                 ReWriteString(tree->baseId->name,NULL,ESCAPE_CHAR),
+                 tree->state);
+      else
+         fprintf(file,"%s",tree->baseId->name);
+      if (tree->nActiveStr == hset->swidth[0])
+         fprintf(file,"\n");
    else {
-      if (node->yes) {
-         ret=GetNode(node->yes,n);
-         if (ret) return(ret);
+         fprintf(file,".stream[");         /* output active stream of current tree */
+         for (s=1,i=1;s<=hset->swidth[0];s++)
+            if (tree->streams.set[s])
+                fprintf(file,"%d%s",s,(i++<tree->nActiveStr)?",":"]\n");
       }
-      if (node->no) {
-         ret=GetNode(node->no,n);
-         if (ret) return(ret);
+      PrintTree(tree,file);
       }
+   FClose(file,isPipe);
    }
-   return(NULL);
+
+float GetNodeOcc (MLink macro, char type)
+{
+   float occ;
+   
+   if (!occStatsLoaded || macro==NULL)
+      return 0.0;
+   
+   switch(type) {
+   case 's': memcpy(&occ,&(((StateInfo  *)macro->structure)->hook),sizeof(float)); break;
+   case 'p': memcpy(&occ,&(((StreamInfo *)macro->structure)->hook),sizeof(float)); break;
+   }
+   
+   return occ;
 }    
 
 Tree *LoadTree(char *name,Source *src)
 {
-   int n,nt,num_no,num_yes;
+   int n,nt,num_no,num_yes,s,nStream=1;
    char type;
    LabId lab_no,lab_yes,qname;
    Tree *tree;
    Node *node;
-   char buf[256],bname[64],*p;
+   char buf[MAXSTRLEN],bname[PAT_LEN],index[PAT_LEN],mname[MAXSTRLEN],*p;
+   Boolean strTree=FALSE;
   
    strcpy(bname,name);
+   if (strstr(bname,"stream")!=NULL) {
+      strcpy(index,bname);
+      *(strstr(bname,"stream")-1)='\0';
+      strTree = TRUE;
+   }
+
    if (name[strlen(bname)-1]==']' && strrchr(bname,'[')!=NULL) {
       p=strchr(bname,'[');
       *p++=0;
@@ -3362,17 +4424,80 @@ Tree *LoadTree(char *name,Source *src)
    }
    else
       n=-1,type='h';
+
+   
    if (GetLabId(bname,TRUE)==NULL)
       HError(2660,"LoadTree: Cannot parse tree name %s (base-phone)",name);
 
    tree=CreateTree(NULL,GetLabId(bname,FALSE),n);
-   nt=0;tree->size=0;
+   nt=0;tree->size=0;tree->nLeaves=0;
    tree->root=CreateTreeNode(NULL,NULL);
    tree->root->snum=0;
+
+   if (strTree) {
+     p = strrchr(index,'[')+1;
+
+     while (*p==' ') p++;
+     s = atoi(p);
+     if (s<=0 || s>hset->swidth[0])
+       HError(9999,"LoadTree: stream index out of range");
+     tree->streams.set[s] = TRUE;
+     while (*p!=',' && *p!=']') p++;
+     while (*p==' ') p++;
+
+     while (*p==',') {
+        p++;
+        s = atoi(p);
+        if (s<=0 || s>hset->swidth[0])
+           HError(9999,"LoadTree: stream index out of range");
+        tree->streams.set[s] = TRUE;
+        nStream++;
+        while (*p!=',' && *p!=']') p++;
+        while (*p==' ') p++;
+     }
+     
+     if (*p != ']')
+       HError(9999,"LoadTree: stream index ] expected");
+     
+     if (IsFullSet(tree->streams)) {
+        type = 's';
+        strTree = FALSE;
+     }
+     else {
+        type = 'p';
+     }
+   }
+   else {
+      nStream = hset->swidth[0];
+      for (s=1;s<=hset->swidth[0];s++)
+         tree->streams.set[s] = TRUE;
+   }
+   tree->nActiveStr=nStream;
+
    ReadString(src,buf);
    if (strcmp(buf,"{")) {
-      if ((tree->root->macro=FindMacroName(hset,type,GetLabId(buf,FALSE)))==NULL)
-         HError(2661,"LoadTree: Macro %s not recognised",buf);
+      tree->root->macro = (MLink *) New(&hmmHeap,nStream*sizeof(MLink));
+      if (strTree && nStream>1) {
+         for (s=1,n=0;s<=hset->swidth[0];s++)
+            if (tree->streams.set[s]) {
+               strcpy(mname,buf);
+               sprintf(index,"%d",s);   /* construct macro name for each stream */
+               strcat(mname,"-");
+               strcat(mname,index);
+               if ((tree->root->macro[n++]=FindMacroName(hset,type,GetLabId(mname,FALSE)))==NULL)
+                  if (useRefTree < 0)
+                     HError(-2661,"LoadTree: Macro %s not recognised",mname);
+            }
+      }
+      else{
+         if ((tree->root->macro[0]=FindMacroName(hset,type,GetLabId(buf,FALSE)))==NULL)
+            if (useRefTree < 0)
+               HError(-2661,"LoadTree: Macro %s not recognised",buf);
+      }
+      tree->nLeaves=1;
+      tree->root->id = GetLabId(buf, TRUE);
+      tree->root->occ = GetNodeOcc(tree->root->macro[0],type);
+      tree->leaf = tree->root;
    }
    else {
       while (ReadString(src,buf),strcmp("}",buf)!=0) {
@@ -3381,13 +4506,14 @@ Tree *LoadTree(char *name,Source *src)
 
          ReadString(src,buf);
          qname=GetLabId(buf,FALSE);
-         if (qname==NULL?TRUE:qname->aux==0)
+         if ((qname==NULL)?TRUE:qname->aux==0)
             HError(2661,"LoadTree: Question %s not recognised",buf);
 
          if ((node=GetNode(tree->root,-n))==NULL)
             HError(2661,"LoadTree: Node %d not in tree",n);
 
-         node->quest=(QLink) qname->aux;
+         node->quest=(Question *) qname->aux;
+         node->quest->used=(useRefTree<0)?TRUE:FALSE;
          node->yes=CreateTreeNode(NULL,node);
          node->yes->ans=TRUE;
          node->no=CreateTreeNode(NULL,node);
@@ -3396,22 +4522,46 @@ Tree *LoadTree(char *name,Source *src)
          ReadString(src,buf);
          if (sscanf(buf,"%d",&num_no)==1)
             lab_no=NULL;
-         else
-            if ((lab_no=GetLabId(buf,FALSE))==NULL)
-               HError(2661,"LoadTree: Macro %s not recognised",buf);
+         else {
+            lab_no=GetLabId(buf,TRUE);
+            node->id = lab_no;
+         }
+
          ReadString(src,buf);
          if (sscanf(buf,"%d",&num_yes)==1)
             lab_yes=NULL;
-         else
-            if ((lab_yes=GetLabId(buf,FALSE))==NULL)
-               HError(2661,"LoadTree: Macro %s not recognised",buf);
+         else {
+            lab_yes=GetLabId(buf,TRUE);
+            node->id = lab_yes;
+         }
+
          if (lab_no) {
-            node->no->macro=FindMacroName(hset,type,lab_no);
+            node->no->id = lab_no;
+            node->no->macro = (MLink *) New(&hmmHeap,nStream*sizeof(MLink));
+            if (strTree && nStream>1) {   /* stream share */
+               for (s=1,n=0;s<=hset->swidth[0];s++)
+                  if (tree->streams.set[s]) {
+                     strcpy(mname,lab_no->name);
+                     sprintf(index,"%d",s);   /* construct macro name for each stream */
+                     strcat(mname,"-");
+                     strcat(mname,index);
+                     if ((node->no->macro[n++]=FindMacroName(hset,type,GetLabId(mname,FALSE)))==NULL)
+                        if (useRefTree < 0)
+                           HError(-2661,"LoadTree: Macro %s not recognised",mname);
+                  }
+            }
+            else{
+               if ((node->no->macro[0]=FindMacroName(hset,type,lab_no))==NULL) 
+                  if (useRefTree < 0)
+                     HError(-2661,"LoadTree: Macro %s not recognised",lab_no->name);
+            }
             node->no->snum=--nt;
             node->no->next=tree->leaf;
-            if (tree->leaf) tree->leaf->prev=node;
+            if (tree->leaf) tree->leaf->prev=node->no;
             node->no->prev=NULL;
-            tree->leaf=node;
+            node->no->occ=GetNodeOcc(node->no->macro[0],type);
+            tree->leaf=node->no;
+            tree->nLeaves++;
          }
          else 
             node->no->snum=-num_no,node->no->macro=NULL;
@@ -3415,13 +4565,34 @@ Tree *LoadTree(char *name,Source *src)
          }
          else 
             node->no->snum=-num_no,node->no->macro=NULL;
+
          if (lab_yes) {
-            node->yes->macro=FindMacroName(hset,type,lab_yes);
+            node->yes->id = lab_yes;
+            node->yes->macro = (MLink *) New(&hmmHeap,nStream*sizeof(MLink));
+            if (strTree && nStream>1) {   /* stream share */
+               for (s=1,n=0;s<=hset->swidth[0];s++)
+                  if (tree->streams.set[s]) {
+                     strcpy(mname,lab_yes->name);
+                     sprintf(index,"%d",s);   /* construct macro name for each stream */
+                     strcat(mname,"-");
+                     strcat(mname,index);
+                     if ((node->yes->macro[n++]=FindMacroName(hset,type,GetLabId(mname,FALSE)))==NULL)
+                        if (useRefTree < 0)
+                           HError(-2661,"LoadTree: Macro %s not recognised",mname);
+                  }
+            }
+            else {
+               if ((node->yes->macro[0]=FindMacroName(hset,type,lab_yes))==NULL) 
+                  if (useRefTree < 0)
+                     HError(-2661,"LoadTree: Macro %s not recognised",lab_yes->name);
+            }
             node->yes->snum=--nt;
             node->yes->next=tree->leaf;
-            if (tree->leaf) tree->leaf->prev=node;
+            if (tree->leaf) tree->leaf->prev=node->yes;
             node->yes->prev=NULL;
-            tree->leaf=node;
+            node->yes->occ=GetNodeOcc(node->yes->macro[0],type);
+            tree->leaf=node->yes;
+            tree->nLeaves++;
          }
          else
             node->yes->snum=-num_yes,node->yes->macro=NULL;
@@ -3433,134 +4604,503 @@ Tree *LoadTree(char *name,Source *src)
 void LoadTreesCommand(void)
 {
    Source src;
-   char qname[256],buf[1024],info[256];
-   char fn[256];
+   char qname[MAXSTRLEN],buf[PAT_LEN],info[PAT_LEN];
+   char fn[MAXSTRLEN];
+   ILink ilist=NULL;
+   char type;
+   char *pattern;
   
    ChkedAlpha("LT trees files name",fn);        /* get name of trees file */
    if (trace & T_BID) {
-      printf("\nLT %s Loading questions/trees from file\n",fn);
+      printf("\nLT %s\n Loading questions/trees from file\n",fn);
       fflush(stdout);
    }
    if(InitSource(fn,&src,NoFilter)<SUCCESS)
       HError(2610,"LoadTreesCommand: Can't open file %s", fn);
 
-   while(ReadString(&src,info)) {
+   while(ReadStringWithLen(&src,info,PAT_LEN)) {
       if (strcmp(info,"QS")!=0)
          break;
       ReadString(&src,qname);
-      ReadLine(&src,buf);
     
+      if (useRefTree >= 0 && reduceMem == 0) {
+	 ilist=NULL;
+	 type='h';
+	 pattern = PItemList(&ilist,&type,hset,&src,NULL,0,0,(trace&T_ITM)?TRUE:FALSE);
+
+	 if (trace & T_QST) {
+	    printf("\nQS %s %s Define question\n",qname,pattern);
+	    fflush(stdout);
+	 }
+	 if (ilist==NULL && (trace & T_QST))
+	    HError(-2631,"QuestionCommand: No items for question %s\n",qname);
+	 else {
+	    LoadQuestion(qname,ilist,pattern);
+	    if (trace & T_QST) {
+	       printf(" QS: Refers to %d of %d models\n",
+		      NumItems(ilist),hset->numLogHMM);
+	       fflush(stdout);
+	    }
+	 }
+      }
+      else {
+         ReadLine(&src,buf);
       LoadQuestion(qname,NULL,buf);
    }
-   if (qHead==NULL)
+   }
+   /* comment out for no-question tree
+   if (qList==NULL)
       HError(2660,"LoadTreesCommand: Questions Expected");
+   */
 
    do {
       LoadTree(info,&src);
    }
-   while (ReadString(&src,info));
+   while (ReadStringWithLen(&src,info,PAT_LEN));
    CloseSource(&src);
 }
 
-/* ----------------- TR - Set Trace Level Command --------------- */
-
-/* SetTraceCommand: set the trace level */
-void SetTraceCommand(void)
+/* ----------------- CM - Convert HMMSets to PDF --------------- */
+void ConvertModelsCommand(void)
 {
-   int m;
+   Boolean out[SMAX], first;
+   int i, j, k, s, v, vSize, sSize, idx, nMix;
+   float weight, mean, vari;
+   Tree *tree;
+   FILE *file = NULL;
+   char dn[MAXSTRLEN], fn[MAXSTRLEN], head[MAXSTRLEN], ext[MAXSTRLEN];
+   Node *leaf, **array;
+   StreamInfo *sti;
+   Boolean isPipe;
 
-   m = ChkedInt("Trace level",0,31);
+   ChkedAlpha("CM output directory name", dn);
    if (trace & T_BID) {
-      printf("\nTR %d\n Adjusting trace level\n",m);
+      printf("\nCM %s\n Convert current HMMSet into the hts_engine format\n",dn);
       fflush(stdout);
    }
-   if (m & T_MEM)
-      PrintAllHeapStats();
-   trace = ((cmdTrace&0xfff0) | (m&0xf));
-}
 
-/* ----------------- RN - Renaming HMMSet Command --------------- */
+   /* check hset is valid for converting */
+   if (hset->hsKind==DISCRETEHS)
+      HError(9999,"ConvertModels: Only continuous HMMSet is supported");
+   if (treeList==NULL)
+      HError(2655,"ConvertModels: No trees loaded - use LT command");
 
-/* RenameHMMSetIdCommand: Change the HMM Set identifier */
-void RenameHMMSetIdCommand(void)
-{
-   char buf[MAXSTRLEN];
+   /* if parent/adapt transforms have been set, apply them */
+   if (hset->curXForm==NULL && hset->parentXForm!=NULL)
+      ApplyHMMSetXForm(hset, hset->parentXForm, TRUE);
+   if (hset->curXForm!=NULL)
+      ApplyHMMSetXForm(hset, hset->curXForm, TRUE);
 
-   ChkedAlpha("RN Rename the HMM Set identifier",buf);
-   hset->hmmSetId=CopyString(hset->hmem,buf);
+   /* start conversion */
+   strcpy(head,"pdf.");
 
+   for (s=1; s<=hset->swidth[0]; s++) {
+      nMix = MaxMixInSetS(hset, s);
+      if ((hset->msdflag[s] && nMix>2) || (!hset->msdflag[s] && nMix>1)) 
+         HError(9999,"ConvertModels: Only single mixture system is supported");
+      out[s]=FALSE;
 }
 
-/* -------------------- CL - Clone Command ---------------------- */
-
+   for (s=1; s<=hset->swidth[0]; s++) {
+      if (!out[s]) {
+         /* output vector size and number of pdfs for each tree */
+         first=TRUE; vSize=0; sSize=0;
+         for (i=2; i<=MaxStatesInSet(hset)+1; i++) {
+            for (tree=treeList; tree!=NULL; tree=tree->next) {
+               if (tree->state==i && tree->streams.set[s] ) {
+                  for (j=1; j<=hset->swidth[0]; j++)
+                     if (tree->streams.set[j]) {
+                        out[j]=TRUE;
+                        vSize += hset->swidth[j];
+                        sSize++;
+                     }
+                  if (first) {
+                     /* write header */
+                     sprintf(ext,"%d",s);
+                     MakeFN(head,dn,ext,fn);
+                     if ((file=FOpen(fn,NoOFilter,&isPipe))==NULL)
+                        HError(2611,"ConvertModels: Cannot create output file %s",fn);
+                     if(hset->msdflag[s])
+                        k=1;
+                     else
+                        k=0;
+                     WriteInt(file, &k, 1, TRUE);
+                     WriteInt(file, &sSize, 1, TRUE);
+                     WriteInt(file, &vSize, 1, TRUE); 
+                     first=FALSE;
+                  }
+                  WriteInt(file, &tree->nLeaves, 1, TRUE);
+               }
+            }
+         }
 
-void SwapLists(HMMSet *set,HMMSet *list)
-{
-   MLink q;
-   int h;
+         /* output pdf (mixture weight, mean vector and covariance matrix) */
+         for (i=2; i<=MaxStatesInSet(hset)+1; i++) {
+            for (tree=treeList; tree!=NULL; tree=tree->next) {
+               if (tree->state==i && tree->streams.set[s] ) {
+                  /* store leaf node to array */
+                  array = (Node **) New(&tmpHeap, tree->nLeaves*sizeof(Node *));
+                  array--;
+                  
+                  for (leaf=tree->leaf; leaf!=NULL; leaf=leaf->next) {
+                     idx = atoi(strrchr(leaf->id->name,'_')+1);
+                     array[idx] = leaf;
+                  }
+                  
+                  /* output array */
+                  for (j=1; j<=tree->nLeaves; j++) {
+                     for (k=0; k<tree->nActiveStr; k++) {
+                        if (IsFullSet(tree->streams))
+                           sti = ((StateInfo *)array[j]->macro[0]->structure)->pdf[k+1].info; /* state tying */
+                        else
+                           sti = (StreamInfo *)array[j]->macro[k]->structure;                 /* stream tying */
+                        vSize = VectorSize(sti->spdf.cpdf[1].mpdf->mean);
+                        for (v=1; v<=VectorSize(sti->spdf.cpdf[1].mpdf->mean); v++) {
+                           switch (sti->spdf.cpdf[1].mpdf->ckind) {
+                           case DIAGC:
+                              vari = sti->spdf.cpdf[1].mpdf->cov.var[v];
+                              break;
+                           case INVDIAGC:
+                              vari = 1.0/sti->spdf.cpdf[1].mpdf->cov.var[v];
+                              break;
+                           case FULLC:
+                              vari = 1.0/sti->spdf.cpdf[1].mpdf->cov.inv[v][v];  /* only diagonal elements are used */
+                              break;
+                           default:
+                              HError(999,"ConvertModels: not supported CovKind");
+                           }
+                           mean = sti->spdf.cpdf[1].mpdf->mean[v];
+                           /* output mean & variance value */
+                           WriteFloat(file, &mean, 1, TRUE);
+                           WriteFloat(file, &vari, 1, TRUE);
+                        }
+                        /* for multi space probability distribution */
+                        if (sti->nMix>1) {
+                           if (vSize!=hset->swidth[sti->stream])
+                              HError(9999,"ConvertModels: Vector size of the first mixture is not equal to stream width (%d, %d)", vSize, hset->swidth[sti->stream]);
+                           /* output space weight */
+                           weight = sti->spdf.cpdf[1].weight;
+                           WriteFloat(file, &weight, 1, TRUE);
+                           weight = 1-weight;
+                           WriteFloat(file, &weight, 1, TRUE);
+                        }
+                     }
+                  }
+                  array++;
+                  Dispose(&tmpHeap, array);
+               }
+            }
+         }
+         if (!first)
+            FClose(file,isPipe);
+      }
+   }
 
-   /* First delete old HMM names */
-   for (h=0; h<MACHASHSIZE; h++)
-      for (q=set->mtab[h]; q!=NULL; q=q->next)
-         if (q->type=='l' || q->type=='h')
-            DeleteMacro(set,q);
-   /* Then add new ones */
-   for (h=0; h<MACHASHSIZE; h++)
-      for (q=list->mtab[h]; q!=NULL; q=q->next) 
-         if (q->type=='l' || q->type=='h')
-            NewMacro(set,fidx,q->type,q->id,q->structure);
+   saveHMMSet = FALSE;
 }
 
-/* CloneCommand: clone the current HMM set to make the target
-   set.  The 'basename' of every target hmm must be in the
-   current HMMlist. */
-void CloneCommand(void)
+/* ----------------- CT - Convert Trees for synthesizer module --------------- */
+
+void ConvertTreesCommand(void)
 {
-   char buf[255];
-   HMMSet *tmpSet;
-   HLink oldHMM,newHMM;
-   MLink p,q;
-   int h;
+   Boolean out[SMAX], first;
+   int i, j, s;
+   Tree *tree;
+   FILE *file = NULL;
+   char dn[MAXSTRLEN], fn[MAXSTRLEN], head[MAXSTRLEN], ext[MAXSTRLEN];
+   Boolean isPipe;
    
-   ChkedAlpha("CL hmmlist file name",buf);
+   ChkedAlpha("CT output directory ", dn);
    if (trace & T_BID) {
-      printf("\nCL %s\n Cloning current hmms to produce new set\n",buf);
+      printf("\nCT %s\n Convert current questions/trees into the hts_engine format\n",dn);
       fflush(stdout);
    }
-   tmpSet=(HMMSet*) New(&hmmHeap,sizeof(HMMSet));
-   CreateHMMSet(tmpSet,&hmmHeap,TRUE);
-   if(MakeHMMSet(tmpSet,buf)<SUCCESS)
-      HError(2628,"CloneCommand: MakeHMMSet failed");
    
-   for (h=0; h<MACHASHSIZE; h++)
-      for (q=tmpSet->mtab[h]; q!=NULL; q=q->next) 
-         if (q->type=='l') {
-            if ((p=FindMacroName(hset,'l',q->id))==NULL)
-               oldHMM=FindBaseModel(hset,q->id,baseMono);
-            else
-               oldHMM=(HLink) p->structure;
-            newHMM=(HLink) q->structure;
-            CloneHMM(oldHMM,newHMM,TRUE);
-            newHMM->nUse=1;
-         }
-   SwapLists(hset,tmpSet);
-}
+   if (treeList==NULL)
+      HError(2655,"ConvertTrees: No trees loaded - use LT command");
 
-/* -------------------- DP - Duplicate Command ---------------------- */
+   strcpy(head,"trees.");
+   for (s=1; s<=hset->swidth[0]; s++)
+      out[s]=FALSE;
 
-SVector DupSVector(SVector v)
-{
-   SVector w;
+   for (s=1; s<=hset->swidth[0]; s++) {
+      if (!out[s]) {      
+         first = TRUE;
+         for (i=2; i<=MaxStatesInSet(hset)+1; i++) {
+            for (tree=treeList; tree!=NULL; tree=tree->next) {
+               if (tree->state==i && tree->streams.set[s]) {
+                  if (first) {
+                     sprintf(ext,"%d",s);
+                     MakeFN(head,dn,ext,fn);
+                     if ((file=FOpen(fn,NoOFilter,&isPipe))==NULL)
+                        HError(2611,"ConvertTrees: Cannot open file %s",fn);
+                     PrintQuestions(file);
+                     first = FALSE;
+                  }
+                  fprintf(file,"%s[%d]\n",
+                          ReWriteString(tree->baseId->name,NULL,ESCAPE_CHAR),
+                          tree->state);
 
-   if (v==NULL) return(NULL);
-   if (GetUse(v)>0) {   /* vector is shared */
-      if ((w=(SVector) GetHook(v))==NULL)
-         HError(2692,"DupSVector: could not find replacement vector macro");
-      IncUse(w);
-   } else {                     /* vector not shared so Dup it */
-      w = CloneSVector(&hmmHeap,v,FALSE);
+                  PrintTree(tree, file);
+                  
+                  for (j=1; j<=hset->swidth[0]; j++)
+                     if (tree->streams.set[j])
+                        out[j]=TRUE;
+               }
+            }
+         }
+         if (!first)
+            FClose(file,isPipe);
    }
-   return(w);
+   }
+
+   saveHMMSet = FALSE;
+}
+
+/* --------- SM - Output KLD-based state mapping table ---------- */
+
+static StreamInfo **DumpStream[SMAX];   /* StreamInfo list per stream index */
+static int DStreamNum[SMAX];    /* number of StreamInfo per stream index */
+static int *DStateIndexList[SMAX];      /* index of StreamInfo per stream index */
+
+#define MAX_KLD_SCORE 1.0E10;
+
+/* DumpAllStreams: dump all streams */
+void DumpAllStreams(HMMSet * hset_L1)
+{
+   HMMScanState hss_L1;
+   int s;
+
+   /* count the total number of stream for each state */
+   memset(DStreamNum, 0, sizeof(int) * SMAX);
+   NewHMMScan(hset_L1, &hss_L1);
+   do {
+      while (GoNextState(&hss_L1, TRUE)) {
+         while (GoNextStream(&hss_L1, TRUE)) {
+            DStreamNum[hss_L1.s]++;
+         }
+      }
+   } while (GoNextHMM(&hss_L1));
+   EndHMMScan(&hss_L1);
+
+   /* alloc memory for dumped streams */
+   for (s = 1; s <= hset_L1->swidth[0]; s++)
+      DumpStream[s] = (StreamInfo **) New(&tmpHeap, sizeof(StreamInfo *) * (DStreamNum[s] + 1));
+   for (s = 1; s <= hset_L1->swidth[0]; s++)
+      DStateIndexList[s] = (int *) New(&tmpHeap, sizeof(int) * (DStreamNum[s] + 1));
+
+   /* dump all stream */
+   memset(DStreamNum, 0, sizeof(int) * SMAX);
+   NewHMMScan(hset_L1, &hss_L1);
+   do {
+      while (GoNextState(&hss_L1, TRUE)) {
+         while (GoNextStream(&hss_L1, TRUE)) {
+            DStreamNum[hss_L1.s]++;
+            DumpStream[hss_L1.s][DStreamNum[hss_L1.s]] = hss_L1.sti;
+            DStateIndexList[hss_L1.s][DStreamNum[hss_L1.s]] = hss_L1.i;
+         }
+      }
+   } while (GoNextHMM(&hss_L1));
+   EndHMMScan(&hss_L1);
+}
+
+/* PerformStateMapping: output state mapping table */
+void PerformStateMapping(HMMSet * hset_L1, HMMSet * hset_L2, char *out_table)
+{
+   FILE *fp;
+   int i = 0, s = 1, j;
+   float min, tmp;
+   Boolean isPipe;
+
+   HMMScanState hss_L2;
+   StreamInfo *sti = NULL;
+   MLink ml_L2, ml_L1;
+
+   /* Dump all streams for L1 model */
+   DumpAllStreams(hset_L1);
+
+   if ((fp = FOpen(out_table, NoOFilter, &isPipe)) == NULL)
+      HError(6601, "PerformStateMapping: Can't open file %s", out_table);
+
+   /* Map each mixture of L2 model to one mixture of L1 model */
+   NewHMMScan(hset_L2, &hss_L2);
+   do {
+      while (GoNextState(&hss_L2, TRUE)) {
+         while (GoNextStream(&hss_L2, TRUE)) {
+            /* KLD mapping */
+            sti = NULL;
+            min = MAX_KLD_SCORE;
+            for (j = 1; j <= DStreamNum[hss_L2.s]; j++) {
+               if (hss_L2.sti->nMix == DumpStream[hss_L2.s][j]->nMix) {
+                  tmp = CalStrKLDist(hss_L2.sti, DumpStream[hss_L2.s][j]);
+                  if (tmp < min) {
+                     min = tmp;
+                     sti = DumpStream[hss_L2.s][j];
+                  }
+               }
+            }
+
+            /* output */
+            ml_L2 = FindMacroStruct(hset_L2, 'p', hss_L2.sti);
+            ml_L1 = FindMacroStruct(hset_L1, 'p', sti);
+            if (ml_L2)
+               fprintf(fp, "%s ", ReWriteString(ml_L2->id->name, NULL, ESCAPE_CHAR));
+            else {
+               HError(-999, "PerformStateMapping: Can't find macro name of L2");
+               fprintf(fp, "%s_%d_%d ",
+                       ReWriteString(HMMPhysName(hss_L2.hset, hss_L2.hmm), NULL, ESCAPE_CHAR),
+                       hss_L2.i, hss_L2.s);
+            }
+            if (ml_L1)
+               fprintf(fp, "%s\n", ReWriteString(ml_L1->id->name, NULL, ESCAPE_CHAR));
+            else {
+               HError(-999, "PerformStateMapping: Can't find macro name of L1");
+               fprintf(fp, "%s",
+                       ReWriteString(HMMPhysNameFromStreamInfo(hset_L1, sti, &i, &s), NULL, ESCAPE_CHAR));
+               fprintf(fp, "_%d_%d\n", i, s);
+            }
+         }
+      }
+   } while (GoNextHMM(&hss_L2));
+   EndHMMScan(&hss_L2);
+
+   FClose(fp, isPipe);
+}
+
+/* StateMappingCommand: state mapping */
+void StateMappingCommand()
+{
+   HMMSet hset_L2;
+   char out_table[MAXFNAMELEN];
+   char in_mmf[MAXFNAMELEN];
+   char in_list[MAXFNAMELEN];
+
+   /* initialise */
+   ChkedAlpha("SM output mapping table", out_table);
+   ChkedAlpha("SM input mmf file", in_mmf);
+   ChkedAlpha("SM input list", in_list);
+
+   if (trace & T_BID) {
+      printf("\nSM %s %s %s\n Output state mapping table\n", out_table, in_mmf, in_list);
+      fflush(stdout);
+   }
+
+   CreateHMMSet(&hset_L2, &hmmHeap, TRUE);
+   AddMMF(&hset_L2, in_mmf);
+
+   /* load */
+   if (MakeHMMSet(&hset_L2, in_list) < SUCCESS)
+      HError(2321, "StateMappingCommand: MakeHMMSet failed");
+   if (LoadHMMSet(&hset_L2, hmmDir, hmmExt) < SUCCESS)
+      HError(2321, "StateMappingCommand: LoadHMMSet failed");
+   SetParmHMMSet(&hset_L2);
+   if (hset_L2.ckind == INVDIAGC)
+      ConvDiagC(&hset_L2, TRUE);
+
+   /* state mapping */
+   PerformStateMapping(hset, &hset_L2, out_table);
+
+   saveHMMSet = FALSE;
+}
+
+/* ----------------- TR - Set Trace Level Command --------------- */
+
+/* SetTraceCommand: set the trace level */
+void SetTraceCommand(void)
+{
+   int m;
+
+   m = ChkedInt("Trace level",0,31);
+   if (trace & T_BID) {
+      printf("\nTR %d\n Adjusting trace level\n",m);
+      fflush(stdout);
+   }
+   if (m & T_MEM)
+      PrintAllHeapStats();
+   trace = ((cmdTrace&0xfff0) | (m&0xf));
+}
+
+/* ----------------- RN - Renaming HMMSet Command --------------- */
+
+/* RenameHMMSetIdCommand: Change the HMM Set identifier */
+void RenameHMMSetIdCommand(void)
+{
+   char buf[MAXSTRLEN];
+
+   ChkedAlpha("RN Rename the HMM Set identifier",buf);
+   hset->hmmSetId=CopyString(hset->hmem,buf);
+
+}
+
+/* -------------------- CL - Clone Command ---------------------- */
+
+void SwapLists(HMMSet *set,HMMSet *list)
+{
+   MLink q;
+   int h;
+
+   /* First delete old HMM names */
+   for (h=0; h<MACHASHSIZE; h++)
+      for (q=set->mtab[h]; q!=NULL; q=q->next)
+         if (q->type=='l' || q->type=='h')
+            DeleteMacro(set,q);
+   /* Then add new ones */
+   for (h=0; h<MACHASHSIZE; h++)
+      for (q=list->mtab[h]; q!=NULL; q=q->next) 
+         if (q->type=='l' || q->type=='h')
+            NewMacro(set,fidx,q->type,q->id,q->structure);
+}
+
+/* CloneCommand: clone the current HMM set to make the target
+   set.  The 'basename' of every target hmm must be in the
+   current HMMlist. */
+void CloneCommand(void)
+{
+   char buf[MAXSTRLEN];
+   HMMSet *tmpSet;
+   HLink oldHMM,newHMM;
+   MLink p,q;
+   int h;
+   
+   ChkedAlpha("CL hmmlist file name",buf);
+   if (trace & T_BID) {
+      printf("\nCL %s\n Cloning current hmms to produce new set\n",buf);
+      fflush(stdout);
+   }
+   tmpSet=(HMMSet*) New(&hmmHeap,sizeof(HMMSet));
+   CreateHMMSet(tmpSet,&hmmHeap,TRUE);
+   if(MakeHMMSet(tmpSet,buf)<SUCCESS)
+      HError(2628,"CloneCommand: MakeHMMSet failed");
+   
+   for (h=0; h<MACHASHSIZE; h++)
+      for (q=tmpSet->mtab[h]; q!=NULL; q=q->next) 
+         if (q->type=='l') {
+            if ((p=FindMacroName(hset,'l',q->id))==NULL)
+               oldHMM=FindBaseModel(hset,q->id,baseMono);
+            else
+               oldHMM=(HLink) p->structure;
+            newHMM=(HLink) q->structure;
+            CloneHMM(oldHMM,newHMM,TRUE);
+            newHMM->nUse=1;
+         }
+   SwapLists(hset,tmpSet);
+}
+
+/* -------------------- DP - Duplicate Command ---------------------- */
+
+SVector DupSVector(SVector v)
+{
+   SVector w;
+
+   if (v==NULL) return(NULL);
+   if (GetUse(v)>0) {   /* vector is shared */
+      if ((w=(SVector) GetHook(v))==NULL)
+         HError(2692,"DupSVector: could not find replacement vector macro");
+      IncUse(w);
+   } else {                     /* vector not shared so Dup it */
+      w = CloneSVector(&hmmHeap,v,FALSE);
+   }
+   return(w);
 }
 
 SMatrix DupSMatrix(SMatrix m)
@@ -3624,15 +5164,26 @@ MixPDF *DupMixPDF(MixPDF *s, Boolean frc
 }
 
 /* DupStream: return a Dup of given stream */
-MixtureElem *DupStream(StreamElem *ste)
+StreamInfo *DupStream(StreamInfo *s, Boolean frc)
 {
    int m,M;
-   MixtureElem *sme,*tme,*t;
+   StreamInfo *t;
+   MixtureElem *sme,*tme;
+
+   if (s->nUse>0 && !frc) {     /* shared struct so just return ptr to it */
+      if ((t=(StreamInfo *) s->hook)==NULL)
+         HError(2692,"DupStream: could not find dup streamInfo macro");
+      ++t->nUse;
+      return t;
+   }
+   M = s->nMix;
+   t = (StreamInfo *) New(&hmmHeap,sizeof(StreamInfo));
+   t->nUse = 0; t->hook = NULL; 
+   t->nMix = M; t->stream = s->stream;
 
-   M = ste->nMix;
    tme = (MixtureElem*) New(&hmmHeap,sizeof(MixtureElem)*M);
-   t = tme-1;
-   sme = ste->spdf.cpdf + 1;
+   t->spdf.cpdf = tme-1;
+   sme = s->spdf.cpdf + 1;
    for (m=1; m<=M; m++,sme++,tme++) {
       tme->weight = sme->weight;
       if (tme->weight > MINMIX)
@@ -3644,14 +5195,14 @@ MixtureElem *DupStream(StreamElem *ste)
 }
 
 /* DupState: return a Dup of given State */
-StateInfo *DupState(StateInfo *si, Boolean frc)
+StateInfo *DupState(StateInfo *s, Boolean frc)
 {
    StateInfo *t;                /* the target */
    StreamElem *tste,*sste;
-   int s;
+   int st;
    
-   if (si->nUse>0 && !frc) {    /* shared struct so just return ptr to it */
-      if ((t=(StateInfo *) si->hook)==NULL)
+   if (s->nUse>0 && !frc) {    /* shared struct so just return ptr to it */
+      if ((t=(StateInfo *) s->hook)==NULL)
          HError(2692,"DupState: could not find dup stateInfo macro");
       ++t->nUse;
       return t;
@@ -3659,14 +5210,13 @@ StateInfo *DupState(StateInfo *si, Boole
    t = (StateInfo*) New(&hmmHeap,sizeof(StateInfo));
    t->nUse = 0; t->hook = NULL;
    tste = (StreamElem*) New(&hmmHeap,sizeof(StreamElem)*hset->swidth[0]);
-   t->pdf = tste-1; sste = si->pdf + 1;
-   for (s=1; s<=hset->swidth[0]; s++,tste++,sste++) {
-      tste->nMix = sste->nMix; 
-      tste->hook = NULL;
-      tste->spdf.cpdf = DupStream(sste);
+   t->pdf = tste-1; 
+   sste = s->pdf + 1;
+   for (st=1; st<=hset->swidth[0]; st++,tste++,sste++) {
+      tste->info = DupStream(sste->info,FALSE);
    }
-   t->dur = DupSVector(si->dur);
-   t->weights = DupSVector(si->weights);
+   t->dur = DupSVector(s->dur);
+   t->weights = DupSVector(s->weights);
    return t;
 }
 
@@ -3704,6 +5254,7 @@ void DupMacro(MLink ml,LabId labid)
    Matrix im,om;
    MixPDF *imp,*omp;
    StateInfo *isi,*osi;
+   StreamInfo *isti,*osti;
    Ptr ostct=NULL;
     
    switch(ml->type) {
@@ -3713,6 +5264,12 @@ void DupMacro(MLink ml,LabId labid)
       ostct=osi;
       isi->hook=osi;
       break;
+   case 'p':
+      isti=(StreamInfo *) ml->structure;
+      osti=DupStream(isti,TRUE);
+      ostct=osti;
+      isti->hook=osti;
+      break;
    case 'm':
       imp=(MixPDF *) ml->structure;
       omp=DupMixPDF(imp,TRUE);
@@ -3756,7 +5313,7 @@ void DupMacro(MLink ml,LabId labid)
    current HMMlist. */
 void DuplicateCommand(void)
 {
-   char buf[255],name[255],*p,id[255],what[255];
+   char buf[MAXSTRLEN],name[MAXSTRLEN],*p,id[MAXSTRLEN],what[MAXSTRLEN];
    MLink ml;
    HLink hmm,newHMM;
    Ptr str;
@@ -3801,6 +5358,14 @@ void DuplicateCommand(void)
                strcat(buf,id);
                DupMacro(ml,GetLabId(buf,TRUE));
             }
+      if (strchr(what,'p'))
+         for (h=0; h<MACHASHSIZE; h++)
+            for (ml=hset->mtab[h]; ml!=NULL; ml=ml->next) {
+               if (ml->type!='p') continue;
+               strcpy(buf,ml->id->name);
+               strcat(buf,id);
+               DupMacro(ml,GetLabId(buf,TRUE));
+            }
       if (strchr(what,'s'))
          for (h=0; h<MACHASHSIZE; h++)
             for (ml=hset->mtab[h]; ml!=NULL; ml=ml->next) {
@@ -3894,7 +5459,7 @@ void RecordTriphone(HLink left, HLink ri
    */
 void MakeTriCommand(void)
 {
-   char fn[255], *s;
+   char fn[MAXFNAMELEN], *s;
    HMMSet *tmpSet;
    HLink hmm,left,right;
    MLink q,match;
@@ -3970,7 +5535,7 @@ void EditTransMat(Boolean adding)
          printf("\nRT %d %d {}\n Removing transitions from transP\n",i,j);
       fflush(stdout);
    }
-   PItemList(&ilist,&type,hset,&source,trace&T_ITM);
+   PItemList(&ilist,&type,hset,&source,NULL,0,0,(trace&T_ITM)?TRUE:FALSE);
    if (ilist == NULL) {
       HError(-2631,"EditTransMat: No trans mats to edit!");
       return;
@@ -4005,7 +5570,7 @@ void EditTransMat(Boolean adding)
    ClearSeenFlags(hset,CLR_HMMS);
    FreeItems(&ilist);
    if (trace & T_BID) {
-      printf(" %cT: %d transP matrices adjusted\n",(adding?'A':'R'),nedit);
+      printf(" %cT: %d transP matrices adjusted\n",((adding)?'A':'R'),nedit);
       fflush(stdout);
    }
 }
@@ -4023,6 +5588,7 @@ void MixUpCommand(void)
    char type = 'p';             /* type of items must be p */
    int ch,j,m,trg,M,mDefunct,n2fix,totm=0,totM=0;
    StreamElem *ste;
+   StreamInfo *sti;
    HMMDef *hmm;
    char *hname;
    
@@ -4031,6 +5597,9 @@ void MixUpCommand(void)
    if (ch=='+') {
       trg = -ChkedInt("Mix increment",1,INT_MAX);
    }
+   else if (ch=='*') {
+      trg = ChkedInt("Mix multiply",1,INT_MAX);
+   }
    else {
       UnGetCh(ch,&source);
       trg = ChkedInt("Mix target",1,INT_MAX);
@@ -4035,16 +5604,20 @@ void MixUpCommand(void)
       UnGetCh(ch,&source);
       trg = ChkedInt("Mix target",1,INT_MAX);
    }
+
    if (trace & T_BID) {
-      if (trg>0)
-         printf("\nMU %d {}\n Mixup to %d components per stream\n",trg,trg);
-      else
+      if (trg<0)
          printf("\nMU +%d {}\n Mixup by %d components per stream\n",-trg,-trg);
+      else if (ch=='*')
+         printf("\nMU *%d {}\n Mixup by %d components per stream\n",trg,trg);
+      else
+         printf("\nMU %d {}\n Mixup to %d components per stream\n",trg,trg);
       fflush(stdout);
    }
+
    if (hset->hsKind==TIEDHS || hset->hsKind==DISCRETEHS)
       HError(2640,"MixUpCommand: MixUp only possible for continuous models");
-   PItemList(&ilist,&type,hset,&source,trace&T_ITM);
+   PItemList(&ilist,&type,hset,&source,NULL,0,0,(trace&T_ITM)?TRUE:FALSE);
    if (ilist == NULL) {
       HError(-2631,"MixUpCommand: No mixtures to increase!");
       return;
@@ -4052,25 +5625,27 @@ void MixUpCommand(void)
    SetGCStats();
    for (i=ilist; i!=NULL; i=i->next) {
       ste = (StreamElem *)i->item;
-      M = ste->nMix;
-      if (M>0) ste->nMix=-M;
+      sti = ste->info;
+      M = sti->nMix;
+      if (M>0) sti->nMix = -M;
    }
    for (i=ilist; i!=NULL; i=i->next) {
       hmm = i->owner; 
-      ste = (StreamElem *)i->item; M = ste->nMix;
+      ste = (StreamElem *)i->item;  sti = ste->info;  M = sti->nMix;
       if (M<0) {
-         M = ste->nMix = -M;
+         M = sti->nMix = -M;
          hname = HMMPhysName(hset,hmm);
          for (j=1; j<=M; j++)   /* reset the split counters */
-            ste->spdf.cpdf[j].mpdf->hook = (void *) 0;
-         mDefunct = CountDefunctMix(ste);
+            sti->spdf.cpdf[j].mpdf->hook = (void *) 0;
+         mDefunct = CountDefunctMix(sti);
          if (trg<0) m=M-trg;
+         else if (ch=='*') m=M*trg;
          else m=trg;
          if (m > M-mDefunct) {
             n2fix = m-M+mDefunct;
             if (n2fix>mDefunct) n2fix = mDefunct;
             if (n2fix>0) {
-               FixDefunctMix(hname,ste,n2fix);
+               FixDefunctMix(hname,sti,n2fix);
             }
          }
          else n2fix=0;
@@ -4082,10 +5657,10 @@ void MixUpCommand(void)
                printf("  %12s : mixup %d -> %d\n",hname,M,m);
          }
          if (m>maxMixes) maxMixes = m;
-         if (m>M) UpMix(hname,ste,M,m);
-         totm+=m;totM+=M;
-         for (j=1; j<=ste->nMix; j++) /* restore the hooks */
-            ste->spdf.cpdf[j].mpdf->hook = NULL;
+         if (m>M) UpMix(hname,sti,M,m);
+         totm+=sti->nMix; totM+=M;
+         for (j=1; j<=sti->nMix; j++) /* restore the hooks */
+            sti->spdf.cpdf[j].mpdf->hook = NULL;
       }
    }
    FreeItems(&ilist);
@@ -4103,12 +5678,12 @@ void TieCommand(void)
 {
    ILink ilist = NULL;          /* list of items to tie */
    char type = ' ';             /* type of items to tie */
-   char macName[255];           /* name of macro to use */
+   char macName[MAXSTRLEN];     /* name of macro to use */
    
    ChkedAlpha("TI macro name",macName);
    if (strlen(macName) > 20 )
       HError(-2639,"TieCommand: %s is rather long for a macro name!",macName);
-   PItemList(&ilist,&type,hset,&source,trace&T_ITM);
+   PItemList(&ilist,&type,hset,&source,NULL,0,0,(trace&T_ITM)?TRUE:FALSE);
    if (trace & (T_BID | T_MAC)) {
       printf("\nTI %s {}\n Tie items\n",macName);
       fflush(stdout);
@@ -4117,14 +5692,43 @@ void TieCommand(void)
    FreeItems(&ilist);
 }
 
-/* -------------------- TI - Tie Command ---------------------- */
+/* ----------------- DM - Delete Macro Command ---------------- */
+
+void DeleteMacroCommand(void)
+{
+   char type, macName[MAXSTRLEN];
+   LabId macId;
+   
+   type = GetCh(&source);
+   ChkedAlpha("DM macro name", macName);
+   macId = GetLabId(macName,FALSE);
+   
+   if (trace & (T_BID | T_MAC)) {
+      printf("\nDM {}\n Delete given macro from model-set\n");
+      fflush(stdout);
+   }
+
+   if (macId==NULL)
+      HError(9999,"DeleteMacroCommand: cannot find macro ~%c %s", type, macName);
+
+   DeleteMacro(hset, FindMacroName(hset,type,macId));
+   
+   if (trace & T_BID) {
+      printf(" DM: Macro ~%c %s was deleted\n", type, macName);
+      fflush(stdout);
+   }
+   
+   return;
+}
+
+/* ------------------ MM - Tie All Command -------------------- */
 
 /* MakeIntoMacrosCommand: tie all components in following itemlist */
 void MakeIntoMacrosCommand(void)
 {
    ILink ilist = NULL;          /* list of items to tie */
    char type = ' ';             /* type of items to tie */
-   char macName[255],buf[255];  /* name of macro to use */
+   char macName[MAXSTRLEN],buf[MAXSTRLEN]; /* name of macro to use */
    ItemRec itemp,*i;
    MixPDF *mp;
    StateInfo *si;
@@ -4139,7 +5743,7 @@ void MakeIntoMacrosCommand(void)
    }
    if (strlen(macName) > 20 )
       HError(-2639,"MakeIntoMacrosCommand: %s is rather long for a macro name!",macName);
-   PItemList(&ilist,&type,hset,&source,trace&T_ITM);
+   PItemList(&ilist,&type,hset,&source,NULL,0,0,(trace&T_ITM)?TRUE:FALSE);
    if (type=='p' || type=='h')
       HError(2640,"MakeIntoMacros: Cannot convert PDFs or HMMs into macro");
    for (i=ilist;i;i=i->next) {
@@ -4186,13 +5790,14 @@ void UntieCommand(void)
       printf("\nUT {}\n Untie previously tied structures\n");
       fflush(stdout);
    }
-   PItemList(&ilist,&type,hset,&source,trace&T_ITM);
+   PItemList(&ilist,&type,hset,&source,NULL,0,0,(trace&T_ITM)?TRUE:FALSE);
    if (ilist==NULL) {
       HError(-2631,"UntieCommand: No items to untie");
       return;
    }
    switch (type) {
    case 's': UntieState(ilist); break;
+   case 'p': UntiePDF(ilist);   break;
    case 'm': UntieMix(ilist);   break;
    case 't': UntieTrans(ilist); break;
    case 'u': UntieMean(ilist);  break;
@@ -4201,8 +5806,6 @@ void UntieCommand(void)
    case 'x': UntieXform(ilist); break;
    case 'h':
       HError(2640,"UntieCommand: Joined HMMs cannot be untied");
-   case 'p':
-      HError(2640,"UntieCommand: Joined PDF's cannot be untied");
    default:
       HError(2640,"UntieCommand: Cannot untie %c's",type);
    }
@@ -4240,7 +5843,7 @@ void ClusterCommand(Boolean nCluster)
 {
    ILink ilist = NULL;          /* list of items to tie */
    char type = ' ';             /* type of items to tie */
-   char macName[255];           /* name of macro to use */
+   char macName[MAXSTRLEN];     /* name of macro to use */
    int numItems,numClust=1;     /* num clusters required */
    float thresh = 1.0E15;
    static int totalItems = 0;   /* for overall statistics */
@@ -4250,7 +5853,7 @@ void ClusterCommand(Boolean nCluster)
       numClust = ChkedInt("No. clusters",1,INT_MAX);
    else
       thresh = ChkedFloat("Cluster threshold",0.0,FLOAT_MAX);
-   ChkedAlpha((char *) (nCluster ? "NC macro name" : "TC macro name"), macName);
+   ChkedAlpha((char *) ((nCluster) ? "NC macro name" : "TC macro name"), macName);
    if (trace & (T_BID | T_CLUSTERS)) {
       if (nCluster) 
          printf("\nNC %d %s {}\n Cluster items into N groups\n",
@@ -4263,7 +5866,7 @@ void ClusterCommand(Boolean nCluster)
    if (strlen(macName) > 20 )
       HError(-2639,"ClusterCommand: %s is rather long for a macro name",
              macName);
-   PItemList(&ilist,&type,hset,&source,trace&T_ITM);
+   PItemList(&ilist,&type,hset,&source,NULL,0,0,(trace&T_ITM)?TRUE:FALSE);
    if (ilist==NULL) {
       HError(-2631,"ClusterCommand: No items to cluster for %s\n",macName);
       return;
@@ -4284,7 +5887,7 @@ void ClusterCommand(Boolean nCluster)
 /* LoadStatsCommand: loads occupation counts for hmms */
 void LoadStatsCommand(void)
 {
-   char statfile[256];
+   char statfile[MAXFNAMELEN];
    
    ChkedAlpha("LS stats file name",statfile);
    if (trace & T_BID) {
@@ -4292,7 +5895,7 @@ void LoadStatsCommand(void)
       printf(" Loading state occupation stats\n");
       fflush(stdout);
    }
-   LoadStatsFile(statfile, hset, trace & T_BID);
+   LoadStatsFile(statfile, hset, (trace&T_BID)?TRUE:FALSE);
    occStatsLoaded = TRUE;
 }
 
@@ -4303,12 +5906,12 @@ void LoadStatsCommand(void)
    */
 void RemOutliersCommand(void)
 {
-   char statfile[256];
+   char statfile[MAXFNAMELEN];
    int ch;
    
    outlierThresh = ChkedFloat("Outlier Occupancy Threshold",0.0,FLOAT_MAX);
    if (trace & T_BID) {
-      printf("RO %.2f ''\n",outlierThresh);
+      printf("\nRO %.2f ''\n",outlierThresh);
       printf(" Setting outlier threshold for clustering\n");
       fflush(stdout);
    }
@@ -4328,7 +5931,7 @@ void RemOutliersCommand(void)
       if (occStatsLoaded)
          HError(-2655,"RemOutliersCommand: Stats already loaded");
       else
-         LoadStatsFile(statfile,hset,trace&T_BID);
+         LoadStatsFile(statfile,hset,(trace&T_BID)?TRUE:FALSE);
       occStatsLoaded = TRUE;
    }
 }
@@ -4344,7 +5947,7 @@ void CompactCommand(void)
    HLink hmm;
    int h;
    Boolean seenMean,seenVar;
-   char fn[255];
+   char fn[MAXFNAMELEN];
    
    ChkedAlpha("CO hmmlist file name",fn);  /* get name of new hmm list */
    if (trace & T_BID) {
@@ -4356,6 +5959,7 @@ void CompactCommand(void)
    seenMean=seenVar=FALSE;
    for (h=0; h<MACHASHSIZE; h++)
       for (q=hset->mtab[h]; q!=NULL; q=q->next)  {
+         if (q->type=='p') seenMean=seenVar=TRUE;
          if (q->type=='m') seenMean=seenVar=TRUE;
          if (q->type=='u') seenMean=TRUE;
          if (q->type=='v' || q->type=='i' || q->type=='c' || q->type=='x')
@@ -4370,7 +5974,7 @@ void CompactCommand(void)
          if (q->type=='h') {
             hmm=(HLink) q->structure;
             for (i=seen;i!=NULL;i=i->next)
-               if (EquivHMM(hmm,i->owner)) break;
+               if (hmm->transP==i->owner->transP && EquivHMM(hmm,i->owner)) break;
             if (i!=NULL) {
                hmm->hook=i->owner;
                i->owner->nUse++;
@@ -4426,7 +6030,7 @@ void SplitStreamCommand(Boolean userWidt
    HMMScanState hss;
    short swidth[SMAX];
    ParmKind pk;
-   Vector vf[SMAX],v;
+   Vector v;
    Boolean simple=TRUE,vfSet,hasE,hasN,hasD,hasA,has0;
 
    S = ChkedInt("No. streams",2,SMAX-1);
@@ -4446,7 +6050,7 @@ void SplitStreamCommand(Boolean userWidt
       fflush(stdout);
    }
    if (hset->hsKind==TIEDHS || hset->hsKind==DISCRETEHS)
-      HError(2640,"SplitStreamsCommand: Only implemented for continuous");
+      HError(2640,"SplitStreamCommand: Only implemented for continuous");
    if (hset->swidth[0] != 1)
       HError(2640,"SplitStreamCommand: Cannot split multiple streams");
    
@@ -4457,7 +6061,7 @@ void SplitStreamCommand(Boolean userWidt
       hasE= HasEnergy(pk); has0 = HasZeroc(pk);
       if (hasE && has0)
          HError(2641,"SplitStreamCommand: Source data cant have _0 and _E");
-      hasE |= has0;     /* dont care which it is any more */
+      hasE = (hasE||has0) ? TRUE:FALSE;     /* dont care which it is any more */
       if (!hasD && !hasE)
          HError(2641,"SplitStreamCommand: Source data must have _D or _E");
       if (S==2) {
@@ -4499,7 +6103,7 @@ void SplitStreamCommand(Boolean userWidt
          printf("\n");
          fflush(stdout);
       }
-      simple = !hasE || (swidth[S]<2) || (S==2) || (hasA && S==3) ;
+      simple = (!hasE || (swidth[S]<2) || (S==2) || (hasA && S==3)) ? TRUE:FALSE;
    }
    
    /* Get varFloor */
@@ -4527,7 +6131,7 @@ void SplitStreamCommand(Boolean userWidt
    /* Do Splitting */
    NewHMMScan(hset,&hss);
    while(GoNextState(&hss,FALSE)) {
-      SplitStreams(hset,hss.si,simple,nedit==0);
+      SplitStreams(hset,hss.si,simple,(nedit==0)?TRUE:FALSE);
       if (trace & (T_SIZ | T_DET)) {
          if (nedit==0) printf(" For model.state["),hmm=NULL;
          if (hmm!=hss.hmm)
@@ -4561,7 +6165,7 @@ void SplitStreamCommand(Boolean userWidt
          if (!simple && !(hasN && s==1))
             epos[s-(hasN?2:1)] = next++;
       }
-      SetVFloor(hset,vf,1.0);
+      SetVFloor(hset,vf,minVar);
    }
          
       
@@ -4578,12 +6182,11 @@ void SplitStreamCommand(Boolean userWidt
 /* SetStreamWidthCommand: change width of stream s to n */
 void SetStreamWidthCommand(void)
 {
-   int i, size, s, n, nedit=0;
+   int s, n, orign, nedit=0;
    char c=' ';
    HMMScanState hss;
    HLink hmm=NULL;
    MixPDF *mp;
-   Vector vf[SMAX];
 
    s = ChkedInt("Stream",1,SMAX-1);
    n = ChkedInt("Stream width",1,INT_MAX);
@@ -4623,19 +6226,16 @@ void SetStreamWidthCommand(void)
       printf("]\n"),fflush(stdout);
    EndHMMScan(&hss);
    /* Now varFloor */
-   SetVFloor(hset,vf,0.0);
+   SetVFloor(hset,vf,minVar);
    if (FindMacroStruct(hset,'v',vf[s])!=NULL) {
       if (trace & T_BID)
          printf(" Resizing varFloor\n");
       ResizeSVector(hset,vf[s],n,'v',0.0);
    }
    badGC = TRUE;
+   orign = hset->swidth[s];
    hset->swidth[s]=n;
-
-   size=0;
-   for (i = 1; i <= hset->swidth[0]; i++)
-      size += hset->swidth[i];
-   hset->vecSize = size;
+   hset->vecSize += n - orign;
    
    if (trace & (T_BID | T_SIZ)) {
       printf(" SW: Stream width changed for %d mixes\n",nedit);
@@ -4648,7 +6248,7 @@ void SetStreamWidthCommand(void)
 /* SetSampKindCommand: change skind of all loaded models */
 void SetSampKindCommand(void)
 {
-   char s[256];
+   char s[MAXSTRLEN];
    ParmKind pk;
    
    ChkedAlpha("SK sample kind",s);
@@ -4725,7 +6325,7 @@ void CreateTMRecs(void)
 }
 
 /* CalcTMWeights: Fix the weights of me using the old stream info */
-Vector CalcTMWeights(int s, StreamElem *ste, double tFloor)
+Vector CalcTMWeights(int s, StreamInfo *sti, double tFloor)
 {
    DVector v;
    Vector tpdf;
@@ -4739,11 +6339,11 @@ Vector CalcTMWeights(int s, StreamElem *
    tpdf = CreateVector(hset->hmem,M);
 
    maxW = LZERO;
-   if (M==ste->nMix) {
+   if (M==sti->nMix) {
       for (m=1;m<=M;m++) {  /* copy weights */
-         for (sm=1,sme=ste->spdf.cpdf+1;sm<=ste->nMix;sm++,sme++)
+         for (sm=1,sme=sti->spdf.cpdf+1;sm<=sti->nMix;sm++,sme++)
             if (sme->mpdf==hset->tmRecs[s].mixes[m]) break;
-         if (sm>ste->nMix)
+         if (sm>sti->nMix)
             HError(2693,"CalcTMWeights: Cannot find matching mixture");
          if (sme->weight>MINMIX)
             w = v[m] = log(sme->weight);
@@ -4755,8 +6355,8 @@ Vector CalcTMWeights(int s, StreamElem *
    else {
       for (m=1;m<=M;m++) {  /* set weights to SOutP(owner) */
          w=LZERO;
-         for (sm=1,sme=ste->spdf.cpdf+1;sm<=ste->nMix;sm++,sme++) {
-            if (sme->weight>MINMIX) {
+         for (sm=1,sme=sti->spdf.cpdf+1;sm<=sti->nMix;sm++,sme++) {
+            if (sme->weight>MINMIX || hset->msdflag[s]) {
                p = MOutP(hset->tmRecs[s].mixes[m]->mean,sme->mpdf);
                w = LAdd(w,log(sme->weight)+p);
             }
@@ -4806,7 +6406,7 @@ void ConvertCont2Tied(void)
 {
    Vector tpdf;
    MLink q;
-   StreamElem *ste;
+   StreamInfo *sti;
    HLink hmm;
    LabId labid;
    char buf[80];
@@ -4823,16 +6423,16 @@ void ConvertCont2Tied(void)
             hmm=(HLink) q->structure;
             for (j=2;j<hmm->numStates;j++) {
                for (s=1;s<=hset->swidth[0];s++) {
-                  ste=hmm->svec[j].info->pdf+s;
-                  if (IsSeen(ste->nMix)) continue;
+                  sti=hmm->svec[j].info->pdf[s].info;
+                  if (IsSeen(sti->nUse)) continue;
                   if (trace & T_DET)
                      printf("   For  %-12s[%d].stream[%d]:  ",
                             HMMPhysName(hset,hmm),j,s);
                   M = hset->tmRecs[s].nMix;
-                  tpdf=CalcTMWeights(s,ste,joinFloor);
-                  ste->spdf.tpdf=tpdf;
-                  ste->nMix=M;
-                  Touch(&ste->nMix);
+                  tpdf=CalcTMWeights(s,sti,joinFloor);
+                  sti->spdf.tpdf=tpdf;
+                  sti->nMix=M;
+                  Touch(&sti->nUse);
                }
             }
          }
@@ -4842,8 +6442,8 @@ void ConvertCont2Tied(void)
             hmm=(HLink) q->structure;
             for (j=2;j<hmm->numStates;j++)
                for (s=1;s<=hset->swidth[0];s++) {
-                  ste=hmm->svec[j].info->pdf+s;
-                  Untouch(&ste->nMix);
+                  sti=hmm->svec[j].info->pdf[s].info;
+                  Untouch(&sti->nUse);
                }
          }
                                   
@@ -4868,7 +6468,7 @@ void ConvertCont2Tied(void)
 /* SetHSetKindCommand: change the hset kind of the current HMM set  */
 void SetHSetKindCommand(void)
 {
-   char s[256];
+   char s[MAXSTRLEN];
    HSetKind hk;
    
    ChkedAlpha("HK HMMSet kind",s);
@@ -4973,7 +6573,7 @@ void RemMeansCommand(void)
    MLink ml;
    Vector sv[SMAX];
    int s,nedit=0;
-   char buf[256];
+   char buf[MAXSTRLEN];
 
    ChkedAlpha("RM hmm file name",buf);
    if (trace & T_BID) {
@@ -4998,7 +6598,7 @@ void RemMeansCommand(void)
    for (s=1; s<=hset->swidth[0]; s++) {
       if (hset->swidth[s] != tmpSet.swidth[s])
          HError(2630,"RemMeansCommand: stream %d different size",s);
-      sv[s] = hmm->svec[2].info->pdf[s].spdf.cpdf[1].mpdf->mean;
+      sv[s] = hmm->svec[2].info->pdf[s].info->spdf.cpdf[1].mpdf->mean;
    }
    NewHMMScan(hset,&hss);
    while(GoNextMix(&hss,FALSE)) {
@@ -5014,22 +6614,34 @@ void RemMeansCommand(void)
 
 /* --------------- QS - Load Question Set Commands ------------ */
 
-/* LoadQuestionCommand: question is an item list of model names */
+/* QuestionCommand: question is an item list of model names */
 void QuestionCommand(void)
 {
-   ILink ilist=NULL;
-   char type='h';
-   char qName[255];
-   char *pattern;
+   char qName[MAXSTRLEN];
 
    ChkedAlpha("QS question name",qName);
+   
    /* get copy of original item list whilst parsing it */
-   pattern=PItemList(&ilist,&type,hset,&source,trace&T_ITM);
+   if (reduceMem!=0) {
+      char pattern[PAT_LEN]; 
+      ReadLine(&source, pattern);
+      if (trace & T_QST) {
+         printf("\nQS %s %s Define question\n",qName,pattern);
+         fflush(stdout);
+      }
+      LoadQuestion(qName,NULL,pattern);
+      setQMTable=FALSE;
+   }
+   else {
+      ILink ilist=NULL;
+      char type='h';
+      char *pattern = PItemList(&ilist,&type,hset,&source,NULL,0,0,(trace&T_ITM)?TRUE:FALSE);
+
    if (trace & T_QST) {
       printf("\nQS %s %s Define question\n",qName,pattern);
       fflush(stdout);
    }
-   if (ilist==NULL)
+      if (ilist==NULL && (trace & T_QST))
       HError(-2631,"QuestionCommand: No items for question %s\n",qName);
    else {
       LoadQuestion(qName,ilist,pattern);
@@ -5039,7 +6651,7 @@ void QuestionCommand(void)
          fflush(stdout);
       }
    }
-   
+   }
 }
 
 /* --------------- TB - Tree Based Clustering Command ------------ */
@@ -5048,40 +6660,59 @@ void TreeBuildCommand(void)
 {
    ILink ilist = NULL;          /* list of items to tie */
    char type = ' ';             /* type of items to tie */
-   char macName[255];           /* name of macro to use */
+   char macName[MAXSTRLEN];     /* name of macro to use */
+   char *pattern, *p;           /* pattern of items to use */
    float thresh = 0.0;
+   int s;
+
+   ClearSet(streams);
    
    thresh = ChkedFloat("Tree build threshold",0.0,FLOAT_MAX);
    ChkedAlpha("TB macro name",macName);
-   if (trace & (T_BID | T_MAC | T_CLUSTERS | T_TREE)) {
-      printf("\nTB %.2f %s {}\n Tree based clustering\n",thresh,macName);
-      fflush(stdout);
-   }
    
-   if (treeList!=NULL && thisCommand!=lastCommand)
+   if (useRefTree<0 && treeList!=NULL && thisCommand!=lastCommand)
       HError(2640,"TreeBuildCommand: TB commands must be in sequence");
    if (!occStatsLoaded)
       HError(2655,"TreeBuildCommand: No stats loaded - use LS command");
    if (strlen(macName) > 20 )
       HError(-2639,"TreeBuildCommand: %s is rather long for a macro name",
              macName);
-   PItemList(&ilist,&type,hset,&source,trace&T_ITM);
+
+   pattern = PItemList(&ilist,&type,hset,&source,&streams,0,0,(trace&T_ITM)?TRUE:FALSE);
+
+   if (trace & (T_BID | T_MAC | T_CLUSTERS | T_TREE)) {
+      printf("\nTB %.2f %s %s\n Tree based clustering ",thresh,macName,pattern);
+      fflush(stdout);
+   }
+   
+   /* extract specified model pattern */ 
+   if (type != 'h') {
+      if ((p = strchr(pattern, '.')) == NULL)
+         HError(9999, "TreeBuild: Specified pattern does not include any dot");
+      *p = '}'; *(p+1) = '\0';
+   }
+      
    if (ilist==NULL) {
       HError(-2631,"TreeBuildCommand: No items to cluster for %s\n",macName);
       return;
    }
-   if (type!='h' && type!='s')
+
+   if (type!='h' && type!='s' && type!='p')
       HError(2640,"TreeBuildCommand: Type %c not implemented",type);
 
+   if (type=='h' || type=='s')
+      for (s=1;s<=hset->swidth[0];s++)
+         streams.set[s] = TRUE;
+   
    /* Do Tree based clustering */
-   BuildTree(ilist,thresh,macName);
+   BuildTree(ilist, (double)thresh, macName, pattern);
 }
 
 /* ------------- AU - Add Unseen Triphones Command --------- */
 
 void AddUnseenCommand(void)
 {
-   char newListFn[255];         /* name of hmmList containing unseen models */
+   char newListFn[MAXFNAMELEN];     /* name of hmmList containing unseen models */
    HMMSet newSet;
    int oldL = hset->numLogHMM;
    int oldP = hset->numPhyHMM;
@@ -5107,36 +6738,225 @@ void AddUnseenCommand(void)
    }
 }
 
-/* ------------- UF - Use File Command --------- */
+/* ------------ IT - Impose Tree Command ---------- */
 
-void UseCommand(void)
+void ImposeTreeCommand (void)
 {
-   MILink mil;
-   char newMMF[256];   /* Name of MMF file to store macros in */
+   char buf[MAXSTRLEN],fn[MAXFNAMELEN],macName[MAXSTRLEN];
+   int h,i,j,snum,totalItems=0,totalClust=0;
+   float occ;
+   Boolean shrinkTree=FALSE;
+   MLink q;
+   HLink hmm;
+   LabId tid=NULL;
+   Node *node;
+   Boolean isYes=FALSE;
+   CLink cl=NULL;
+   Tree *tree;
+   ILink ilist=NULL;
+   
+   void ShrinkTree(Tree *tree, Node *node, int *snum, const float threshold);
+   
+   ChkedAlpha("IT trees file name",fn);  /* get name of trees file */
 
-   ChkedAlpha("UF file name",newMMF);
    if (trace & T_BID) {
-      printf("\nUF %s\n Using MMF file to store new macros",newMMF);
+      printf("\nIT\n Clustering while imposing previously constructed tree-based tying structure\n");
       fflush(stdout);
    }
-   mil=AddMMF(hset,newMMF);
-   mil->isLoaded=TRUE; /* Just to make sure we actually save to file */
-   fidx=mil->fidx;
-}
 
-/* -------------------------- FA Command ------------------------- */
-void FloorAverageCommand(void)
-{
-   HMMScanState hss;
-   StateInfo *si   ;
-   StreamElem *ste;
-   SVector var , mean;
-   DVector *varAcc;
-   double occAcc;
-   float weight;
-   float occ; 
-   int l=0,k,i,s,S;
-   float varScale;
+   if (hset->hsKind!=PLAINHS)
+      HError(9999,"ImposeTreeCommand: only PLAINHS is supported");
+   
+   if (!occStatsLoaded)
+      HError(2672, "ImposeTreeCommand: Use LoadStats (LS <whatever-dir/stats>) before doing this.");
+   
+   if (treeList == NULL)
+      HError(2662,"ImposeTreeCommand: there are no existing trees");
+   
+   for (tree=treeList; tree!=NULL; tree=tree->next) {
+      /* set active stream flag */
+      ClearSet(streams);
+      for (i=1; i<=tree->streams.nMembers; i++) 
+         streams.set[i] = tree->streams.set[i];
+      
+      /* assign HMM states to leaf nodes */
+      for (h=0; h<MACHASHSIZE; h++) {
+         for (q=hset->mtab[h]; q!=NULL; q=q->next) {
+            if (q->type=='h') {
+               hmm=(HLink) q->structure;
+               
+               /* find tree to use */
+               strcpy(buf,q->id->name);
+               if (!usePattern) {
+                  if (strchr(buf,'*')!=NULL || strchr(buf,'?')!=NULL)
+                     HError(9999,"ImposeTreeCommand: baseId %s includes pattern character", buf);
+                  TriStrip(buf); 
+                  MapTreeName(buf);
+                  tid = GetLabId(buf,FALSE);
+               }
+               
+               if (((usePattern && IPatMatch(buf, tree->patList)) 
+                 || singleTree 
+                 || (!singleTree && !usePattern && tree->baseId == tid))) {  /* check this model matches to this tree */    
+        
+                  /* traverse tree */
+                  node = tree->root;  
+                  occ=hmm->svec[2].info->stateCounter; node->occ+=occ;  /* acc occ to shrink tree, use occ of HMM instead of state */
+                  while (node->yes != NULL) {
+                     isYes = QMatch(q->id->name,node->quest);
+                     node = (isYes) ? node->yes : node->no;
+                     node->occ += occ;
+                  }
+   
+                  /* make clist */
+                  j = tree->state;
+                  if (j<0) {
+                     AddItem(hmm, hmm, &ilist);
+                     for (j=2; j<hmm->numStates; j++)
+                       InitTreeAccs(hmm->svec+j);
+                  }
+                  else {
+                     AddItem(hmm, hmm->svec+j, &ilist);
+                     InitTreeAccs(hmm->svec+j);
+                  }           
+                  cl=(CLink) New(&tmpHeap,sizeof(CRec));
+                  hmm->hook = cl;
+                  cl->item = ilist;  cl->ans = FALSE;
+                  cl->idx = -1;
+                  cl->next = node->clist;
+                  node->clist = cl;
+                  totalItems++;
+               }
+            }
+         }
+      }
+      
+      /* get macroname */
+      for (node=tree->leaf; node->next!=NULL; node=node->next);
+      strcpy(macName,node->id->name);
+      macName[strlen(macName)-1] = '\0';
+      
+      /* shrink tree to avoid empty leaf node */
+      for (node=tree->leaf,numTreeClust=0; node!=NULL; node=node->next) {
+         if (node->clist==NULL) {
+            tree->leaf=NULL; numTreeClust=0; snum=0;
+            ShrinkTree(tree,tree->root,&snum,0.1);
+            if (trace & T_BID) {
+               if (tree->state>0)
+                  printf(" Tree %s.state[%d]",ReWriteString(tree->baseId->name,NULL,ESCAPE_CHAR),tree->state);
+               else
+                  printf(" Tree %s",tree->baseId->name);
+               if (tree->nActiveStr==hset->swidth[0])
+                  printf("\n");
+               else {
+                  printf(".stream[");         /* output active stream of current tree */
+                  for (i=1,j=1; j<=hset->swidth[0]; j++)
+                     if (tree->streams.set[j])
+                        printf("%d%s",j,(i++<tree->nActiveStr)?",":"]\n");
+               }
+               printf("  %d leaf nodes were pruned into %d nodes\n\n", tree->nLeaves, numTreeClust);
+               fflush(stdout);
+            }
+            tree->nLeaves=numTreeClust; tree->size=snum;
+            
+            /* reset node->id && node->macro */
+            for (node=tree->leaf; node!=NULL; node=node->next) {
+               node->id = NULL;  node->macro = NULL;
+            }
+            /* turn on output tree flag */
+            shrinkTree = TRUE;
+            break;
+         }
+         else
+            numTreeClust++;
+      }
+   
+      /* tie leaf nodes */
+      no.sum=CreateDVector(&tmpHeap,hset->vecSize);
+      no.sqr=CreateDVector(&tmpHeap,hset->vecSize);
+      MakeAccSum(&no,ilist);
+      
+      TieLeafNodes(tree,macName);
+      
+      FreeDVector(&tmpHeap,no.sum);
+      ilist = NULL;
+      totalClust+=numTreeClust;
+   }
+   if (trace & T_BID) {
+      printf("\n IT: Stats %d->%d [%.1f%%] total\n", totalItems, totalClust,(float)totalClust*100.0/(float)totalItems);
+      fflush(stdout);
+   }
+   
+   
+   /* if any trees are shrinked, output trees to fn */ 
+   if (shrinkTree) {
+      int s;
+      FILE *file;
+      Boolean isPipe;
+      
+      if (trace & T_BID) {
+         printf("\nIT %s\n Writing new trees to file\n",fn);
+         fflush(stdout);
+      }
+      if ((file=FOpen(fn,NoOFilter,&isPipe))==NULL)
+         HError(2611,"ShowTreesCommand: Cannot open trees file %s",fn);
+      
+      PrintQuestions(file);
+    
+      for (tree=treeList;tree!=NULL;tree=tree->next) {
+         if (tree->state>0)                       
+            fprintf(file,"%s[%d]",
+                    ReWriteString(tree->baseId->name,NULL,ESCAPE_CHAR),
+                    tree->state);
+         else
+            fprintf(file,"%s",tree->baseId->name);
+         if (tree->nActiveStr == hset->swidth[0])
+            fprintf(file,"\n");
+         else {
+            fprintf(file,".stream[");         /* output active stream of current tree */
+            for (s=1,i=1;s<=hset->swidth[0];s++)
+               if (tree->streams.set[s])
+                   fprintf(file,"%d%s",s,(i++<tree->nActiveStr)?",":"]\n");
+         }
+         PrintTree(tree,file);
+      }
+      FClose(file,isPipe);
+   }
+   
+   return;
+}
+
+/* ------------- UF - Use File Command --------- */
+
+void UseCommand(void)
+{
+   MILink mil;
+   char newMMF[MAXFNAMELEN];   /* Name of MMF file to store macros in */
+
+   ChkedAlpha("UF file name",newMMF);
+   if (trace & T_BID) {
+      printf("\nUF %s\n Using MMF file to store new macros",newMMF);
+      fflush(stdout);
+   }
+   mil=AddMMF(hset,newMMF);
+   mil->isLoaded=TRUE; /* Just to make sure we actually save to file */
+   fidx=mil->fidx;
+}
+
+/* -------------------------- FA Command ------------------------- */
+void FloorAverageCommand(void)
+{
+   HMMScanState hss;
+   StateInfo *si   ;
+   StreamInfo *sti;
+   SVector var , mean;
+   DVector *varAcc;
+   double occAcc[SMAX];
+   float weight;
+   float occ,occs;
+   int l=0,k,i,s,S;
+   float varScale;
+   Boolean singleMix;
 
    /*  need stats for operation */
    if (!occStatsLoaded)
@@ -5155,36 +6975,52 @@ void FloorAverageCommand(void)
       ZeroDVector(varAcc[s]);
    }
    NewHMMScan(hset,&hss);
-   occAcc = 0.0;
+   for (s=1;s<=S;s++) occAcc[s] = 0.0;
    while(GoNextState(&hss,FALSE)) {
       si = hss.si;
-      memcpy(&occ,&(si->hook),sizeof(float));
-      occAcc += occ;
-      s=0;
       while (GoNextStream(&hss,TRUE)) {
-         l=hset->swidth[hss.s];
-         ste = hss.ste;
-         s++;
-         if ( hss.M > 1 ) { 
+         s=hss.s;
+         l=hset->swidth[s];
+         sti = hss.sti;
+         memcpy(&occ,&(sti->hook),sizeof(float));
+         /* single/multiple mix check */
+         for (i=1,k=0; i<=hss.M; i++) {
+            if (hset->swidth[s] == VectorSize(sti->spdf.cpdf[i].mpdf->mean))  /* MSD check */
+               k++;
+         }
+         singleMix = (k==1) ? TRUE : FALSE;
+         /* accumulate statistics */
+         if ( !singleMix ) { 
+            occs = 0.0;
             for (k=1;k<=l;k++) { /* loop over k-th dimension */
                double    rvar  = 0.0;
                double    rmean = 0.0;
                for (i=1; i<= hss.M; i++) {
-                  weight = ste->spdf.cpdf[i].weight;
-                  var  = ste->spdf.cpdf[i].mpdf->cov.var;
-                  mean = ste->spdf.cpdf[i].mpdf->mean;
+                  if (VectorSize(sti->spdf.cpdf[i].mpdf->mean) == l) {  /* MSD check */
+                  weight = sti->spdf.cpdf[i].weight;
+                  var  = sti->spdf.cpdf[i].mpdf->cov.var;
+                  mean = sti->spdf.cpdf[i].mpdf->mean;
                   
                   rvar  += weight * ( var[k] + mean[k] * mean[k] );
                   rmean += weight * mean[k];
+                  if (k==1) occs += weight * occ;
+                  }
                }
                rvar -= rmean * rmean;
-               varAcc[s][k] += rvar * occ ;
+               varAcc[s][k] += rvar * occs ;
             }
+            occAcc[s] += occs;
          }
-         else { /* single mix */
-            var  = ste->spdf.cpdf[1].mpdf->cov.var;
+         else { /* single mix (single space matches the stream weight) */
+            for (i=1; i<=hss.M; i++) {
+               if (VectorSize(sti->spdf.cpdf[i].mpdf->mean) == l) {
+                  weight = sti->spdf.cpdf[i].weight;
+                  var    = sti->spdf.cpdf[i].mpdf->cov.var;
             for (k=1;k<=l;k++) 
-               varAcc[s][k] += var[k]*occ;
+                     varAcc[s][k] += occ * weight * var[k];
+                  occAcc[s] += occ * weight;
+               }
+            }
          }
       }
    }
@@ -5192,7 +7028,7 @@ void FloorAverageCommand(void)
    /* normalisation */
    for (s=1;s<=S;s++)
       for (k=1;k<=hset->swidth[s];k++)
-         varAcc[s][k] /= occAcc;
+         varAcc[s][k] /= occAcc[s];
    /* set the varFloorN macros */
    for (s=1; s<=S; s++){
       int size;
@@ -5217,7 +7053,7 @@ void FloorAverageCommand(void)
          NewMacro(hset,hset->numFiles,'v',id,v);
       }
       /* scale and store */
-      for (k=1;k<=l;k++)
+      for (k=1;k<=hset->swidth[s];k++)
          v[k] = varAcc[s][k]*varScale;
    }
    /* and apply floors */
@@ -5225,6 +7061,9 @@ void FloorAverageCommand(void)
        ApplyVFloor(hset);
    else
        HError(-7023,"FloorAverageCommand: variance floors have not been applied to mixes");
+
+   for (s=S; s>=1; s--)
+      FreeDVector(&gstack, varAcc[s]);
    Dispose(&gstack,varAcc);
 }
 
@@ -5236,7 +7075,7 @@ void FloorVectorCommand(void)
    char fn[MAXFNAMELEN],mac[MAXSTRLEN],buf[MAXSTRLEN];
    Source src;
    int s,S,n,i;
-   char c,h;
+   char c;
    LabId id;
    SVector v;
    MLink m;
@@ -5262,15 +7101,13 @@ void FloorVectorCommand(void)
          if (!ReadString(&src,buf))
             HError(2613,"FloorVectorCommand: cannot parse file %s",fn);
          strcpy(mac,"varFloor");
-         h=buf[strlen(mac)];
+         s=atoi(buf+strlen(mac));
          buf[strlen(mac)]='\0';
          if (strcmp(mac,buf)!=0) /* not a varFloor */
             continue;
-         assert(SMAX<10); s=h-'0';
          if(s<1||s>S)
             HError(2613,"FloorVectorCommand: undefined stream %d in HMM set",s);
-         mac[strlen(buf)]=h;
-         mac[strlen(buf)+1]='\0';
+         sprintf(mac,"%s%d",mac,s);
          if (trace & T_BID) {
             printf("loading vector %s\n",mac);
          }
@@ -5315,24 +7152,25 @@ void FloorVectorCommand(void)
 #define ABS(a) ((a)>0?(a):-(a))
 
 /* Sets size of state... */
-int SetSize(char *hname, StreamElem *ste /*nMix must be +ve*/, int tgt){ /*returns nDefunct*/
-   int nDefunct=0,sign = (ste->nMix > 0 ? 1 : -1); 
+int SetSize(char *hname, StreamInfo *sti /*nMix must be +ve*/, int tgt)
+{  /*returns nDefunct*/
+   int nDefunct=0,sign = (sti->nMix > 0 ? 1 : -1); 
    int m, M;
-   ste->nMix *= sign; M=ste->nMix;
+   sti->nMix *= sign; M=sti->nMix;
 
    /* (1) remove defunct mixture compoonents */
    for (m=1; m<=M; m++)
-      if (ste->spdf.cpdf[m].weight <= MINMIX) {
-         MixPDF *mp=ste->spdf.cpdf[m].mpdf;
+      if (sti->spdf.cpdf[m].weight <= MINMIX) {
+         MixPDF *mp=sti->spdf.cpdf[m].mpdf;
          if (mp->nUse) mp->nUse--; /* decrement MixPDF use */
-         ste->spdf.cpdf[m] = ste->spdf.cpdf[M]; M--; 
+         sti->spdf.cpdf[m] = sti->spdf.cpdf[M]; M--; 
          nDefunct++;
       }
    /* (2) get to desired size.. */
-   ste->nMix = M;
-   if(tgt < M) DownMix(hname,ste,tgt,TRUE);
-   else if(tgt > M) UpMix(hname, ste, M, tgt);
-   ste->nMix *= sign;
+   sti->nMix = M;
+   if(tgt < M) DownMix(hname,sti,tgt,TRUE);
+   else if(tgt > M) UpMix(hname, sti, M, tgt);
+   sti->nMix *= sign;
    return nDefunct;
 }
 
@@ -5375,7 +7213,7 @@ void PowerSizeCommand(void)
       memcpy(&stateocc,&(hss.si->hook),sizeof(float));
       sum += exp(log(MAX(stateocc,MINLARG)) * Power);
       S++; M+=hss.M;  maxM=MAX(maxM,hss.M); 
-      for (m=1;m<=hss.M;m++){ minweight = MIN(hss.ste->spdf.cpdf[m].weight, minweight); }
+      for (m=1;m<=hss.M;m++){ minweight = MIN(hss.ste->info->spdf.cpdf[m].weight, minweight); }
    }  /*count states. */
    EndHMMScan(&hss);
 
@@ -5403,7 +7241,7 @@ void PowerSizeCommand(void)
       }
       newM += itgt;
       if(itgt > hss.M*2) nTooBig++;
-      nDefunct += SetSize(HMMPhysName(hset,hss.hmm), hss.ste, itgt);
+      nDefunct += SetSize(HMMPhysName(hset,hss.hmm), hss.ste->info, itgt);
    }
    EndHMMScan(&hss);
    
@@ -5426,6 +7264,7 @@ void MixDownCommand(void)
    int m,M;
    int totm=0,totM=0;
    StreamElem *ste;
+   StreamInfo *sti;
    HMMDef *hmm;
    char *hname;
    int nDefunct,nDefunctMix;
@@ -5440,7 +7279,7 @@ void MixDownCommand(void)
       HError(2640,"MixDownCommand: MixDown only possible for continuous models");
 
    /* get itemlist */
-   PItemList(&ilist,&type,hset,&source,trace&T_ITM);
+   PItemList(&ilist,&type,hset,&source,NULL,0,0,(trace&T_ITM)?TRUE:FALSE);
    if (ilist == NULL) {
       HError(-2631,"MixDownCommand: No mixtures to decrease!");
       return;
@@ -5449,8 +7288,9 @@ void MixDownCommand(void)
    nDefunct = nDefunctMix= 0; 
    for (i=ilist; i!=NULL; i=i->next) {
       ste = (StreamElem *)i->item;
-      M = ste->nMix;
-      if (M>0) ste->nMix=-M;
+      sti = ste->info;
+      M = sti->nMix;
+      if (M>0) sti->nMix = -M;
    }
 
    /* mix down all pdf's */
@@ -5458,28 +7298,29 @@ void MixDownCommand(void)
    for (i=ilist; i!=NULL; i=i->next){
       hmm = i->owner;
       ste = (StreamElem *)i->item; 
-      M = ste->nMix;
+      sti = ste->info; 
+      M = sti->nMix;
       if (M<0) { 
          /* mix not yet processed */
-         M = ste->nMix = -M;
+         M = sti->nMix = -M;
          hname = HMMPhysName(hset,hmm);
          /* remove defunct mixture compoonents */
          for (m=1; m<=M; m++)
-            if (ste->spdf.cpdf[m].weight <= MINMIX) {
-               MixPDF *mp=ste->spdf.cpdf[m].mpdf;
+            if (sti->spdf.cpdf[m].weight <= MINMIX) {
+               MixPDF *mp=sti->spdf.cpdf[m].mpdf;
                if (mp->nUse) mp->nUse--; /* decrement MixPDF use */
-               ste->spdf.cpdf[m] = ste->spdf.cpdf[M]; M--; 
+               sti->spdf.cpdf[m] = sti->spdf.cpdf[M]; M--; 
                nDefunct++;
             }
-         if(ste->nMix>M) {
+         if(sti->nMix>M) {
             if ( trace & T_DET) 
-               printf("MD %12s : %d out of %d mixes defunct\n",hname,ste->nMix-M,ste->nMix);
+               printf("MD %12s : %d out of %d mixes defunct\n",hname,sti->nMix-M,sti->nMix);
             nDefunctMix++;
-            ste->nMix = M;
+            sti->nMix = M;
          }
          /* downmix if necessary */
          if (trg<M) {
-            DownMix(hname,ste,trg,TRUE);
+            DownMix(hname,sti,trg,TRUE);
             totm+=trg;
          }
          else 
@@ -5503,7 +7344,7 @@ void MixDownCommand(void)
 void FullCovarCommand(void)
 {
    HMMScanState hss;
-   int i,u,z;
+   int i,j,u,z;
    SVector var;
    STriMat invcov;
    MLink ml;
@@ -5523,9 +7364,12 @@ void FullCovarCommand(void)
       if (u==0 || !IsSeen(u)) {
          z = VectorSize(var);
          invcov = CreateSTriMat(&hmmHeap,z);
-         ZeroTriMat(invcov);
-         for (i=1; i<=z; i++) 
+         /* ZeroTriMat(invcov); */
+         for (i=1; i<=z; i++) {
+            for (j=1; j<i; j++)
+               invcov[i][j] = 0.0;
             invcov[i][i] = var[i];
+         } 
          if (u!=0) {
             ml = FindMacroStruct(hset,'v',var);
             DeleteMacro(hset,ml);                  /* this needs to delete */
@@ -5543,6 +7387,51 @@ void FullCovarCommand(void)
    hset->ckind = FULLC;
 }
 
+/* ------------- DV - DiagVar Command ----------------- */
+
+void DiagVarCommand (void)
+{
+   HMMScanState hss;
+   int i,u,z;
+   SVector var;
+   STriMat inv;
+   MLink ml;
+
+   if (hset->hsKind==TIEDHS || hset->hsKind==DISCRETEHS)
+      HError(2640,"DiagVarCommand: Only possible for continuous models");
+   if (hset->ckind != FULLC)
+      HError(2640,"DiagVarCommand: Only implemented for FULLC models");
+
+   NewHMMScan(hset,&hss);
+   while(GoNextMix(&hss,FALSE)) {
+      inv = hss.me->mpdf->cov.inv;
+      hss.me->mpdf->ckind = INVDIAGC;
+      u = GetUse(inv);
+      if (u==0 || !IsSeen(u)) {
+         z = TriMatSize(inv);
+         var = CreateSVector(&hmmHeap,z);
+         for (i=1; i<=z; i++)
+            var[i] = inv[i][i];
+         if (u!=0) {
+            ml = FindMacroStruct(hset,'i',inv);
+            DeleteMacro(hset,ml);                 /* this needs to delete */
+            NewMacro(hset,fidx,'v',ml->id,var);   /* the macro name also */
+            TouchV(inv);
+            SetUse(var,u);
+            SetHook(inv,var);
+         }
+      }
+      else  /* a macro that we have already seen */
+         var = GetHook(inv);
+      hss.me->mpdf->cov.var = var;
+   }
+   EndHMMScan(&hss);
+   hset->ckind = DIAGC;
+   
+   ConvDiagC(hset,TRUE);  /* inv -> var */
+   FixAllGConsts(hset);   /* fix gConsts */
+}
+
 /* ------------- PR - ProjectCommand   ----------------- */
 
 void ProjectCommand(void)
@@ -5581,23 +7470,26 @@ typedef struct _CoList {
 /* node information in the regression class tree */
 typedef struct {
 
+   int vSize;                /* vector size of this cluster */
    Vector aveMean;           /* node cluster mean */
    Vector aveCovar;          /* node cluster variance */
-   float  clusterScore;      /* node cluster score */
-   float  clustAcc;          /* accumulates in this cluster */
+   double clusterScore;      /* node cluster score */
+   double clustAcc;          /* accumulates in this cluster */
    int  nComponents;         /* number of components in this cluster */
    short  nodeIndex;         /* node index number */
    CoList *list;             /* linked list of the mixture components */
+   Boolean pureVecSize;
+   Boolean pureStream;     
 
 } RNode;
 
-/* return the node of a tree */
-static RNode *GetRNode(RegNode *n) 
+/* GetRNode: return the node of a tree */
+RNode *GetRNode (RegNode *n) 
 {
    return ((RNode *) n->info);
 }
 
-/* Create a link for a cluster linked list */
+/* CreateClusterLink: Create a link for a cluster linked list */
 CoList *CreateClusterLink(char *s, int state, int stream, int mix, 
                           MixPDF *mp) 
 {
@@ -5617,12 +7509,67 @@ CoList *CreateClusterLink(char *s, int s
 
 }
 
+/* PureVecSize: check dimensionality in list */
+Boolean PureVecSize (CoList *list) 
+{
+   CoList *c;
+   int vSize;
+   
+   if (list==NULL)
+      return TRUE;
+      
+   vSize = VectorSize(list->mp->mean);
+
+   for (c=list->next; c!=NULL; c=c->next)
+      if (VectorSize(c->mp->mean)!=vSize)
+         return FALSE;
+
+   return TRUE;
+}
+
+/* PureStream: check stream in list */
+Boolean PureStream (CoList *list) 
+{
+   CoList *c;
+   int stream;
+   
+   if (list==NULL)
+      return TRUE;
+      
+   stream = list->stream;
+
+   for (c=list->next; c!=NULL; c=c->next)
+      if (c->stream != stream)
+         return FALSE;
+
+   return TRUE;
+}
+
+/* MaxVecSize: maximum dimensionality in list */
+int MaxVecSize (CoList *list) 
+{
+   CoList *c;
+   int vSize;
+   
+   if (list==NULL)
+      return 0;
+      
+   vSize = VectorSize(list->mp->mean);
+
+   for (c=list->next; c!=NULL; c=c->next)
+      if (VectorSize(c->mp->mean) > vSize)
+         vSize = VectorSize(c->mp->mean);
+
+   return vSize;
+}
+
 /* Create a tree node for use in the regression tree */
 RNode *CreateRegTreeNode(CoList *list, int vSize) 
 {
    RNode *n;
 
    n = (RNode *) New(&tmpHeap, sizeof(RNode));
+   n->vSize = vSize;
    n->aveMean  = CreateVector(&tmpHeap, vSize);
    n->aveCovar = CreateVector(&tmpHeap, vSize);
    ZeroVector(n->aveMean);
@@ -5631,12 +7578,21 @@ RNode *CreateRegTreeNode(CoList *list, i
    n->nComponents = 0;
    n->clusterScore = 0.0;
    n->nodeIndex = -1;
+   n->pureStream = FALSE;
+   n->pureVecSize = FALSE;
 
    return n;
+}
 
+/* FreeRegTreeNode: free RNode */
+void FreeRegTreeNode (RNode *r)
+{
+   FreeVector(&tmpHeap, r->aveCovar);
+   FreeVector(&tmpHeap, r->aveMean);
+   Dispose(&tmpHeap, r);
 }
 
-void PrintNodeInfo(RNode *n, int vSize) 
+void PrintNodeInfo(RNode *n) 
 {
    int i;
 
@@ -5644,39 +7600,44 @@ void PrintNodeInfo(RNode *n, int vSize) 
    printf("%d components with %f occupation count;\n  Cluster score of %e\n",
           n->nComponents, n->clustAcc, n->clusterScore);
    printf("MEAN:-\n");
-   for (i = 1; i <= vSize; i++)
+   for (i=1; i<=n->vSize; i++)
       printf("%e ", n->aveMean[i]);
    printf("\nCOVARIANCE:-\n");
-   for (i = 1; i <= vSize; i++)
+   for (i=1; i<=n->vSize; i++)
       printf("%e ", n->aveCovar[i]);
    printf("\n");
    fflush(stdout);
 }
 
 
-float Distance(Vector v1, Vector v2) 
+double Distance (Vector v1, Vector v2) 
 {  
    int k, vSize;
-   float x, dist = 0.0;
+   double x, dist = 0.0;
 
    vSize = VectorSize(v1);
+   if (vSize==0)
+      return LZERO;
+
    for (k = 1; k <= vSize; k++) {
-      x = v1[k] - v2[k];
+      x = (double)(v1[k] - v2[k]);
       x *= x;
       dist += x;
    }
 
-   return ((float) sqrt((double) dist));
-
+   return (sqrt(dist));
 }
 
-float CalcNodeScore(RNode *n, int vSize) 
+double CalcNodeScore (RNode *n) 
 {
-   float score = 0.0;
+   double score = 0.0;
    Vector mean;
    CoList *c;
    AccSum *acc;
 
+   if (!(n->pureVecSize && n->pureStream))
+      return -LZERO;
+      
    for(c = n->list; c != NULL; c = c->next) {
       mean = c->mp->mean;
       acc  = (AccSum *) c->mp->hook;
@@ -5684,33 +7645,38 @@ float CalcNodeScore(RNode *n, int vSize)
          score += Distance(mean, n->aveMean) * acc->occ ;
    }
 
-   return score;
-
+   return(score);
 }
 
-/* calculation of the cluster distribution -> aveMean aveCovar */
-void CalcClusterDistribution(RNode *n, int vSize) 
+/* CalcClusterDistribution: calculation of the cluster distribution -> aveMean aveCovar */
+void CalcClusterDistribution (RNode *n) 
 {
    CoList *c;
    AccSum *acc;
-   int k;
-   float occ;
-   Vector sum, sqr;
+   int k, s;
+   double occ;
+   DVector sum, sqr;
   
-   sum = CreateVector(&gstack, vSize);
-   sqr = CreateVector(&gstack, vSize);
+   sum = CreateDVector(&gstack, n->vSize);
+   sqr = CreateDVector(&gstack, n->vSize);
    occ = 0.0;
-   ZeroVector(sum);
-   ZeroVector(sqr);
+   ZeroDVector(sum);
+   ZeroDVector(sqr);
+   s = n->list->stream;
 
    for (c = n->list; c != NULL; c = c->next) {
       /* scaled(mean) and scaled(mean*mean + covar) already stored in mp->hook */
       acc = (AccSum *) c->mp->hook;
       if (acc != NULL) {
-         for (k = 1; k <= vSize; k++) {
+         /* check pure stream and vecSize */
+         if (n->pureVecSize && n->pureStream) {      
+            for (k=1; k<=n->vSize; k++) {
             sum[k] += acc->sum[k];
             sqr[k] += acc->sqr[k];
          }
+         }
+         /* count only 1 stream */
+         if (c->stream == s)
          occ += acc->occ;
       }
       else
@@ -5719,46 +7685,44 @@ void CalcClusterDistribution(RNode *n, i
    }
 
    /* now calculate mean and covariance for this cluster */
-   for (k = 1; k <= vSize; k++) {
-      n->aveMean[k]  = sum[k] / occ;
-      n->aveCovar[k] = (sqr[k] - sum[k]*sum[k]/occ) / occ;
+   for (k=1; k<=n->vSize; k++) {
+      n->aveMean[k]  = (n->pureVecSize && n->pureStream) ? (float)(sum[k] / occ) : 0.0;
+      n->aveCovar[k] = (n->pureVecSize && n->pureStream) ? (float)((sqr[k] - sum[k]*sum[k]/occ) / occ) : 1.0;
    }
    n->clustAcc = occ;
 
-   FreeVector(&gstack, sum);
-
+   FreeDVector(&gstack, sqr);
+   FreeDVector(&gstack, sum);
 }
     
-/* Initialise a regression tree root node -- will also separate out
+/* InitRegTree: Initialise a regression tree root node -- will also separate out
    speech and non-speech sounds */
-RegTree *InitRegTree(HMMSet *hset, int *vSize, ILink ilist) 
+RegTree *InitRegTree (HMMSet *hset, ILink ilist) 
 {  
   HMMScanState hss;
   CoList *listSp=NULL,*listNonSp=NULL,*cs, *cn;
   RNode *r1=NULL, *r2=NULL, *rNode=NULL;
   RegNode *root;
   RegTree *rTree;
-  int nComponentsSp = 0, nComponentsNonSp = 0;
+  int vSize, nComponentsSp = 0, nComponentsNonSp = 0;
   StreamElem *ste;
   ILink p=NULL;
 
   if (!occStatsLoaded)
     HError(2672, "InitRegTree: Building regression classes must load the stats file!\n");
   
-  cs = cn = NULL;
-  *vSize = hset->swidth[1];
-  if (*vSize <= 0)
-    HError(2673, "InitRegTree: Problem with vector Size = %d", vSize);
+  SetSet(streams);
 
   NewHMMScan(hset,&hss);
 
   if (!(hss.isCont || (hss.hset->hsKind == TIEDHS))) {
-     HError(2673,"InitRegTree: Can only resize continuous featured systems");
+     HError(2673,"InitRegTree: Can only resize continuous featured system");
   }
 
+  cs = cn = NULL;
   do {
     while (GoNextState(&hss,TRUE)) {
-      InitTreeAccs(hss.se, *vSize);
+      InitTreeAccs(hss.se);
       while (GoNextStream(&hss,TRUE)) {
 	/* go through item list to see if non-speech sound */
 	if (ilist != NULL)
@@ -5800,12 +7764,19 @@ RegTree *InitRegTree(HMMSet *hset, int *
   } while (GoNextHMM(&hss));
   EndHMMScan(&hss);
 
+  /* create an instance of the node */
   cs = NULL; cn = NULL;
-  r1 = CreateRegTreeNode(listSp, *vSize);  
+  vSize = MaxVecSize(listSp);
+  if (vSize <= 0)
+    HError(2673, "InitRegTree: Problem with vector Size = %d", vSize);
+  r1 = CreateRegTreeNode(listSp, vSize);  
   r1->nodeIndex = 1;
   r1->nComponents = nComponentsSp;
-  CalcClusterDistribution(r1, *vSize);
-  r1->clusterScore = CalcNodeScore(r1, *vSize);
+  r1->pureVecSize = PureVecSize(r1->list);
+  r1->pureStream  = PureStream (r1->list);
+  CalcClusterDistribution(r1);
+  r1->clusterScore = CalcNodeScore(r1);
+   
   /* create an instance of the tree */
   rTree = (RegTree *) New(&tmpHeap, sizeof(RegTree));
   rTree->bclass = NULL;
@@ -5816,19 +7788,25 @@ RegTree *InitRegTree(HMMSet *hset, int *
   if (nComponentsNonSp > 0) {
     /* reset the root node */
     root->nodeIndex = 1;
-    rNode = CreateRegTreeNode(NULL, *vSize);
+    rNode = CreateRegTreeNode(listSp, vSize);  /* use listSp for dummy */
     rNode->nodeIndex = 1;
+    rNode->nComponents = nComponentsNonSp + nComponentsSp;
+    rNode->pureVecSize = r1->pureVecSize;
+    rNode->pureStream  = r1->pureStream;
     root->info = rNode;
     root->numChild = 2;
     root->child = (RegNode **)New(&tmpHeap,3*sizeof(RegNode *));
     root->child[1] = (RegNode *) New(&tmpHeap, sizeof(RegNode));
     root->child[2] = (RegNode *) New(&tmpHeap, sizeof(RegNode));
     /* set-up information for first child */
-    r2 = CreateRegTreeNode(listNonSp, *vSize);
+    vSize = MaxVecSize(listNonSp);
+    r2 = CreateRegTreeNode(listNonSp, vSize);
     r2->nodeIndex = 2;
     r2->nComponents = nComponentsNonSp;
-    CalcClusterDistribution(r2, *vSize);
-    r2->clusterScore = CalcNodeScore(r2, *vSize);
+    r2->pureVecSize = PureVecSize(r2->list);
+    r2->pureStream  = PureStream (r2->list);
+    CalcClusterDistribution(r2);
+    r2->clusterScore = CalcNodeScore(r2);
     root->child[1]->info = r2;
     root->child[1]->numChild = 0;
     root->child[1]->child = NULL;
@@ -5860,19 +7838,21 @@ void PerturbMean(Vector mean, Vector cov
 
 }
 
-void CalcDistance(CoList *list, RNode *ch1, RNode *ch2, int vSize)
+void CalcDistance (CoList *list, RNode *ch1, RNode *ch2)
 {
-   int k;
+   int k, vSize;
    CoList *c;
    AccSum *acc;
-   float score1, score2;
-   Vector mean, sum1, sum2;
+   double score1, score2;
+   Vector mean;
+   DVector sum1, sum2;
 
-   sum1 = CreateVector(&gstack, vSize);
-   ZeroVector(sum1);
-   sum2 = CreateVector(&gstack, vSize);
-   ZeroVector(sum2);
+   vSize = MaxVecSize(list);
 
+   sum1 = CreateDVector(&gstack, vSize);
+   ZeroDVector(sum1);
+   sum2 = CreateDVector(&gstack, vSize);
+   ZeroDVector(sum2);
 
    ch1->clusterScore = ch2->clusterScore = 0.0;
    ch1->clustAcc = ch2->clustAcc = 0.0;
@@ -5901,25 +7881,30 @@ void CalcDistance(CoList *list, RNode *c
    }
 
    for (k = 1; k <= vSize; k++) {
-      ch1->aveMean[k] = sum1[k] / ch1->clustAcc;
-      ch2->aveMean[k] = sum2[k] / ch2->clustAcc;
+      ch1->aveMean[k] = (float)(sum1[k] / ch1->clustAcc);
+      ch2->aveMean[k] = (float)(sum2[k] / ch2->clustAcc);
    }
 
-   FreeVector(&gstack, sum1);
-
+   FreeDVector(&gstack, sum2);
+   FreeDVector(&gstack, sum1);
 }
 
-void CreateChildNodes(CoList *list, RNode *ch1, RNode *ch2, int vSize) 
+void CreateChildNodes (RNode *parent, RNode *ch1, RNode *ch2) 
 {
-   CoList *c, *c1, *c2;
-   float score1, score2;
-   int numLeft, numRight;
+   CoList *c, *c1, *c2, *list;
+   double score1, score2;
+   int numLeft, numRight, s, v;
    Vector mean;
 
+   list = parent->list;
    c1 = c2 = NULL;
    numLeft = numRight = 0;
+   s = list->stream;
+   v = VectorSize(list->mp->mean);
 
    for(c = list; c != NULL; c = c->next) {
+      if (parent->pureStream && parent->pureVecSize) {
+         /* both stream & vecSize in this list are pure */
       mean = c->mp->mean;
       score1 = Distance(mean, ch1->aveMean);
       score2 = Distance(mean, ch2->aveMean);
@@ -5930,7 +7915,48 @@ void CreateChildNodes(CoList *list, RNod
             c1->next = c;
             c1 = c1->next;
          }
-         numLeft += 1;
+            numLeft++;
+         }
+         else {
+            if (c2==NULL)
+               c2 = ch2->list = c;
+            else {
+               c2->next = c;
+               c2 = c2->next;
+            }
+            numRight++;
+         }
+      }
+      else if (!parent->pureStream) {
+         /* stream is not pure */
+         if (c->stream == s) {
+            if (c1==NULL)
+               c1 = ch1->list = c;
+            else {
+               c1->next = c;
+               c1 = c1->next;
+            }
+            numLeft++;
+         }
+         else {
+            if (c2==NULL)
+               c2 = ch2->list = c;
+            else {
+               c2->next = c;
+               c2 = c2->next;
+            }
+            numRight++;
+         }
+      }
+      else {
+         if (VectorSize(c->mp->mean) == v) {
+            if (c1==NULL)
+               c1 = ch1->list = c;
+            else {
+               c1->next = c;
+               c1 = c1->next;
+            }
+            numLeft++;
       }
       else {
          if (c2 == NULL)
@@ -5939,7 +7965,8 @@ void CreateChildNodes(CoList *list, RNod
             c2->next = c;
             c2 = c2->next;
          }
-         numRight += 1;
+            numRight++;
+         }
       }
    }
 
@@ -5949,26 +7977,20 @@ void CreateChildNodes(CoList *list, RNod
       c1->next = NULL;
    if (c2 != NULL)
       c2->next = NULL;
-
-   /* calculate the average mean and variance of the clusters */
-   CalcClusterDistribution(ch1, vSize);
-   CalcClusterDistribution(ch2, vSize);
-   ch1->clusterScore = CalcNodeScore(ch1, vSize);
-   ch2->clusterScore = CalcNodeScore(ch2, vSize);
-
 }
 
-void ClusterChildren(RNode *parent, RNode *ch1, RNode *ch2, int vSize) 
+void ClusterChildren (RNode *parent, RNode *ch1, RNode *ch2) 
 { 
-   const float thresh = 1.0e-12;
+   const double thresh = 1.0e-12;
    int iter=0;
-   float oldDistance, newDistance=0.0 ;
+   double oldDistance, newDistance=0.0 ;
 
+   if (parent->pureStream && parent->pureVecSize) {
    do {
       iter+=1;
       if (iter >= MAX_ITER)
          break;
-      CalcDistance(parent->list, ch1, ch2, vSize);
+         CalcDistance(parent->list, ch1, ch2);
       if (iter == 1)
          oldDistance = ((ch1->clusterScore + ch2->clusterScore) / 
             (ch1->clustAcc + ch2->clustAcc)) + thresh + 1;
@@ -5980,8 +8002,7 @@ void ClusterChildren(RNode *parent, RNod
          if (iter == 1)
             printf("Iteration %d: Distance = %e\n", iter, newDistance);
          else
-            printf("Iteration %d: Distance = %e, Delta = %e\n", iter, newDistance,
-                   oldDistance - newDistance);
+               printf("Iteration %d: Distance = %e, Delta = %e\n", iter, newDistance, oldDistance - newDistance);
          fflush(stdout);
       }
    } while ((oldDistance - newDistance) > thresh);
@@ -5989,9 +8010,9 @@ void ClusterChildren(RNode *parent, RNod
    if (trace & T_CLUSTERS)
       printf("Cluster 1: Score %e, Occ %e\t Cluster 2: Score %e, Occ %e\n",
              ch1->clusterScore,ch1->clustAcc, ch2->clusterScore,ch2->clustAcc);
+   }
 
-   CreateChildNodes(parent->list, ch1, ch2, vSize);
-
+   CreateChildNodes(parent, ch1, ch2);
 }
 
 static void GetTreeVector(RegNode **nVec, RegNode *t) 
@@ -6017,6 +8038,8 @@ void PrintRegTree(FILE *f, RegTree *t, i
    --tVec;
    GetTreeVector(tVec, t->root);
    fprintf(f,"~r %s\n",ReWriteString(rname,NULL,DBL_QUOTE));
+   
+   /* print base classes */
    fprintf(f,"<BASECLASS>~b %s\n",ReWriteString(bname,NULL,DBL_QUOTE));
    for (i=1;i<=nNodes;i++) {
      n = GetRNode(tVec[i]);
@@ -6035,6 +8058,9 @@ void PrintRegTree(FILE *f, RegTree *t, i
        fprintf(f, "<TNODE> %d 1 %d\n",n->nodeIndex,t->numTNodes);
      }
    }
+   
+   tVec++;
+   Dispose(&gstack, tVec);
 }
 
 void PrintBaseClass(FILE *f, RegTree *t, int nNodes, char *bname) 
@@ -6050,7 +8076,16 @@ void PrintBaseClass(FILE *f, RegTree *t,
   fprintf(f,"~b %s\n",ReWriteString(bname,NULL,DBL_QUOTE));
   fprintf(f,"<MMFIDMASK> %s\n",mmfIdMask);
   fprintf(f,"<PARAMETERS> MIXBASE\n");
+   /* put <StreamInfo> for multiple streams system */
+   if (hset->swidth[0]>1) {
+      fprintf(f,"<STREAMINFO> ");
+      WriteShort(f, hset->swidth, 1, FALSE);
+      for (i=1; i<=hset->swidth[0]; i++)
+         WriteShort(f, hset->swidth+i, 1, FALSE);
+      fprintf(f,"\n");
+   }
   fprintf(f,"<NUMCLASSES> %d\n",t->numTNodes);
+
   for (i=1;i<=nNodes;i++) {
     /* print out the information from the baseclasses */
     if (tVec[i]->numChild == 0) {
@@ -6068,22 +8102,25 @@ void PrintBaseClass(FILE *f, RegTree *t,
       fprintf(f,"}\n");
     }
   }
+  
+  tVec++;
+  Dispose(&gstack, tVec);
 }
 
-RegNode *FindBestTerminal(RegNode *t, float *score, int vSize, RegNode *best) 
+RegNode *FindBestTerminal (RegNode *t, double *score, RegNode *best) 
 {
   RNode *n;
-  float nodeScore;
+  double nodeScore;
   int i;
 
   if (t != NULL) {
     if (t->numChild>0) {
       for (i=1;i<=t->numChild;i++)
-	best = FindBestTerminal(t->child[i], score, vSize, best);
+        best = FindBestTerminal(t->child[i], score, best);
     } else {
       n = GetRNode(t);
       nodeScore = n->clusterScore;
-      if ((*score < nodeScore) && (n->nComponents > vSize*3)) {
+      if (!n->pureVecSize || !n->pureStream || ((*score < nodeScore) && (n->nComponents > n->vSize*3))) {
 	*score = nodeScore;
 	best = t;
       }
@@ -6093,16 +8130,25 @@ RegNode *FindBestTerminal(RegNode *t, fl
 }
 
 
-int BuildRegClusters(RegNode *rtree, int vSize, int nTerminals, 
-                     Boolean nonSpeechNode) 
+int BuildRegClusters (RegNode *rtree, const int nTerminals, Boolean nonSpeechNode) 
 {
   RegNode *t;
   RNode *ch1, *ch2, *n, *r;   /* temporary children */  
-  float score;
-  int k, index;
+  double score;
+  int s, k, index, nStrTerminals[SMAX];
+  IntSet strTerminals;
+
+  /* prepare children nodes for clustering */
+  r = GetRNode(rtree);
+  ch1 = CreateRegTreeNode(NULL, r->vSize);
+  ch2 = CreateRegTreeNode(NULL, r->vSize);
 
-  ch1 = CreateRegTreeNode(NULL, vSize);
-  ch2 = CreateRegTreeNode(NULL, vSize);
+  /* initialise # of terminals in each stream */
+  strTerminals = CreateSet(hset->swidth[0]);
+  for (s=1; s<=hset->swidth[0]; s++)
+    nStrTerminals[s] = 0;
+  if (r->pureStream && r->pureVecSize && r->vSize>0)
+    nStrTerminals[r->list->stream] = (nonSpeechNode) ? 2 : 1; 
 
   /* the artificial first split of speech/non-speech has been made */
   if (nonSpeechNode)
@@ -6111,12 +8157,12 @@ int BuildRegClusters(RegNode *rtree, int
     index = 2;
 
   k = index/2;
-  for (; k < nTerminals; k++) { 
-    
+  while (!IsFullSet(strTerminals)) { 
     score = 0.0;
     /* find the best (worst scoring) terminal to split 
        based on score and number of examples */
-    t = FindBestTerminal(rtree, &score, vSize, rtree);  
+    t = FindBestTerminal(rtree, &score, rtree);
+
     /* check to see if there are no more nodes to split */
     if ((k > 1 || score == 0.0) && t == rtree) {
       printf("No more nodes to split..\n");
@@ -6124,73 +8170,114 @@ int BuildRegClusters(RegNode *rtree, int
       break;
     }
     r = GetRNode(t);
-    if (trace & T_BID) {
-      printf("Splitting Node %d, score %e\n", r->nodeIndex, score);
-      fflush(stdout);
-    }
+      
+    /* check to see whether this node should be split or not */
+    if (r->pureStream && r->pureVecSize && r->vSize>0) {
+      if (nStrTerminals[r->list->stream]>=nTerminals) {  /* no more splitting */
+        r->clusterScore = 0.0;
+        AddMember(strTerminals, r->list->stream);
+        continue;
+      }
+         
+      /* decrement nStrTerminals[s] */
+      nStrTerminals[r->list->stream]--;
+    }
+
+    if (trace & T_BID) {
+      printf("Splitting Node %d, score %e\n", r->nodeIndex, score);
+         if (!r->pureStream) 
+            printf("(Stream splitting)\n");
+         else if (!r->pureVecSize)
+            printf("(MSD splitting)\n");
+         else
+            printf("(Stream=%d, vSize=%d)\n", r->list->stream, r->vSize);
+      fflush(stdout);
+    }
 
     /* copy parent node distribution to children */
-    CopyVector(r->aveMean, ch1->aveMean);
-    CopyVector(r->aveMean, ch2->aveMean);
-    CopyVector(r->aveCovar, ch1->aveCovar);
-    CopyVector(r->aveCovar, ch2->aveCovar);
+    ZeroVector(ch1->aveMean);  ZeroVector(ch2->aveMean);
+    ZeroVector(ch1->aveCovar); ZeroVector(ch2->aveCovar);
+
+    CopyRVector(r->aveMean,  ch1->aveMean,  r->vSize);
+    CopyRVector(r->aveMean,  ch2->aveMean,  r->vSize);
+    CopyRVector(r->aveCovar, ch1->aveCovar, r->vSize);
+    CopyRVector(r->aveCovar, ch2->aveCovar, r->vSize);
     
     PerturbMean(ch1->aveMean, ch1->aveCovar, 0.2);
     PerturbMean(ch2->aveMean, ch2->aveCovar, -0.2);
     
-    ClusterChildren(r, ch1, ch2, vSize);
+    /* cluster children of r into ch1 and ch2 */
+    ClusterChildren(r, ch1, ch2);
   
     /* Currently always build a binary regression tree */
     t->numChild = 2;
     t->child = (RegNode **)New(&tmpHeap,3*sizeof(RegNode *));
     /* now create new left child node and store the clusters */
     t->child[1] = (RegNode *) New(&tmpHeap, sizeof(RegNode));
-    n = CreateRegTreeNode(ch1->list, vSize);
-    t->child[1]->info = n;
+    t->child[1]->info = (Ptr) CreateRegTreeNode(NULL, MaxVecSize(ch1->list));
     t->child[1]->numChild = 0;
     t->child[1]->child = NULL;
 
-    CopyVector(ch1->aveMean, n->aveMean);
-    CopyVector(ch1->aveCovar, n->aveCovar);
-    n->clusterScore = ch1->clusterScore;
-    n->clustAcc     = ch1->clustAcc;
-    n->nComponents  = ch1->nComponents;
-    n->nodeIndex    = index++;
-
-    /* now create new right child nodes and store the clusters */
     t->child[2] = (RegNode *) New(&tmpHeap, sizeof(RegNode));
-    n = CreateRegTreeNode(ch2->list, vSize);
-    t->child[2]->info = n;
+    t->child[2]->info = (Ptr) CreateRegTreeNode(NULL, MaxVecSize(ch2->list));
     t->child[2]->numChild = 0;
     t->child[2]->child = NULL;
 
-    CopyVector(ch2->aveMean, n->aveMean);
-    CopyVector(ch2->aveCovar, n->aveCovar);
-    n->clusterScore = ch2->clusterScore;
-    n->clustAcc     = ch2->clustAcc;
+    /* store the clusters */
+    n = GetRNode(t->child[1]);
+    n->list = ch1->list;
+    n->pureVecSize = PureVecSize(n->list);
+    n->pureStream  = PureStream (n->list);
+    CalcClusterDistribution(n);
+    n->clusterScore = CalcNodeScore(n);
+    n->nComponents  = ch1->nComponents;
+    n->nodeIndex    = index++;
+    if (n->pureStream && n->pureVecSize && n->vSize>0)
+      nStrTerminals[n->list->stream]++;
+
+    n = GetRNode(t->child[2]);
+    n->list = ch2->list;
+    n->pureVecSize = PureVecSize(n->list);
+    n->pureStream  = PureStream (n->list);
+    CalcClusterDistribution(n);
+    n->clusterScore = CalcNodeScore(n);
     n->nComponents  = ch2->nComponents;
     n->nodeIndex    = index++;
+    if (n->pureStream && n->pureVecSize && n->vSize>0)
+      nStrTerminals[n->list->stream]++;
+      
+    k++;
   }
+   
+  if (trace&T_BID) {
+    for (s=1; s<=hset->swidth[0]; s++)
+      printf("stream %d: #terminals=%d\n", s, nStrTerminals[s]);
+    fflush(stdout);
+  }
+   
+  /* free strTerminals */
+  FreeSet(strTerminals);
+      
   return(index-1);   
 } 
 
 void RegClassesCommand(void) 
 {
   char ch;
-  char buf[MAXSTRLEN], fname[MAXSTRLEN], bname[MAXSTRLEN], tname[MAXSTRLEN];
-  char macroname[MAXSTRLEN], fname2[MAXSTRLEN];
+  char buf[MAXSTRLEN], fname[MAXFNAMELEN], bname[MAXSTRLEN], tname[MAXSTRLEN];
+  char macroname[MAXSTRLEN], fname2[MAXFNAMELEN];
   RegTree *regTree;
   char type = 'p';             /* type of items must be p (pdfs) */
   ILink ilist=NULL;            /* list of items that are non-speech sounds */
-  int nTerminals, vSize, nNodes;   
+  int nTerminals, nNodes;   
   FILE *f;
   Boolean isPipe;
 
   nTerminals = ChkedInt("Maximum number of terminal nodes is 256",0,256);
   ChkedAlpha("RC regression trees identifier",buf);         
   if (trace & T_BID) {
-    printf("\nRC %d %s\n Building regression tree with %d terminals\n",
-	   nTerminals, buf, nTerminals);
+    printf("\nRC %d %s\n Building regression tree with %d terminals (%d streams)\n",
+           nTerminals, buf, nTerminals, hset->swidth[0]);
     printf("Creating regression class tree with ident %s.tree and baseclass %s.base\n",
 	   buf, buf);
     fflush(stdout);
@@ -6202,13 +8289,13 @@ void RegClassesCommand(void) 
   while(ch!=EOF && isspace((int) ch));
   UnGetCh(ch,&source);
   if (ch != '\n')
-    PItemList(&ilist,&type,hset,&source,trace&T_ITM);
+    PItemList(&ilist,&type,hset,&source,NULL,0,0,(trace&T_ITM)?TRUE:FALSE);
 
-  regTree = InitRegTree(hset, &vSize, ilist);
+  regTree = InitRegTree(hset, ilist);
   if (ilist != NULL) 
-    nNodes = BuildRegClusters(regTree->root, vSize, nTerminals, TRUE);
+    nNodes = BuildRegClusters(regTree->root, nTerminals, TRUE);
   else
-    nNodes = BuildRegClusters(regTree->root, vSize, nTerminals, FALSE);
+    nNodes = BuildRegClusters(regTree->root, nTerminals, FALSE);
 
   /* now store the baseclasses and regression classes */
   MakeFN(buf,newDir,"tree",fname);
@@ -6250,12 +8337,12 @@ void RegClassesCommand(void) 
 
 void InputXFormCommand()
 {
-   char fn[256], macroname[256];
+   char fn[MAXFNAMELEN], macroname[MAXSTRLEN];
    InputXForm *xf;
 
-   ChkedAlpha("XF input Xform file name",fn); 
+   ChkedAlpha("IX input Xform file name",fn); 
    if (trace & T_BID) {
-      printf("\nXF %s\n Setting HMMSet input XForm\n", fn);
+      printf("\nIX %s\n Setting HMMSet input XForm\n", fn);
       fflush(stdout);
    }
    xf = LoadInputXForm(hset, NameOf(fn,macroname), fn);
@@ -6264,6 +8351,229 @@ void InputXFormCommand()
 }
 
 
+/* ----------------- ParentXForm Command -------------------- */
+
+void ParentXFormCommand()
+{
+   char fn[MAXFNAMELEN], macroname[MAXSTRLEN];
+   AdaptXForm *xf;
+   
+   ChkedAlpha("PX parent Xform file name", fn); 
+   if (trace & T_BID) {
+      printf("\nPX %s\n Setting HMMSet parent XForm\n", fn);
+      fflush(stdout);
+   }
+   xf = LoadOneXForm(hset,NameOf(fn,macroname),fn);
+   SetParentXForm(hset, NULL, xf);
+}
+
+/* ----------------- AdaptXForm Command -------------------- */
+
+typedef struct _StateMapping {
+   char *l1;
+   char *l2;
+   struct _StateMapping *next;
+   struct _StateMapping *prev;
+} StateMapping;
+
+typedef struct _StateMappingTable {
+   struct _StateMapping *head;
+   struct _StateMapping *tail;
+} StateMappingTable;
+
+void StateMappingTableInitialize(StateMappingTable * smt)
+{
+   smt->head = NULL;
+   smt->tail = NULL;
+}
+
+void StateMappingTablePush(StateMappingTable * smt, char *l1, char *l2)
+{
+   StateMapping *sm;
+
+   if (l1 == NULL || l2 == NULL)
+      return;
+
+   sm = New(&tmpHeap, sizeof(StateMapping));
+   sm->l1 = CopyString(&tmpHeap, l1);
+   sm->l2 = CopyString(&tmpHeap, l2);
+   sm->next = NULL;
+   sm->prev = NULL;
+
+   if (smt->head == NULL) {
+      sm->prev = NULL;
+      smt->head = sm;
+   } else {
+      sm->prev = smt->tail->next;
+      smt->tail->next = sm;
+   }
+   smt->tail = sm;
+}
+
+void StateMappingTableClear(StateMappingTable * smt)
+{
+   StateMapping *s1, *s2;
+
+   s1 = smt->tail;
+   while (s1 != NULL) {
+      s2 = s1->prev;
+      Dispose(&tmpHeap, s1);
+      s1 = s2;
+   }
+   StateMappingTableInitialize(smt);
+}
+
+/* PerformMapAdapt: Apply xform to L2 model using state mapping table */
+void PerformMapAdapt(HMMSet * hset_L1, HMMSet * hset_L2, StateMappingTable * smt)
+{
+   HMMScanState hss_L2;
+   MixPDF *mp_L2 = NULL;
+   MixPDF *mp_L1 = NULL;
+   MLink ml_L2 = NULL;
+   MLink ml_L1 = NULL;
+   LabId id_L1 = NULL;
+   StreamInfo *sti_L1 = NULL;
+   int m;
+   StateMapping *s;
+   Boolean find;
+
+   /* Attach XForm information into L2 model */
+   AttachXFormInfo(hset_L2);
+
+   NewHMMScan(hset_L2, &hss_L2);
+   do {
+      while (GoNextState(&hss_L2, TRUE)) {
+         while (GoNextStream(&hss_L2, TRUE)) {
+            ml_L2 = FindMacroStruct(hset_L2, 'p', hss_L2.sti);
+            find = FALSE;
+            for (s = smt->head; s != NULL; s = s->next) {
+               if (strcmp(ml_L2->id->name, s->l2) == 0) {
+                  id_L1 = GetLabId(s->l1, FALSE);
+                  ml_L1 = FindMacroName(hset_L1, 'p', id_L1);
+                  sti_L1 = (StreamInfo *) ml_L1->structure;
+
+                  for (m = 1; m <= hss_L2.sti->nMix; m++) {
+                     mp_L2 = hss_L2.sti->spdf.cpdf[m].mpdf;
+                     mp_L1 = sti_L1->spdf.cpdf[m].mpdf;
+                     if (VectorSize(mp_L2->mean) != VectorSize(mp_L1->mean))
+                        HError(6611, "PerformMapAdapt: Only support same vector size");
+                     if (VectorSize(mp_L2->mean) > 0) { /* if vector size = 0 then skip */
+                        ApplyMapXForm(mp_L2, mp_L1, hset_L1->curXForm, TRUE);
+                        hset_L2->ckind = hss_L2.mp->ckind;
+                     }
+                  }
+                  find = TRUE;
+                  break;
+               }
+            }
+            if (find == FALSE)
+               HError(-6611, "PerformMapAdapt: Can't find state mapping table for %s", ml_L2->id->name);
+         }
+      }
+   }
+   while (GoNextHMM(&hss_L2));
+   EndHMMScan(&hss_L2);
+
+   if (hset_L2->ckind == FULLC) {
+      NewHMMScan(hset_L2, &hss_L2);
+      while (GoNextMix(&hss_L2, FALSE)) {
+         hss_L2.mp->ckind = FULLC;
+      }
+      EndHMMScan(&hss_L2);
+   }
+}
+
+void AdaptXFormCommand()
+{
+   char fn[MAXFNAMELEN], macroname[MAXSTRLEN];
+   AdaptXForm *xf;
+   char c;
+   char mapping[MAXFNAMELEN];
+   char mmf_L2[MAXFNAMELEN];
+   char list_L2[MAXFNAMELEN];
+   char out_mmf[MAXFNAMELEN];
+   HMMSet hset_L2;
+   StateMappingTable smt;
+   char name_L1[MAXSTRLEN];
+   char name_L2[MAXSTRLEN];
+   FILE *fp;
+   Boolean is_pipe = FALSE;
+
+   ChkedAlpha("AX adapt Xform file name", fn);
+
+   /* check next args */
+   do {
+      c = GetCh(&source);
+      if (c == '\n')
+         break;
+   }
+   while (c != EOF && isspace(c));
+   UnGetCh(c, &source);
+
+   if (c == '\n' || c == EOF) {
+      /* apply xform */
+      if (trace & T_BID) {
+         printf("\nAX %s\n Setting HMMSet adapt XForm\n", fn);
+         fflush(stdout);
+      }
+      xf = LoadOneXForm(hset, NameOf(fn, macroname), fn);
+      SetXForm(hset, &xfInfo, xf);
+   } else {
+      /* apply xform to hset and another one */
+      ChkedAlpha("State mapping list", mapping);
+      ChkedAlpha("L2 mmf", mmf_L2);
+      ChkedAlpha("L2 model list", list_L2);
+      ChkedAlpha("Output mmf", out_mmf);
+
+      if (trace & T_BID) {
+         printf("\nAX %s %s %s %s %s\n Apply XForm to HMMSet and another one\n", fn, mapping, mmf_L2, list_L2, out_mmf);
+         fflush(stdout);
+      }
+
+      /* load state mapping table */
+      StateMappingTableInitialize(&smt);
+      fp = FOpen(mapping, NoFilter, &is_pipe);
+      if (fp == NULL)
+         HError(999, "AdaptXFormCommand: Can't open state mapping table");
+      while (fscanf(fp, "%s%s", name_L2, name_L1) == 2)
+         StateMappingTablePush(&smt, name_L1, name_L2);
+      FClose(fp, is_pipe);
+
+      /* L1 model */
+      SetParmHMMSet(hset);
+      if (hset->ckind == INVDIAGC)
+         ConvDiagC(hset, TRUE);
+
+      /* L2 model */
+      CreateHMMSet(&hset_L2, &hmmHeap, TRUE);
+      AddMMF(&hset_L2, mmf_L2);
+      if (MakeHMMSet(&hset_L2, list_L2) < SUCCESS)
+         HError(2321, "AdaptXFormCommand: MakeHMMSet failed");
+      if (LoadHMMSet(&hset_L2, hmmDir, hmmExt) < SUCCESS)
+         HError(2321, "AdaptXFormCommand: LoadHMMSet failed");
+      SetParmHMMSet(&hset_L2);
+      if (hset_L2.ckind == INVDIAGC)
+         ConvDiagC(&hset_L2, TRUE);
+
+      /* apply xform to L1 model */
+      xf = LoadOneXForm(hset, NameOf(fn, macroname), fn);
+      SetXForm(hset, &xfInfo, xf);
+
+      /* apply xform to L2 model and save HMMSet */
+      PerformMapAdapt(hset, &hset_L2, &smt);
+
+      /* save L2 model */
+      ConvDiagC(&hset_L2, TRUE);
+      SaveInOneFile(&hset_L2, out_mmf);
+      if (SaveHMMSet(&hset_L2, NULL, NULL, NULL, inBinary) < SUCCESS)
+         HError(2611, "PerformMapAdapt: SaveHMMSet failed");
+
+      /* free state mapping table */
+      StateMappingTableClear(&smt);
+      saveHMMSet = FALSE;
+   }
+}
+
 /* ----------------- ReOrderFeatures Command -------------------- */
 
 void ReOrderFeaturesCommand()
@@ -6323,22 +8633,772 @@ void ReOrderFeaturesCommand()
 	 printf(" RF: Transform re-ordered according to %d, %d, %d, ...\n",frv[1],frv[2],frv[3]);
 	 fflush(stdout);
       }
+      FreeMatrix(&gstack, tmpxf);
    }
    if (trace & T_BID) {
       printf(" RF: Parameters re-ordered according to %d, %d, %d, ...\n",frv[1],frv[2],frv[3]);
       fflush(stdout);
    }
+   
+   FreeVector(&gstack, tmpv);
+   FreeVector(&gstack, tmpm);
    FreeIntVec(&gstack,frv);
 }
 
+/* ----------------- JoinModel Command -------------------- */
+
+void JoinModelByState (ILink ilist, HMMSet *srcSet, HMMSet *dstSet)
+{
+   HLink hmm;
+   ILink p;
+   MLink mSrc, mDst;
+   StateElem *se;
+   StateInfo *si;
+   int j;
+   int state, N;
+
+   hmm = ilist->owner;
+   N = hmm->numStates;
+
+   for (j=2,state=0; j<hmm->numStates; j++)
+      if (hmm->svec+j==(StateElem *)ilist->item) {
+         state = j;
+         break;
+      }
+
+   if (state==0)
+      HError(2663,"JoinModelByState: cannot find state index");
+
+   for (p=ilist; p!=NULL; p=p->next) {
+      se = (StateElem *)p->item;
+      si = se->info;
+
+      mSrc = FindMacroStruct(srcSet,'s',si);
+      if (mSrc!=NULL) {  /* shared state */
+         mDst = FindMacroName(dstSet, 's', mSrc->id);
+
+         if (mDst==NULL) {
+            mDst = NewMacro(dstSet, mSrc->fidx, 's', mSrc->id, mSrc->structure);
+            si = (StateInfo *) mDst->structure;
+
+            if (trace&T_DET) {
+               printf(" Adding macro(state=%d) %s\n", state, mSrc->id->name);
+               fflush(stdout);
+            }
+         }
+         else {  /* already existed, update si */
+            si = (StateInfo *) mDst->structure;
+         }
+      }
+      else {  /* not a shared state */
+         if (trace&T_DET) {
+            mSrc = FindMacroStruct(srcSet,'h',p->owner);
+            HError(-2663,"JoinModelByState: not a shared stream (state=%d) in macro %s\n", state, mSrc->id->name);
+         }
+      }
+
+      /* then handle state itself */
+      mSrc = FindMacroStruct(srcSet, 'h', p->owner);
+      mDst = FindMacroName  (dstSet, 'h', mSrc->id);
+
+      (((HLink)mDst->structure)->svec + state)->info = si;
+   }
+
+   return;
+}
+
+void JoinModelByStream (ILink ilist, HMMSet *srcSet, HMMSet *dstSet)
+{
+   HLink hmm;
+   ILink p;
+   MLink mSrc, mDst;
+   StateElem *se;
+   StateInfo *si;
+   StreamElem *ste;
+   StreamInfo *sti;
+   int j, s;
+   int state, N;
+
+   hmm = ilist->owner;
+   N = hmm->numStates;
+
+   state = 0;
+   if (ilist->owner==ilist->item) {  /* never go here */
+      HError(-2663,"JoinModelByStream: Join Model on model level is not supported.\n");
+      state = -1;
+      return;
+   }
+   else {
+      for (j=2,state=0; j<hmm->numStates; j++)
+         if (hmm->svec+j==(StateElem *)ilist->item) {
+            state = j;
+            break;
+         }
+   }
+
+   if (state==0)
+      HError(2663,"JoinModelByStream: cannot find state index");
+
+   for (p=ilist; p!=NULL; p=p->next) {
+      se = (StateElem *) p->item;
+      si = se->info;
+
+      for(s=1; s<=srcSet->swidth[0]; s++) {
+         if (streams.set[s]) {
+            /* Merge this stream from srcSet to dstSet */
+            ste = si->pdf+s;
+            sti = ste->info;
+
+            /* First we handle shared macro */
+            mSrc = FindMacroStruct(srcSet,'p',sti);
+            if (mSrc!=NULL) {  /* shared stream */
+               mDst = FindMacroName(dstSet, 'p', mSrc->id);
+
+               if (mDst==NULL) {
+                  mDst = NewMacro(dstSet, mSrc->fidx, 'p', mSrc->id, mSrc->structure);
+                  sti = (StreamInfo *)mDst->structure;
+                  if (trace&T_DET) {
+                     printf(" Adding macro (state=%d, stream=%d) %s\n", state, s, mSrc->id->name);
+                     fflush(stdout);
+                  }
+               }
+               else {  /* already existed, update sti */
+                  sti = (StreamInfo *)mDst->structure;
+               }
+            }
+            else {
+               /* Not a shared stream */
+               if (trace & T_DET) {
+                  mSrc = FindMacroStruct(srcSet,'h',p->owner);
+                  HError(-2663,"JoinModelByStream: not a shared stream(state=%d, stream=%d) in macro %s\n", state, s, mSrc->id->name);
+               }
+            }
+
+            /* Then we handle stream itself */
+            mSrc = FindMacroStruct(srcSet, 'h', p->owner);
+            mDst = FindMacroName  (dstSet, 'h', mSrc->id);
+
+            (((((HLink)mDst->structure)->svec + state)->info)->pdf+s)->info = sti;
+         }
+      }
+   }
+
+   return;
+}
+
+void JoinModelCommand (void)
+{
+   HMMSet tmpSet;
+   HMMSet * tmpset;
+   char buf[MAXSTRLEN];
+
+   ILink ilist=NULL;  /* list of items to tie */
+   char type=' ';     /* type of items to tie */
+   char *pattern,*p;  /* pattern of items to use */
+   int s;
+
+   ChkedAlpha("JM MMF file name", buf);
+
+   CreateHMMSet(&tmpSet,&hmmHeap,TRUE);
+   tmpset = &tmpSet;
+   if(MakeHMMSet(&tmpSet,hmmListFn)<SUCCESS)
+      HError(2628,"JoinModelCommand: MakeHMMSet failed");
+   AddMMF(&tmpSet,buf);
+   if(LoadHMMSet(&tmpSet,NULL,NULL)<SUCCESS)
+      HError(2628,"JoinModelCommand: LoadHMMSet failed");
+
+   if (hset->swidth[0]!=tmpset->swidth[0])
+      HError(2630,"JoinModelCommand: num streams incompatible");
+   if (hset->pkind!=tmpset->pkind)
+      HError(2630,"JoinModelCommand: different parameter kinds");
+   if (hset->numLogHMM!=tmpset->numLogHMM)
+      HError(2630,"JoinModelCommand: different number of logical HMMs");
+   if (hset->numPhyHMM!=tmpset->numPhyHMM)
+      HError(2630,"JoinModelCommand: different number of physical HMMs");
+   ClearSet(streams);
+   pattern = PItemList(&ilist,&type,tmpset,&source,&streams,0,0,(trace&T_ITM)?TRUE:FALSE);
+
+   if (trace&T_BID) {
+      printf("JM %s %s\n", buf, pattern);
+      fflush(stdout);
+   }
+
+   /* extract specified model pattern */
+   if (type!='h') {
+      if ((p=strchr(pattern, '.'))==NULL)
+         HError(9999, "JoinModelCommand: Specified pattern does not include any dot");
+      *p = '}'; *(p+1) = '\0';
+   }
+
+   if (ilist==NULL) {
+      HError(-2631,"JoinModelCommand: No items to cluster\n");
+      return;
+   }
+
+   if (type=='h' || type=='s')
+      for (s=1;s<=hset->swidth[0];s++)
+         streams.set[s] = TRUE;
+
+   switch(type) {
+   case 's':
+      JoinModelByState(ilist, tmpset, hset); break;
+   case 'p':
+      JoinModelByStream(ilist, tmpset, hset); break;
+   case 'h':
+   default:
+      HError(2663,"JoinModelCommand: type %c is not supported", type);
+      break;
+   }
+
+   if (CheckHSet(hset)<SUCCESS){
+      ResetHMMSet(hset);
+      HRError(7031,"LoadHMMSet: Invalid HMM data");
+      return;
+   }
+
+   SetIndexes(hset);
+   SetCovKindUsage(hset);
+   SetParmHMMSet(hset);
+
+   return;
+}
+
+/* ----------------- DR - Convert decision trees to a regression tree for adaptation --------------- */
+
+void AssignHMMsToNodes (Tree *tree)
+{
+   char buf[MAXSTRLEN];
+   int h;
+   MLink q;
+   HLink hmm;
+   LabId tid=NULL;
+   Node *node;
+   Boolean isYes=FALSE;
+
+   for (h=0; h<MACHASHSIZE; h++)
+      for (q=hset->mtab[h]; q!=NULL; q=q->next)
+         if (q->type=='h') {
+            hmm=(HLink) q->structure;
+
+            /* First find Tree to use */
+            strcpy(buf,q->id->name);
+            if (!usePattern) {
+               if (strchr(buf,'*')!=NULL || strchr(buf,'?')!=NULL)
+                  HError(9999,"AssignHMMsToNodes: baseId %s includes pattern character", buf);
+               TriStrip(buf); 
+               MapTreeName(buf);
+               tid = GetLabId(buf,FALSE);
+            }
+            
+            if (((usePattern && IPatMatch(buf, tree->patList)) 
+              || singleTree 
+              || (!singleTree && !usePattern && tree->baseId == tid))) {  /* check this model matches to this tree */    
+     
+               /* traverse tree */
+               node = tree->root;
+               while (node->yes != NULL) {
+                  isYes = QMatch(q->id->name,node->quest);
+                  node = (isYes) ? node->yes : node->no;
+               }
+
+               /* originally node->qlist is used to store active questions in a node, 
+                * but here we use it to store HMM/macro list which is assigned to the node */
+               AddItem(hmm,q,&node->qlist);
+            }
+         }
+   
+   return;                    
+}
+
+/* NumSpaces: return number of spaces in the s-th stream */
+int NumSpaces (IMatrix vecSize, const int s)
+{
+   int j;
+   
+   for (j=1; j<=maxMixes && vecSize[s][j]>=0; j++);
+   
+   return j-1;
+}     
+
+/* InitDec2Reg: initialization for decision trees to a regression tree conversion */
+void InitDec2Reg (ILink ***st, IMatrix *vs)
+{
+   int j, m, s;
+   int vSize, state;
+   StreamInfo *sti;
+   HLink hmm;
+   Tree *tree;
+   Node *node;
+   ILink p, strTree[SMAX], **spaceTree;
+   IMatrix vecSize;
+   HMMScanState hss;
+   Boolean added;
+   
+   const int maxM = maxMixes;
+   
+   /* initialize strTree and spaceTree */
+   spaceTree = (ILink **) New(&tmpHeap, hset->swidth[0]*sizeof(ILink *));
+   spaceTree--;
+   for (s=1; s<=hset->swidth[0]; s++) {
+      spaceTree[s] = (ILink *) New(&tmpHeap, maxM*sizeof(ILink));
+      spaceTree[s]--;
+      for (m=1; m<=maxM; m++) 
+         spaceTree[s][m] = NULL;
+      strTree[s] = NULL;
+   }
+   
+   /* set vector size of spaces in each stream */
+   vecSize = CreateIMatrix(&tmpHeap, hset->swidth[0], maxM);
+   for (s=1; s<=hset->swidth[0]; s++) 
+      for (m=1; m<=maxM; m++)
+         vecSize[s][m] = -1;  
+   
+   NewHMMScan(hset, &hss);
+   while (GoNextMix(&hss,FALSE)) {
+      vSize = VectorSize(hss.mp->mean);
+      for (m=1; m<=maxM; m++) {
+         if (vSize==vecSize[hss.s][m])
+            break;
+         if (vecSize[hss.s][m]==-1) {
+            vecSize[hss.s][m] = vSize;
+            break;
+         }
+      }
+   }
+   EndHMMScan(&hss);
+   
+   /* assign HMM lists to terminal nodes of decision trees 
+    * and cluster trees to streams */   
+   for (tree=treeList; tree!=NULL; tree=tree->next) {
+      AssignHMMsToNodes(tree);
+      for (s=1; s<=hset->swidth[0]; s++) 
+         if (tree->streams.set[s])
+            AddItem(NULL, tree, &strTree[s]);
+   }
+   
+   /* compose tree list for each space of each stream */      
+   for (s=1; s<=hset->swidth[0]; s++) {
+      for (j=1; j<=maxM && vecSize[s][j]!=-1; j++) {
+         for (p=strTree[s]; p!=NULL; p=p->next) {
+            tree = (Tree *) p->item;
+            added = FALSE;
+            for (node=tree->leaf; node!=NULL; node=node->next) {
+               hmm = node->qlist->owner;
+               
+               for (state=((tree->state>0)?tree->state:2); state<=((tree->state>0)?tree->state:hmm->numStates-1); state++) {
+                  sti = hmm->svec[state].info->pdf[s].info;
+            
+                  for (m=1; m<=sti->nMix; m++) {
+                     if (VectorSize(sti->spdf.cpdf[m].mpdf->mean)==vecSize[s][j]) {
+                        AddItem(NULL, tree, &spaceTree[s][j]);
+                        added = TRUE;
+                        break;
+                     }
+                  }   
+                  if (added) break;
+               }
+               if (added) break;
+            }
+         }
+      }
+   }
+   
+   /* free itemlist for stream tree lists */
+   for (s=1; s<=hset->swidth[0]; s++) 
+      FreeItems(&strTree[s]);
+   
+   if (trace & T_BID) {
+      for (s=1; s<=hset->swidth[0]; s++) {
+         printf(" Stream %d has %d space(s)\n", s, NumSpaces(vecSize, s));
+         for (j=1; j<=NumSpaces(vecSize, s); j++) {
+            printf("  space %d: vSize=%d #trees=%d\n",j,vecSize[s][j],NumItems(spaceTree[s][j]));
+         }
+         printf("\n");
+      }
+   }
+   
+   *vs = vecSize;
+   *st = spaceTree;
+                   
+   return;
+}
+
+/* ResetDec2Reg: free objects used in Dec2Reg */
+void ResetDec2Reg (ILink ***st, IMatrix *vs)
+{
+   int m, s;
+   Tree *tree;
+   Node *node;
+   ILink **spaceTree = *st;
+   IMatrix vecSize = *vs;
+   
+   for (tree=treeList; tree!=NULL; tree=tree->next)
+      for (node=tree->leaf; node!=NULL; node=node->next)
+         FreeItems(&node->qlist);
+         
+   FreeIMatrix(&tmpHeap, vecSize);
+   
+   for (s=hset->swidth[0]; s>0; s--) {
+      for (m=1; m<=maxMixes; m++)
+         FreeItems(&spaceTree[s][m]);
+      spaceTree[s]++;
+      Dispose(&tmpHeap, spaceTree[s]);
+   }
+   spaceTree++;
+   Dispose(&tmpHeap, spaceTree);
+                   
+   return;
+}
+
+void PrintNodeBaseClass (FILE *f, ILink ilist, const int state, const int stream, const int class, const int vSize)
+{
+   int m,j;
+   ILink c;
+   MLink macro;
+   HLink hmm;
+   StreamInfo *sti; 
+   Boolean first=TRUE,firstmix;
+   
+   fprintf(f,"<CLASS> %d {", class);
+   
+   for (c=ilist; c!=NULL; c=c->next) {
+      macro = (MLink) c->item;
+      hmm = c->owner;
+      for (j=((state>0)?state:2); j<=((state>0)?state:hmm->numStates-1); j++) {
+         sti = hmm->svec[j].info->pdf[stream].info;
+         firstmix=TRUE;
+         for (m=1; m<=sti->nMix; m++) {
+            if (VectorSize(sti->spdf.cpdf[m].mpdf->mean)==vSize) {
+               if (!IsSeen(sti->spdf.cpdf[m].mpdf->nUse)) {
+                  /* print baseclass */
+                  if (firstmix && !first) fprintf(f,",");
+                  if (hset->swidth[0] == 1) { /* single stream case */
+                     if (firstmix) {
+                        fprintf(f,"%s.state[%d].mix[%d", macro->id->name, j, m);
+                        firstmix=FALSE;
+                     }
+                     else
+                        fprintf(f,",%d", m);
+                  }
+                  else {
+                     if (firstmix) { 
+                        fprintf(f,"%s.state[%d].stream[%d].mix[%d", macro->id->name, j, stream, m);
+                        firstmix=FALSE;
+                     }
+                     else
+                        fprintf(f,",%d", m);
+                  }
+                  first = FALSE;
+                  Touch(&sti->spdf.cpdf[m].mpdf->nUse);
+               }
+            }
+         }
+         if (!firstmix)
+            fprintf(f,"]");
+      }
+   }
+   fprintf(f,"}\n");
+   
+   return;
+}
+
+CLink GetChildCList (Node *node)
+{
+   CLink p;
+   
+   /* yes node */
+   if (node->yes!=NULL) {
+      if (node->clist==NULL)
+         node->clist = GetChildCList(node->yes);
+      else {
+         for (p=node->clist; p->next!=NULL; p=p->next);
+         p->next = GetChildCList(node->yes);
+      }
+   }
+   /* no node */
+   if (node->no!=NULL) {
+      if (node->clist==NULL)
+         node->clist = GetChildCList(node->no);
+      else {
+         for (p=node->clist; p->next!=NULL; p=p->next);
+         p->next = GetChildCList(node->no);
+      }
+   }
+   
+   return node->clist;
+}
+
+void ShrinkTree(Tree *tree, Node *node, int *snum, const float threshold)
+{
+   if (node->yes!=NULL && node->occ>threshold && node->yes->occ>0.0 && node->no->occ>0.0) {
+      node->snum = *snum; (*snum)++;
+      ShrinkTree(tree, node->yes, snum, threshold);
+      ShrinkTree(tree, node->no,  snum, threshold);
+   }
+   else {
+      /* link leaf list */
+      node->next=tree->leaf;
+      if (tree->leaf) tree->leaf->prev=node;
+      node->prev=NULL;
+      tree->leaf=node;
+         
+      /* initialize variables */
+      node->clist = GetChildCList(node);
+      node->yes = node->no = NULL;
+      node->quest = NULL;
+      
+      /* update # of clusters count */
+      numTreeClust++;
+   }
+   
+   return;
+}
+
+void DecTrees2RegTreeCommand(void)
+{
+   char buf[MAXSTRLEN], fname1[MAXFNAMELEN], fname2[MAXFNAMELEN], tname[MAXSTRLEN], bname[MAXSTRLEN], macroname[MAXSTRLEN];
+   int i, j, s, snum;
+   int bias, tindex, tnodeindex, tmpindex, nclass;
+   FILE *f1=NULL, *f2=NULL;
+   Boolean isPipe1, isPipe2, zeroOcc;
+   Tree *tree;
+   Node *node, *leaf, **array;
+   ILink p, **spaceTree;
+   IMatrix vecSize;
+   
+   ChkedAlpha("DR regression tree identifier", buf);
+   
+   if (trace & T_BID) {
+      printf("\nDR: Convert decision trees to a regression tree\n");
+      fflush(stdout);
+   }
+
+   if (treeList==NULL)
+      HError(2655,"DecTrees2RegTreeCommand: No decision trees loaded - use LT command first");
+   
+   if (shrinkOccThresh!=NULL) {
+      if (!occStatsLoaded)
+         HError(2655,"DecTrees2RegTreeCommand: Shrinking tree requires stats - use LS command");
+   
+      for (tree=treeList; tree!=NULL; tree=tree->next) {
+         /* get stream index */
+         for (s=1; s<=hset->swidth[0]; s++) 
+            if (tree->streams.set[s]) break;
+
+         /* update occ counts of all nodes */
+         for (leaf=tree->leaf,zeroOcc=TRUE; leaf!=NULL; leaf=leaf->next) {
+            if (tree->nLeaves > 1) {
+            for (node=leaf; node->parent!=NULL; node=node->parent) {
+               node->parent->occ += leaf->occ;
+               if (leaf->occ>0.0)
+                  zeroOcc = FALSE;
+            }
+            } else {
+               if (leaf->occ>0.0)
+                  zeroOcc = FALSE;
+            }
+         }
+         if (zeroOcc)
+            HError(9999,"DecTree2RegTree: Load stats file before loading tree files.");
+      
+         /* shrink tree */
+         tree->leaf=NULL; numTreeClust=0; snum=0;  
+         ShrinkTree(tree,tree->root,&snum,shrinkOccThresh[s]);
+         if (trace & T_BID) {
+            if (tree->state>0)
+               printf(" Tree %s.state[%d]",ReWriteString(tree->baseId->name,NULL,ESCAPE_CHAR),tree->state);
+            else
+               printf(" Tree %s",tree->baseId->name);
+            if (tree->nActiveStr==hset->swidth[0])
+               printf("\n");
+            else {
+               printf(".stream[");         /* output active stream of current tree */
+               for (i=1,j=1; j<=hset->swidth[0]; j++)
+                  if (tree->streams.set[j])
+                     printf("%d%s",j,(i++<tree->nActiveStr)?",":"]\n");
+            }
+            printf("  %d leaf nodes were pruned into %d nodes (occ thresh=%.1f)\n\n",
+                   tree->nLeaves, numTreeClust, shrinkOccThresh[s]);
+            fflush(stdout);
+         }
+         tree->nLeaves=numTreeClust; tree->size=snum;
+      }
+   }
+   
+   /* initialization */
+   InitDec2Reg(&spaceTree, &vecSize);
+   
+   /* now store the baseclasses and regression classes */
+   MakeFN(buf,newDir,"tree",fname1);
+   if ((f1=FOpen(fname1,NoOFilter,&isPipe1)) == NULL) {
+      HError(999,"DecTrees2RegTreeCommand: Cannot create output file %s",fname1);
+   }
+   MakeFN(buf,newDir,"base",fname2);
+   if ((f2=FOpen(fname2,NoOFilter,&isPipe2)) == NULL) {
+      HError(999,"DecTrees2RegTreeCommand: Cannot create output file %s",fname2);
+   }
+   MakeFN(buf,NULL,"tree",tname);
+   MakeFN(buf,NULL,"base",bname);
+   
+   /* print baseclass and tree names to regression tree file */
+   fprintf(f1,"~r %s\n",ReWriteString(tname,NULL,DBL_QUOTE));
+   fprintf(f1,"<BASECLASS>~b %s\n",ReWriteString(bname,NULL,DBL_QUOTE));
+   
+   /* print baseclass macro name and header to regression class file */
+   fprintf(f2,"~b %s\n",ReWriteString(bname,NULL,DBL_QUOTE));
+   fprintf(f2,"<MMFIDMASK> %s\n",mmfIdMask);
+   fprintf(f2,"<PARAMETERS> MIXBASE\n");
+   
+   /* print <StreamInfo> if multiple stream */
+   if (hset->swidth[0]>1) {
+      fprintf(f2,"<STREAMINFO> ");
+      WriteShort(f2, hset->swidth, 1, FALSE);
+      for (i=1; i<=hset->swidth[0]; i++)
+         WriteShort(f2, hset->swidth+i, 1, FALSE);
+      fprintf(f2,"\n");
+   }
+   
+   
+   /* first output root node of the regression tree (separate streams) */
+   bias=1; tmpindex=2;
+   fprintf(f1,"<NODE> %d %d", bias++, hset->swidth[0]);
+   for (s=1; s<=hset->swidth[0]; s++)
+      fprintf(f1, " %d", tmpindex++);
+   fprintf(f1, "\n");
+   fflush(f1);
+   
+   /* secondly output nodes for each stream (separate MSD spaces) */
+   tmpindex = bias + hset->swidth[0];
+   for (s=1; s<=hset->swidth[0]; s++) {
+      fprintf(f1,"<NODE> %d %d", bias++, NumSpaces(vecSize, s));
+      for (i=1; i<=NumSpaces(vecSize, s); i++)
+         fprintf(f1," %d", tmpindex++);
+      fprintf(f1,"\n");
+   }     
+   fflush(f1);
+   
+   /* thirdly output nodes for each space (separate decision trees) 
+    * and number of baseclasses (leaf nodes) */
+   tmpindex = bias;
+   nclass = 0;
+   for (s=1; s<=hset->swidth[0]; s++)
+      tmpindex += NumSpaces(vecSize, s);
+   for (s=1; s<=hset->swidth[0]; s++) {
+      for (i=1; i<=NumSpaces(vecSize, s); i++) {
+         fprintf(f1,"<NODE> %d %d", bias++, NumItems(spaceTree[s][i]));
+         for (p=spaceTree[s][i]; p!=NULL; p=p->next) {
+            tree = (Tree *) p->item;
+            fprintf(f1," %d", tmpindex);
+            tmpindex += tree->size + tree->nLeaves;
+            nclass += tree->nLeaves;
+         }
+         fprintf(f1,"\n");
+      }
+   }
+   fprintf(f2,"<NUMCLASSES> %d\n",nclass);
+   fflush(f1);
+   fflush(f2);
+   
+   /* finally output each decision tree */
+   tindex=1;
+   for (s=1; s<=hset->swidth[0]; s++) {  /* process multiple streams */
+      for (j=1; j<=NumSpaces(vecSize, s); j++) {
+         for (p=spaceTree[s][j]; p!=NULL; p=p->next) {
+            tree = (Tree *)p->item; 
+            if (tree->size==0) {
+               fprintf(f1, "<TNODE> %d 1 %d\n", bias++, tindex);
+               PrintNodeBaseClass(f2, tree->root->qlist, tree->state, s, tindex, vecSize[s][j]);
+               tindex++;
+            }
+            else {
+               array=(Node**) New(&tmpHeap,sizeof(Node*)*tree->size);
+               for (i=0; i<tree->size; i++)  array[i]=NULL;
+               DownTree(tree->root,array);
+         
+               tnodeindex = bias+tree->size;
+               tmpindex = tindex;
+               for (i=0; i<tree->size; i++) {
+                  node=array[i];
+                  if (node==NULL) 
+                     HError(2695,"DecTrees2RegTreeCommand: Cannot find node %d",i);
+                  if (node->yes==NULL || node->no==NULL) 
+                     HError(2695,"DecTrees2RegTreeCommand: Node %d has no children",i);
+               
+                  fprintf(f1,"<NODE> %d 2", bias+i);
+               
+                  /* no node */
+                  if (node->no->yes)
+                     fprintf(f1," %d", bias+node->no->snum);
+                  else {
+                     PrintNodeBaseClass(f2, node->no->qlist, tree->state, s, tmpindex++, vecSize[s][j]);
+                     fprintf(f1," %d", tnodeindex++);
+                  }
+                  /* yes node */
+                  if (node->yes->yes)
+                     fprintf(f1," %d\n", bias+node->yes->snum);
+                  else {
+                     PrintNodeBaseClass(f2, node->yes->qlist, tree->state, s, tmpindex++, vecSize[s][j]);
+                     fprintf(f1," %d\n", tnodeindex++);
+                  }
+               }
+         
+               /* output terminal nodes */
+               for (i=bias+tree->size; i<tnodeindex; i++)
+               fprintf(f1, "<TNODE> %d 1 %d\n", i, tindex++);  
+               bias += tree->size+tree->nLeaves;
+            
+               Dispose(&tmpHeap,array);
+            }
+            fflush(f1);
+            fflush(f2);
+         }
+      }
+   }
+   ClearSeenFlags(hset,CLR_ALL);
+   
+   ResetDec2Reg(&spaceTree, &vecSize);
+   
+   FClose(f2,isPipe2);  
+   FClose(f1,isPipe1);  
+   
+   if (trace & T_BID) {
+      printf(" Conversion finished.\n");
+      printf(" A regression tree with %d nodes (#terminal nodes=%d) and its baseclass were generated.\n", bias, nclass);
+      fflush(stdout);
+   }
+    
+   /* Create the macros so they can be stored with the models */
+   LoadBaseClass(hset,NameOf(bname,macroname),fname2);  
+   LoadRegTree(hset,NameOf(tname,macroname),fname1);  
+}
+
+/* -------------------- Comment Command -------------------- */
+
+void CommentCommand()
+{
+   if (trace > 0) {
+      char comment[MAXSTRLEN];
+      
+      /* read this line from source */
+      ReadLine(&source, comment);
+      
+      /* output comment */
+      fflush(stdout);
+      printf("\n// %s",comment);
+      fflush(stdout);
+   }
+   else
+      /* skip this line */
+      SkipLine(&source);
+}
 
 /* -------------------- Initialisation --------------------- */
  
 void Initialise(char *hmmListFn)
 {
   
-   CreateHeap(&questHeap,"Question Heap",MSTAK,1,1.0,8000,16000);
-   CreateHeap(&tmpHeap,"Temporary Heap",MSTAK,1,1.0,40000,400000);
+   CreateHeap(&questHeap,"Question Heap",MSTAK,1,1.0,8000,200000);
+   CreateHeap(&tmpHeap,"Temporary Heap",MSTAK,1,1.0,40000,1600000);
 
 
    if(MakeHMMSet(&hSet,hmmListFn)<SUCCESS)
@@ -6350,6 +9410,8 @@ void Initialise(char *hmmListFn)
    maxStates = MaxStatesInSet(hset);
    maxMixes = MaxMixInSet(hset);
 
+   streams = CreateSet(SMAX);
+
    if (trace != 0) {
       printf("HHEd\n");
       printf(" %d/%d Models Loaded [%d states max, %d mixes max]\n",
@@ -6357,26 +9419,27 @@ void Initialise(char *hmmListFn)
       fflush(stdout);
    }
 
+   SetVFloor(hset, vf, minVar);
 }
 
 /* -------------------- Top Level of Editing ---------------- */
 
 
-static int  nCmds = 40;
+static int  nCmds = 52;
 
-static char *cmdmap[] = {"AT","RT","SS","CL","CO","JO","MU","TI","UF","NC",
+static char *cmdmap[] = {"AT","RT","SS","CL","CM","CO","CT","JO","MU","TI","UF","NC","SM",
                          "TC","UT","MT","SH","SU","SW","SK",
                          "RC",
                          "RO","RM","RN","RP",
                          "LS","QS","TB","TR","AU","GQ","MD","ST","LT",
-                         "MM","DP","HK","FC","FA","FV","XF","PS","PR","" };
+                         "MM","DP","HK","FC","DV","FA","FV","IX","PX","AX","PS","PR","DR","DM","IT","JM","//","" };
 
-typedef enum           { AT=1, RT , SS , CL , CO , JO , MU , TI , UF , NC ,
+typedef enum           { AT=1,RT , SS , CL , CM , CO , CT , JO , MU , TI , UF , NC , SM ,
                          TC , UT , MT , SH , SU , SW , SK ,
                          RC ,
                          RO , RM , RN , RP ,
                          LS , QS , TB , TR , AU , GQ , MD , ST , LT ,
-                         MM , DP , HK , FC , FA , FV, XF, PS, PR }
+                         MM , DP , HK , FC , DV , FA , FV , IX , PX , AX , PS , PR , DR , DM , IT , JM , XX }
 cmdNum;
 
 /* CmdIndex: return index 1..N of given command */
@@ -6416,12 +9479,15 @@ void DoEdit(char * editFn)
       case RT: EditTransMat(FALSE); break;
       case SS: SplitStreamCommand(FALSE); break;
       case CL: CloneCommand(); break;
+      case CM: ConvertModelsCommand(); break;
       case CO: CompactCommand(); break;
+      case CT: ConvertTreesCommand(); break;
       case JO: JoinSizeCommand(); break;
       case MU: MixUpCommand(); break;
       case MD: MixDownCommand(); break;
       case TI: TieCommand(); break;
       case NC: ClusterCommand(TRUE); break;
+      case SM: StateMappingCommand(); break;
       case TC: ClusterCommand(FALSE); break;
       case UT: UntieCommand(); break;
       case MT: MakeTriCommand(); break;
@@ -6443,14 +9509,22 @@ void DoEdit(char * editFn)
       case ST: ShowTreesCommand(); break;
       case LT: LoadTreesCommand(); break;
       case MM: MakeIntoMacrosCommand(); break;
+      case DM: DeleteMacroCommand(); break;
       case DP: DuplicateCommand(); break;
-      case XF: InputXFormCommand(); break;
+      case IX: InputXFormCommand(); break;
+      case PX: ParentXFormCommand(); break;
+      case AX: AdaptXFormCommand(); break;
       case UF: UseCommand(); break;
       case FA: FloorAverageCommand(); break;
       case FC: FullCovarCommand(); break;
+      case DV: DiagVarCommand(); break;
       case FV: FloorVectorCommand(); break;
       case PS: PowerSizeCommand(); break;
       case PR: ProjectCommand(); break;
+      case DR: DecTrees2RegTreeCommand(); break;
+      case IT: ImposeTreeCommand (); break;
+      case JM: JoinModelCommand(); break;
+      case XX: CommentCommand(); break;
       default: 
          HError(2650,"DoEdit: Command %s not recognised",cmds);
       }
@@ -6466,9 +9540,12 @@ void DoEdit(char * editFn)
          printf("\nSaving new HMM files ...\n");
          fflush(stdout);
       }
+      if (badGC) {
       FixAllGConsts(hset);         /* in case any bad gConsts around */
       badGC=FALSE;
+      }
       PurgeMacros(hset);
+
       if (mmfFn!=NULL)
          SaveInOneFile(hset,mmfFn);
       if(SaveHMMSet(&hSet,newDir,newExt,NULL,inBinary)<SUCCESS)
diff -pbBEwurNa --ignore-matching-lines='.*vc_id.*' HTK-3.4.1/HTKTools/HInit.c HTS-2.2_for_HTK-3.4.1/HTKTools/HInit.c
--- HTK-3.4.1/HTKTools/HInit.c	2009-03-13 03:52:22.000000000 +0900
+++ HTS-2.2_for_HTK-3.4.1/HTKTools/HInit.c	2011-06-16 13:18:30.000000000 +0900
@@ -32,8 +32,53 @@
 /*         File: HInit.c: HMM initialisation program           */
 /* ----------------------------------------------------------- */
 
+/*  *** THIS IS A MODIFIED VERSION OF HTK ***                        */
+/* ----------------------------------------------------------------- */
+/*           The HMM-Based Speech Synthesis System (HTS)             */
+/*           developed by HTS Working Group                          */
+/*           http://hts.sp.nitech.ac.jp/                             */
+/* ----------------------------------------------------------------- */
+/*                                                                   */
+/*  Copyright (c) 2001-2011  Nagoya Institute of Technology          */
+/*                           Department of Computer Science          */
+/*                                                                   */
+/*                2001-2008  Tokyo Institute of Technology           */
+/*                           Interdisciplinary Graduate School of    */
+/*                           Science and Engineering                 */
+/*                                                                   */
+/* All rights reserved.                                              */
+/*                                                                   */
+/* Redistribution and use in source and binary forms, with or        */
+/* without modification, are permitted provided that the following   */
+/* conditions are met:                                               */
+/*                                                                   */
+/* - Redistributions of source code must retain the above copyright  */
+/*   notice, this list of conditions and the following disclaimer.   */
+/* - Redistributions in binary form must reproduce the above         */
+/*   copyright notice, this list of conditions and the following     */
+/*   disclaimer in the documentation and/or other materials provided */
+/*   with the distribution.                                          */
+/* - Neither the name of the HTS working group nor the names of its  */
+/*   contributors may be used to endorse or promote products derived */
+/*   from this software without specific prior written permission.   */
+/*                                                                   */
+/* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND            */
+/* CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,       */
+/* INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF          */
+/* MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE          */
+/* DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS */
+/* BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,          */
+/* EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED   */
+/* TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,     */
+/* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON */
+/* ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,   */
+/* OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY    */
+/* OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE           */
+/* POSSIBILITY OF SUCH DAMAGE.                                       */
+/* ----------------------------------------------------------------- */
+
 char *hinit_version = "!HVER!HInit:   3.4.1 [CUED 12/03/09]";
-char *hinit_vc_id = "$Id: HInit.c,v 1.1.1.1 2006/10/11 09:55:01 jal58 Exp $";
+char *hinit_vc_id = "$Id: HInit.c,v 1.13 2011/06/16 04:18:30 uratec Exp $";
 
 /*
    This program is used to initialise (or tune) a single hidden
@@ -98,6 +143,7 @@ static HLink hmmLink;            /* link
 static int maxMixInS[SMAX];      /* array[1..swidth[0]] of max mixes */
 static int nStates;              /* number of states in hmm */
 static int nStreams;             /* number of streams in hmm */
+static MSDInfo ***msdInfo;       /* MSD information */
 static SegStore segStore;        /* Storage for data segments */
 static MemHeap segmentStack;     /* Used by segStore */
 static MemHeap sequenceStack;    /* For storage of sequences */
@@ -105,12 +151,15 @@ static MemHeap clustSetStack;    /* For 
 static MemHeap transStack;       /* For storage of transcription */
 static MemHeap traceBackStack;   /* For storage of traceBack info */
 static MemHeap bufferStack;      /* For storage of buffer */
+static MemHeap msdinfoStack;     /* For storage of msdinfo */
 static ParmBuf pbuf;             /* Currently input parm buffer */
 
 /* Storage for Viterbi Decoding */
 static Vector   thisP,lastP;     /* Columns of log probabilities */
 static short   **traceBack;      /* array[1..segLen][2..numStates-1] */
    
+/* Variable for Multi-Space probability Density */   
+static Boolean ignOutVec = TRUE;    /* ignore outlier vector */
 
 /* ---------------- Process Conf File & Command Line ----------------- */
 
@@ -127,9 +176,11 @@ void SetConfParms(void)
 
 void ReportUsage(void)
 {
+   printf("\nModified for HTS\n");
    printf("\nUSAGE: HInit [options] hmmFile trainFiles...\n\n");
    printf(" Option                                       Default\n\n");
    printf(" -e f    Set convergence factor epsilon       1.0E-4\n");
+   printf(" -g      Ignore outlier vector in MSD                      on\n");
    printf(" -i N    Set max iterations to N              20\n");
    printf(" -l s    Set segment label to s               none\n");
    printf(" -m N    Set min segments needed              3\n");
@@ -138,7 +189,7 @@ void ReportUsage(void)
    printf(" -u mvwt Update m)eans v)ars w)ghts t)rans    mvwt\n");
    printf(" -v f    Set minimum variance to f            1.0E-2\n");
    printf(" -w f    set mix wt/disc prob floor to f      0.0\n");
-   PrintStdOpts("BFGHILMX");
+   PrintStdOpts("BFGHILMXS");
    printf("\n\n");
 }
 
@@ -194,6 +245,8 @@ int main(int argc, char *argv[])
       switch(s[0]){
       case 'e':
          epsilon = GetChkedFlt(0.0,1.0,s); break;
+      case 'g':
+         ignOutVec = FALSE; break;
       case 'i':
          maxIter = GetChkedInt(0,100,s); break;
       case 'l':
@@ -284,6 +337,28 @@ int main(int argc, char *argv[])
    if (trace&T_TOP)
       printf("Output written to directory %s\n",
              outDir==NULL?"current":outDir);
+   
+   InitMem();   InitLabel();
+   InitMath();  InitSigP();
+   InitWave();  InitAudio();
+   InitVQ();    InitModel();
+   if(InitParm()<SUCCESS)  
+      HError(2100,"HInit: InitParm failed");
+   InitTrain(); InitUtil();
+   
+   ResetUtil();
+   ResetTrain();
+   ResetParm();
+   ResetModel();
+   ResetVQ();
+   ResetAudio();
+   ResetWave();
+   ResetSigP();
+   ResetMath();
+   ResetLabel();
+   ResetMem();
+   ResetShell();
+   
    Exit(0);
    return (0);          /* never reached -- make compiler happy */
 }
@@ -332,6 +407,7 @@ void Initialise(void)
    CreateHeap(&transStack,"TransStore", MSTAK, 1, 0.0, 1000, 1000);
    CreateHeap(&traceBackStack,"TraceBackStore", MSTAK, 1, 0.0, 1000, 1000);
    CreateHeap(&bufferStack,"BufferStore", MSTAK, 1, 0.0, 1000, 1000);
+   CreateHeap(&msdinfoStack,"MSDInfoStore", MSTAK, 1, 0.0, 1000, 1000);
 
    /* Load HMM def */
    if(MakeOneHMM( &hset, BaseOf(hmmfn,base))<SUCCESS)
@@ -351,6 +427,7 @@ void Initialise(void)
    nStreams = hset.swidth[0];
    for(s=1; s<=nStreams; s++)
       maxMixInS[s] = MaxMixInS(hmmLink, s);
+   msdInfo = CreateMSDInfo(&msdinfoStack, hmmLink);
 
    SetVFloor( &hset, vFloor, minVar);
 
@@ -371,7 +448,7 @@ void InitSegStore(BufferInfo *info)
 
    SetStreamWidths(info->tgtPK,info->tgtVecSize,hset.swidth,&eSep);
    obs = MakeObservation(&gstack,hset.swidth,info->tgtPK,
-                         hset.hsKind==DISCRETEHS,eSep);
+                         ((hset.hsKind==DISCRETEHS) ? TRUE:FALSE),eSep);
    segStore = CreateSegStore(&segmentStack,obs,10);
    firstTime = FALSE;
 }
@@ -398,7 +475,7 @@ void CheckData(char *fn, BufferInfo info
 void LoadFile(char *fn)
 {
    BufferInfo info;
-   char labfn[80];
+   char labfn[MAXSTRLEN];
    Transcription *trans;
    long segStIdx,segEnIdx;
    static int segIdx=1;  /* Between call handle on latest seg in segStore */  
@@ -469,42 +546,50 @@ void LoadFile(char *fn)
 
 
 /* CreateSeqMat: Create a matrix of sequences */
-Sequence ** CreateSeqMat(void)
+Sequence *** CreateSeqMat(void)
 {
-   int i,j;
-   Sequence **seqMat;
+   int i,j,k,nKindS;
+   Sequence ***seqMat;
 
-   seqMat = (Sequence**)New(&sequenceStack,(nStates-2)*sizeof(Sequence*));
+   seqMat = (Sequence***)New(&sequenceStack,(nStates-2)*sizeof(Sequence**));
    seqMat -= 2;   /* index is 2, ...,nStates-1 */
    for (i=2; i<nStates; i++){
-      seqMat[i] = (Sequence*)New(&gstack, nStreams*sizeof(Sequence));
+      seqMat[i] = (Sequence**)New(&gstack, nStreams*sizeof(Sequence*));
       --seqMat[i];
       for (j=1; j<=nStreams; j++ ){
-         seqMat[i][j] = CreateSequence(&sequenceStack, 100);
+         nKindS = msdInfo[i][j]->nKindS;
+         seqMat[i][j] = (Sequence*)New(&gstack, nKindS*sizeof(Sequence));
+         --seqMat[i][j];
+         for(k=1; k<=nKindS; k++)
+            seqMat[i][j][k] = CreateSequence(&sequenceStack, 100);
       }
    }
    return seqMat;
 }
 
 /* ShowSeqMat: show number of obs for each state/stream */
-void ShowSeqMat(Sequence **seqMat)
+void ShowSeqMat(Sequence ***seqMat)
 {
-   int j,s;
+   int j,s,k,nKindS;
    
    printf("Sequence Matrix\n");
    for (j=2; j<nStates; j++) {
-      printf(" state %2d: ",j);
-      for (s=1; s<=nStreams; s++)
-         printf("%5d",seqMat[j][s]->nItems);
+      printf(" state %2d: \n",j);
+      for (s=1; s<=nStreams; s++) {
+         printf("  stream %2d: ",s);
+         nKindS = msdInfo[j][s]->nKindS;
+         for (k=1; k<=nKindS; k++)
+            printf("%8d",seqMat[j][s][k]->nItems);
       printf("\n");
    }
 }
+}
 
 /* UCollectData: Collect data from segStore for each stream s of each 
    state n and store in seqMat[n][s]*/
-void UCollectData(Sequence **seqMat)
+void UCollectData(Sequence ***seqMat)
 {
-   int i,j,n,s,numSegs,segLen;
+   int i,j,k,n,s,numSegs,segLen,order;
    float obsPerState;
    Observation obs;
    Ptr p;
@@ -520,10 +605,16 @@ void UCollectData(Sequence **seqMat)
          n = (int)(((float)(j-1)/obsPerState)+2);
          for (s=1; s<=nStreams; s++){
             if (hset.hsKind==DISCRETEHS){
-               p = (Ptr)((int)obs.vq[s]);
-               StoreItem(seqMat[n][s],p);
+               p = (Ptr)((long)obs.vq[s]);
+               StoreItem(seqMat[n][s][1],p);
+            } else if(hset.msdflag[s]){
+               order = SpaceOrder(obs.fv[s]);
+               if ((k = IncludeSpace(msdInfo[n][s],order)))
+                  StoreItem(seqMat[n][s][k],obs.fv[s]);
+               else if(!ignOutVec)
+                  HError(2122,"UCollectData: no space corresponded to order[%d]",order);
             }else
-               StoreItem(seqMat[n][s],obs.fv[s]);
+               StoreItem(seqMat[n][s][1],obs.fv[s]);
          }
       }
    }
@@ -532,12 +623,13 @@ void UCollectData(Sequence **seqMat)
 /* UniformSegment: and cluster within each state/segment */
 void UniformSegment(void)
 {
-   Sequence **seqMat;   /* Matrix [2..numStates-1][1..numStreams]*/
+   Sequence ***seqMat;   /* Matrix [2..numStates-1][1..numStreams][1..nKindS]*/
    Sequence seq;
-   int count,size,i,vqidx,s,n,m,M,j,k;
+   int count,size,i,s,n,m,M,j,k,sumItems;
+   long vqidx;
    ClusterSet *cset;
    Cluster *c;
-   StreamElem *ste;
+   StreamInfo *sti;
    Covariance cov;
    CovKind ck;
    MixPDF *mp;
@@ -545,6 +637,10 @@ void UniformSegment(void)
    ShortVec dw;
    float x,z;
    Vector floor;
+   SpaceInfo *si;
+
+   void FloorMixes  (MixtureElem *mixes, const int M, const float floor);
+   void FloorTMMixes(Vector mixes,       const int M, const float floor);
 
    if (trace & T_UNI)
       printf(" Uniform Segmentation\n");
@@ -557,34 +653,43 @@ void UniformSegment(void)
    for (n=2; n<nStates; n++) {
       if (trace&T_UNI) printf(" state %d ",n);
       for (s=1; s<=nStreams; s++){
-         size = hset.swidth[s];
          floor = vFloor[s];
-         ste = hmmLink->svec[n].info->pdf+s;
+         sti = hmmLink->svec[n].info->pdf[s].info;
          if (hset.hsKind == TIEDHS){
             tmRec = &(hset.tmRecs[s]);
             M = tmRec->nMix;
             tmRec->topM = tmRec->nMix;
          }
          else
-            M = ste->nMix; 
+            M = sti->nMix; 
          if (trace&T_UNI) printf(" stream %d\n",s);
-         seq = seqMat[n][s];
          switch (hset.hsKind){
          case PLAINHS:
          case SHAREDHS:
-            ck = ste->spdf.cpdf[1].mpdf->ckind;
-            cset = FlatCluster(&clustSetStack,seq,M,NULLC,ck,cov);
+            ck = sti->spdf.cpdf[1].mpdf->ckind;
+            sumItems = 0;
+            for(k=1; k<=msdInfo[n][s]->nKindS; k++)
+               sumItems += seqMat[n][s][k]->nItems;
+            for(k=1,si=msdInfo[n][s]->next; k<=msdInfo[n][s]->nKindS; k++,si=si->next){
+               seq = seqMat[n][s][k];
+               if(seq->nItems == 0){
+                  for (m=1; m<=si->count; m++)
+                     if (uFlags&UPMIXES)
+                        sti->spdf.cpdf[si->sindex[m]].weight = 0;
+               } else {
+                  cset = FlatCluster(&clustSetStack,seq,si->count,NULLC,ck,cov);
             if (trace&T_UNI) ShowClusterSet(cset);
-            for (m=1; m<=M; m++){
-               mp = ste->spdf.cpdf[m].mpdf;
+                  for (m=1; m<=si->count; m++){
+                     mp = sti->spdf.cpdf[si->sindex[m]].mpdf;
+                     size = VectorSize(mp->mean);
                if (mp->ckind != ck)
                   HError(2123,"UniformSegment: different covkind within a mix\n");
                c = cset->cl+m;
                if (uFlags&UPMIXES)
-                  ste->spdf.cpdf[m].weight = (float)c->csize/(float)seq->nItems;
+                        sti->spdf.cpdf[si->sindex[m]].weight = (float)((double)c->csize/(double)sumItems);
                if (uFlags&UPMEANS)
-                  CopyVector(c->vCtr,mp->mean);
-               if (uFlags&UPVARS)
+                        CopyRVector(c->vCtr,mp->mean,si->order);
+                     if (uFlags&UPVARS){
                   switch(ck){
                   case DIAGC:
                      for (j=1; j<=size; j++){
@@ -605,14 +710,20 @@ void UniformSegment(void)
                      HError(2124,"UniformSegment: bad cov kind %d\n",ck);
                   }
             }
+                  }
+               }
+            }
+            FloorMixes(sti->spdf.cpdf+1,M,mixWeightFloor);
             break;
          case DISCRETEHS:
-            count = 0; dw = ste->spdf.dpdf;
+            size = hset.swidth[s];
+            seq = seqMat[n][s][1];
+            count = 0; dw = sti->spdf.dpdf;
             ZeroShortVec(dw);             
             for (i=1; i<=seq->nItems; i++){
-               vqidx = (int)GetItem(seq,i);
+               vqidx = (long)GetItem(seq,i);
                if (vqidx<1 || vqidx>M)
-                  HError(2170,"UniformSegment: vqidx out of range[%d]",vqidx);
+                  HError(2170,"UniformSegment: vqidx out of range[%ld]",vqidx);
                ++dw[vqidx]; ++count;
             }
             for (m=1; m<=M; m++){
@@ -622,6 +733,8 @@ void UniformSegment(void)
             }
             break;
          case TIEDHS:
+            size = hset.swidth[s];
+            seq = seqMat[n][s][1];
             ck = tmRec->mixes[1]->ckind;
             cset = FlatCluster(&clustSetStack,seq,M,NULLC,ck,cov);
             if (trace&T_UNI) ShowClusterSet(cset);
@@ -631,7 +744,7 @@ void UniformSegment(void)
                   HError(2123,"UniformSegment: different covkind within a mix\n");
                c = cset->cl+m;
                if (uFlags&UPMIXES)
-                  ste->spdf.tpdf[m] = (float)c->csize/(float)seq->nItems;
+                  sti->spdf.tpdf[m] = (float)c->csize/(float)seq->nItems;
                if (uFlags&UPMEANS)
                   CopyVector(c->vCtr,mp->mean);
                if (uFlags&UPVARS)
@@ -655,6 +768,7 @@ void UniformSegment(void)
                      HError(2124,"UniformSegment: bad cov kind %d\n",ck);
                   }                 
             }
+            FloorTMMixes(sti->spdf.tpdf,M,mixWeightFloor);
             break;       
          }
          ResetHeap(&clustSetStack);
@@ -740,6 +854,7 @@ void FindBestMixes(int segNum, int segLe
 {
    int i,s,m,bestm,M=0;
    StreamElem *ste;
+   StreamInfo *sti;
    IntVec smix;
    Observation obs;
    Vector v;
@@ -755,8 +870,9 @@ void FindBestMixes(int segNum, int segLe
       if (hset.hsKind == TIEDHS)
          PrecomputeTMix(&hset, &obs, 0.0, 1);
       for (s=1; s<=nStreams; s++,ste++){
+         sti = ste->info;
          if (hset.hsKind != TIEDHS)
-            M = ste->nMix;
+            M = sti->nMix;
          smix = mixes[s];
          if (hset.hsKind==TIEDHS) /* PrecomputeTMix has already sorted probs */
             bestm = hset.tmRecs[s].probs[1].index;
@@ -768,7 +884,7 @@ void FindBestMixes(int segNum, int segLe
             if (trace&T_MIX)
                printf("  seg %d, stream %d: ",i,s);
             for (m=1; m<=M; m++){
-               me =  ste->spdf.cpdf+m;
+               me =  sti->spdf.cpdf+m;
                mp = me->mpdf;
                p = MOutP(v,mp);
                if (p>bestP){
@@ -877,11 +993,12 @@ LogFloat ViterbiAlign(int segNum,int seg
 /* UpdateCounts: using frames in seg i and alignment in states/mixes */
 void UpdateCounts(int segNum, int segLen, IntVec states,IntVec *mixes)
 {
-   int M=0,i,j,k,s,m,state,last;
+   int M=0,i,j,k,s,m,size,state,last;
    StreamElem *ste;
+   StreamInfo *sti;
    MixPDF *mp = NULL;
    WtAcc *wa;
-   MuAcc *ma;
+   MuAcc *ma = NULL;
    VaAcc *va;
    TrAcc *ta;
    Vector v;
@@ -901,6 +1018,7 @@ void UpdateCounts(int segNum, int segLen
             PrecomputeTMix(&hset, &obs, 50.0, 0);         
          ste = hmmLink->svec[state].info->pdf+1;
          for (s=1; s<=nStreams; s++,ste++){
+            sti = ste->info;
             if (hset.hsKind==DISCRETEHS){
                m = obs.vq[s]; v = NULL;
             } else {
@@ -914,7 +1032,7 @@ void UpdateCounts(int segNum, int segLen
             case PLAINHS:
             case SHAREDHS:
             case DISCRETEHS:
-               M = ste->nMix;
+               M = sti->nMix;
                break;
             }
             if (m<1 || m > M)
@@ -923,7 +1041,7 @@ void UpdateCounts(int segNum, int segLen
                printf("   stream %d -> mix %d[%d]\n",s,m,M); 
             /* update mixture weight */
             if (M>1 && (uFlags&UPMIXES)) {
-               wa = (WtAcc *)ste->hook;
+               wa = (WtAcc *)sti->hook;
                wa->occ += 1.0; wa->c[m] += 1.0;
                if (trace&T_CNT)
                   printf("   mix wt -> %.1f\n",wa->c[m]);
@@ -934,7 +1052,7 @@ void UpdateCounts(int segNum, int segLen
             switch(hset.hsKind){
             case PLAINHS:
             case SHAREDHS:
-               mp = ste->spdf.cpdf[m].mpdf;
+               mp = sti->spdf.cpdf[m].mpdf;
                break;
             case TIEDHS:
                mp = tmRec->mixes[m];
@@ -943,7 +1061,8 @@ void UpdateCounts(int segNum, int segLen
             ma = (MuAcc *)GetHook(mp->mean);
             va = (VaAcc *)GetHook(mp->cov.var);
             ma->occ += 1.0; va->occ += 1.0;
-            for (j=1; j<=hset.swidth[s]; j++) {
+            size = VectorSize(mp->mean);
+            for (j=1; j<=size; j++) {
                x = v[j] - mp->mean[j];
                ma->mu[j] += x;
                if (uFlags&UPVARS)
@@ -993,8 +1112,62 @@ void UpdateCounts(int segNum, int segLen
 
 /* ----------------- Update Parameters --------------------------- */
 
+/* FloorMixes: apply floor to given mix set */
+void FloorMixes (MixtureElem *mixes, const int M, const float floor)
+{
+   float sum,fsum,scale;
+   MixtureElem *me;
+   int m;
+
+   sum = fsum = 0.0;
+   for (m=1,me=mixes; m<=M; m++,me++) {
+      if (me->weight>floor)
+         sum += me->weight;
+      else {
+         fsum += floor; me->weight = floor;
+      }
+   }
+   if (fsum>1.0)
+      HError(2223,"FloorMixes: Floor sum too large");
+   scale = (1.0-fsum)/sum;
+   if (trace&T_CNT) printf("MIXW: ");
+   for (m=1,me=mixes; m<=M; m++,me++){
+      if (me->weight>floor)
+         me->weight *= scale;
+         if (trace&T_CNT) printf(" %.2f",me->weight);
+   }
+   if (trace&T_CNT) printf("\n");
+}
+
+/* FloorTMMixes: apply floor to given tied mix set */
+void FloorTMMixes (Vector mixes, const int M, const float floor)
+{
+   float sum,fsum,scale,fltWt;
+   int m;
+
+   sum = fsum = 0.0;
+   for (m=1; m<=M; m++) {
+      fltWt = mixes[m];
+      if (fltWt>floor)
+         sum += fltWt;
+      else {
+         fsum += floor;
+         mixes[m] = floor;
+      }
+   }
+   if (fsum>1.0) HError(2223,"FloorTMMixes: Floor sum too large");
+   scale = (1.0-fsum)/sum;
+   if (trace&T_CNT) printf("MIXW: ");
+      for (m=1; m<=M; m++){
+      fltWt = mixes[m];
+      if (fltWt>floor)
+         mixes[m] = fltWt*scale;
+      if (trace&T_CNT) printf(" %.2f",fltWt);
+   }
+}
+
 /* UpWeights: update given mixture weights */
-void UpWeights(int i, int s, int M, WtAcc *wa, StreamElem *ste)
+void UpWeights(int i, int s, int M, WtAcc *wa, StreamInfo *sti)
 {
    int m;
    float sum=0.0;
@@ -1006,15 +1179,27 @@ void UpWeights(int i, int s, int M, WtAc
       switch(hset.hsKind){
       case PLAINHS:
       case SHAREDHS:
-         ste->spdf.cpdf[m].weight = wa->c[m] / wa->occ;
+         sti->spdf.cpdf[m].weight = wa->c[m] / wa->occ;
          break;
       case TIEDHS:
-         ste->spdf.tpdf[m] = wa->c[m] / wa->occ;
+         sti->spdf.tpdf[m] = wa->c[m] / wa->occ;
          break;
       }
    }
    if (fabs(sum-wa->occ)/sum > 0.001)
       HError(2190,"UpWeights: mix weight sum error");
+      
+   if (mixWeightFloor>0.0) {
+      switch(hset.hsKind) {
+      case PLAINHS:
+      case SHAREDHS:
+         FloorMixes(sti->spdf.cpdf+1,M,mixWeightFloor);
+         break;
+      case TIEDHS:
+         FloorTMMixes(sti->spdf.tpdf,M,mixWeightFloor);
+         break;
+      }
+   }
 }
 
 /* UpMeans: update mean, leave old mean in acc */
@@ -1118,7 +1303,7 @@ void UpdateParameters(void)
 {
    HMMScanState hss;
    int size;
-   StreamElem *ste;
+   StreamInfo *sti;
    WtAcc *wa;
    MuAcc *ma = NULL;
    VaAcc *va;
@@ -1130,19 +1315,20 @@ void UpdateParameters(void)
       hFound = TRUE;
       while (GoNextState(&hss,TRUE)) {
          while (GoNextStream(&hss,TRUE)) {
-            ste = hss.ste;
+            sti = hss.sti;
             if (hss.M>1 && (uFlags&UPMIXES)){
-               wa = (WtAcc *)ste->hook;
+               wa = (WtAcc *)sti->hook;
                if (hset.hsKind == DISCRETEHS)
-                  UpDProbs(hss.i,hss.s,hss.M,wa,ste->spdf.dpdf);
+                  UpDProbs(hss.i,hss.s,hss.M,wa,sti->spdf.dpdf);
                else
-                  UpWeights(hss.i,hss.s,hss.M,wa,ste);
+                  UpWeights(hss.i,hss.s,hss.M,wa,sti);
             }
-            size = hset.swidth[hss.s];
             if (hss.isCont && (uFlags&(UPMEANS|UPVARS)))/*PLAINHS or SHAREDHS*/
                while (GoNextMix(&hss,TRUE)) {
+                  size = VectorSize(hss.mp->mean);
                   if (!IsSeenV(hss.mp->mean)) {
                      ma = (MuAcc *)GetHook(hss.mp->mean);
+                     if (ma->occ!=0.0)
                      UpMeans(hss.i,hss.s,hss.m,size,ma,hss.mp->mean);
                      /* NB old mean left in ma->mu */
                      TouchV(hss.mp->mean);
@@ -1150,9 +1336,9 @@ void UpdateParameters(void)
                   if (!IsSeenV(hss.mp->cov.var)) {
                      if (uFlags&UPVARS) {
                         va = (VaAcc *)GetHook(hss.mp->cov.var);
-                        shared = GetUse(hss.mp->cov.var) > 1;
-                        UpVars(hss.i,hss.s,hss.m,size,va,ma->mu,hss.mp->mean,
-                               shared,hss.mp);
+                        shared = (GetUse(hss.mp->cov.var) > 1) ? TRUE:FALSE;
+                        if (va->occ!=0.0)
+                           UpVars(hss.i,hss.s,hss.m,size,va,ma->mu,hss.mp->mean,shared,hss.mp);
                      }
                      TouchV(hss.mp->cov.var);
                   }
@@ -1209,8 +1395,7 @@ void EstimateModel(void)
       for (newP=0.0,i=1;i<=numSegs;i++) {
          segLen = SegLength(segStore,i);
          states = CreateIntVec(&gstack,segLen);
-         mixes  = (hset.hsKind==DISCRETEHS)?NULL:
-            CreateMixes(&gstack,segLen);
+         mixes  = (hset.hsKind==DISCRETEHS)? NULL : CreateMixes(&gstack,segLen);
          newP += ViterbiAlign(i,segLen,states,mixes);
          if (trace&T_ALN) ShowAlignment(i,segLen,states,mixes);
          UpdateCounts(i,segLen,states,mixes);
@@ -1219,7 +1404,7 @@ void EstimateModel(void)
       /* Update parameters or quit */
       newP /= (float)numSegs;
       delta = newP - totalP;
-      converged = (iter>1) && (fabs(delta) < epsilon);
+      converged = ((iter>1) && (fabs(delta) < epsilon)) ? TRUE:FALSE;
       if (!converged)
          UpdateParameters();
       totalP = newP;
diff -pbBEwurNa --ignore-matching-lines='.*vc_id.*' HTK-3.4.1/HTKTools/HLEd.c HTS-2.2_for_HTK-3.4.1/HTKTools/HLEd.c
--- HTK-3.4.1/HTKTools/HLEd.c	2009-03-13 03:52:34.000000000 +0900
+++ HTS-2.2_for_HTK-3.4.1/HTKTools/HLEd.c	2011-06-16 13:18:30.000000000 +0900
@@ -19,8 +19,53 @@
 /*      File: HLEd.c: Edit label file(s)                       */
 /* ----------------------------------------------------------- */
 
+/*  *** THIS IS A MODIFIED VERSION OF HTK ***                        */
+/* ----------------------------------------------------------------- */
+/*           The HMM-Based Speech Synthesis System (HTS)             */
+/*           developed by HTS Working Group                          */
+/*           http://hts.sp.nitech.ac.jp/                             */
+/* ----------------------------------------------------------------- */
+/*                                                                   */
+/*  Copyright (c) 2001-2011  Nagoya Institute of Technology          */
+/*                           Department of Computer Science          */
+/*                                                                   */
+/*                2001-2008  Tokyo Institute of Technology           */
+/*                           Interdisciplinary Graduate School of    */
+/*                           Science and Engineering                 */
+/*                                                                   */
+/* All rights reserved.                                              */
+/*                                                                   */
+/* Redistribution and use in source and binary forms, with or        */
+/* without modification, are permitted provided that the following   */
+/* conditions are met:                                               */
+/*                                                                   */
+/* - Redistributions of source code must retain the above copyright  */
+/*   notice, this list of conditions and the following disclaimer.   */
+/* - Redistributions in binary form must reproduce the above         */
+/*   copyright notice, this list of conditions and the following     */
+/*   disclaimer in the documentation and/or other materials provided */
+/*   with the distribution.                                          */
+/* - Neither the name of the HTS working group nor the names of its  */
+/*   contributors may be used to endorse or promote products derived */
+/*   from this software without specific prior written permission.   */
+/*                                                                   */
+/* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND            */
+/* CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,       */
+/* INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF          */
+/* MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE          */
+/* DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS */
+/* BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,          */
+/* EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED   */
+/* TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,     */
+/* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON */
+/* ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,   */
+/* OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY    */
+/* OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE           */
+/* POSSIBILITY OF SUCH DAMAGE.                                       */
+/* ----------------------------------------------------------------- */
+
 char *hled_version = "!HVER!HLEd:   3.4.1 [CUED 12/03/09]";
-char *hled_vc_id = "$Id: HLEd.c,v 1.1.1.1 2006/10/11 09:55:01 jal58 Exp $";
+char *hled_vc_id = "$Id: HLEd.c,v 1.13 2011/06/16 04:18:30 uratec Exp $";
 
 #include "HShell.h"
 #include "HMem.h"
@@ -142,6 +187,7 @@ void Summary(void)
 
 void ReportUsage(void)
 {
+   printf("\nModified for HTS\n");
    printf("\nUSAGE: HLEd [options] edCmdFile labFiles...\n\n");
    printf(" Option                                       Default\n\n");
    printf(" -b      suppress boundary times              off\n");
@@ -275,6 +321,14 @@ int main(int argc, char *argv[])
    }
    ListFinds();
    if (newLabs != NULL) fclose(newLabs);
+
+   ResetDict();
+   ResetLabel();
+   ResetWave();
+   ResetMath();
+   ResetMem();
+   ResetShell();
+   
    Exit(0);
    return (0);          /* never reached -- make compiler happy */
 }
@@ -302,9 +356,9 @@ void Initialise(void)
    SetConfParms();
    asterix = GetLabId("*",TRUE);
    for (i=1;i<=99;i++) {
-      sprintf(buf,"%d",i);
+      sprintf(buf,"%ld",(long)i);
       labid=GetLabId(buf,TRUE);
-      labid->aux=(void*) i;
+      labid->aux=(void*)((long) i);
    }
    CreateHeap(&permHeap, "permHeap", MSTAK, 1, 1.2, 512, 4096);
    CreateHeap(&tempHeap, "tempHeap", MSTAK, 1, 1.2, 4096, 8192);
@@ -553,11 +607,11 @@ void PrintScript(char *scriptFN)
          printf(" ]\n");
          break;
       case SETLEV:
-         printf("Set Level to %d\n",(int)i->cmd.args[0]->aux);
+         printf("Set Level to %d\n",(int)((long)i->cmd.args[0]->aux));
          break;
       case DELLEV:
          if (i->cmd.nArgs==1)
-            printf("Delete Level %d\n",(int)i->cmd.args[0]->aux);
+            printf("Delete Level %d\n",(int)((long)i->cmd.args[0]->aux));
          else
             printf("Delete Current Level\n");
          break;
@@ -729,7 +783,7 @@ void ReadScript(char *scriptFn)
       case SETLEV:
          i->cmd.nArgs = ReadIdList(&src,i->cmd.args);
          if (i->cmd.nArgs!=1 || 
-             (n=(int)i->cmd.args[0]->aux)<1 || n>99 )
+             (n=(int)((long)i->cmd.args[0]->aux))<1 || n>99 )
             HError(1230,"ReadScript: ML must have 1 arg between 1 and 99");          
          break;   
       case DELLEV:
@@ -737,7 +791,7 @@ void ReadScript(char *scriptFn)
          if (i->cmd.nArgs>1)
             HError(1230,"ReadScript: DL can have at most 1 arg");
          if (i->cmd.nArgs==1 && 
-             ((n=(int)i->cmd.args[0]->aux)<1 || n>99) )
+             ((n=(int)((long)i->cmd.args[0]->aux))<1 || n>99) )
             HError(1230,"ReadScript: DL arg must be between 1 and 99");           
          break;   
       case SORT:
@@ -849,7 +903,7 @@ Boolean IsSame(LabId a, LabId b)
       strcpy(buf,a->name); TriStrip(buf); a = GetLabId(buf,TRUE);
       strcpy(buf,b->name); TriStrip(buf); b = GetLabId(buf,TRUE);
    }
-   return a==b;
+   return ((a==b) ? TRUE:FALSE);
 }
 
 /* IsInIdList: return true if id is in idlist */
@@ -1372,7 +1426,7 @@ void DeleteLevel(Transcription *ltr,int 
 void EditFile(char *labfn)
 {
    ScriptItem *i;
-   char outfn[255];
+   char outfn[MAXFNAMELEN];
    int m,d,r,c,a,clev,nlev,list;
    Transcription *ct,*levs,*at;
    LabList *ll,*rl;
@@ -1405,7 +1459,7 @@ void EditFile(char *labfn)
          if (i->cmd.op != CHANGE || i==script) /* terminate any pending */
             ChangeOp(NULL, NULL);     /* sequence of CH(ange operations */
          if (i->cmd.op == TRIST)
-            triStrip = !triStrip;
+            triStrip = (!triStrip) ? TRUE:FALSE;
          if (ll!=NULL)
             switch (i->cmd.op) {
             case FIND:
@@ -1426,7 +1480,7 @@ void EditFile(char *labfn)
                d += DeleteOp(ll,i->cmd.args); break;
             case DELLEV:
                if (i->cmd.nArgs==1)
-                  DeleteLevel(levs,(int)i->cmd.args[0]->aux);
+                  DeleteLevel(levs,(int)((long)i->cmd.args[0]->aux));
                else
                   DeleteLevel(levs,clev);
                break;
@@ -1437,7 +1491,7 @@ void EditFile(char *labfn)
             case ISIL:
                a += ISilOp(ll,i->cmd.args); break;
             case SETLEV:
-               clev=(int)i->cmd.args[0]->aux;
+               clev=(int)((long)i->cmd.args[0]->aux);
                if (clev>nlev) {
                   ll = NULL;
                   HError(-1231,"EditLevel: Level %d does not exist",clev);
@@ -1486,6 +1540,6 @@ void EditFile(char *labfn)
 }
 
 
-/* ------------------------------------------------------------ */
+/* ----------------------------------------------------------- */
 /*                         END:  HLEd.c                         */
-/* ------------------------------------------------------------ */
+/* ----------------------------------------------------------- */
diff -pbBEwurNa --ignore-matching-lines='.*vc_id.*' HTK-3.4.1/HTKTools/HLRescore.c HTS-2.2_for_HTK-3.4.1/HTKTools/HLRescore.c
--- HTK-3.4.1/HTKTools/HLRescore.c	2009-03-13 03:52:51.000000000 +0900
+++ HTS-2.2_for_HTK-3.4.1/HTKTools/HLRescore.c	2011-06-16 13:18:30.000000000 +0900
@@ -27,6 +27,51 @@
 /*       File: HLRescore.c: Lattice rescoring/pruning          */
 /* ----------------------------------------------------------- */
 
+/*  *** THIS IS A MODIFIED VERSION OF HTK ***                        */
+/* ----------------------------------------------------------------- */
+/*           The HMM-Based Speech Synthesis System (HTS)             */
+/*           developed by HTS Working Group                          */
+/*           http://hts.sp.nitech.ac.jp/                             */
+/* ----------------------------------------------------------------- */
+/*                                                                   */
+/*  Copyright (c) 2001-2011  Nagoya Institute of Technology          */
+/*                           Department of Computer Science          */
+/*                                                                   */
+/*                2001-2008  Tokyo Institute of Technology           */
+/*                           Interdisciplinary Graduate School of    */
+/*                           Science and Engineering                 */
+/*                                                                   */
+/* All rights reserved.                                              */
+/*                                                                   */
+/* Redistribution and use in source and binary forms, with or        */
+/* without modification, are permitted provided that the following   */
+/* conditions are met:                                               */
+/*                                                                   */
+/* - Redistributions of source code must retain the above copyright  */
+/*   notice, this list of conditions and the following disclaimer.   */
+/* - Redistributions in binary form must reproduce the above         */
+/*   copyright notice, this list of conditions and the following     */
+/*   disclaimer in the documentation and/or other materials provided */
+/*   with the distribution.                                          */
+/* - Neither the name of the HTS working group nor the names of its  */
+/*   contributors may be used to endorse or promote products derived */
+/*   from this software without specific prior written permission.   */
+/*                                                                   */
+/* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND            */
+/* CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,       */
+/* INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF          */
+/* MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE          */
+/* DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS */
+/* BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,          */
+/* EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED   */
+/* TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,     */
+/* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON */
+/* ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,   */
+/* OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY    */
+/* OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE           */
+/* POSSIBILITY OF SUCH DAMAGE.                                       */
+/* ----------------------------------------------------------------- */
+
 /*#### todo:
 
      - implement lattice oracle WER calculation
@@ -162,6 +207,7 @@ void SetConfParms(void)
 
 void ReportUsage(void)
 {
+   printf("\nModified for HTS\n");
    printf("\nUSAGE: HLRescore [options] vocabFile Files...\n\n");
    printf(" Option                                   Default\n\n");
    printf(" -i s    Output transcriptions to MLF s       off\n"); 
@@ -554,10 +600,13 @@ void ProcessLattice (char *latfn)
       if (labOutForm)
          FormatTranscription (trans, 
                               1.0e7, FALSE, FALSE,
-                              strchr(labOutForm,'X')!=NULL,
-                              strchr(labOutForm,'N')!=NULL,strchr(labOutForm,'S')!=NULL,
-                              strchr(labOutForm,'C')!=NULL,strchr(labOutForm,'T')!=NULL,
-                              strchr(labOutForm,'W')!=NULL,strchr(labOutForm,'M')!=NULL);
+                              ((strchr(labOutForm,'X')!=NULL) ? TRUE:FALSE),
+                              ((strchr(labOutForm,'N')!=NULL) ? TRUE:FALSE), 
+                              ((strchr(labOutForm,'S')!=NULL) ? TRUE:FALSE),
+                              ((strchr(labOutForm,'C')!=NULL) ? TRUE:FALSE),
+                              ((strchr(labOutForm,'T')!=NULL) ? TRUE:FALSE),
+                              ((strchr(labOutForm,'W')!=NULL) ? TRUE:FALSE),
+                              ((strchr(labOutForm,'M')!=NULL) ? TRUE:FALSE));
       
       MakeFN (latfn, labOutDir, labOutExt, lfn);
       if (LSave (lfn, trans, ofmt) < SUCCESS)
@@ -715,10 +764,13 @@ void ProcessLabels (char *labfn)
       if (labOutForm)
          FormatTranscription (trans,
                               1.0e7, FALSE, FALSE,
-                              strchr(labOutForm,'X')!=NULL,
-                              strchr(labOutForm,'N')!=NULL,strchr(labOutForm,'S')!=NULL,
-                              strchr(labOutForm,'C')!=NULL,strchr(labOutForm,'T')!=NULL,
-                              strchr(labOutForm,'W')!=NULL,strchr(labOutForm,'M')!=NULL);
+                              ((strchr(labOutForm,'X')!=NULL) ? TRUE:FALSE),
+                              ((strchr(labOutForm,'N')!=NULL) ? TRUE:FALSE),
+                              ((strchr(labOutForm,'S')!=NULL) ? TRUE:FALSE),
+                              ((strchr(labOutForm,'C')!=NULL) ? TRUE:FALSE),
+                              ((strchr(labOutForm,'T')!=NULL) ? TRUE:FALSE),
+                              ((strchr(labOutForm,'W')!=NULL) ? TRUE:FALSE),
+                              ((strchr(labOutForm,'M')!=NULL) ? TRUE:FALSE));
       
       MakeFN (labfn, labOutDir, labOutExt, lfn);
       if (LSave (lfn, trans, ofmt) < SUCCESS)
@@ -791,3 +843,7 @@ void ProcessLabels (char *labfn)
     c-file-style: "htk"
     End:
 */
+
+/* ----------------------------------------------------------- */
+/*                      END:  HLRescore.c                      */
+/* ----------------------------------------------------------- */
diff -pbBEwurNa --ignore-matching-lines='.*vc_id.*' HTK-3.4.1/HTKTools/HLStats.c HTS-2.2_for_HTK-3.4.1/HTKTools/HLStats.c
--- HTK-3.4.1/HTKTools/HLStats.c	2009-03-13 03:52:59.000000000 +0900
+++ HTS-2.2_for_HTK-3.4.1/HTKTools/HLStats.c	2011-06-16 13:18:30.000000000 +0900
@@ -19,8 +19,53 @@
 /*    File: HLStats.c: gather statistics from transcriptions   */
 /* ----------------------------------------------------------- */
 
+/*  *** THIS IS A MODIFIED VERSION OF HTK ***                        */
+/* ----------------------------------------------------------------- */
+/*           The HMM-Based Speech Synthesis System (HTS)             */
+/*           developed by HTS Working Group                          */
+/*           http://hts.sp.nitech.ac.jp/                             */
+/* ----------------------------------------------------------------- */
+/*                                                                   */
+/*  Copyright (c) 2001-2011  Nagoya Institute of Technology          */
+/*                           Department of Computer Science          */
+/*                                                                   */
+/*                2001-2008  Tokyo Institute of Technology           */
+/*                           Interdisciplinary Graduate School of    */
+/*                           Science and Engineering                 */
+/*                                                                   */
+/* All rights reserved.                                              */
+/*                                                                   */
+/* Redistribution and use in source and binary forms, with or        */
+/* without modification, are permitted provided that the following   */
+/* conditions are met:                                               */
+/*                                                                   */
+/* - Redistributions of source code must retain the above copyright  */
+/*   notice, this list of conditions and the following disclaimer.   */
+/* - Redistributions in binary form must reproduce the above         */
+/*   copyright notice, this list of conditions and the following     */
+/*   disclaimer in the documentation and/or other materials provided */
+/*   with the distribution.                                          */
+/* - Neither the name of the HTS working group nor the names of its  */
+/*   contributors may be used to endorse or promote products derived */
+/*   from this software without specific prior written permission.   */
+/*                                                                   */
+/* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND            */
+/* CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,       */
+/* INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF          */
+/* MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE          */
+/* DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS */
+/* BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,          */
+/* EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED   */
+/* TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,     */
+/* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON */
+/* ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,   */
+/* OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY    */
+/* OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE           */
+/* POSSIBILITY OF SUCH DAMAGE.                                       */
+/* ----------------------------------------------------------------- */
+
 char *hlstats_version = "!HVER!HLStats:   3.4.1 [CUED 12/03/09]";
-char *hlstats_vc_id = "$Id: HLStats.c,v 1.1.1.1 2006/10/11 09:55:01 jal58 Exp $";
+char *hlstats_vc_id = "$Id: HLStats.c,v 1.10 2011/06/16 04:18:30 uratec Exp $";
 
 #include "HShell.h"
 #include "HMem.h"
@@ -103,6 +148,7 @@ void SetConfParms(void)
 
 void ReportUsage(void)
 {
+   printf("\nModified for HTS\n");
    printf("\nUSAGE: HLStats [options] hmmList labFile...\n\n");
    printf(" Option                                       Default\n\n");
    printf(" -b fn    output bigram to file fn            off\n");
@@ -277,6 +323,14 @@ int main(int argc, char *argv[])
 
    if (trace&T_MEM)
       PrintAllHeapStats();
+
+   ResetLM();
+   ResetLabel();
+   ResetWave();
+   ResetMath();
+   ResetMem();
+   ResetShell();
+   
    Exit(0);
    return (0);          /* never reached -- make compiler happy */
 }
@@ -366,7 +420,9 @@ void InitWordInfo(WordInfo *w, LabId id,
 /* InitStats: Create and init all necessary global accumulators */
 void InitStats(char *listFn)
 {
-   int h,p,l;
+   int h;
+   long l;
+   long p;
    MLink q,hm;
    HLink hmm;
    HMMSet *hset;
@@ -420,7 +476,7 @@ void InitStats(char *listFn)
             if (hm==NULL || hmm->hook==0)
                HError(1390,"InitStats: No physical name found for %s",
                       q->id->name);
-            InitWordInfo(lTab+l,q->id,pTab+(int)hmm->hook);
+            InitWordInfo(lTab+l,q->id,pTab+(long)hmm->hook);
             l++;
          }
    qsort(lTab+1,lSize,sizeof(WordInfo),wd_cmp);
@@ -489,13 +545,13 @@ void GatherStats(Transcription *t)
    if (l->labid==exitId) en--;
 
    /* Coerce previous labels to be enterId */
-   for (i=0; i<ASIZE; i++) in[i]=(int)enterId->aux;
-   lt = lTab+(int)enterId->aux; ++lt->count;
+   for (i=0; i<ASIZE; i++) in[i]=(long)enterId->aux;
+   lt = lTab+(long)enterId->aux; ++lt->count;
    
    /* Process actual labels in list */ 
    for (i=st; i<=en; i++) {
       l = GetLabN(ll,i);
-      lab=(int)l->labid->aux;
+      lab=(long)l->labid->aux;
       dur = (float)(l->end - l->start)/10000.0;
       lt=lTab+lab;
       /* increment stats */
@@ -507,7 +563,7 @@ void GatherStats(Transcription *t)
       if (doBigram) {
          /* We ignore all transitions into enterId and exitId */
          /* May wish to warn user about badly formed sentences */
-         if (!(lab==(int)enterId->aux || (lab==(int)exitId->aux))) {
+         if (!(lab==(long)enterId->aux || (lab==(long)exitId->aux))) {
             for (j=ASIZE-1;j>0;j--) in[j]=in[j-1];
             in[0]=lab;
             ae = GetAEntry(in,TRUE);
@@ -518,11 +574,11 @@ void GatherStats(Transcription *t)
    /* Deal with transition into EXIT */
    if (doBigram) {
       for (j=ASIZE-1;j>0;j--) in[j]=in[j-1];
-      in[0]=(int)exitId->aux;
+      in[0]=(int)((long)exitId->aux);
       ae = GetAEntry(in,TRUE);
       ae->count++;
    }
-   lt = lTab+(int)exitId->aux; ++lt->count;
+   lt = lTab+(long)exitId->aux; ++lt->count;
 }
 
 /* ----------------------- Output Results -------------------- */
@@ -536,7 +592,7 @@ int CmpCntr(const void *p1, const void *
 
    c1=(Cntr *)p1; c2=(Cntr *)p2;
    diff=c1->count-c2->count;
-   if (diff==0) return((int)c2->name->aux-(int)c1->name->aux);
+   if (diff==0) return((int)((long)c2->name->aux-(long)c1->name->aux));
    else return(diff);
 }
 
@@ -550,7 +606,7 @@ int CmpWordInfo(const void *p1, const vo
    
    c1=(WordInfo *)p1; c2=(WordInfo *)p2;
    diff=c1->count-c2->count;
-   if (diff==0) return((int)c2->name->aux-(int)c1->name->aux);
+   if (diff==0) return((long)c2->name->aux-(long)c1->name->aux);
    else return(diff);
 }
 
@@ -663,10 +719,10 @@ static float BuildNEntry(NEntry *ne,Vect
    ne->nse=0;
    tot=cnt=0.0;
    bsum=1.0;
-   if (ne->word[0]!=(int)exitId->aux)
+   if (ne->word[0]!=(long)exitId->aux)
       for (ae=(AEntry *) ne->user; ae!=NULL; ae=ae->link) {
          tot+=ae->count;
-         if (ae->word[0]!=0 && ae->word[0]!=(int)enterId->aux &&
+         if (ae->word[0]!=0 && ae->word[0]!=(long)enterId->aux &&
              ae->count>bigThresh)
             cnt+=(ae->count-disCount),ne->nse++,bsum-=boff[ae->word[0]];
       }
@@ -680,7 +736,7 @@ static float BuildNEntry(NEntry *ne,Vect
       bowt = (bsum>0.0) ? (1.0-cnt/tot)/bsum : 0.0;
       ent  = (bowt>0.0) ? bowt*(bent-log2(bowt)) : 0.0;
       for (cse=ne->se,ae=(AEntry *) ne->user; ae!=NULL; ae=ae->link)
-         if (ae->word[0]!=0 && ae->word[0]!=(int)enterId->aux &&
+         if (ae->word[0]!=0 && ae->word[0]!=(long)enterId->aux &&
              ae->count>bigThresh) {
             prob=((double)ae->count-disCount)/tot;
             cse->word=ae->word[0];
@@ -723,7 +779,7 @@ void OutputBoBigram(void)
    RebuildAETab(aelists);          /* Un-hash hashtable */
 
    for (i=1,tot=0.0;i<=lSize;i++) {    /* Calculate unigrams first */
-      if (i==(int)enterId->aux)
+      if (i==(long)enterId->aux)
          nglm->unigrams[i]=0.0;
       else if (lTab[i].count<uniFloor)
          nglm->unigrams[i]=uniFloor;
@@ -752,9 +808,9 @@ void OutputBoBigram(void)
       ent = BuildNEntry(ne,nglm->unigrams,uent);
       nglm->counts[2]+=ne->nse;
       if (trace&T_BIG) 
-         if (i!=(int)exitId->aux){
-            if (i==(int)enterId->aux)
-               bent+=nglm->unigrams[(int)exitId->aux]*ent;
+         if (i!=(long)exitId->aux){
+            if (i==(long)enterId->aux)
+               bent+=nglm->unigrams[(long)exitId->aux]*ent;
             else 
                bent+=nglm->unigrams[i]*ent;
             printf("   %-20s - %4d foll, ent %6.3f [= %6.2f]\n",
@@ -826,7 +882,7 @@ void OutputMatBigram(void)
             ae->count=0;
       scale = (1.0 - fsum) / vsum;
       for (j=1;j<=lSize;j++) {
-         if (j==(int)enterId->aux) vec[j]=0.0;
+         if (j==(int)((long)enterId->aux)) vec[j]=0.0;
          else if (tot==0.0) vec[j]=1.0/(lSize-1);
          else vec[j]=bigFloor;
       }
@@ -848,7 +904,7 @@ void OutputMatBigram(void)
                ent += fent;
                nf--;  np++;
             }
-         if (i!=(int)exitId->aux){
+         if (i!=(int)((long)exitId->aux)){
             j=lTab[i].count;
             bent+=j*ent;tn+=j;
             if (tot==0.0)
@@ -899,6 +955,6 @@ void OutputStats(void)
       OutputCounts(); /* Breaks log->phy links */
 }
 
-/* ------------------------------------------------------------ */
+/* ----------------------------------------------------------- */
 /*                      END:  HLStats.c                         */
-/* ------------------------------------------------------------ */
+/* ----------------------------------------------------------- */
diff -pbBEwurNa --ignore-matching-lines='.*vc_id.*' HTK-3.4.1/HTKTools/HList.c HTS-2.2_for_HTK-3.4.1/HTKTools/HList.c
--- HTK-3.4.1/HTKTools/HList.c	2009-03-13 03:52:42.000000000 +0900
+++ HTS-2.2_for_HTK-3.4.1/HTKTools/HList.c	2011-06-16 13:18:30.000000000 +0900
@@ -32,8 +32,53 @@
 /*      File: HList.c: List a Speech File or Audio Source      */
 /* ----------------------------------------------------------- */
 
+/*  *** THIS IS A MODIFIED VERSION OF HTK ***                        */
+/* ----------------------------------------------------------------- */
+/*           The HMM-Based Speech Synthesis System (HTS)             */
+/*           developed by HTS Working Group                          */
+/*           http://hts.sp.nitech.ac.jp/                             */
+/* ----------------------------------------------------------------- */
+/*                                                                   */
+/*  Copyright (c) 2001-2011  Nagoya Institute of Technology          */
+/*                           Department of Computer Science          */
+/*                                                                   */
+/*                2001-2008  Tokyo Institute of Technology           */
+/*                           Interdisciplinary Graduate School of    */
+/*                           Science and Engineering                 */
+/*                                                                   */
+/* All rights reserved.                                              */
+/*                                                                   */
+/* Redistribution and use in source and binary forms, with or        */
+/* without modification, are permitted provided that the following   */
+/* conditions are met:                                               */
+/*                                                                   */
+/* - Redistributions of source code must retain the above copyright  */
+/*   notice, this list of conditions and the following disclaimer.   */
+/* - Redistributions in binary form must reproduce the above         */
+/*   copyright notice, this list of conditions and the following     */
+/*   disclaimer in the documentation and/or other materials provided */
+/*   with the distribution.                                          */
+/* - Neither the name of the HTS working group nor the names of its  */
+/*   contributors may be used to endorse or promote products derived */
+/*   from this software without specific prior written permission.   */
+/*                                                                   */
+/* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND            */
+/* CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,       */
+/* INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF          */
+/* MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE          */
+/* DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS */
+/* BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,          */
+/* EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED   */
+/* TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,     */
+/* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON */
+/* ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,   */
+/* OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY    */
+/* OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE           */
+/* POSSIBILITY OF SUCH DAMAGE.                                       */
+/* ----------------------------------------------------------------- */
+
 char *hlist_version = "!HVER!HList:   3.4.1 [CUED 12/03/09]";
-char *hlist_vc_id = "$Id: HList.c,v 1.1.1.1 2006/10/11 09:55:01 jal58 Exp $";
+char *hlist_vc_id = "$Id: HList.c,v 1.9 2011/06/16 04:18:30 uratec Exp $";
 
 #include "HShell.h"
 #include "HMem.h"
@@ -95,6 +140,7 @@ void SetConfParms(void)
 
 void ReportUsage(void)
 {
+   printf("\nModified for HTS\n");
    printf("\nUSAGE: HList [options] file ...\n\n");
    printf(" Option                                       Default\n\n");
    printf(" -d      Coerce observation to VQ symbols     off\n");
@@ -108,7 +154,7 @@ void ReportUsage(void)
    printf(" -s N    Start at sample N                    0\n");
    printf(" -t      Print target header info             off\n");
    printf(" -z      Suppress printing data               on\n");
-   PrintStdOpts("F");
+   PrintStdOpts("FS");
    printf("\n\n");
 }
    
@@ -183,6 +229,18 @@ int main(int argc, char *argv[])
             HError(1119,"HList: List file name expected");
          ListSpeech(GetStrArg());
       }
+
+   ResetParm();
+   ResetModel();
+   ResetLabel();
+   ResetVQ();
+   ResetAudio();
+   ResetWave();
+   ResetSigP();
+   ResetMath();
+   ResetMem();
+   ResetShell();
+   
    Exit(0);
    return (0);          /* never reached -- make compiler happy */
 }
@@ -303,7 +361,7 @@ Boolean IsWave(char *srcFile)
    /* Read all configuration params and get target */
    if (GetConfStr(cParm,nParm,"TARGETKIND",buf))
       tgtPK = Str2ParmKind(buf);
-   isWave = tgtPK == WAVEFORM;
+   isWave = (tgtPK == WAVEFORM) ? TRUE:FALSE;
    if (tgtPK == ANON){
       if ((srcFF == HTK || srcFF == ESIG) && srcFile != NULL){
          strncpy (actfname, srcFile, MAXFNAMELEN);
@@ -324,7 +382,7 @@ Boolean IsWave(char *srcFile)
                       srcFile);
             break;
          }
-         isWave = kind == WAVEFORM;
+         isWave = (kind == WAVEFORM) ? TRUE:FALSE;
          FClose(f,isPipe);
       } else
          isWave = TRUE;
@@ -468,7 +526,7 @@ void ListParms(char *src)
       HError(1150,"ListParms: Config parameters invalid");
    GetBufferInfo(pbuf,&info);
    SetBarWidth(8);
-   hi.isAudio = src==NULL;
+   hi.isAudio = (src==NULL) ? TRUE:FALSE;
    if (replay && hi.isAudio)
       AttachReplayBuf(info.a,100000);
    if (srcHdr) {
diff -pbBEwurNa --ignore-matching-lines='.*vc_id.*' HTK-3.4.1/HTKTools/HMGenS.c HTS-2.2_for_HTK-3.4.1/HTKTools/HMGenS.c
--- HTK-3.4.1/HTKTools/HMGenS.c	1970-01-01 09:00:00.000000000 +0900
+++ HTS-2.2_for_HTK-3.4.1/HTKTools/HMGenS.c	2011-06-16 13:27:17.000000000 +0900
@@ -0,0 +1,894 @@
+/* ----------------------------------------------------------------- */
+/*           The HMM-Based Speech Synthesis System (HTS)             */
+/*           developed by HTS Working Group                          */
+/*           http://hts.sp.nitech.ac.jp/                             */
+/* ----------------------------------------------------------------- */
+/*                                                                   */
+/*  Copyright (c) 2001-2011  Nagoya Institute of Technology          */
+/*                           Department of Computer Science          */
+/*                                                                   */
+/*                2001-2008  Tokyo Institute of Technology           */
+/*                           Interdisciplinary Graduate School of    */
+/*                           Science and Engineering                 */
+/*                                                                   */
+/* All rights reserved.                                              */
+/*                                                                   */
+/* Redistribution and use in source and binary forms, with or        */
+/* without modification, are permitted provided that the following   */
+/* conditions are met:                                               */
+/*                                                                   */
+/* - Redistributions of source code must retain the above copyright  */
+/*   notice, this list of conditions and the following disclaimer.   */
+/* - Redistributions in binary form must reproduce the above         */
+/*   copyright notice, this list of conditions and the following     */
+/*   disclaimer in the documentation and/or other materials provided */
+/*   with the distribution.                                          */
+/* - Neither the name of the HTS working group nor the names of its  */
+/*   contributors may be used to endorse or promote products derived */
+/*   from this software without specific prior written permission.   */
+/*                                                                   */
+/* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND            */
+/* CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,       */
+/* INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF          */
+/* MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE          */
+/* DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS */
+/* BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,          */
+/* EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED   */
+/* TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,     */
+/* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON */
+/* ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,   */
+/* OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY    */
+/* OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE           */
+/* POSSIBILITY OF SUCH DAMAGE.                                       */
+/* ----------------------------------------------------------------- */
+
+char *hmgens_version = "!HVER!HMGenS: 2.2 [NIT 07/07/11]";
+char *hmgens_vc_id = "$Id: HMGenS.c,v 1.52 2011/06/16 04:27:17 uratec Exp $";
+
+/*  
+    This program is used to generate feature vector sequences 
+    which maximize its output probability 
+    from concatenated HMMs
+    under the constraints between observed and            
+    augmented vector sequences                            
+*/
+
+#include "HShell.h"
+#include "HMem.h"
+#include "HMath.h"
+#include "HSigP.h"
+#include "HAudio.h"
+#include "HWave.h"
+#include "HParm.h"
+#include "HLabel.h"
+#include "HModel.h"
+#include "HTrain.h"
+#include "HUtil.h"
+#include "HAdapt.h"
+#include "HMap.h"
+#include "HFB.h"
+#include "HGen.h"
+
+/* ----------------------- Trace Flags ----------------------- */
+
+#define T_TOP 0001              /* Top level tracing              */
+#define T_DUR 0002              /* show duration of each state    */
+
+/* ---------------- Global Data Structures --------------------- */
+
+
+/* Global Settings */
+
+static char *labDir = NULL;     /* label (transcription) file directory */
+static char *labExt = "lab";    /* label file extension */
+static char *hmmDir = NULL;     /* directory to look for hmm def files */
+static char *hmmExt = NULL;     /* hmm def file extension */
+static char *dmDir = NULL;      /* directory to look for dm def files */
+static char *dmExt = NULL;      /* dm def file extension */
+static char *genDir = NULL;     /* directory to store new hmm def files */
+static char *genExt = "gen";    /* extension for generated sequence */
+static char *durExt = "dur";    /* extension for state duration */
+static char *pdfExt = "pdf";    /* extension for pdf sequence */
+static char *winDir = NULL;     /* directory to look for window files */
+static char *winExt = NULL;     /* extension for window file */
+
+static MemHeap hmmStack;        /* Stack holds all hmm related info */
+static MemHeap dmStack;         /* Stack holds all duration model related info */
+static MemHeap genStack;        /* Heap holds all calcuration info */
+static MemHeap uttStack;        /* Stack for utterance info */
+static MemHeap fbInfoStack;     /* Stack for Forward-Backward info */
+
+static HMMSet hmset;            /* HMM set */
+static HMMSet dmset;            /* Duration model set */
+
+static FileFormat lff = UNDEFF; /* label file format */
+
+/* variables for forward-backward */
+static ConfParam *cParm[MAXGLOBS];      /* configuration parameters */
+static int nParm = 0;           /* total num params */
+static UttInfo *utt;            /* utterance information storage */
+static GenInfo *genInfo;        /* generation information */
+static FBInfo *fbInfo;          /* forward-backward information storage */
+static Boolean useHMMFB = FALSE;        /* do not use duration models in the forward-backward algorithm */
+Boolean keepOccm = TRUE;        /* keep mixture-level occupancy prob for EM-based parameter generation */
+
+/* Global settings */
+static int trace = 0;           /* trace level */
+static int totalT = 0;          /* total number of frames in training data */
+static LogDouble totalPr = 0;   /* total log prob upto current utterance */
+
+static LogDouble pruneInit = NOPRUNE;   /* pruning threshold initially */
+static LogDouble pruneInc = 0.0;        /* pruning threshold increment */
+static LogDouble pruneLim = NOPRUNE;    /* pruning threshold limit */
+static float minFrwdP = NOPRUNE;        /* mix prune threshold */
+
+/* information about transforms */
+static XFInfo xfInfo_hmm;
+static XFInfo xfInfo_dur;
+
+/* configuration variables */
+static Boolean inBinary = FALSE;        /* set to generated parameters in binary */
+static Boolean outPdf = FALSE;  /* output pdf */
+static ParmGenType type = CHOLESKY;     /* type of parameter generation algorithm */
+static Boolean modelAlign = FALSE;      /* use model alignment from label */
+static Boolean stateAlign = FALSE;      /* use state alignment from label */
+static Boolean useAlign = FALSE;        /* use model alignment from label for EM-based parameter generation */
+static float MSDthresh = 0.5;   /* threshold for swithing space index for MSD */
+static HTime frameRate = 50000; /* frame rate (default: 5ms) */
+static float speakRate = 1.0;   /* speaking rate (1.0 => standard speaking rate) */
+
+static IntVec nPdfStr = NULL;   /* # of PdfStream */
+static IntVec pdfStrOrder = NULL;       /* order of each PdfStream */
+static char **pdfStrExt = NULL; /* fn ext of each PdfStream */
+static char **winFn[SMAX];      /* fn of window */
+
+/* --------------------- Process Command Line ---------------------- */
+
+void SetConfParms(void)
+{
+   int s, i;
+   char *c, buf[MAXSTRLEN], tmp[MAXSTRLEN];
+   Boolean b;
+
+   for (s = 1; s < SMAX; s++)
+      winFn[s] = NULL;
+
+   nParm = GetConfig("HMGENS", TRUE, cParm, MAXGLOBS);
+   if (nParm > 0) {
+      if (GetConfInt(cParm, nParm, "TRACE", &i))
+         trace = i;
+      if (GetConfBool(cParm, nParm, "SAVEBINARY", &b))
+         inBinary = b;
+      if (GetConfBool(cParm, nParm, "OUTPDF", &b))
+         outPdf = b;
+      if (GetConfInt(cParm, nParm, "PARMGENTYPE", &i))
+         type = (ParmGenType) i;
+      if (GetConfBool(cParm, nParm, "MODELALIGN", &b))
+         modelAlign = b;
+      if (GetConfBool(cParm, nParm, "STATEALIGN", &b))
+         stateAlign = b;
+      if (GetConfBool(cParm, nParm, "USEALIGN", &b))
+         useAlign = b;
+      if (GetConfBool(cParm, nParm, "USEHMMFB", &b))
+         useHMMFB = b;
+      if (GetConfStr(cParm, nParm, "INXFORMMASK", buf))
+         xfInfo_hmm.inSpkrPat = xfInfo_dur.inSpkrPat = CopyString(&genStack, buf);
+      if (GetConfStr(cParm, nParm, "PAXFORMMASK", buf))
+         xfInfo_hmm.paSpkrPat = xfInfo_dur.paSpkrPat = CopyString(&genStack, buf);
+
+      if (GetConfStr(cParm, nParm, "PDFSTRSIZE", buf))
+         nPdfStr = ParseConfIntVec(&gstack, buf, TRUE);
+      if (GetConfStr(cParm, nParm, "PDFSTRORDER", buf))
+         pdfStrOrder = ParseConfIntVec(&gstack, buf, TRUE);
+      if (GetConfStr(cParm, nParm, "PDFSTREXT", buf))
+         pdfStrExt = ParseConfStrVec(&gstack, buf, TRUE);
+      if (GetConfStr(cParm, nParm, "WINEXT", buf))
+         winExt = CopyString(&gstack, buf);
+      if (GetConfStr(cParm, nParm, "WINDIR", buf))
+         winDir = CopyString(&gstack, buf);
+      if (GetConfStr(cParm, nParm, "WINFN", buf)) {
+         for (s = 1, c = buf; s < SMAX && c != NULL; s++) {
+            winFn[s] = ParseConfStrVec(&gstack, c, FALSE);
+            for (i = 1; i <= winFn[s][0][0] + 2; i++)   /* "StrVec" + "n" + # of file names */
+               c = ParseString(c, tmp);
+            if (ParseString(c, tmp) == NULL)
+               break;
+         }
+      }
+   }
+}
+
+void ReportUsage(void)
+{
+   printf("\nUSAGE: HMGenS [options] hmmList dmList labFiles...\n\n");
+   printf(" Option                                                    Default\n\n");
+   printf(" -a      Use an input linear transform for HMMs            off\n");
+   printf(" -b      Use an input linear transform for dur models      off\n");
+   printf(" -c n    type of parameter generation algorithm            0\n");
+   printf("          0: both mix and state sequences are given        \n");
+   printf("          1: state sequence is given,                      \n");
+   printf("             but mix sequence is hidden                    \n");
+   printf("          2: both state and mix sequences are hidden       \n");
+   printf(" -d s    dir to find hmm definitions                       current\n");
+   printf(" -e      use model alignment from label for pruning        off\n");
+   printf(" -f f    frame shift in 100 ns                             50000\n");
+   printf(" -g f    Mixture pruning threshold                         10.0\n");
+   printf(" -h s [s] set speaker name pattern to s,                   *.%%%%%%\n");
+   printf("         optionally set parent patterns                    \n");
+   printf(" -m      use model alignment for duration                  off\n");
+   printf(" -n s    dir to find duration model definitions            current\n");
+   printf(" -p      output pdf sequences                              off\n");
+   printf(" -r f    speaking rate factor (f<1: fast  f>1: slow)       1.0\n");
+   printf(" -s      use state alignment for duration                  off\n");
+   printf(" -t f [i l] set pruning to f [inc limit]                   inf\n");
+   printf(" -v f    threshold for switching spaces for MSD            0.5\n");
+   printf(" -x s    extension for hmm files                           none\n");
+   printf(" -y s    extension for duration model files                none\n");
+   PrintStdOpts("BEGHIJLMNSTWXY");
+   printf("\n");
+   Exit(0);
+}
+
+void CheckGenSetUp(void)
+{
+   int d, p, r, s, stream;
+   PdfStream *pst = NULL;
+
+   /* # of PdfStreams */
+   genInfo->nPdfStream[0] = (nPdfStr == NULL) ? hmset.swidth[0] : IntVecSize(nPdfStr);
+   if (genInfo->nPdfStream[0] > hmset.swidth[0])
+      HError(999, "CheckGenSetUp: # of PdfStreams (%d) is too large (should be less than %d)", genInfo->nPdfStream[0], hmset.swidth[0]);
+
+   /* size of each PdfStreams */
+   r = hmset.swidth[0];
+   for (p = stream = 1; p <= genInfo->nPdfStream[0]; stream += genInfo->nPdfStream[p++]) {
+      pst = &(genInfo->pst[p]);
+
+      /* # of streams in this PdfStream */
+      genInfo->nPdfStream[p] = (nPdfStr == NULL) ? 1 : nPdfStr[p];
+      r -= genInfo->nPdfStream[p];
+
+      /* calculate vector size for this PdfStream */
+      for (s = stream, pst->vSize = 0; s < stream + genInfo->nPdfStream[p]; s++)
+         pst->vSize += hmset.swidth[s];
+
+      /* order (vecSize of static feature vector) of this PdfStream */
+      pst->order = (pdfStrOrder == NULL) ? 1 : pdfStrOrder[p];
+      if (pst->order < 1 || pst->order > pst->vSize)
+         HError(999, "CheckGenSetUp: Order of PdfStream %d should be within 1--%d", p, pst->vSize);
+
+      /* window coefficients */
+      if (winFn[p] == NULL)
+         HError(9999, "CheckGenSetUp: window file names are not specified");
+      pst->win.num = (int) winFn[p][0][0];
+      if (pst->win.num > MAXWINNUM)
+         HError(9999, "CheckGenSetUp: # of window out of range");
+      if (pst->win.num * pst->order != pst->vSize)
+         HError(9999, "CheckGenSetUp: # of window (%d) times order (%d) should be equal to vSize (%d)", pst->win.num, pst->order, pst->vSize);
+      for (d = 0; d < pst->win.num; d++)
+         MakeFN(winFn[p][d + 1], winDir, winExt, pst->win.fn[d]);
+
+      /* generated filename ext */
+      if (pdfStrExt == NULL)
+         strcpy(pst->ext, genExt);
+      else
+         strcpy(pst->ext, pdfStrExt[p]);
+   }
+   if (r != 0)
+      HError(9999, "CheckGenSetUp: # of streams in HMMSet (%d) and PdfStreams (%d) are inconsistent", hmset.swidth[0], genInfo->nPdfStream[0]);
+
+   /* output trace information */
+   if (trace & T_TOP) {
+      for (p = 1; p <= genInfo->nPdfStream[0]; p++) {
+         printf("PdfStream [%d]:\n", p);
+         printf("  #streams: %d (vSize=%d)\n", genInfo->nPdfStream[p], genInfo->pst[p].vSize);
+         printf("  #order:   %d\n", genInfo->pst[p].order);
+         printf("  file ext: %s\n", genInfo->pst[p].ext);
+         for (d = 0; d < pst->win.num; d++)
+            printf("  %d-th window: %s\n", d + 1, genInfo->pst[p].win.fn[d]);
+      }
+      printf("\n");
+      fflush(stdout);
+   }
+}
+
+int main(int argc, char *argv[])
+{
+   char *s;
+   char *labfn;
+   int numUtt;
+
+   void Initialise(void);
+   void DoGeneration(char *labfn);
+
+   if (InitShell(argc, argv, hmgens_version, hmgens_vc_id) < SUCCESS)
+      HError(2300, "HMGenS: InitShell failed");
+   InitMem();
+   InitMath();
+   InitSigP();
+   InitWave();
+   InitLabel();
+   InitModel();
+   if (InitParm() < SUCCESS)
+      HError(2300, "HMGenS: InitParm failed");
+   InitUtil();
+   InitFB();
+   InitAdapt(&xfInfo_hmm, &xfInfo_dur);
+   InitMap();
+   InitGen();
+
+   if (NumArgs() == 0)
+      ReportUsage();
+
+   CreateHeap(&genStack, "genStore", MSTAK, 1, 1.0, 80000, 400000);
+   CreateHeap(&uttStack, "uttStore", MSTAK, 1, 0.5, 100, 1000);
+   CreateHeap(&fbInfoStack, "FBInfoStore", MSTAK, 1, 0.5, 100, 1000);
+   CreateHeap(&hmmStack, "HmmStore", MSTAK, 1, 1.0, 50000, 500000);
+   CreateHeap(&dmStack, "dmStore", MSTAK, 1, 1.0, 50000, 500000);
+   SetConfParms();
+   CreateHMMSet(&hmset, &hmmStack, TRUE);
+   CreateHMMSet(&dmset, &dmStack, TRUE);
+
+   utt = (UttInfo *) New(&uttStack, sizeof(UttInfo));
+   genInfo = (GenInfo *) New(&genStack, sizeof(GenInfo));
+   fbInfo = (FBInfo *) New(&fbInfoStack, sizeof(FBInfo));
+
+   while (NextArg() == SWITCHARG) {
+      s = GetSwtArg();
+      if (strlen(s) != 1)
+         HError(9919, "HMGenS: Bad switch %s; must be single letter", s);
+      switch (s[0]) {
+      case 'a':
+         xfInfo_hmm.useInXForm = TRUE;
+         break;
+      case 'b':
+         xfInfo_dur.useInXForm = TRUE;
+         break;
+      case 'c':
+         if (NextArg() != INTARG)
+            HError(2119, "HMGenS: Parameter generation algorithm type value expected");
+         type = (ParmGenType) GetChkedInt(CHOLESKY, FB, s);
+         break;
+      case 'd':
+         if (NextArg() != STRINGARG)
+            HError(2319, "HMGenS: HMM definition directory expected");
+         hmmDir = GetStrArg();
+         break;
+      case 'e':
+         useAlign = TRUE;
+         break;
+      case 'f':
+         frameRate = (HTime) GetChkedFlt(0.0, 10000000.0, s);
+         break;
+      case 'g':
+         minFrwdP = GetChkedFlt(0.0, 1000.0, s);
+         break;
+      case 'h':
+         if (NextArg() != STRINGARG)
+            HError(1, "Speaker name pattern expected");
+         xfInfo_hmm.inSpkrPat = xfInfo_dur.inSpkrPat = GetStrArg();
+         if (NextArg() == STRINGARG)
+            xfInfo_hmm.paSpkrPat = xfInfo_dur.paSpkrPat = GetStrArg();
+         if (NextArg() != SWITCHARG)
+            HError(2319, "HMGenS: cannot have -h as the last option");
+         break;
+      case 'm':
+         modelAlign = TRUE;
+         break;
+      case 'n':
+         if (NextArg() != STRINGARG)
+            HError(2319, "HMGenS: duration model definition directory expected");
+         dmDir = GetStrArg();
+         break;
+      case 'p':
+         outPdf = TRUE;
+         break;
+      case 'r':
+         if (NextArg() != FLOATARG)
+            HError(2119, "HMGenS: Speaking rate value (float) expected");
+         speakRate = GetChkedFlt(0.0, 3.0, s);
+         break;
+      case 's':
+         stateAlign = TRUE;
+         break;
+      case 't':
+         pruneInit = GetChkedFlt(0.0, 1.0E20, s);
+         if (NextArg() == FLOATARG || NextArg() == INTARG) {
+            pruneInc = GetChkedFlt(0.0, 1.0E20, s);
+            pruneLim = GetChkedFlt(0.0, 1.0E20, s);
+         } else {
+            pruneInc = 0.0;
+            pruneLim = pruneInit;
+         }
+         break;
+      case 'v':
+         MSDthresh = GetChkedFlt(0.0, 1.0, s);
+         break;
+      case 'x':
+         if (NextArg() != STRINGARG)
+            HError(2319, "HMGenS: HMM file extension expected");
+         hmmExt = GetStrArg();
+         break;
+      case 'y':
+         if (NextArg() != STRINGARG)
+            HError(2319, "HMGenS: duration model file extension expected");
+         dmExt = GetStrArg();
+         break;
+      case 'B':
+         inBinary = TRUE;
+         break;
+      case 'E':
+         if (NextArg() != STRINGARG)
+            HError(2319, "HMGenS: parent transform directory expected");
+         xfInfo_hmm.usePaXForm = TRUE;
+         xfInfo_hmm.paXFormDir = GetStrArg();
+         if (NextArg() == STRINGARG)
+            xfInfo_hmm.paXFormExt = GetStrArg();
+         if (NextArg() != SWITCHARG)
+            HError(2319, "HMGenS: cannot have -E as the last option");
+         break;
+      case 'G':
+         if (NextArg() != STRINGARG)
+            HError(2119, "HMGenS: Label File format expected");
+         if ((lff = Str2Format(GetStrArg())) == ALIEN)
+            HError(-2189, "HMGenS: Warning ALIEN Label file format set");
+         break;
+      case 'H':
+         if (NextArg() != STRINGARG)
+            HError(3219, "HMGenS: HMM MMF File name expected");
+         AddMMF(&hmset, GetStrArg());
+         break;
+      case 'I':
+         if (NextArg() != STRINGARG)
+            HError(2319, "HMGenS: MLF file name expected");
+         LoadMasterFile(GetStrArg());
+         break;
+      case 'J':
+         if (NextArg() != STRINGARG)
+            HError(2319, "HMGenS: input transform directory expected");
+         AddInXFormDir(&hmset, GetStrArg());
+         if (NextArg() == STRINGARG)
+            xfInfo_hmm.inXFormExt = GetStrArg();
+         if (NextArg() != SWITCHARG)
+            HError(2319, "HMGenS: cannot have -J as the last option");
+         break;
+      case 'L':
+         if (NextArg() != STRINGARG)
+            HError(2319, "HMGenS: Label file directory expected");
+         labDir = GetStrArg();
+         break;
+      case 'M':
+         if (NextArg() != STRINGARG)
+            HError(2319, "HMGenS: Output macro file directory expected");
+         genDir = GetStrArg();
+         break;
+      case 'N':
+         if (NextArg() != STRINGARG)
+            HError(3219, "HMGenS: Duration MMF File name expected");
+         AddMMF(&dmset, GetStrArg());
+         break;
+      case 'T':
+         if (NextArg() != INTARG)
+            HError(2119, "HMGenS: Trace value expected");
+         trace = GetChkedInt(0, 0002, s);
+         break;
+      case 'W':
+         if (NextArg() != STRINGARG)
+            HError(2319, "HMGenS: parent duration transform directory expected");
+         xfInfo_dur.usePaXForm = TRUE;
+         xfInfo_dur.paXFormDir = GetStrArg();
+         if (NextArg() == STRINGARG)
+            xfInfo_dur.paXFormExt = GetStrArg();
+         if (NextArg() != SWITCHARG)
+            HError(2319, "HMGenS: cannot have -W as the last option");
+         break;
+      case 'X':
+         if (NextArg() != STRINGARG)
+            HError(2319, "HMGenS: Label file extension expected");
+         labExt = GetStrArg();
+         break;
+      case 'Y':
+         if (NextArg() != STRINGARG)
+            HError(2319, "HMGenS: input duration transform directory expected");
+         AddInXFormDir(&dmset, GetStrArg());
+         if (NextArg() == STRINGARG) {
+            if (xfInfo_dur.inXFormExt == NULL)
+               xfInfo_dur.inXFormExt = GetStrArg();
+            else
+               HError(2319, "MGenS: only one input duration transform extension may be specified");
+         }
+         if (NextArg() != SWITCHARG)
+            HError(2319, "HMGenS: cannot have -Y as the last option");
+         break;
+      default:
+         HError(9919, "HMGenS: Unknown switch %s", s);
+      }
+   }
+   if (NextArg() != STRINGARG)
+      HError(2319, "HMGenS: file name of vocabulary list expected");
+
+   Initialise();
+   InitUttInfo(utt, FALSE);
+   numUtt = 1;
+
+   if (trace & T_TOP)
+      SetTraceGen();
+
+   /* generate parameter sequences */
+   do {
+      if (NextArg() != STRINGARG)
+         HError(2319, "HMGenS: data file name expected");
+      labfn = GetStrArg();
+
+      /* track speakers */
+      if (UpdateSpkrStats(&hmset, &xfInfo_hmm, labfn)) {
+         if (!xfInfo_hmm.useInXForm)
+            xfInfo_hmm.inXForm = NULL;
+      }
+      if (UpdateSpkrStats(&dmset, &xfInfo_dur, labfn)) {
+         if (!xfInfo_dur.useInXForm)
+            xfInfo_dur.inXForm = NULL;
+         else
+            ResetDMMPreComps(&dmset);
+      }
+
+      fbInfo->xfinfo_hmm = &xfInfo_hmm;
+      fbInfo->xfinfo_dur = &xfInfo_dur;
+      fbInfo->inXForm_hmm = xfInfo_hmm.inXForm;
+      fbInfo->inXForm_dur = xfInfo_dur.inXForm;
+      fbInfo->al_inXForm_hmm = xfInfo_hmm.al_inXForm;
+      fbInfo->al_inXForm_dur = xfInfo_dur.al_inXForm;
+      fbInfo->paXForm_hmm = xfInfo_hmm.paXForm;
+      fbInfo->paXForm_dur = xfInfo_dur.paXForm;
+
+      /* generate parameters */
+      DoGeneration(labfn);
+      numUtt++;
+   } while (NumArgs() > 0);
+
+   if (trace & T_TOP) {
+      printf("Generation complete - average log prob per frame = %e (%d frames)\n", totalPr / totalT, totalT);
+   }
+
+   /* Reset stacks */
+   Dispose(&fbInfoStack, fbInfo);
+   Dispose(&genStack, genInfo);
+   Dispose(&uttStack, utt);
+   ResetHeap(&fbInfoStack);
+   ResetHeap(&uttStack);
+   ResetHeap(&genStack);
+   ResetHeap(&dmStack);
+   ResetHeap(&hmmStack);
+
+   /* Reset modules */
+   ResetGen();
+   ResetAdapt(&xfInfo_hmm, &xfInfo_dur);
+   ResetFB();
+   ResetUtil();
+   ResetParm();
+   ResetModel();
+   ResetLabel();
+   ResetWave();
+   ResetSigP();
+   ResetMath();
+   ResetMem();
+   ResetShell();
+
+   Exit(0);
+   return (0);                  /* never reached -- make compiler happy */
+}
+
+/* -------------------------- Initialisation ----------------------- */
+
+void Initialise(void)
+{
+   /* load HMM mmf */
+   if (MakeHMMSet(&hmset, GetStrArg()) < SUCCESS)
+      HError(9928, "Initialise: MakeHMMSet failed");
+   if (LoadHMMSet(&hmset, hmmDir, hmmExt) < SUCCESS)
+      HError(9928, "Initialise: LoadHMMSet failed");
+   if (hmset.hsKind == DISCRETEHS)
+      HError(9999, "Initialise: Only continuous model is surpported");
+   ConvDiagC(&hmset, TRUE);
+
+   if (trace & T_TOP) {
+      PrintrFlags();
+      printf("HMMSet is ");
+      switch (hmset.hsKind) {
+      case PLAINHS:
+         printf("PLAIN\n");
+         break;
+      case SHAREDHS:
+         printf("SHARED\n");
+         break;
+      case TIEDHS:
+         printf("TIED\n");
+         break;
+      default:
+         HError(9999, "Initialise: Only continuous model is supported");
+      }
+
+      printf("%d Logical/%d Physical Models Loaded, VecSize=%d\n", hmset.numLogHMM, hmset.numPhyHMM, hmset.vecSize);
+      if (hmset.numFiles > 0)
+         printf("%d MMF input files\n", hmset.numFiles);
+      fflush(stdout);
+   }
+
+   /* load duration mmf */
+   if (!stateAlign) {
+      if (MakeHMMSet(&dmset, GetStrArg()) < SUCCESS)
+         HError(9928, "Initialise: MakeHMMSet failed");
+      if (LoadHMMSet(&dmset, dmDir, dmExt) < SUCCESS)
+         HError(9928, "Initialise: LoadHMMSet failed");
+      if (hmset.hsKind == DISCRETEHS)
+         HError(9999, "Initialise: Only continuous duration model mmf is surpported");
+      ConvDiagC(&dmset, TRUE);
+
+      if (trace & T_TOP) {
+         printf("DurationModelSet is ");
+         switch (dmset.hsKind) {
+         case PLAINHS:
+            printf("PLAIN\n");
+            break;
+         case SHAREDHS:
+            printf("SHARED\n");
+            break;
+         case TIEDHS:
+            printf("TIED\n");
+            break;
+         default:
+            HError(9999, "Initialise: Only continuous model is supported");
+         }
+
+         printf("%d Logical/%d Physical Models Loaded, VecSize=%d\n", dmset.numLogHMM, dmset.numPhyHMM, dmset.vecSize);
+         if (dmset.numFiles > 0)
+            printf("%d MMF input files\n", dmset.numFiles);
+         fflush(stdout);
+      }
+   }
+
+   /* setup GenInfo */
+   genInfo->genMem = &genStack;
+   genInfo->hset = &hmset;
+   genInfo->dset = &dmset;
+   genInfo->maxStates = MaxStatesInSet(&hmset);
+   genInfo->maxMixes = MaxMixInSet(&hmset);
+   genInfo->speakRate = speakRate;
+   genInfo->MSDthresh = MSDthresh;
+   genInfo->modelAlign = modelAlign;
+   genInfo->stateAlign = stateAlign;
+   genInfo->frameRate = frameRate;
+
+   CheckGenSetUp();
+
+   /* setup EM-based parameter generation */
+   AttachAccs(&hmset, &gstack, (UPDSet) 0);
+   ZeroAccs(&hmset, (UPDSet) 0);
+
+   if (!stateAlign) {
+      AttachAccs(&dmset, &gstack, (UPDSet) 0);
+      ZeroAccs(&dmset, (UPDSet) 0);
+   }
+
+   if (type != CHOLESKY)
+      InitialiseForBack(fbInfo, &fbInfoStack, &hmset, (UPDSet) 0, ((useHMMFB || stateAlign) ? NULL : &dmset), (UPDSet) 0, pruneInit, pruneInc, pruneLim, minFrwdP, useAlign, FALSE);
+
+   /* handle input xform */
+   xfInfo_hmm.inFullC = xfInfo_dur.inFullC = TRUE;
+
+   /* semi-tied case */
+   if (hmset.semiTied != NULL) {
+      SetXForm(&hmset, NULL, hmset.semiTied);
+      ApplyHMMSetXForm(&hmset, hmset.semiTied, TRUE);
+   }
+
+   /* linear weight -> log weight */
+   ConvLogWt(&hmset);
+}
+
+/* -------------------- output routines ------------------------- */
+
+/* WriteStateDurations: output state duration to file */
+void WriteStateDurations(char *labfn, GenInfo * genInfo)
+{
+   char fn[MAXFNAMELEN];
+   int i, j, k, s, cnt, nState, modeldur;
+   float modelMean;
+   Label *label;
+   FILE *durfp;
+   Vector mean = NULL;
+   Boolean isPipe;
+
+   /* open file pointer for saving state durations */
+   MakeFN(labfn, genDir, durExt, fn);
+   if ((durfp = FOpen(fn, NoOFilter, &isPipe)) == NULL)
+      HError(9911, "WriteStateDurations: Cannot create output file %s", fn);
+
+   /* prepare mean vector */
+   mean = CreateVector(genInfo->genMem, genInfo->maxStates);
+
+   for (i = 1; i <= genInfo->labseqlen; i++) {
+      label = GetLabN(genInfo->labseq->head, i);
+      nState = genInfo->hmm[i]->numStates - 2;
+
+      /* compose mean vector of the i-th state duration model */
+      for (s = cnt = 1; s <= genInfo->dset->swidth[0]; s++) {
+         for (k = 1; k <= genInfo->dset->swidth[s]; k++, cnt++)
+            mean[cnt] = genInfo->dm[i]->svec[2].info->pdf[s].info->spdf.cpdf[1].mpdf->mean[k];
+      }
+
+      modeldur = 0;
+      modelMean = 0.0;
+      for (j = 1; genInfo->sindex[i][j] != 0; j++) {
+         /* output state duration */
+         fprintf(durfp, "%s.state[%d]: duration=%d (frame), mean=%e\n", label->labid->name, genInfo->sindex[i][j], genInfo->durations[i][j], mean[genInfo->sindex[i][j] - 1]);
+         fflush(durfp);
+
+         if (trace & T_DUR) {
+            printf("%s.state[%d]: duration=%d (frame), mean=%e\n", label->labid->name, genInfo->sindex[i][j], genInfo->durations[i][j], mean[genInfo->sindex[i][j] - 1]);
+            fflush(stdout);
+         }
+
+         modeldur += genInfo->durations[i][j];
+         modelMean += mean[genInfo->sindex[i][j] - 1];
+      }
+
+      fprintf(durfp, "%s: duration=%d (frame), mean=%e\n", label->labid->name, modeldur, modelMean);
+      fflush(durfp);
+
+      if (trace & T_DUR) {
+         printf("%s: duration=%d (frame), mean=%e\n", label->labid->name, modeldur, modelMean);
+         fflush(stdout);
+      }
+   }
+
+   /* dispose mean vector */
+   FreeVector(genInfo->genMem, mean);
+
+   /* close file pointer for saving state durations */
+   FClose(durfp, isPipe);
+
+   return;
+}
+
+/* WriteParms: write generated parameter vector sequences */
+void WriteParms(char *labfn, GenInfo * genInfo)
+{
+   int p, t, v, k;
+   char ext[MAXSTRLEN], fn[MAXFNAMELEN];
+   float ig;
+   Vector igvec;
+   TriMat igtm;
+   FILE *parmfp = NULL, *pdffp = NULL;
+   Boolean isPipe1, isPipe2;
+   PdfStream *pst;
+
+   /* get ignore value for MSD */
+   ig = ReturnIgnoreValue();
+
+   /* save generated parameters */
+   for (p = 1; p <= genInfo->nPdfStream[0]; p++) {
+      /* p-th PdfStream */
+      pst = &(genInfo->pst[p]);
+
+      /* create ignore value vector/triangular matrix */
+      igvec = CreateVector(&genStack, pst->vSize);
+      igtm = CreateTriMat(&genStack, pst->vSize);
+      for (v = 1; v <= pst->vSize; v++) {
+         igvec[v] = ig;
+         for (k = 1; k <= v; k++)
+            igtm[v][k] = ig;
+      }
+
+      /* open file pointer for saving generated parameters */
+      MakeFN(labfn, genDir, pst->ext, fn);
+      if ((parmfp = FOpen(fn, NoOFilter, &isPipe1)) == NULL)
+         HError(9911, "WriteParms: Cannot create ouput file %s", fn);
+
+      /* open file pointer for saving pdf parameters */
+      if (outPdf) {
+         sprintf(ext, "%s_%s", pst->ext, pdfExt);
+         MakeFN(labfn, genDir, ext, fn);
+         if ((pdffp = FOpen(fn, NoOFilter, &isPipe2)) == NULL)
+            HError(9911, "WriteParms: Cannot create output file %s", fn);
+      }
+
+      /* output generated parameter sequence */
+      for (t = pst->t = 1; t <= genInfo->tframe; t++) {
+         if (pst->ContSpace[t]) {
+            /* output generated parameters */
+            WriteVector(parmfp, pst->C[pst->t], inBinary);
+
+            /* output pdfs */
+            if (outPdf) {
+               WriteVector(pdffp, pst->mseq[pst->t], inBinary);
+               if (pst->fullCov)
+                  WriteTriMat(pdffp, pst->vseq[pst->t].inv, inBinary);
+               else
+                  WriteVector(pdffp, pst->vseq[pst->t].var, inBinary);
+            }
+
+            pst->t++;
+         } else {
+            /* output ignoreValue symbol for generated parameters */
+            WriteFloat(parmfp, &igvec[1], pst->order, inBinary);
+
+            /* output ignoreValue symbol for pdfs */
+            if (outPdf) {
+               WriteVector(pdffp, igvec, inBinary);
+               if (pst->fullCov)
+                  WriteTriMat(pdffp, igtm, inBinary);
+               else
+                  WriteVector(pdffp, igvec, inBinary);
+            }
+         }
+      }
+
+      /* close file pointer */
+      if (outPdf)
+         FClose(pdffp, isPipe2);
+      FClose(parmfp, isPipe1);
+
+      /* free igvec */
+      FreeVector(&genStack, igvec);
+   }
+
+   return;
+}
+
+/* ----------------------- Generate parameter sequences from HMMs ----------------------- */
+
+/* DoGeneration: Generate parameter sequences from HMMs */
+void DoGeneration(char *labfn)
+{
+   char labFn[MAXFNAMELEN], buf[MAXSTRLEN];
+   int t;
+   Boolean eSep;
+   Transcription *tr;
+
+   if (trace & T_TOP) {
+      printf(" Generating Label %s\n", NameOf(labfn, buf));
+      fflush(stdout);
+   }
+
+   /* load a given input label file */
+   ResetHeap(&utt->transStack);
+   MakeFN(labfn, labDir, labExt, labFn);
+   tr = LOpen(&genStack, labFn, lff);
+
+   /* compose a sentence HMM corresponding to the input label */
+   InitialiseGenInfo(genInfo, tr, FALSE);
+
+   /* set utterance informations for forward-backward algorithm */
+   SetStreamWidths(hmset.pkind, hmset.vecSize, hmset.swidth, &eSep);
+   utt->tr = tr;
+   utt->Q = genInfo->labseqlen;
+   utt->T = genInfo->tframe;
+   utt->twoDataFiles = FALSE;
+   utt->o = (Observation *) New(&gstack, utt->T * sizeof(Observation));
+   utt->o--;
+   for (t = 1; t <= utt->T; t++)
+      utt->o[t] = MakeObservation(&gstack, hmset.swidth, hmset.pkind, FALSE, eSep);
+
+   /* parameter generation */
+   ParamGen(genInfo, utt, fbInfo, type);
+
+   /* output state durations and generated parameter sequences */
+   if (!stateAlign)
+      WriteStateDurations(labfn, genInfo);
+   WriteParms(labfn, genInfo);
+
+   /* free memory */
+   Dispose(&gstack, ++utt->o);
+   ResetGenInfo(genInfo);
+
+   /* increment total number of generated frames */
+   totalT += utt->T;
+   totalPr += utt->pr;
+
+   return;
+}
+
+/* ----------------------------------------------------------- */
+/*                      END:  HMGenS.c                         */
+/* ----------------------------------------------------------- */
diff -pbBEwurNa --ignore-matching-lines='.*vc_id.*' HTK-3.4.1/HTKTools/HMMIRest.c HTS-2.2_for_HTK-3.4.1/HTKTools/HMMIRest.c
--- HTK-3.4.1/HTKTools/HMMIRest.c	2009-03-13 03:53:07.000000000 +0900
+++ HTS-2.2_for_HTK-3.4.1/HTKTools/HMMIRest.c	2011-06-16 13:18:30.000000000 +0900
@@ -28,6 +28,51 @@
 /*     Using Frame Discrimination.                             */
 /* ----------------------------------------------------------- */
 
+/*  *** THIS IS A MODIFIED VERSION OF HTK ***                        */
+/* ----------------------------------------------------------------- */
+/*           The HMM-Based Speech Synthesis System (HTS)             */
+/*           developed by HTS Working Group                          */
+/*           http://hts.sp.nitech.ac.jp/                             */
+/* ----------------------------------------------------------------- */
+/*                                                                   */
+/*  Copyright (c) 2001-2011  Nagoya Institute of Technology          */
+/*                           Department of Computer Science          */
+/*                                                                   */
+/*                2001-2008  Tokyo Institute of Technology           */
+/*                           Interdisciplinary Graduate School of    */
+/*                           Science and Engineering                 */
+/*                                                                   */
+/* All rights reserved.                                              */
+/*                                                                   */
+/* Redistribution and use in source and binary forms, with or        */
+/* without modification, are permitted provided that the following   */
+/* conditions are met:                                               */
+/*                                                                   */
+/* - Redistributions of source code must retain the above copyright  */
+/*   notice, this list of conditions and the following disclaimer.   */
+/* - Redistributions in binary form must reproduce the above         */
+/*   copyright notice, this list of conditions and the following     */
+/*   disclaimer in the documentation and/or other materials provided */
+/*   with the distribution.                                          */
+/* - Neither the name of the HTS working group nor the names of its  */
+/*   contributors may be used to endorse or promote products derived */
+/*   from this software without specific prior written permission.   */
+/*                                                                   */
+/* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND            */
+/* CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,       */
+/* INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF          */
+/* MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE          */
+/* DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS */
+/* BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,          */
+/* EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED   */
+/* TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,     */
+/* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON */
+/* ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,   */
+/* OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY    */
+/* OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE           */
+/* POSSIBILITY OF SUCH DAMAGE.                                       */
+/* ----------------------------------------------------------------- */
+
 #define EXITSTATUS 0 /*2 for gprof.*/
 
 char *hmmirest_version = "!HVER!HMMIRest:   3.4.1 [CUED 12/03/09]";
@@ -114,9 +159,9 @@ static float mixWeightFloor=MINMIX*2; /*
 
 static int nSnt      = 0;        /* num sentences from current speaker */
 
-static UPDSet uFlags = UPMEANS|UPVARS|UPTRANS|UPMIXES;   /* update flags */
-static UPDSet uFlagsAccs = UPMEANS|UPVARS|UPTRANS|UPMIXES;   /* used in storing accs. */
-static UPDSet uFlagsMLE = 0; /*which we only update with MLE, ignoring the MMI parameters.*/
+static UPDSet uFlags = (UPDSet) (UPMEANS|UPVARS|UPTRANS|UPMIXES);   /* update flags */
+static UPDSet uFlagsAccs = (UPDSet) (UPMEANS|UPVARS|UPTRANS|UPMIXES);   /* used in storing accs. */
+static UPDSet uFlagsMLE = (UPDSet) 0; /*which we only update with MLE, ignoring the MMI parameters.*/
 
 
 static int parMode   = -1;       /* enable one of the parallel modes */
@@ -254,15 +299,17 @@ void SetConfParms(void)
       if (GetConfFlt(cParm,nParm,"E",&f)) E = f;
       if (GetConfFlt(cParm,nParm,"DFACTOROCC",&f)) E = f; /*Back-compat. */
       if (GetConfFlt(cParm,nParm,"HCRIT",&f)) hcrit = f;
-      if (GetConfBool(cParm,nParm,"MPE",&b)){  MPE = b; THREEACCS=MPE&&MPEStoreML; }
-      if (GetConfBool(cParm,nParm,"MWE",&b)){  MPE = b; THREEACCS=MPE&&MPEStoreML; } /* "MWE" has identical effects here but differs in HFBLat.c */
-      if (GetConfBool(cParm,nParm,"MEE",&b)){  MPE = b; THREEACCS=MPE&&MPEStoreML; } /* Back-compat. */
-      if (GetConfBool(cParm,nParm,"MLE",&b)){  ML_MODE=TRUE; THREEACCS=FALSE; 
-      uFlagsMLE =  UPMEANS|UPVARS|UPTRANS|UPMIXES; }
+      if (GetConfBool(cParm,nParm,"MPE",&b)){  MPE = b; THREEACCS=(MPE&&MPEStoreML) ? TRUE:FALSE; }
+      if (GetConfBool(cParm,nParm,"MWE",&b)){  MPE = b; THREEACCS=(MPE&&MPEStoreML) ? TRUE:FALSE; } /* "MWE" has identical effects here but differs in HFBLat.c */
+      if (GetConfBool(cParm,nParm,"MEE",&b)){  MPE = b; THREEACCS=(MPE&&MPEStoreML) ? TRUE:FALSE; } /* Back-compat. */
+      if (GetConfBool(cParm,nParm,"MLE",&b)) {  
+         ML_MODE=TRUE; THREEACCS=FALSE; 
+         uFlagsMLE = (UPDSet) (UPMEANS|UPVARS|UPTRANS|UPMIXES); 
+      }
       if (GetConfBool(cParm,nParm,"MMIPRIOR",&b)){  MMIPrior = b;}
       if (GetConfFlt(cParm,nParm,"MMITAUI",&f)){ MMITauI = f;}
-      if (GetConfFlt(cParm,nParm,"ISMOOTHTAU",&f)){ ISmoothTau = f; MPEStoreML=TRUE; THREEACCS=MPE&&MPEStoreML; }
-      if (GetConfFlt(cParm,nParm,"ICRITOCC",  &f)){ ISmoothTau = f; MPEStoreML=TRUE; THREEACCS=MPE&&MPEStoreML; } /*back-compat. */
+      if (GetConfFlt(cParm,nParm,"ISMOOTHTAU",&f)){ ISmoothTau = f; MPEStoreML=TRUE; THREEACCS=(MPE&&MPEStoreML) ? TRUE:FALSE; }
+      if (GetConfFlt(cParm,nParm,"ICRITOCC",  &f)){ ISmoothTau = f; MPEStoreML=TRUE; THREEACCS=(MPE&&MPEStoreML) ? TRUE:FALSE; } /*back-compat. */
 
       if (GetConfFlt(cParm,nParm,"ISMOOTHTAUT",&f)){ ISmoothTauTrans = f; ISmoothTauTransSet=TRUE; }
       if (GetConfFlt(cParm,nParm,"ISMOOTHTAUW",&f)){ ISmoothTauWeights = f; ISmoothTauWeightsSet=TRUE; }
@@ -321,6 +368,7 @@ void SetConfParms(void)
 
 void ReportUsage(void)
 {
+   printf("\nModified for HTS\n");
    printf("\nUSAGE: HMMIRest [options] hmmList dataFiles...\n\n");
    printf(" Option                                   Default\n\n");
    printf(" -a      Use an input linear transform        off\n");
@@ -358,19 +406,20 @@ void SetuFlags(UPDSet *uFlags)
    char *s;
    
    s=GetStrArg();
-   *uFlags=0;        
+   *uFlags=(UPDSet)0;        
    while (*s != '\0')
       switch (*s++) {
-      case 't': (*uFlags)+=UPTRANS; break;
-      case 'm': (*uFlags)+=UPMEANS; break;
-      case 'v': (*uFlags)+=UPVARS;  break;
-      case 'w': (*uFlags)+=UPMIXES; break;
-      case 'a': (*uFlags)+=UPXFORM; break;
+      case 't': (*uFlags) = (UPDSet) ((*uFlags)+UPTRANS); break;
+      case 'm': (*uFlags) = (UPDSet) ((*uFlags)+UPMEANS); break;
+      case 'v': (*uFlags) = (UPDSet) ((*uFlags)+UPVARS);  break;
+      case 'w': (*uFlags) = (UPDSet) ((*uFlags)+UPMIXES); break;
+      case 'a': (*uFlags) = (UPDSet) ((*uFlags)+UPXFORM); break;
       }
 }
 
 
-void PrintCriteria(){
+void PrintCriteria (void)
+{
    printf("\nMMI criterion per frame is: %f (%f - %f)\n", (totalPr1-totalPr2)/totalT,totalPr1/totalT,totalPr2/totalT);
    if(MPE) printf("\nMPE/MWE criterion is: %f ( %f / %d )\n", TotalCorr/TotalNWords, TotalCorr, TotalNWords);
    if(!MPE || MPEStoreML) printf("\nML criterion per frame is: %f (%f/%d)\n", totalPr1/totalT,totalPr1, totalT);
@@ -410,7 +459,7 @@ int main(int argc, char *argv[]) 
    InitDict();
    InitLat();
    InitNet();
-   InitAdapt(&xfInfo); 
+   InitAdapt(&xfInfo,NULL); 
 
    if (!InfoPrinted() && NumArgs() == 0)
       ReportUsage();
@@ -437,7 +486,7 @@ int main(int argc, char *argv[]) 
         break;   
 
       case 'g': ML_MODE=TRUE; THREEACCS=FALSE;/*This is the option used during re-estimation when we are only using one set of accs.*/
-         uFlagsMLE =  UPMEANS|UPVARS|UPTRANS|UPMIXES; /*TODO, check if necessary. */
+         uFlagsMLE = (UPDSet)(UPMEANS|UPVARS|UPTRANS|UPMIXES); /*TODO, check if necessary. */
          break; 
       case 'l':
          maxSnt = GetChkedInt(0,1000,s); break;
@@ -696,6 +745,7 @@ int main(int argc, char *argv[]) 
 	    }
 	 
             if (UpdateSpkrStats(&hset,&xfInfo, datafn)) nSnt=0 ;
+            fbInfo.xfinfo  = &xfInfo;
             fbInfo.inXForm = xfInfo.inXForm;
             fbInfo.paXForm = xfInfo.paXForm;
 
@@ -709,7 +759,7 @@ int main(int argc, char *argv[]) 
                strcpy (datafn_lat, datafn);
 
             if(nDenLats > 0){ /* Load denominator (recognition) lattices. */
-               char buf1[1024],buf2[1024],buf3[1024];
+               char buf1[MAXFNAMELEN],buf2[MAXFNAMELEN],buf3[MAXFNAMELEN];
                for(latn = 0; latn<nDenLats;latn++){
                   if ( denLatSubDirPat[0] ){
                      if ( !MaskMatch( denLatSubDirPat , buf1 , datafn_lat ) )
@@ -741,7 +791,7 @@ int main(int argc, char *argv[]) 
             }
 
             if(nNumLats > 0){  /* Load numerator (correct transcription) lattices. */
-               char buf1[1024],buf2[1024],buf3[1024];
+               char buf1[MAXFNAMELEN],buf2[MAXFNAMELEN],buf3[MAXFNAMELEN];
                for(latn=0;latn<nNumLats;latn++){
                   if ( numLatSubDirPat[0] ){
                      if ( !MaskMatch( numLatSubDirPat , buf1 , datafn_lat ) )
@@ -774,8 +824,8 @@ int main(int argc, char *argv[]) 
             { /*apply F-B*/
                Boolean DoCorrectSentence,DoRecogLattice;
                int CorrIndex,RecogIndex1, RecogIndex2;
-               DoCorrectSentence = !MPE || (MPE&&MPEStoreML);
-               DoRecogLattice = !ML_MODE;
+               DoCorrectSentence = (!MPE || (MPE&&MPEStoreML)) ? TRUE:FALSE;
+               DoRecogLattice = (!ML_MODE) ? TRUE:FALSE;
 
                CorrIndex = MPE&&!ML_MODE ? 2 : 0;   /* If MPE then the correct transcription ("mle" acc) goes in position 2, if MMI then in 0. */
                RecogIndex1 = MPE ? 0 : 1;  /* If MPE then the first of the indices of the recognition lattice is the "num" acc (0).
@@ -884,6 +934,28 @@ int main(int argc, char *argv[]) 
       if (updateMode&UPMODE_UPDATE)
         UpdateModels(); 
    }
+
+   /* Reset modules */
+   ResetAdapt(&xfInfo,NULL);
+   ResetNet();
+   ResetLat();
+   ResetDict();
+   ResetArc();
+   ResetExactMPE();
+   ResetFBLat();
+   ResetUtil();
+   ResetTrain();
+   ResetLabel();
+   ResetParm();
+   ResetModel();
+   ResetVQ();
+   ResetWave();
+   ResetAudio();
+   ResetSigP();
+   ResetMath();
+   ResetMem();
+   ResetShell();
+   
    Exit(EXITSTATUS);
    return (0);          /* keep compiler happy */
 }
@@ -892,7 +964,7 @@ int main(int argc, char *argv[]) 
 
 void Initialise(char *hmmListFn)
 {  
-   char buf[256];
+   char buf[MAXSTRLEN];
 
    CreateHeap(&transStack,   "transStore",    MSTAK, 1, 0.5, 1000,  10000);
    CreateHeap(&accStack,   "accStore",    MSTAK, 1, 1.0, 50000,  500000);
@@ -914,7 +986,7 @@ void Initialise(char *hmmListFn)
    else NumAccs=2;
    
    {
-      uFlagsAccs =  uFlags|(uFlags&UPMEANS||uFlags&UPVARS ? UPMEANS|UPVARS : 0);  
+      uFlagsAccs = (UPDSet) (uFlags|(uFlags&UPMEANS||uFlags&UPVARS ? UPMEANS|UPVARS : 0));  
       /*That modification to uFlags means: if either mean or var is updated, accumulate both.*/
       AttachAccsParallel(&hset, &accStack, uFlagsAccs, NumAccs);
       ZeroAccsParallel(&hset, uFlagsAccs, NumAccs); 
@@ -940,7 +1012,7 @@ void Initialise(char *hmmListFn)
    /*!Deleted*/
 
    /*Initialise those modules.*/
-   InitialiseFBInfo(&fbInfo, &hset,   uFlags|(uFlags&UPMEANS||uFlags&UPVARS ? UPMEANS|UPVARS : 0), twoDataFiles);
+   InitialiseFBInfo(&fbInfo, &hset, (UPDSet)(uFlags|(uFlags&UPMEANS||uFlags&UPVARS ? UPMEANS|UPVARS : 0)), twoDataFiles);
    /*That modification to uFlags means: if either mean or var is updated, accumulate both.*/
  
 
@@ -962,7 +1034,7 @@ void Initialise(char *hmmListFn)
           HError(999,"Can only update linear transforms OR model parameters!");
         xfInfo.useOutXForm = TRUE;
         /* This initialises things - temporary hack - THINK!! */
-        CreateAdaptXForm(&hset, "tmp"); 
+        CreateAdaptXForm(&hset, &xfInfo, "tmp"); 
       }
       printf("\n ");
       if (parMode>=0) printf("Parallel-Mode[%d] ",parMode);
@@ -992,7 +1064,7 @@ void Initialise(char *hmmListFn)
 /* ------------------- Statistics Reporting  -------------------- */
 
 /* PrintStats: for given hmm */
-void PrintStats(FILE *f, int n, HLink hmm, int numEgs)
+void PrintStats(FILE *f, int n, HLink hmm, long numEgs)
 {
    WtAcc *wa;
    char buf[MAXSTRLEN];
@@ -1001,10 +1073,10 @@ void PrintStats(FILE *f, int n, HLink hm
     
    N = hmm->numStates;
    ReWriteString(HMMPhysName(&hset,hmm),buf,DBL_QUOTE);
-   fprintf(f,"%4d %14s %4d ",n,buf,numEgs);
+   fprintf(f,"%4d %14s %4ld ",n,buf,numEgs);
    for (i=2;i<N;i++) {
       si = hmm->svec[i].info;
-      wa = (WtAcc *)((si->pdf+1)->hook);
+      wa = (WtAcc *)(si->pdf[1].info->hook);
       fprintf(f," %10f",wa->occ);
    }
    fprintf(f,"\n");
@@ -1026,7 +1098,7 @@ void StatReport(void) /*This is used by 
    px=1;
    do {
       hmm = hss.hmm;
-      PrintStats(f,px,hmm,(int)hmm->hook);
+      PrintStats(f,px,hmm,(long)hmm->hook);
       px++;
    } while (GoNextHMM(&hss));
    EndHMMScan(&hss);
@@ -1348,18 +1420,20 @@ Boolean UpdateGauss(int stream, MixPDF *
 
 
 
-void UpdateWeightsAndTrans(void){
+void UpdateWeightsAndTrans (void)
+{
    HMMScanState hss;
    HLink hmm;
-   int px,n;
-   void UpdateWeight(int s, StreamElem *ste);
+   int px;
+   long n;
+   void UpdateWeight(const int s, StreamInfo *sti);
 
    NewHMMScan(&hset,&hss);
 
 
    while(GoNextStream(&hss,FALSE)){
       if(uFlags&UPMIXES)
-         UpdateWeight(hss.s, hss.ste);
+         UpdateWeight(hss.s, hss.sti);
    }
    EndHMMScan(&hss);
 
@@ -1368,7 +1442,7 @@ void UpdateWeightsAndTrans(void){
    do{
       void UpdateTrans(int px, HLink hmm);
       hmm=hss.hmm;
-      n = (int)hmm->hook; /*The number of training egs seen*/
+      n = (long)hmm->hook; /*The number of training egs seen*/
 
       /* n is NO LONGER USED. */
 
@@ -1377,18 +1451,21 @@ void UpdateWeightsAndTrans(void){
       px++;
    }while (GoNextHMM(&hss));
    EndHMMScan(&hss);
+   
+   return;
 }
 
 
 static void FixHMMForICrit();
 
 
-static void FixWeightsForICrit(float Tau, Boolean THREEACCS){
+static void FixWeightsForICrit(float Tau, Boolean THREEACCS)
+{
    HMMScanState hss;
    NewHMMScan(&hset,&hss); 
    while(GoNextStream(&hss,FALSE)){
       WtAcc *wa_src, *wa_dst; int m,M;
-      M = hss.M; wa_dst = (WtAcc*)hss.ste->hook; wa_src = (THREEACCS ? wa_dst+2 : wa_dst); /* THREEACCS should be true for the forseeable use of this. */
+      M = hss.M; wa_dst = (WtAcc*)hss.sti->hook; wa_src = (THREEACCS ? wa_dst+2 : wa_dst); /* THREEACCS should be true for the forseeable use of this. */
 
       for(m=1;m<=M;m++) wa_dst->c[m] += Tau * (wa_src->occ ? wa_src->c[m]/wa_src->occ : 1/M);
       if(!wa_src->occ) HError(-1, "wa_src->occ zero, in FixWeightsForICrit.");
@@ -1397,8 +1474,10 @@ static void FixWeightsForICrit(float Tau
    EndHMMScan(&hss); 
 }
 
-static void FixTransForICrit(float Tau, Boolean THREEACCS){
+static void FixTransForICrit(float Tau, Boolean THREEACCS)
+{
    HMMScanState hss;
+
    NewHMMScan(&hset,&hss); 
    do{
       TrAcc *ta_src, *ta_dst; int m,M;
@@ -1408,7 +1487,7 @@ static void FixTransForICrit(float Tau, 
          int n;
          if(ta_src->occ[m] != 0){
             for(n=1;n<=M;n++){
-               ta_dst->tran[m][n] += Tau /*not * M!*/  *  ta_src->tran[m][n]/ta_src->occ[m];
+               ta_dst->tran[m][n] += Tau * ta_src->tran[m][n]/ta_src->occ[m]; /* Tau! not * M!*/ 
             }
             ta_dst->occ[m] += Tau;
          }
@@ -1418,7 +1497,7 @@ static void FixTransForICrit(float Tau, 
 }
 
 /* Calclulate MMI acc and save it in the orignial ML acc position, i.e., 3rd acc */
-static void GetMMIAccMix(int stream, MixPDF *mp)
+static void GetMMIAccMix (const int stream, MixPDF *mp)
 {
    int i,k,vSize;
    float occ1,occ2,D,s,mmimean,mmivar;
@@ -1468,7 +1547,8 @@ static void GetMMIAccMix(int stream, Mix
 }
 
 
-static void _FixHMMForICrit(float Tau, Boolean THREEACCS){
+static void _FixHMMForICrit(float Tau, Boolean THREEACCS)
+{
    /* Normally both Mu and Var occupancy will be identical. */
    HMMScanState hss;
    NewHMMScan(&hset,&hss); 
@@ -1512,7 +1592,8 @@ static void _FixHMMForICrit(float Tau, B
 }
 
 
-void AddPriorsFromPriorHMM(int dst_index, float Tau, float K, Boolean IsMMI, float ISmoothTau){
+void AddPriorsFromPriorHMM(int dst_index, float Tau, float K, Boolean IsMMI, float ISmoothTau)
+{
    /* Normally both Mu and Var occupancy will be identical. */
    HMMScanState hss, hss_prior;
    NewHMMScan(&hset,&hss); NewHMMScan(&hset_prior,&hss_prior); 
@@ -1560,8 +1641,10 @@ void AddPriorsFromPriorHMM(int dst_index
    EndHMMScan(&hss);    EndHMMScan(&hss_prior);
 }
 
-static void SmoothWeightsFromPriorHMM(int index, float Tau){
+static void SmoothWeightsFromPriorHMM (const int index, const float Tau)
+{
    HMMScanState hss,hss_prior;
+
    NewHMMScan(&hset,&hss);  NewHMMScan(&hset_prior,&hss_prior);
    while(GoNextStream(&hss,FALSE) && GoNextStream(&hss_prior,FALSE)){
       WtAcc *wa_dst; int m,M; 
@@ -1566,16 +1649,18 @@ static void SmoothWeightsFromPriorHMM(in
    while(GoNextStream(&hss,FALSE) && GoNextStream(&hss_prior,FALSE)){
       WtAcc *wa_dst; int m,M; 
       M = hss.M; 
-      wa_dst = ((WtAcc*)hss.ste->hook) + index;
-      for(m=1;m<=M;m++) wa_dst->c[m] += Tau * hss_prior.ste->spdf.cpdf[m].weight;
+      wa_dst = ((WtAcc*)hss.sti->hook) + index;
+      for(m=1;m<=M;m++) wa_dst->c[m] += Tau * hss_prior.sti->spdf.cpdf[m].weight;
       wa_dst->occ += Tau;
    }
    EndHMMScan(&hss); EndHMMScan(&hss_prior); 
 }
 
 
-static void SmoothTransFromPriorHMM(int index, float Tau){
+static void SmoothTransFromPriorHMM(int index, float Tau)
+{
    HMMScanState hss,hss_prior;
+
    NewHMMScan(&hset,&hss);    NewHMMScan(&hset_prior,&hss_prior); 
    do{
       TrAcc *ta_dst; int m,M;
@@ -1594,7 +1679,8 @@ static void SmoothTransFromPriorHMM(int 
 
 
 
-static void FixHMMForICrit(){
+static void FixHMMForICrit (void)
+{
    Boolean ISmoothingDone=FALSE;
 
    if(PriorTau>0||PriorK>0||PriorK>0||PriorTauTrans>0) {
@@ -1625,12 +1710,15 @@ static void FixHMMForICrit(){
 
    if(ISmoothTauTrans>0)
       FixTransForICrit(ISmoothTauTrans, THREEACCS);
+      
+   return;
 }
 
 
 
 
-void UpdateWeightsOrTrans(int M, float *acc1, float *acc2, float *mixes, float *oldMixes, float C){ 
+void UpdateWeightsOrTrans(int M, float *acc1, float *acc2, float *mixes, float *oldMixes, float C)
+{ 
    int iter=0;
    int m;
    float objective = 0, last_objective=0, last_last_objective=0;
@@ -1683,10 +1771,11 @@ void UpdateWeightsOrTrans(int M, float *
    return;
 }
 
-void UpdateWeight(int s, StreamElem *ste){
+void UpdateWeight (const int s, StreamInfo *sti)
+{
    int i,n,M=0;
    WtAcc *wa1,*wa2,*wa3;
-   wa1 = (WtAcc *)ste->hook;
+   wa1 = (WtAcc *)sti->hook;
    wa2 = (ML_MODE?NULL:wa1+1);
    wa3 = (THREEACCS?wa1+2:NULL); /*non-NULL in MPE case, where it is the ML accs. */
 
@@ -1695,7 +1784,7 @@ void UpdateWeight(int s, StreamElem *ste
    switch (hsKind){
    case PLAINHS:
    case SHAREDHS:
-      M=ABS(ste->nMix);
+      M=ABS(sti->nMix);
       break;
    case TIEDHS:
       M = hset.tmRecs[s].nMix;
@@ -1708,10 +1797,10 @@ void UpdateWeight(int s, StreamElem *ste
     
       switch(hsKind){
       case PLAINHS: case SHAREDHS:
-         for(n=1;n<=M;n++)	NewWghts[n] = OldWghts[n] = ste->spdf.cpdf[n].weight;
+         for(n=1;n<=M;n++)	NewWghts[n] = OldWghts[n] = sti->spdf.cpdf[n].weight;
          break;
       case TIEDHS:
-         for(n=1;n<=M;n++)	NewWghts[n] = OldWghts[n] = ste->spdf.tpdf[n];
+         for(n=1;n<=M;n++)	NewWghts[n] = OldWghts[n] = sti->spdf.tpdf[n];
          break;
       default: HError(1, "Unhandled hsKind.");
       }
@@ -1726,12 +1815,12 @@ void UpdateWeight(int s, StreamElem *ste
       case PLAINHS:
       case SHAREDHS:
          for(n=1;n<=M;n++){
-            ste->spdf.cpdf[n].weight=(NewWghts[n] > MINMIX ? NewWghts[n] : 0.0);
+            sti->spdf.cpdf[n].weight=(NewWghts[n] > MINMIX ? NewWghts[n] : 0.0);
          }
          break;
       case TIEDHS:
          for(n=1;n<=M;n++){
-            ste->spdf.tpdf[n]=(NewWghts[n] > MINMIX ? NewWghts[n] : 0.0);
+            sti->spdf.tpdf[n]=(NewWghts[n] > MINMIX ? NewWghts[n] : 0.0);
          }
          break;
       default: HError(1, "Unhandled hsKind.");
@@ -1742,16 +1831,16 @@ void UpdateWeight(int s, StreamElem *ste
          switch (hsKind){
          case PLAINHS:
          case SHAREDHS:
-            FloorMixes(ste->spdf.cpdf+1,M,mixWeightFloor); 
+            FloorMixes(sti->spdf.cpdf+1,M,mixWeightFloor); 
             break;
          case TIEDHS:
-            FloorTMMixes(ste->spdf.tpdf,M,mixWeightFloor);
+            FloorTMMixes(sti->spdf.tpdf,M,mixWeightFloor);
             break;
          default: HError(1, "Unhandled hsKind.");
          }
       }
    }
-   ste->hook = 0;
+   sti->hook = 0;
 }
 
 
diff -pbBEwurNa --ignore-matching-lines='.*vc_id.*' HTK-3.4.1/HTKTools/HMgeTool.c HTS-2.2_for_HTK-3.4.1/HTKTools/HMgeTool.c
--- HTK-3.4.1/HTKTools/HMgeTool.c	1970-01-01 09:00:00.000000000 +0900
+++ HTS-2.2_for_HTK-3.4.1/HTKTools/HMgeTool.c	2011-06-19 20:53:07.000000000 +0900
@@ -0,0 +1,1472 @@
+/* ----------------------------------------------------------------- */
+/*           The HMM-Based Speech Synthesis System (HTS)             */
+/*           developed by HTS Working Group                          */
+/*           http://hts.sp.nitech.ac.jp/                             */
+/* ----------------------------------------------------------------- */
+/*                                                                   */
+/*  Copyright (c) 2001-2011  Nagoya Institute of Technology          */
+/*                           Department of Computer Science          */
+/*                                                                   */
+/*                2001-2008  Tokyo Institute of Technology           */
+/*                           Interdisciplinary Graduate School of    */
+/*                           Science and Engineering                 */
+/*                                                                   */
+/* All rights reserved.                                              */
+/*                                                                   */
+/* Redistribution and use in source and binary forms, with or        */
+/* without modification, are permitted provided that the following   */
+/* conditions are met:                                               */
+/*                                                                   */
+/* - Redistributions of source code must retain the above copyright  */
+/*   notice, this list of conditions and the following disclaimer.   */
+/* - Redistributions in binary form must reproduce the above         */
+/*   copyright notice, this list of conditions and the following     */
+/*   disclaimer in the documentation and/or other materials provided */
+/*   with the distribution.                                          */
+/* - Neither the name of the HTS working group nor the names of its  */
+/*   contributors may be used to endorse or promote products derived */
+/*   from this software without specific prior written permission.   */
+/*                                                                   */
+/* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND            */
+/* CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,       */
+/* INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF          */
+/* MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE          */
+/* DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS */
+/* BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,          */
+/* EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED   */
+/* TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,     */
+/* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON */
+/* ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,   */
+/* OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY    */
+/* OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE           */
+/* POSSIBILITY OF SUCH DAMAGE.                                       */
+/* ----------------------------------------------------------------- */
+
+char *hmgetool_version = "!HVER!HMgeTool: 2.2 [NIT 07/07/11]";
+char *hmgetool_vc_id = "$Id: HMgeTool.c,v 1.3 2011/06/19 11:53:07 uratec Exp $";
+
+/*
+  This program is used for MGE training
+*/
+
+/* ------------------- HMM ToolKit Modules ------------------- */
+#include "HShell.h"
+#include "HMem.h"
+#include "HMath.h"
+#include "HSigP.h"
+#include "HAudio.h"
+#include "HWave.h"
+#include "HVQ.h"
+#include "HParm.h"
+#include "HLabel.h"
+#include "HModel.h"
+#include "HTrain.h"
+#include "HUtil.h"
+#include "HAdapt.h"
+#include "HFB.h"
+#include "HGen.h"
+#include "HMTrain.h"
+
+/* ----------------------- Trace Flags ----------------------- */
+#define T_TOP   0001            /* Top level tracing */
+#define T_PROC  0001            /* Process information */
+
+/* --------------------- Global Settings --------------------- */
+static char *labDir = NULL;     /* label (transcription) file directory */
+static char *labExt = "lab";    /* label file extension */
+static char *hmmDir = NULL;     /* directory to look for hmm def files */
+static char *hmmExt = NULL;     /* hmm def file extension */
+static char *outDir = NULL;     /* directory to store new hmm def files */
+static char *outExt = NULL;     /* extension of new reestimated hmm files */
+static char *winDir = NULL;     /* directory to look for window files */
+static char *winExt = NULL;     /* extension for window file */
+static char *mmfFn = NULL;      /* output MMF file, if any */
+static char *scalefn = NULL;    /* scaling rate file */
+static char *outLabDir = NULL;  /* output label file directory */
+static char *hmmListFn = NULL;  /* hmm list file */
+static char *xformfn = NULL;    /* transform file */
+
+static UPDSet uFlags = (UPDSet) 0;      /* update flags */
+
+static float MSDthresh = 0.5;   /* threshold for swithing space index for MSD */
+static HTime frameRate = 50000; /* frame rate (default: 5ms) */
+
+static MFType funcType = MGE_TRAIN;     /* MGE function type */
+static Boolean bMgeUpdate = FALSE;      /* flag for mge training */
+static int dftInvQuaSize = 100; /* default value for InvQuaSize */
+static int startIter = 0;       /* start iteration index of MGE training */
+static int endIter = 0;         /* end iteration index of MGE training */
+static float A_STEP = 1000.0f;  /* parameter for step size = 1/(A + B*nSent) */
+static float B_STEP = 1.0f;     /* parameter for step size = 1/(A + B*nSent) */
+
+static int dftVarWinSize = -1;  /* default value for win size of variance calculation */
+static float dftGVDistWght = 1.0f;      /* distance weight for gv component */
+static float fGVDistWght = 1.0f;        /* distance weight for gv component */
+
+static Boolean bBoundAdj = FALSE;       /* flag for boundary adjustment */
+static int nBoundAdjWin = 5;    /* window size for boundary adjustment */
+static int nBAEndIter = -1;     /* end iteration for boundary adjustment */
+static int nMaxBAIter = 1;      /* maximum length for each bound adjustment (i.e. maximum times to shift the boundary */
+static int nMaxBALen = 1;       /* maximum length for each boundary shifting, i.e. shift nMax frames */
+
+static int trace = 0;           /* trace level */
+static Boolean inBinary = FALSE;        /* save output in binary  */
+Boolean keepOccm = FALSE;       /* keep mixture-level occ prob */
+Boolean outProcData = FALSE;    /* output the process data (HMM) */
+
+static MemHeap hmmStack;        /* for storage of HMM set */
+static MemHeap orighmmStack;    /* for storage of HMM set */
+static MemHeap accStack;        /* for storage of acc info */
+static MemHeap genStack;        /* for storage of generation data */
+static MemHeap mgeStack;        /* for storage of MGE training data */
+
+static HMMSet hset;             /* Set of HMMs */
+static HMMSet orighset;
+
+static MTStatInfo *statInfo;    /* statistical info of MGE training */
+static GenInfo *genInfo;        /* structure for generation */
+static MgeTrnInfo *mtInfo;      /* structure for MGE training */
+
+static ConfParam *cParm[MAXGLOBS];      /* configuration parameters */
+static IntVec nPdfStr = NULL;   /* # of PdfStream */
+static IntVec pdfStrOrder = NULL;       /* order of each PdfStream */
+static char **winFn[SMAX];      /* fn of window */
+static IntVec pbMTrn = NULL;    /* whether perform MGE train for the stream */
+static IntVec pbGVTrn = NULL;   /* whether incorporate GV component into MGE training */
+static IntVec pbAccErr = NULL;  /* accumulate generation error */
+static IntVec pnInvQuaSize = NULL;      /* bandwith of quasi-diagonal inversion matrix */
+static IntVec pnVarWin = NULL;  /* window for local variance calculation */
+static Vector pfGVWght = NULL;  /* GV weights */
+
+static IntVec pbGainWght = NULL;        /* gain weight for generation error */
+static Boolean dftGWFlag = FALSE;       /* default flag for gain weight */
+
+static int total_T[SMAX];
+static int total_unstab_T[SMAX];
+static int nSamples = 0;
+
+static XFInfo xfInfo;
+
+#define MAX_SENT_NUM    50000
+
+/* Data File list struct */
+typedef struct _TDataFile {
+   char datafn[255];
+   Boolean bValid;
+} TDataFile, *PTDataFile;
+
+static PTDataFile g_pDataFileList[MAX_SENT_NUM];
+static PTDataFile g_pShufDFList[MAX_SENT_NUM];
+static int g_nDataFileNum, g_nValidDfNum;
+
+/* ------------------ Process Command Line -------------------------- */
+static void Initialise();
+static void PerformMgeTrain();
+static void PerformMgeEval();
+static void PerformMgeAdapt();
+
+static void SetConfParms(void)
+{
+   int s, i, nParm;
+   char *c, buf[MAXSTRLEN], tmp[MAXSTRLEN];
+   Boolean b;
+
+   for (s = 1; s < SMAX; s++)
+      winFn[s] = NULL;
+
+   nParm = GetConfig("HMGETOOL", TRUE, cParm, MAXGLOBS);
+   if (nParm > 0) {
+      if (GetConfInt(cParm, nParm, "TRACE", &i))
+         trace = i;
+      if (GetConfBool(cParm, nParm, "SAVEBINARY", &b))
+         inBinary = b;
+
+      if (GetConfStr(cParm, nParm, "PDFSTRSIZE", buf))
+         nPdfStr = ParseConfIntVec(&gstack, buf, TRUE);
+      if (GetConfStr(cParm, nParm, "PDFSTRORDER", buf))
+         pdfStrOrder = ParseConfIntVec(&gstack, buf, TRUE);
+
+      if (GetConfStr(cParm, nParm, "MGETRNFLAG", buf))
+         pbMTrn = ParseConfIntVec(&gstack, buf, TRUE);
+      if (GetConfStr(cParm, nParm, "GVTRNFLAG", buf))
+         pbGVTrn = ParseConfIntVec(&gstack, buf, TRUE);
+      if (GetConfStr(cParm, nParm, "ACCERRFLAG", buf))
+         pbAccErr = ParseConfIntVec(&gstack, buf, TRUE);
+      if (GetConfStr(cParm, nParm, "INVQUASIZE", buf))
+         pnInvQuaSize = ParseConfIntVec(&gstack, buf, TRUE);
+      if (GetConfStr(cParm, nParm, "VARWINSIZE", buf))
+         pnVarWin = ParseConfIntVec(&gstack, buf, TRUE);
+      if (GetConfStr(cParm, nParm, "GVDISTWGHT", buf))
+         pfGVWght = ParseConfVector(&gstack, buf, TRUE);
+      if (GetConfStr(cParm, nParm, "GAINWTFLAG", buf))
+         pbGainWght = ParseConfIntVec(&gstack, buf, TRUE);
+
+      if (GetConfStr(cParm, nParm, "WINEXT", buf))
+         winExt = CopyString(&gstack, buf);
+      if (GetConfStr(cParm, nParm, "WINDIR", buf))
+         winDir = CopyString(&gstack, buf);
+      if (GetConfStr(cParm, nParm, "WINFN", buf)) {
+         for (s = 1, c = buf; s < SMAX && c != NULL; s++) {
+            winFn[s] = ParseConfStrVec(&gstack, c, FALSE);
+            for (i = 1; i <= winFn[s][0][0] + 2; i++)   /* "StrVec" + "n" + # of file names */
+               c = ParseString(c, tmp);
+            if (ParseString(c, tmp) == NULL)
+               break;
+         }
+      }
+   }
+}
+
+/* SetuFlags: Set the updating flags */
+static void SetuFlags(void)
+{
+   char *s;
+
+   s = GetStrArg();
+   while (*s != '\0') {
+      switch (*s++) {
+      case 'm':
+         uFlags = (UPDSet) (uFlags + UPMEANS);
+         break;
+      case 'v':
+         uFlags = (UPDSet) (uFlags + UPVARS);
+         break;
+      case 'w':
+         uFlags = (UPDSet) (uFlags + UPMIXES);
+         break;
+      case 'a':
+         uFlags = (UPDSet) (uFlags + UPXFORM);
+         break;
+      default:
+         HError(2320, "SetuFlags: Unknown update flag %c", *s);
+         break;
+      }
+   }
+   if (uFlags & UPMEANS || uFlags & UPVARS || uFlags & UPMIXES || uFlags & UPXFORM)
+      bMgeUpdate = TRUE;
+}
+
+/* CheckGenSetUp: Check & setup GenInfo structure */
+static void CheckGenSetUp(void)
+{
+   int d, p, r, s, stream;
+   PdfStream *pst = NULL;
+
+   /* # of PdfStreams */
+   genInfo->nPdfStream[0] = (nPdfStr == NULL) ? hset.swidth[0] : IntVecSize(nPdfStr);
+   if (genInfo->nPdfStream[0] > hset.swidth[0])
+      HError(6604, "CheckGenSetUp: # of PdfStreams (%d) is too large (should be less than %d)", genInfo->nPdfStream[0], hset.swidth[0]);
+
+   /* size of each PdfStreams */
+   r = hset.swidth[0];
+   for (p = stream = 1; p <= genInfo->nPdfStream[0]; stream += genInfo->nPdfStream[p++]) {
+      pst = &(genInfo->pst[p]);
+
+      /* # of streams in this PdfStream */
+      genInfo->nPdfStream[p] = (nPdfStr == NULL) ? 1 : nPdfStr[p];
+      r -= genInfo->nPdfStream[p];
+
+      /* calculate vector size for this PdfStream */
+      for (s = stream, pst->vSize = 0; s < stream + genInfo->nPdfStream[p]; s++)
+         pst->vSize += hset.swidth[s];
+
+      /* order (vecSize of static feature vector) of this PdfStream */
+      pst->order = (pdfStrOrder == NULL) ? 1 : pdfStrOrder[p];
+      if (pst->order < 1 || pst->order > pst->vSize)
+         HError(6604, "CheckGenSetUp: Order of PdfStream %d should be within 1--%d", p, pst->vSize);
+
+      /* window coefficients */
+      if (winFn[p] == NULL)
+         HError(6604, "CheckGenSetUp: window file names are not specified");
+      pst->win.num = (int) winFn[p][0][0];
+      if (pst->win.num > MAXWINNUM)
+         HError(6604, "CheckGenSetUp: # of window out of range");
+      if (pst->win.num * pst->order != pst->vSize)
+         HError(6604, "CheckGenSetUp: # of window (%d) times order (%d) should be equal to vSize (%d)", pst->win.num, pst->order, pst->vSize);
+      for (d = 0; d < pst->win.num; d++)
+         MakeFN(winFn[p][d + 1], winDir, winExt, pst->win.fn[d]);
+   }
+   if (r != 0)
+      HError(6604, "CheckGenSetUp: # of streams in HMMSet (%d) and PdfStreams (%d) are inconsistent", hset.swidth[0], genInfo->nPdfStream[0]);
+
+   /* output trace information */
+   if (trace & T_TOP) {
+      for (p = 1; p <= genInfo->nPdfStream[0]; p++) {
+         printf("PdfStream [%d]:\n", p);
+         printf("  #streams: %d (vSize=%d)\n", genInfo->nPdfStream[p], genInfo->pst[p].vSize);
+         printf("  #order:   %d\n", genInfo->pst[p].order);
+         printf("  file ext: %s\n", genInfo->pst[p].ext);
+         for (d = 0; d < pst->win.num; d++)
+            printf("  %d-th window: %s\n", d, pst->win.fn[d]);
+      }
+      printf("\n");
+      fflush(stdout);
+   }
+}
+
+/* CheckMTInfoSetUp: Check & setup MgeTrnInfo structure */
+static void CheckMTInfoSetUp(void)
+{
+   int p;
+   if (pbMTrn != NULL) {
+      if (mtInfo->genInfo->nPdfStream[0] != IntVecSize(pbMTrn))
+         HError(6604, "CheckMTInfoSetUp: MTrn Flag is incompatible with PdfStream");
+      for (p = 1; p <= IntVecSize(pbMTrn); p++)
+         mtInfo->pbMTrn[p] = (Boolean) pbMTrn[p];
+   }
+
+   if (pbGVTrn != NULL) {
+      if (mtInfo->genInfo->nPdfStream[0] != IntVecSize(pbGVTrn))
+         HError(6604, "CheckMTInfoSetUp: GVTrn Flag is incompatible with PdfStream");
+      for (p = 1; p <= IntVecSize(pbGVTrn); p++)
+         mtInfo->pbGVTrn[p] = (Boolean) pbGVTrn[p];
+   }
+
+   if (pbAccErr != NULL) {
+      if (mtInfo->genInfo->nPdfStream[0] != IntVecSize(pbAccErr))
+         HError(6604, "CheckMTInfoSetUp: AccErr Flag is incompatible with PdfStream");
+      for (p = 1; p <= IntVecSize(pbAccErr); p++)
+         mtInfo->pbAccErr[p] = (Boolean) pbAccErr[p];
+   } else {
+      for (p = 1; p <= genInfo->nPdfStream[0]; p++)
+         mtInfo->pbAccErr[p] = TRUE;    /* by default to accumulate the generation error */
+   }
+
+   if (pnInvQuaSize != NULL) {
+      if (mtInfo->genInfo->nPdfStream[0] != IntVecSize(pnInvQuaSize))
+         HError(6604, "CheckMTInfoSetUp: InvQuaSize is incompatible with PdfStream");
+      for (p = 1; p <= IntVecSize(pnInvQuaSize); p++)
+         mtInfo->pnInvQuaSize[p] = pnInvQuaSize[p];
+   } else {
+      for (p = 1; p <= genInfo->nPdfStream[0]; p++)
+         mtInfo->pnInvQuaSize[p] = dftInvQuaSize;
+   }
+
+   if (pnVarWin != NULL) {
+      if (mtInfo->genInfo->nPdfStream[0] != IntVecSize(pnVarWin))
+         HError(6604, "CheckMTInfoSetUp: pnVarWin is incompatible with PdfStream");
+      for (p = 1; p <= IntVecSize(pnVarWin); p++)
+         mtInfo->pnVarWin[p] = pnVarWin[p];
+   } else {
+      for (p = 1; p <= genInfo->nPdfStream[0]; p++)
+         mtInfo->pnVarWin[p] = dftVarWinSize;
+   }
+
+   if (pfGVWght != NULL) {
+      if (mtInfo->genInfo->nPdfStream[0] != IntVecSize(pnVarWin))
+         HError(6604, "CheckMTInfoSetUp: pnVarWin is incompatible with PdfStream");
+      for (p = 1; p <= VectorSize(pfGVWght); p++)
+         mtInfo->pfGVWght[p] = pfGVWght[p];
+   } else {
+      for (p = 1; p <= genInfo->nPdfStream[0]; p++)
+         mtInfo->pfGVWght[p] = dftGVDistWght;
+   }
+
+   if (pbGainWght != NULL) {
+      if (mtInfo->genInfo->nPdfStream[0] != IntVecSize(pbGainWght))
+         HError(6604, "CheckMTInfoSetUp: Gain weight is incompatible with PdfStream");
+      for (p = 1; p <= IntVecSize(pbGainWght); p++)
+         mtInfo->pbGainWght[p] = (Boolean) pbGainWght[p];
+   } else {
+      for (p = 1; p < SMAX; p++)
+         mtInfo->pbGainWght[p] = dftGWFlag;
+   }
+}
+
+/* GetTotalOrder: */
+static int GetTotalOrder(GenInfo * pGenInfo)
+{
+   int p, order;
+
+   order = 0;
+   for (p = 1; p <= pGenInfo->nPdfStream[0]; p++) {
+      order += pGenInfo->pst[p].order;
+   }
+   return order;
+}
+
+/* ReadOneLine: */
+static Boolean ReadOneLine(FILE * fp, char *line)
+{
+   if (feof(fp))
+      return FALSE;
+   line[0] = 0;
+   fgets(line, 256, fp);
+   if (line[0] == '#' || line[0] == 0x0a || line[0] == 0x0d)
+      return ReadOneLine(fp, line);
+   return TRUE;
+}
+
+/* LoadScaleRate: Load scale rate file for parameter updating */
+static void LoadScaleRate(char *scalefile)
+{
+   char *line;
+   FILE *fp;
+   int i, p;
+   float fScale;
+
+   line = (char *) malloc(256 * sizeof(char));
+   fp = fopen(scalefile, "rt");
+
+   /* read the scale */
+   ReadOneLine(fp, line);
+   fScale = (float) atof(line);
+   for (p = 1; p <= genInfo->nPdfStream[0]; p++) {
+      for (i = 1; i <= genInfo->pst[p].order; i++) {
+         if (!ReadOneLine(fp, line))
+            break;
+         mtInfo->SRMean[p][i] = (float) atof(line) * fScale;
+      }
+   }
+
+   /* read the scale */
+   ReadOneLine(fp, line);
+   fScale = (float) atof(line);
+   for (p = 1; p <= genInfo->nPdfStream[0]; p++) {
+      for (i = 1; i <= genInfo->pst[p].order; i++) {
+         if (!ReadOneLine(fp, line))
+            break;
+         mtInfo->SRVar[p][i] = (float) atof(line) * fScale;
+      }
+   }
+
+   /* read the scale */
+   ReadOneLine(fp, line);
+   fScale = (float) atof(line);
+   for (p = 1; p <= genInfo->nPdfStream[0]; p++) {
+      for (i = 1; i <= genInfo->pst[p].order; i++) {
+         if (!ReadOneLine(fp, line))
+            break;
+         mtInfo->DWght[p][i] = (float) atof(line) * fScale;
+      }
+   }
+
+   free(line);
+   fclose(fp);
+}
+
+/* InitMgeTrnInfo: Initialize all info struct for MGE training */
+static void InitMgeTrnInfo()
+{
+   int i, p, nWin;
+
+   /* setup GenInfo */
+   genInfo->genMem = &genStack;
+   genInfo->hset = &hset;
+   genInfo->maxStates = MaxStatesInSet(&hset);
+   genInfo->MSDthresh = MSDthresh;
+   genInfo->frameRate = frameRate;
+   genInfo->stateAlign = TRUE;
+   CheckGenSetUp();
+
+   /* setup MTStatInfo */
+   statInfo->order = GetTotalOrder(mtInfo->genInfo);
+   for (p = 1; p <= genInfo->nPdfStream[0]; p++) {
+      statInfo->initErrAcc[p] = CreateDVector(&gstack, genInfo->pst[p].order * 2);
+      statInfo->prevErrAcc[p] = CreateDVector(&gstack, genInfo->pst[p].order * 2);
+      statInfo->currErrAcc[p] = CreateDVector(&gstack, genInfo->pst[p].order * 2);
+      ZeroDVector(statInfo->initErrAcc[p]);
+      ZeroDVector(statInfo->prevErrAcc[p]);
+      ZeroDVector(statInfo->currErrAcc[p]);
+   }
+
+   nWin = mtInfo->genInfo->pst[1].win.num;
+   for (p = 1; p <= genInfo->nPdfStream[0]; p++) {
+      statInfo->pnMeanFloor[p] = (IMatrix *) New(&gstack, statInfo->order * sizeof(IMatrix *));
+      statInfo->pnMeanFloor[p]--;
+      statInfo->pnVarFloor[p] = (IMatrix *) New(&gstack, statInfo->order * sizeof(IMatrix *));
+      statInfo->pnVarFloor[p]--;
+      for (i = 1; i <= statInfo->order; i++) {
+         statInfo->pnMeanFloor[p][i] = CreateIMatrix(&gstack, nWin, 2); /* 2: High & Low floor */
+         ZeroIMatrix(statInfo->pnMeanFloor[p][i]);
+         statInfo->pnVarFloor[p][i] = CreateIMatrix(&gstack, nWin, 2);  /* 2: High & Low floor */
+         ZeroIMatrix(statInfo->pnVarFloor[p][i]);
+      }
+   }
+
+   /* setup MgeTrnInfo */
+   mtInfo->nBoundAdjWin = nBoundAdjWin;
+   mtInfo->fGVDistWght = fGVDistWght;
+   mtInfo->uFlags = uFlags;
+   mtInfo->funcType = funcType;
+   for (p = 1; p <= genInfo->nPdfStream[0]; p++) {
+      mtInfo->SRMean[p] = CreateVector(&gstack, genInfo->pst[p].order);
+      mtInfo->SRVar[p] = CreateVector(&gstack, genInfo->pst[p].order);
+      mtInfo->DWght[p] = CreateVector(&gstack, genInfo->pst[p].order);
+      ZeroVector(mtInfo->SRMean[p]);
+      ZeroVector(mtInfo->SRVar[p]);
+      ZeroVector(mtInfo->DWght[p]);
+   }
+
+   if (scalefn != NULL) {
+      LoadScaleRate(scalefn);
+      mtInfo->bMScale = TRUE;
+   } else
+      mtInfo->bMScale = FALSE;
+   CheckMTInfoSetUp();
+
+   return;
+}
+
+/* ReportUsage: */
+static void ReportUsage(void)
+{
+   printf("\nMinimum Generation Error (MGE) based HMM training\n\n");
+   printf("USAGE: HMgeTool [options] ScriptFile\n\n");
+   printf(" Option                                                    Default\n\n");
+   printf(" -a i j  i: max times to shift the boundary                none\n");
+   printf("         j: max length for each boundary shifting          1\n");
+   printf(" -b i j  i: end iteration for boundary adjustment          none\n");
+   printf("         j: window size for boundary adjustment            5\n");
+   printf(" -c      output the process data                           off\n");
+   printf(" -d dir  HMM definition directory                          none\n");
+   printf(" -e      enable limit the updating rate for each step      off\n");
+   printf(" -f r    frame rate                                        50000\n");
+   printf(" -g      enable multiply variance ratio for mean updating  off\n");
+   printf(" -i i j  start/end iteration index of MGE training         0 0\n");
+   printf(" -j flg  0: eval 1: train 2: adapt                         1\n");
+   printf(" -l dir  output label directory                            none\n");
+   printf(" -o ext  HMM def file extension                            none\n");
+   printf(" -p a b  parameter for step size: 1/(a + b*n)              1000.0 1.0\n");
+   printf(" -r file load HMM for reference                            none\n");
+   printf(" -s file updating scale file                               none\n");
+   printf(" -u mvwa update t)rans m)eans v)ars w)ghts                 none\n");
+   printf("                a)daptation xform\n");
+   printf(" -v f    threshold for switching spaces for MSD            0.5\n");
+   printf(" -w f    distance weight for gv component                  1.0\n");
+   printf(" -x ext  label file extension                              lab\n");
+   PrintStdOpts("ABCDGHIJKLMSTX");
+   printf("\n");
+   Exit(0);
+}
+
+/* main: */
+int main(int argc, char *argv[])
+{
+   char *s;
+   char fname[MAXSTRLEN];
+
+   InitShell(argc, argv, hmgetool_version, hmgetool_vc_id);
+   InitMem();
+   InitMath();
+   InitSigP();
+   InitWave();
+   InitLabel();
+   InitModel();
+   InitTrain();
+   InitParm();
+   InitUtil();
+   InitFB();
+   InitGen();
+   InitAdapt(&xfInfo, NULL);
+   InitMTrain();
+
+   /* process argument */
+   if (NumArgs() == 0)
+      ReportUsage();
+   CreateHeap(&hmmStack, "Model Stack", MSTAK, 1, 1.0, 80000, 4000000);
+   CreateHeap(&orighmmStack, "Model Stack", MSTAK, 1, 1.0, 80000, 4000000);
+   CreateHeap(&accStack, "Acc Stack", MSTAK, 1, 1.0, 80000, 400000);
+   CreateHeap(&genStack, "Gen Stack", MSTAK, 1, 1.0, 80000, 400000);
+   CreateHeap(&mgeStack, "MGE Train Stack", MSTAK, 1, 1.0, 80000, 400000);
+
+   SetConfParms();
+   CreateHMMSet(&hset, &hmmStack, TRUE);
+   CreateHMMSet(&orighset, &orighmmStack, TRUE);
+
+   statInfo = (MTStatInfo *) New(&gstack, sizeof(MTStatInfo));
+   memset(statInfo, 0, sizeof(MTStatInfo));
+
+   genInfo = (GenInfo *) New(&genStack, sizeof(GenInfo));
+   memset(genInfo, 0, sizeof(GenInfo));
+   genInfo->hset = &hset;
+   genInfo->genMem = &genStack;
+
+   mtInfo = (MgeTrnInfo *) New(&mgeStack, sizeof(MgeTrnInfo));
+   memset(mtInfo, 0, sizeof(MgeTrnInfo));
+   mtInfo->genInfo = genInfo;
+   mtInfo->statInfo = statInfo;
+   mtInfo->hset = &hset;
+   mtInfo->orighset = &orighset;
+   mtInfo->mgeMem = &mgeStack;
+
+   while (NextArg() == SWITCHARG) {
+      s = GetSwtArg();
+      if (strlen(s) != 1)
+         HError(6601, "HMgeTool: Bad switch %s; must be single letter", s);
+      switch (s[0]) {
+      case 'a':
+         nMaxBAIter = GetChkedInt(1, 1000, s);
+         nMaxBALen = GetChkedInt(1, 1000, s);
+         break;
+      case 'b':
+         mtInfo->bBoundAdj = TRUE;
+         nBAEndIter = GetChkedInt(0, 1000, s);
+         nBoundAdjWin = GetChkedInt(1, 1000, s);
+         break;
+      case 'c':
+         outProcData = TRUE;
+         break;
+      case 'd':
+         if (NextArg() != STRINGARG)
+            HError(6601, "HMgeTool: HMM definition directory expected");
+         hmmDir = GetStrArg();
+         break;
+      case 'e':
+         mtInfo->bStepLimit = TRUE;
+         break;
+      case 'f':
+         frameRate = (HTime) GetChkedFlt(0.0, 10000000.0, s);
+         break;
+      case 'g':
+         mtInfo->bMVar = TRUE;
+         break;
+      case 'i':
+         startIter = GetChkedInt(0, 1000, s);
+         endIter = GetChkedInt(startIter, 1000, s);
+         break;
+      case 'j':
+         funcType = GetChkedInt(0, 2, s);
+         mtInfo->funcType = funcType;
+         break;
+      case 'l':
+         if (NextArg() != STRINGARG)
+            HError(6601, "HMgeTool: Label file output directory expected");
+         outLabDir = GetStrArg();
+         break;
+      case 'o':
+         if (NextArg() != STRINGARG)
+            HError(6601, "HMgeTool: HMM file extension expected");
+         outExt = GetStrArg();
+         break;
+      case 'p':
+         A_STEP = GetChkedFlt(0.0, 10000000.0, s);
+         B_STEP = GetChkedFlt(0.0, 10000000.0, s);
+         break;
+      case 'r':
+         mtInfo->bOrigHmmRef = TRUE;
+         if (NextArg() != STRINGARG)
+            HError(6601, "HMgeTool: HMM macro file name expected");
+         s = GetStrArg();
+         AddMMF(&orighset, s);
+         break;
+      case 's':                /* updating scale file */
+         scalefn = GetStrArg();
+         break;
+      case 'u':
+         SetuFlags();
+         break;
+      case 'v':
+         MSDthresh = GetChkedFlt(0.0, 1.0, s);
+         break;
+      case 'w':
+         fGVDistWght = GetChkedFlt(0.0, 1000.0, s);
+         break;
+      case 'x':
+         if (NextArg() != STRINGARG)
+            HError(6601, "HMgeTool: HMM file extension expected");
+         hmmExt = GetStrArg();
+         break;
+      case 'B':
+         inBinary = TRUE;
+         break;
+      case 'G':
+         mtInfo->nGainStreamIndex = GetChkedInt(1, SMAX, s);
+         mtInfo->nGainDimIndex = GetChkedInt(1, 1000, s);
+         if (NextArg() == FLOATARG || NextArg() == INTARG)
+            mtInfo->fGainWghtComp = GetChkedFlt(-10000.0, 1000000.0, s);
+         break;
+      case 'H':
+         if (NextArg() != STRINGARG)
+            HError(6601, "HMgeTool: HMM macro file name expected");
+         mmfFn = GetStrArg();
+         AddMMF(&hset, mmfFn);
+         break;
+      case 'I':
+         if (NextArg() != STRINGARG)
+            HError(6601, "HMgeTool: MLF file name expected");
+         LoadMasterFile(GetStrArg());
+         break;
+      case 'J':                /* regression class and tree */
+         if (NextArg() != STRINGARG)
+            HError(6601, "HMgeTool: HMM regression class/tree file name expected");
+         s = GetStrArg();
+         AddMMF(&hset, s);
+         AddMMF(&orighset, s);
+         break;
+      case 'K':
+         if (NextArg() != STRINGARG)
+            HError(6601, "HMgeTool: HMM transform file name expected");
+         xformfn = GetStrArg();
+         break;
+      case 'L':
+         if (NextArg() != STRINGARG)
+            HError(6601, "HMgeTool: Label file directory expected");
+         labDir = GetStrArg();
+         break;
+      case 'M':
+         if (NextArg() != STRINGARG)
+            HError(6601, "HMgeTool: Output macro file directory expected");
+         outDir = GetStrArg();
+         break;
+      case 'T':
+         trace = GetChkedInt(0, 0100000, s);
+         break;
+      case 'X':
+         if (NextArg() != STRINGARG)
+            HError(2319, "HMGenS: Label file extension expected");
+         labExt = GetStrArg();
+         break;
+      default:
+         HError(6601, "HMgeTool: Unknown switch %s", s);
+      }
+   }
+
+   if (NextArg() != STRINGARG)
+      HError(6601, "HMgeTool: file name of model list expected");
+   hmmListFn = GetStrArg();
+   Initialise();
+
+   if (funcType == MGE_EVAL) {
+      PerformMgeEval();
+   } else if (funcType == MGE_TRAIN) {
+      PerformMgeTrain();
+      if (endIter > 0 && bMgeUpdate) {
+         /* output HMM files */
+         ConvDiagC(&hset, TRUE);
+         SaveHMMSet(&hset, outDir, outExt, NULL, inBinary);
+      }
+   } else if (funcType == MGE_ADAPT) {
+      PerformMgeAdapt();
+      if (endIter > 0 && bMgeUpdate) {
+         MakeFN(xformfn, outDir, NULL, fname);
+         SaveOneXForm(&hset, hset.curXForm, fname, FALSE);
+      }
+   }
+
+   ResetHeap(&hmmStack);
+   ResetHeap(&orighmmStack);
+   ResetHeap(&accStack);
+   ResetHeap(&genStack);
+   ResetHeap(&mgeStack);
+
+   return 0;
+}
+
+/* AttachAccToModel: */
+static void AttachAccToModel()
+{
+   AttachAccsParallel(&hset, &accStack, uFlags, 1);
+   ZeroAccsParallel(&hset, uFlags, 1);
+}
+
+/* Initialise: */
+static void Initialise()
+{
+   char macroname[MAXSTRLEN];
+   AdaptXForm *xform;
+
+   /* load HMMs and init HMMSet related global variables */
+   if (trace & T_TOP)
+      printf("Loading HMM for updating ... ... \n");
+   if (MakeHMMSet(&hset, hmmListFn) < SUCCESS)
+      HError(2321, "Initialise: MakeHMMSet failed");
+   if (LoadHMMSet(&hset, hmmDir, hmmExt) < SUCCESS)
+      HError(2321, "Initialise: LoadHMMSet failed");
+   SetParmHMMSet(&hset);
+   /* variance inversion, MGE training only support INVDIAGC case */
+   if (hset.ckind == DIAGC)
+      ConvDiagC(&hset, TRUE);
+   /* load transform */
+   if (xformfn != NULL) {
+      xform = LoadOneXForm(&hset, NameOf(xformfn, macroname), xformfn);
+      SetXForm(&hset, &xfInfo, xform);
+   }
+
+   if (funcType == MGE_TRAIN)
+      AttachAccToModel();
+
+   /* reload the HMM for reference in training */
+   if (mtInfo->bOrigHmmRef) {
+      if (trace & T_TOP)
+         printf("Loading HMM for reference ... ... \n");
+      if (MakeHMMSet(&orighset, hmmListFn) < SUCCESS)
+         HError(2321, "Initialise: MakeHMMSet failed");
+      if (LoadHMMSet(&orighset, hmmDir, hmmExt) < SUCCESS)
+         HError(2321, "Initialise: LoadHMMSet failed");
+      SetParmHMMSet(&orighset);
+      /* variance inversion, MGE training only support INVDIAGC case */
+      if (hset.ckind == DIAGC)
+         ConvDiagC(&orighset, TRUE);
+      /* load transform */
+      if (xformfn != NULL) {
+         xform = LoadOneXForm(&orighset, NameOf(xformfn, macroname), xformfn);
+         SetXForm(&orighset, &xfInfo, xform);
+      }
+   }
+
+   if (trace & T_TOP) {
+      printf("System is ");
+      switch (hset.hsKind) {
+      case PLAINHS:
+         printf("PLAIN\n");
+         break;
+      case SHAREDHS:
+         printf("SHARED\n");
+         break;
+      case TIEDHS:
+         printf("TIED\n");
+         break;
+      case DISCRETEHS:
+         printf("DISCRETE\n");
+         break;
+      }
+
+      printf("%d Logical/%d Physical Models Loaded, VecSize=%d\n", hset.numLogHMM, hset.numPhyHMM, hset.vecSize);
+      if (hset.numFiles > 0)
+         printf("%d MMF input files\n", hset.numFiles);
+      if (mmfFn != NULL)
+         printf("Output to MMF file:  %s\n", mmfFn);
+      fflush(stdout);
+   }
+
+   /* initialize a MgeTrnInfo for MGE training of HMM */
+   InitMgeTrnInfo();
+}
+
+/* CreateDataFileList: */
+static void CreateDataFileList()
+{
+   char *datafn;
+   g_nDataFileNum = 0;
+   do {
+      if (NextArg() != STRINGARG)
+         HError(2319, "HMGenS: data file name expected");
+      datafn = GetStrArg();
+
+      g_pDataFileList[g_nDataFileNum] = (TDataFile *) New(&gstack, sizeof(TDataFile));
+      strcpy(g_pDataFileList[g_nDataFileNum]->datafn, datafn);
+      g_pDataFileList[g_nDataFileNum]->bValid = TRUE;
+      g_nDataFileNum++;
+   } while (NumArgs() > 0);
+}
+
+/* ExtraceDataFile: */
+static TDataFile *ExtractDataFile(int nIndex)
+{
+   int i;
+   nIndex = nIndex % g_nValidDfNum;
+   for (i = 0; i < g_nDataFileNum; i++) {
+      if (g_pDataFileList[i]->bValid) {
+         if (nIndex == 0)
+            return g_pDataFileList[i];
+         nIndex--;
+      }
+   }
+   return NULL;
+}
+
+/* UniformRandom: Random function */
+static float UniformRandom()
+{
+   static long unsigned int x = 100;
+   const long unsigned int a = 2147437301;
+   const double m = 2147483648.0;
+   const double c = 347813413.0;
+
+   x = (long unsigned int) fmod(a * x + c, m);
+   return ((float) x / (float) m);
+}
+
+/* ShuffleDataFileList: Shuffle data file list */
+static void ShuffleDataFileList()
+{
+   int i, nIndex;
+
+   g_nValidDfNum = g_nDataFileNum;
+   /* shuffle data file list */
+   for (i = 0; i < g_nDataFileNum; i++) {
+      nIndex = (int) (UniformRandom() * g_nDataFileNum);
+      g_pShufDFList[i] = ExtractDataFile(nIndex);
+      g_pShufDFList[i]->bValid = FALSE;
+      g_nValidDfNum--;
+   }
+
+   /* copy shuffle list to orig list */
+   for (i = 0; i < g_nDataFileNum; i++) {
+      g_pDataFileList[i] = g_pShufDFList[i];
+      g_pDataFileList[i]->bValid = TRUE;
+   }
+}
+
+/* ResetAllStateInfo: */
+static void ResetAllStatInfo(int nIter)
+{
+   int p, i;
+   for (p = 1; p <= genInfo->nPdfStream[0]; p++) {
+      total_T[p] = 0;
+      total_unstab_T[p] = 0;
+      statInfo->pnTotalFrm[p] = 0;
+      CopyDVector(statInfo->currErrAcc[p], statInfo->prevErrAcc[p]);
+      ZeroDVector(statInfo->currErrAcc[p]);
+      for (i = 1; i <= statInfo->order; i++) {
+         ZeroIMatrix(statInfo->pnMeanFloor[p][i]);
+         ZeroIMatrix(statInfo->pnVarFloor[p][i]);
+      }
+   }
+}
+
+/* PrintFinalResult: */
+static void PrintFinalResult(int nSent, int nIter)
+{
+   int p, i;
+   double init_err, curr_err, ti_err, tc_err;
+
+   if (total_T[1] <= 0)
+      return;
+
+   ti_err = 0.0;
+   tc_err = 0.0;
+   fprintf(stdout, "\n\n========= Final report of generation error ========\n");
+   for (p = 1; p <= genInfo->nPdfStream[0]; p++) {
+      if (!mtInfo->pbMTrn[p] && !mtInfo->pbAccErr[p])
+         continue;
+
+      fprintf(stdout, "\nGen Error of PdfStream [%d]: %d / %d / %d (sentences / frames)\n", p, nSent, total_T[p], total_unstab_T[p]);
+      for (i = 1; i <= genInfo->pst[p].order; i++) {
+         init_err = statInfo->initErrAcc[p][i] / total_T[p];
+         curr_err = statInfo->currErrAcc[p][i] / total_T[p];
+         fprintf(stdout, "   Dim %d: %.6e -> %.6e (imp %.2f%%)\n", i, init_err, curr_err, 100.0 * (init_err - curr_err) / init_err);
+         ti_err += statInfo->initErrAcc[p][i] * mtInfo->DWght[p][i];
+         tc_err += statInfo->currErrAcc[p][i] * mtInfo->DWght[p][i];
+      }
+
+      if (mtInfo->pbGVTrn[p]) {
+         /* output gen error for global variance */
+         for (; i <= genInfo->pst[p].order * 2; i++) {
+            init_err = statInfo->initErrAcc[p][i] / total_T[p];
+            curr_err = statInfo->currErrAcc[p][i] / total_T[p];
+            fprintf(stdout, "   Dim %d: %.6e -> %.6e (imp %.2f%%)\n", i, init_err, curr_err, 100.0 * (init_err - curr_err) / init_err);
+         }
+      }
+
+   }
+   fflush(stdout);
+
+   ti_err /= total_T[1];
+   tc_err /= total_T[1];
+   fprintf(stdout, "\nTotal Gen Error: %.6e -> %.6e (imp %.2f%%)\n", ti_err, tc_err, 100.0 * (ti_err - tc_err) / ti_err);
+   fflush(stdout);
+}
+
+/* PrintStateInfo: */
+static void PrintStatInfo(int nSent, int nIter)
+{
+   int p, i, j;
+   double prev_err, curr_err, tp_err, tc_err;
+
+   if (total_T[1] <= 0)
+      return;
+
+   tp_err = tc_err = 0.0;
+   for (p = 1; p <= genInfo->nPdfStream[0]; p++) {
+      if (!mtInfo->pbMTrn[p] && !mtInfo->pbAccErr[p])
+         continue;
+
+      fprintf(stdout, "\nGen Error of PdfStream [%d]: %d / %d / %d (sentences / frames)\n", p, nSent, total_T[p], total_unstab_T[p]);
+      for (i = 1; i <= genInfo->pst[p].order; i++) {
+         prev_err = statInfo->prevErrAcc[p][i] / total_T[p];
+         curr_err = statInfo->currErrAcc[p][i] / total_T[p];
+         if (nIter > 0)
+            fprintf(stdout, "   Dim %d: %.6e -> %.6e (imp %.2f%%)\n", i, prev_err, curr_err, 100.0 * (prev_err - curr_err) / fabs(prev_err));
+         else
+            fprintf(stdout, "   Dim %d: %.6e\n", i, curr_err);
+         tp_err += statInfo->prevErrAcc[p][i] * mtInfo->DWght[p][i];
+         tc_err += statInfo->currErrAcc[p][i] * mtInfo->DWght[p][i];
+      }
+
+      if (mtInfo->pbGVTrn[p]) {
+         /* output gen error for global variance */
+         for (; i <= genInfo->pst[p].order * 2; i++) {
+            prev_err = statInfo->prevErrAcc[p][i] / total_T[p];
+            curr_err = statInfo->currErrAcc[p][i] / total_T[p];
+            if (nIter > 0)
+               fprintf(stdout, "   Dim %d: %.6e -> %.6e (imp %.2f%%)\n", i, prev_err, curr_err, 100.0 * (prev_err - curr_err) / fabs(prev_err));
+            else
+               fprintf(stdout, "   Dim %d: %.6e\n", i, curr_err);
+         }
+      }
+
+      if (!mtInfo->pbMTrn[p])
+         continue;
+      if (nIter > 0 && (trace & T_PROC)) {
+         fprintf(stdout, "\nUpdate Floor of PdfStream [%d]: %d / %d (sentences / frames)\n", p, nSent, total_T[p]);
+         for (i = 1; i <= genInfo->pst[p].order; i++) {
+            fprintf(stdout, "   Mean_D_%d = ", i);
+            for (j = 1; j <= genInfo->pst[p].win.num; j++) {
+               fprintf(stdout, "H:%5d L:%5d;  ", statInfo->pnMeanFloor[p][i][j][HIGH_FLOOR], statInfo->pnMeanFloor[p][i][j][LOW_FLOOR]);
+            }
+            fprintf(stdout, "\n");
+            fprintf(stdout, "    Var_D_%d = ", i);
+            for (j = 1; j <= genInfo->pst[p].win.num; j++) {
+               fprintf(stdout, "H:%5d L:%5d;  ", statInfo->pnVarFloor[p][i][j][HIGH_FLOOR], statInfo->pnVarFloor[p][i][j][LOW_FLOOR]);
+            }
+            fprintf(stdout, "\n");
+         }
+      }
+      fflush(stdout);
+   }
+
+   tp_err /= total_T[1];
+   tc_err /= total_T[1];
+   if (nIter > 0)
+      fprintf(stdout, "\nTotal Generation Error: %.6e -> %.6e (imp %.2f%%)\n", tp_err, tc_err, 100.0 * (tp_err - tc_err) / fabs(tp_err));
+   else
+      fprintf(stdout, "\nTotal Generation Error: %.6e\n", tc_err);
+   fflush(stdout);
+
+   /* if first iteration, set up initial statistical info */
+   if (nIter == startIter) {
+      for (p = 1; p <= genInfo->nPdfStream[0]; p++) {
+         CopyDVector(statInfo->currErrAcc[p], statInfo->initErrAcc[p]);
+      }
+   }
+}
+
+/* LoadMgeTrnHmmFile: */
+static void LoadMgeTrnHmmFile(int nIter)
+{
+   char hext[15], hmmFile[255];
+
+   ResetHeap(&hmmStack);
+   CreateHeap(&hmmStack, "Model Stack", MSTAK, 1, 1.0, 80000, 400000);
+
+   sprintf(hext, "mmf%d", nIter);
+   MakeFN(mmfFn, outDir, hext, hmmFile);
+
+   CreateHMMSet(&hset, &hmmStack, TRUE);
+   AddMMF(&hset, hmmFile);
+   if (trace & T_TOP)
+      printf("Loading MGE-trained HMM in iteration %d ... ... \n", nIter);
+   if (MakeHMMSet(&hset, hmmListFn) < SUCCESS)
+      HError(2321, "Initialise: MakeHMMSet failed");
+   if (LoadHMMSet(&hset, hmmDir, hmmExt) < SUCCESS)
+      HError(2321, "Initialise: LoadHMMSet failed");
+   SetParmHMMSet(&hset);
+   /* variance inversion, MGE training only support INVDIAGC case */
+   ConvDiagC(&hset, TRUE);
+
+   if (funcType == MGE_TRAIN)
+      AttachAccToModel();
+}
+
+/* OutputIntmdHmmFile: Output intermedia HMM files */
+static void OutputIntmdHmmFile(int nIter)
+{
+   char hext[16];
+
+   if (trace & T_TOP) {
+      fprintf(stdout, "\nSaving HMM to %s ... \n", outDir);
+      fflush(stdout);
+   }
+   /* fix variance floor */
+   ApplyVFloor(&hset);
+
+   /* variance re-inversion for output HMM */
+   ConvDiagC(&hset, TRUE);
+   sprintf(hext, "mmf%d", nIter);
+   SaveHMMSet(&hset, outDir, NULL, hext, TRUE);
+   ConvDiagC(&hset, TRUE);
+}
+
+/* OutputIntmdXForm: Output intermedia HMM files */
+static void OutputIntmdXForm(int nIter)
+{
+   char hext[16], fname[MAXSTRLEN];
+
+   if (trace & T_TOP) {
+      fprintf(stdout, "\nSaving XForm to %s ... \n", outDir);
+      fflush(stdout);
+   }
+   sprintf(hext, ".%d", nIter);
+   MakeFN(xformfn, outDir, NULL, fname);
+   strcat(fname, hext);
+   SaveOneXForm(&hset, hset.curXForm, fname, FALSE);
+}
+
+/* OneIterMgeEval: */
+static int OneIterMgeEval(int nIter)
+{
+   char *datafn, labfn[256], basefn[255];
+   int nSent, nAdjNum, p, nTotalAdj;
+
+   if (nIter > 1)
+      nMaxBALen = 1;
+   /* set all stat info to zero */
+   ResetAllStatInfo(nIter);
+   nTotalAdj = 0;
+   /* process all data */
+   for (nSent = 0; nSent < g_nDataFileNum; nSent++) {
+      datafn = g_pDataFileList[nSent]->datafn;
+      /* after first boundary adjustment, use the adjusted label files */
+      if (nIter >= 1 && bBoundAdj && outLabDir != NULL)
+         MakeFN(datafn, outLabDir, labExt, labfn);
+      else
+         MakeFN(datafn, labDir, labExt, labfn);
+      NameOf(datafn, basefn);
+
+      if (bBoundAdj) {
+         nAdjNum = OneSentBoundAdjust(mtInfo, labfn, datafn, outLabDir, nMaxBAIter, nMaxBALen, FALSE);
+         if (trace & T_PROC) {
+            fprintf(stdout, "Total BA Number: %d\n", nAdjNum);
+            fflush(stdout);
+         }
+         nTotalAdj += nAdjNum;
+      }
+      /* accumulation of generation error only */
+      OneSentGenErrAcc(mtInfo, labfn, datafn);
+      for (p = 1; p <= genInfo->nPdfStream[0]; p++) {
+         total_T[p] += genInfo->pst[p].T;
+      }
+   }
+
+   return nSent;
+}
+
+/* MGE evaluation main procedure */
+static void PerformMgeEval()
+{
+   int nIter, nSent;
+
+   /* create data file list */
+   CreateDataFileList();
+   nSent = g_nDataFileNum;
+   nSamples = 0;
+
+   /* synchronize parameters with previous iterations */
+   if (nBAEndIter < 0)
+      nBAEndIter = endIter;
+   for (nIter = 1; nIter < startIter; nIter++) {
+      nSamples += nSent;
+      if (nMaxBAIter > 1 && nIter > 0)
+         nMaxBAIter -= 1;
+      if (nMaxBALen > 1 && nIter > 0)
+         nMaxBALen -= 1;
+   }
+
+   /* apply transform to related models */
+   if (hset.curXForm != NULL)
+      ApplyHMMSetXForm(&hset, hset.curXForm, TRUE);
+
+   /* iteration from startIter to endIter */
+   for (nIter = startIter; nIter <= endIter; nIter++) {
+      if (trace & T_TOP) {
+         fprintf(stdout, "\n\n\n--------------------- Iteration %d -------------------\n", nIter);
+         fflush(stdout);
+      }
+      /* load MGE-trained HMM files */
+      if (nIter > 0)
+         LoadMgeTrnHmmFile(nIter);
+      /* set the flag for boundary adjustment */
+      bBoundAdj = mtInfo->bBoundAdj;
+
+      /* one iteration of MGE training */
+      nSent = OneIterMgeEval(nIter);
+      /* print the statistical information of training */
+      PrintStatInfo(nSent, nIter);
+      /* reduce the shift iterations and length after each iteration until it reach to 1 */
+      /* heuristic code to improve the efficiency */
+      if (nMaxBAIter > 1 && nIter > 0)
+         nMaxBAIter -= 1;
+      if (nMaxBALen > 1 && nIter > 0)
+         nMaxBALen -= 1;
+   }
+
+   PrintFinalResult(nSent, nIter);
+}
+
+/* OneIterMgeTrain: */
+static int OneIterMgeTrain(int nIter)
+{
+   char *datafn, labfn[256], basefn[255];
+   int nSent, nAdjNum, p, nTotalAdj;
+   float stepSize;
+
+   /* set all stat info to zero */
+   ResetAllStatInfo(nIter);
+   /* zero all acc info for batch mode updating */
+   ZeroAccsParallel(&hset, uFlags, 1);
+
+   stepSize = 1 / (A_STEP + B_STEP * nSamples);
+   nAdjNum = 0;
+   nTotalAdj = 0;
+   /* first refine the boundary for all data */
+   if (bBoundAdj && (nIter != 0 && nIter != startIter - 1)) {
+      for (nSent = 0; nSent < g_nDataFileNum; nSent++) {
+         datafn = g_pDataFileList[nSent]->datafn;
+         /* after first boundary adjustment, use the adjusted label files */
+         if (nIter > 1 && bBoundAdj && outLabDir != NULL)
+            MakeFN(datafn, outLabDir, labExt, labfn);
+         else
+            MakeFN(datafn, labDir, labExt, labfn);
+         NameOf(datafn, basefn);
+
+         if (trace & T_TOP) {
+            fprintf(stdout, "Boundary refining %4d %s ... \n", nSent, basefn);
+            fflush(stdout);
+         }
+         nAdjNum = OneSentBoundAdjust(mtInfo, labfn, datafn, outLabDir, nMaxBAIter, nMaxBALen, !bMgeUpdate);
+         if (trace & T_TOP) {
+            fprintf(stdout, "BA Number: %d\n", nAdjNum);
+            fflush(stdout);
+         }
+         nTotalAdj += nAdjNum;
+      }
+   }
+   /* process all data */
+   for (nSent = 0; nSent < g_nDataFileNum; nSent++) {
+      datafn = g_pDataFileList[nSent]->datafn;
+      /* after first boundary adjustment, use the adjusted label files */
+      if (nIter >= 1 && bBoundAdj && outLabDir != NULL)
+         MakeFN(datafn, outLabDir, labExt, labfn);
+      else
+         MakeFN(datafn, labDir, labExt, labfn);
+      NameOf(datafn, basefn);
+
+      if (trace & T_TOP) {
+         fprintf(stdout, "Prcessing %4d %s ... \n", nSent, basefn);
+         fflush(stdout);
+      }
+      /* accumulation of generation error only */
+      if (nIter == 0 || nIter == startIter - 1) {
+         OneSentGenErrAcc(mtInfo, labfn, datafn);
+      } else if (bMgeUpdate) {
+         OneSentMgeTrain(mtInfo, labfn, datafn, stepSize);
+         nSamples++;
+      }
+
+      for (p = 1; p <= genInfo->nPdfStream[0]; p++) {
+         total_T[p] += genInfo->pst[p].T;
+      }
+      /* update step size */
+      stepSize = 1 / (A_STEP + B_STEP * nSamples);
+      /* fix variance floor */
+      if ((uFlags & UPVARS) && nSent % 100 == 0)
+         ApplyVFloor(&hset);
+   }
+
+   if (nIter > 0 && bBoundAdj) {
+      if (trace & T_TOP) {
+         fprintf(stdout, "Bound Adjust Number: %d\n", nTotalAdj);
+         fflush(stdout);
+      }
+   }
+
+   if (nIter > 0 && bBoundAdj && (uFlags & UPMIXES))
+      UpdateAllMSDWeight(mtInfo);
+
+   return nSent;
+}
+
+/* PerformMgeTrain: MGE training main procedur */
+static void PerformMgeTrain()
+{
+   int nIter, nSent;
+
+   /* create data file list */
+   CreateDataFileList();
+   nSent = g_nDataFileNum;
+   nSamples = 0;
+
+   /* synchronize parameters with previous iterations */
+   if (nBAEndIter < 0)
+      nBAEndIter = endIter;
+   for (nIter = 1; nIter < startIter; nIter++) {
+      nSamples += nSent;
+      ShuffleDataFileList();
+      if (nMaxBAIter > 1 && nIter > 0)
+         nMaxBAIter -= 1;
+      if (nMaxBALen > 1 && nIter > 0)
+         nMaxBALen -= 1;
+   }
+   /* initialize step size */
+   mtInfo->initStepSize = 1 / A_STEP;
+
+   /* apply transform to related models */
+   if (hset.curXForm != NULL) {
+      ApplyHMMSetXForm(&hset, hset.curXForm, TRUE);
+      if (mtInfo->bOrigHmmRef)
+         ApplyHMMSetXForm(&orighset, orighset.curXForm, TRUE);
+   }
+
+   /* iteration from startIter ~ endIter */
+   for (nIter = startIter; nIter <= endIter; nIter++) {
+      /* shuffle data file list */
+      if (nIter != 0)
+         ShuffleDataFileList();
+
+      if (trace & T_TOP) {
+         fprintf(stdout, "\n\n\n--------------------- Iteration %d -------------------\n", nIter);
+         fflush(stdout);
+      }
+      /* set the flag for boundary adjustment */
+      if (nMaxBAIter > 1 || nIter <= nBAEndIter)
+         bBoundAdj = mtInfo->bBoundAdj;
+      else
+         bBoundAdj = FALSE;
+
+      /* one iteration of MGE training */
+      nSent = OneIterMgeTrain(nIter);
+
+      /* print the statistical information of training */
+      PrintStatInfo(nSent, nIter);
+
+      /* output intermedia HMM files */
+      if (nIter > 0 && outProcData && bMgeUpdate)
+         OutputIntmdHmmFile(nIter);
+      /* reduce the shift length after each iteration until it reach to 2 */
+      /* heuristic code to improve the efficiency */
+      if (nMaxBAIter > 1 && nIter > 0)
+         nMaxBAIter -= 1;
+      if (nMaxBALen > 1 && nIter > 0)
+         nMaxBALen -= 1;
+   }
+
+   PrintFinalResult(nSent, nIter);
+}
+
+/* OneIterMgeAdapt: */
+static int OneIterMgeAdapt(int nIter)
+{
+   char *datafn, labfn[256], basefn[255];
+   int nSent, nAdjNum, p, nTotalAdj;
+   float stepSize;
+
+   if (nIter > 1)
+      nMaxBALen = 1;
+   /* set all stat info to zero */
+   ResetAllStatInfo(nIter);
+
+   stepSize = 1 / (A_STEP + B_STEP * nSamples);
+   nAdjNum = 0;
+   nTotalAdj = 0;
+   /* process all data */
+   for (nSent = 0; nSent < g_nDataFileNum; nSent++) {
+      datafn = g_pDataFileList[nSent]->datafn;
+      /* after first boundary adjustment, use the adjusted label files */
+      if (nIter > 1 && bBoundAdj && outLabDir != NULL)
+         MakeFN(datafn, outLabDir, labExt, labfn);
+      else
+         MakeFN(datafn, labDir, labExt, labfn);
+      NameOf(datafn, basefn);
+
+      if (trace & T_TOP) {
+         fprintf(stdout, "Prcessing %4d %s ... \n", nSent, basefn);
+         fflush(stdout);
+      }
+
+      /* apply transform to related models */
+      if (hset.curXForm != NULL)
+         OneSentTransform(mtInfo, labfn, datafn);
+
+      /* accumulation of generation error only */
+      if (nIter == 0) {
+         OneSentGenErrAcc(mtInfo, labfn, datafn);
+      } else {
+         if (bBoundAdj) {
+            nAdjNum = OneSentBoundAdjust(mtInfo, labfn, datafn, outLabDir, nMaxBAIter, nMaxBALen, !bMgeUpdate);
+            if (trace & T_TOP) {
+               fprintf(stdout, "BA Number: %d\n", nAdjNum);
+               fflush(stdout);
+            }
+            nTotalAdj += nAdjNum;
+         }
+         if (bMgeUpdate) {
+            OneSentMgeAdapt(mtInfo, labfn, datafn, stepSize);
+            nSamples++;
+         }
+      }
+
+      for (p = 1; p <= genInfo->nPdfStream[0]; p++) {
+         total_T[p] += genInfo->pst[p].T;
+      }
+
+      /* update step size */
+      stepSize = 1 / (A_STEP + B_STEP * nSamples);
+      /* fix variance floor */
+      if ((uFlags & UPVARS) && nSent % 100 == 0)
+         ApplyVFloor(&hset);
+   }
+   if (nIter > 0 && bBoundAdj) {
+      if (trace & T_TOP) {
+         fprintf(stdout, "Bound Adjust Number: %d\n", nTotalAdj);
+         fflush(stdout);
+      }
+   }
+
+   return nSent;
+}
+
+/* PerformMgeAdapt: MGE adaptation main procedure */
+static void PerformMgeAdapt()
+{
+   int nIter, nSent;
+
+   /* create data file list */
+   CreateDataFileList();
+   nSent = g_nDataFileNum;
+   nSamples = 0;
+
+   /* synchronize parameters with previous iterations */
+   if (nBAEndIter < 0)
+      nBAEndIter = endIter;
+   for (nIter = 1; nIter < startIter; nIter++) {
+      nSamples += nSent;
+      ShuffleDataFileList();
+      if (nMaxBAIter > 1 && nIter > 0)
+         nMaxBAIter -= 1;
+      if (nMaxBALen > 1 && nIter > 0)
+         nMaxBALen -= 1;
+   }
+   /* initialize step size */
+   mtInfo->initStepSize = 1 / A_STEP;
+
+   /* iteration from startIter to endIter */
+   for (nIter = startIter; nIter <= endIter; nIter++) {
+      /* shuffle data file list */
+      if (nIter != 0)
+         ShuffleDataFileList();
+
+      if (trace & T_TOP) {
+         fprintf(stdout, "\n\n\n--------------------- Iteration %d -------------------\n", nIter);
+         fflush(stdout);
+      }
+      /* set the flag for boundary adjustment */
+      if (nMaxBAIter > 1 || nIter <= nBAEndIter)
+         bBoundAdj = mtInfo->bBoundAdj;
+      else
+         bBoundAdj = FALSE;
+
+      /* one iteration of MGE training */
+      nSent = OneIterMgeAdapt(nIter);
+
+      /* print the statistical information of training */
+      PrintStatInfo(nSent, nIter);
+
+      /* output intermedia HMM files */
+      if (nIter > 0 && outProcData && bMgeUpdate)
+         OutputIntmdXForm(nIter);
+      /* reduce the shift length after each iteration until it reach to 2 */
+      /* heuristic code to improve the efficiency */
+      if (nMaxBAIter > 1 && nIter > 0)
+         nMaxBAIter -= 1;
+      if (nMaxBALen > 1 && nIter > 0)
+         nMaxBALen -= 1;
+   }
+
+   PrintFinalResult(nSent, nIter);
+}
+
+/* ----------------------------------------------------------- */
+/*                      END:  HMgeTool.c                       */
+/* ----------------------------------------------------------- */
diff -pbBEwurNa --ignore-matching-lines='.*vc_id.*' HTK-3.4.1/HTKTools/HParse.c HTS-2.2_for_HTK-3.4.1/HTKTools/HParse.c
--- HTK-3.4.1/HTKTools/HParse.c	2009-03-13 03:53:16.000000000 +0900
+++ HTS-2.2_for_HTK-3.4.1/HTKTools/HParse.c	2011-06-16 13:18:30.000000000 +0900
@@ -19,8 +19,53 @@
 /*     File: HParse.c: HParse based word-network definition    */
 /* ----------------------------------------------------------- */
 
+/*  *** THIS IS A MODIFIED VERSION OF HTK ***                        */
+/* ----------------------------------------------------------------- */
+/*           The HMM-Based Speech Synthesis System (HTS)             */
+/*           developed by HTS Working Group                          */
+/*           http://hts.sp.nitech.ac.jp/                             */
+/* ----------------------------------------------------------------- */
+/*                                                                   */
+/*  Copyright (c) 2001-2011  Nagoya Institute of Technology          */
+/*                           Department of Computer Science          */
+/*                                                                   */
+/*                2001-2008  Tokyo Institute of Technology           */
+/*                           Interdisciplinary Graduate School of    */
+/*                           Science and Engineering                 */
+/*                                                                   */
+/* All rights reserved.                                              */
+/*                                                                   */
+/* Redistribution and use in source and binary forms, with or        */
+/* without modification, are permitted provided that the following   */
+/* conditions are met:                                               */
+/*                                                                   */
+/* - Redistributions of source code must retain the above copyright  */
+/*   notice, this list of conditions and the following disclaimer.   */
+/* - Redistributions in binary form must reproduce the above         */
+/*   copyright notice, this list of conditions and the following     */
+/*   disclaimer in the documentation and/or other materials provided */
+/*   with the distribution.                                          */
+/* - Neither the name of the HTS working group nor the names of its  */
+/*   contributors may be used to endorse or promote products derived */
+/*   from this software without specific prior written permission.   */
+/*                                                                   */
+/* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND            */
+/* CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,       */
+/* INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF          */
+/* MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE          */
+/* DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS */
+/* BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,          */
+/* EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED   */
+/* TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,     */
+/* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON */
+/* ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,   */
+/* OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY    */
+/* OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE           */
+/* POSSIBILITY OF SUCH DAMAGE.                                       */
+/* ----------------------------------------------------------------- */
+
 char *hparse_version = "!HVER!HParse:   3.4.1 [CUED 12/03/09]";
-char *hparse_vc_id = "$Id: HParse.c,v 1.1.1.1 2006/10/11 09:55:01 jal58 Exp $";
+char *hparse_vc_id = "$Id: HParse.c,v 1.10 2011/06/16 04:18:30 uratec Exp $";
 
 /* The HParse program reads in a set of HTK  HParse rewrite rules
    (as used in HTK V1.x) and writes out an HTK V2 lattice and
@@ -189,6 +234,7 @@ void SetConfParms(void)
 
 void ReportUsage(void)
 {
+   printf("\nModified for HTS\n");
    printf("\nUSAGE: HParse [options] netFile latFile\n\n");
    printf(" Option                                       Default\n\n");
    printf(" -b      output lattice in binary             ascii\n");   
@@ -263,6 +309,14 @@ int main(int argc, char *argv[])
    if (trace&T_HPNET) 
       PrintHParseNetwork(&theNet);
    ConvertHParseNetwork(&theNet,latFn,dictFn);
+
+   ResetNet();
+   ResetDict();
+   ResetMath();
+   ResetLabel();
+   ResetMem();
+   ResetShell();
+   
    Exit(0);
    return (0);          /* never reached -- make compiler happy */
 }
@@ -379,7 +433,7 @@ static void PrModelName(Link p)
       strcpy(name,"????");
    else
       strcpy(name,p->modelName->name);
-   printf("%s[%03d] ",name, ((int)p % 4000) / 4 );
+   printf("%s[%03ld] ",name, ((long)p % 4000) / 4 );
 }
 
 /* PrintLinkSet: print first n slots of given LinkSet to stdout */
@@ -927,7 +981,7 @@ static Boolean SameLinks(int a1, int a2)
 
 static Boolean IsJoined(int a, int b)
 {
-   return (jmat[a][b/8] & (1 <<(b&7))) != 0;
+   return ( ((jmat[a][b/8] & (1 <<(b&7))) != 0) ? TRUE:FALSE );
 }
 
 static int NumJSuccs(int a)
@@ -1714,17 +1768,17 @@ static Boolean CanCompact(Link p)
 
    for (i=1; (i <= p->succ->numLinks) && ok ; i++) {
       succNode = p -> succ->links[i];
-      ok = (succNode -> modelName != NULL);
+      ok = (succNode -> modelName != NULL) ? TRUE:FALSE;
    }
    if (!ok) {
       ok = TRUE;    
       for (i=1; (i <= p->pred->numLinks) && ok ; i++) {
          predNode = p -> pred->links[i];
-         ok = (predNode -> modelName != NULL);
+         ok = (predNode -> modelName != NULL) ? TRUE:FALSE;
       }
    }
    if (!ok)
-      ok = ((p->succ->numLinks == 1) && (p->pred->numLinks == 1));
+      ok = ((p->succ->numLinks == 1) && (p->pred->numLinks == 1)) ? TRUE:FALSE;
    return ok;
 }
 
@@ -2000,7 +2054,7 @@ void LabelInternal(Link p)
       }  
    }
    else if ((ni->nType != wdEnd) && (ni->nType != wdInternal))
-      HError(3131,"LabelInternal: incorrect WD_BEGIN/WD_END node connection, node %d is %d",((int)p % 4000) / 4,ni->nType);
+      HError(3131,"LabelInternal: incorrect WD_BEGIN/WD_END node connection, node %ld is %d",((long)p % 4000) / 4,ni->nType);
 }
 
 /* FindNodeTypes: mark each node as wdInternal or wdExternal */
@@ -2326,4 +2380,6 @@ static void ConvertHParseNetwork(HPNetwo
    SaveLattice(lat,latFn,format);
 }
 
-/* ------------------- End of HParse.c --------------------------------- */
+/* ----------------------------------------------------------- */
+/*                      END:  HParse.c                         */
+/* ----------------------------------------------------------- */
diff -pbBEwurNa --ignore-matching-lines='.*vc_id.*' HTK-3.4.1/HTKTools/HQuant.c HTS-2.2_for_HTK-3.4.1/HTKTools/HQuant.c
--- HTK-3.4.1/HTKTools/HQuant.c	2009-03-13 03:53:25.000000000 +0900
+++ HTS-2.2_for_HTK-3.4.1/HTKTools/HQuant.c	2011-06-16 13:18:30.000000000 +0900
@@ -19,8 +19,53 @@
 /*       File: HQuant.c: VQ table generation                   */
 /* ----------------------------------------------------------- */
 
+/*  *** THIS IS A MODIFIED VERSION OF HTK ***                        */
+/* ----------------------------------------------------------------- */
+/*           The HMM-Based Speech Synthesis System (HTS)             */
+/*           developed by HTS Working Group                          */
+/*           http://hts.sp.nitech.ac.jp/                             */
+/* ----------------------------------------------------------------- */
+/*                                                                   */
+/*  Copyright (c) 2001-2011  Nagoya Institute of Technology          */
+/*                           Department of Computer Science          */
+/*                                                                   */
+/*                2001-2008  Tokyo Institute of Technology           */
+/*                           Interdisciplinary Graduate School of    */
+/*                           Science and Engineering                 */
+/*                                                                   */
+/* All rights reserved.                                              */
+/*                                                                   */
+/* Redistribution and use in source and binary forms, with or        */
+/* without modification, are permitted provided that the following   */
+/* conditions are met:                                               */
+/*                                                                   */
+/* - Redistributions of source code must retain the above copyright  */
+/*   notice, this list of conditions and the following disclaimer.   */
+/* - Redistributions in binary form must reproduce the above         */
+/*   copyright notice, this list of conditions and the following     */
+/*   disclaimer in the documentation and/or other materials provided */
+/*   with the distribution.                                          */
+/* - Neither the name of the HTS working group nor the names of its  */
+/*   contributors may be used to endorse or promote products derived */
+/*   from this software without specific prior written permission.   */
+/*                                                                   */
+/* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND            */
+/* CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,       */
+/* INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF          */
+/* MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE          */
+/* DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS */
+/* BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,          */
+/* EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED   */
+/* TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,     */
+/* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON */
+/* ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,   */
+/* OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY    */
+/* OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE           */
+/* POSSIBILITY OF SUCH DAMAGE.                                       */
+/* ----------------------------------------------------------------- */
+
 char *hquant_version = "!HVER!HQuant:   3.4.1 [CUED 12/03/09]";
-char *hquant_vc_id = "$Id: HQuant.c,v 1.1.1.1 2006/10/11 09:55:01 jal58 Exp $";
+char *hquant_vc_id = "$Id: HQuant.c,v 1.8 2011/06/16 04:18:30 uratec Exp $";
 
 /* 
    This program calculates a vector quantisation table from a
@@ -110,6 +155,7 @@ void InitStreamVars(void)
 
 void ReportUsage(void)
 {
+   printf("\nModified for HTS\n");
    printf("\nUSAGE: HQuant [options] vqFile trainFiles...\n\n" );
    printf(" Option                                       Default\n\n");
    printf(" -d      Use diagonal cov Mahalanobis         Euclidean\n");
@@ -258,6 +304,19 @@ int main(int argc, char *argv[])
       ClusterVecs(dSeq,stream);
    }
    WriteVQTable(cs,vqfn);
+
+   ResetTrain();
+   ResetParm();
+   ResetModel();
+   ResetVQ();
+   ResetAudio();
+   ResetWave();
+   ResetSigP();
+   ResetMath();
+   ResetLabel();
+   ResetMem();
+   ResetShell();
+   
    Exit(0);
    return (0);          /* never reached -- make compiler happy */
 }
diff -pbBEwurNa --ignore-matching-lines='.*vc_id.*' HTK-3.4.1/HTKTools/HRest.c HTS-2.2_for_HTK-3.4.1/HTKTools/HRest.c
--- HTK-3.4.1/HTKTools/HRest.c	2009-03-13 03:53:33.000000000 +0900
+++ HTS-2.2_for_HTK-3.4.1/HTKTools/HRest.c	2011-06-16 13:18:30.000000000 +0900
@@ -32,8 +32,53 @@
 /*         File: HRest.c: HMM initialisation program           */
 /* ----------------------------------------------------------- */
 
+/*  *** THIS IS A MODIFIED VERSION OF HTK ***                        */
+/* ----------------------------------------------------------------- */
+/*           The HMM-Based Speech Synthesis System (HTS)             */
+/*           developed by HTS Working Group                          */
+/*           http://hts.sp.nitech.ac.jp/                             */
+/* ----------------------------------------------------------------- */
+/*                                                                   */
+/*  Copyright (c) 2001-2011  Nagoya Institute of Technology          */
+/*                           Department of Computer Science          */
+/*                                                                   */
+/*                2001-2008  Tokyo Institute of Technology           */
+/*                           Interdisciplinary Graduate School of    */
+/*                           Science and Engineering                 */
+/*                                                                   */
+/* All rights reserved.                                              */
+/*                                                                   */
+/* Redistribution and use in source and binary forms, with or        */
+/* without modification, are permitted provided that the following   */
+/* conditions are met:                                               */
+/*                                                                   */
+/* - Redistributions of source code must retain the above copyright  */
+/*   notice, this list of conditions and the following disclaimer.   */
+/* - Redistributions in binary form must reproduce the above         */
+/*   copyright notice, this list of conditions and the following     */
+/*   disclaimer in the documentation and/or other materials provided */
+/*   with the distribution.                                          */
+/* - Neither the name of the HTS working group nor the names of its  */
+/*   contributors may be used to endorse or promote products derived */
+/*   from this software without specific prior written permission.   */
+/*                                                                   */
+/* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND            */
+/* CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,       */
+/* INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF          */
+/* MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE          */
+/* DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS */
+/* BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,          */
+/* EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED   */
+/* TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,     */
+/* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON */
+/* ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,   */
+/* OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY    */
+/* OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE           */
+/* POSSIBILITY OF SUCH DAMAGE.                                       */
+/* ----------------------------------------------------------------- */
+
 char *hrest_version = "!HVER!HRest:   3.4.1 [CUED 12/03/09]";
-char *hrest_vc_id = "$Id: HRest.c,v 1.1.1.1 2006/10/11 09:55:01 jal58 Exp $";
+char *hrest_vc_id = "$Id: HRest.c,v 1.13 2011/06/16 04:18:30 uratec Exp $";
 
 /*
    This program is used to estimate the transition parameters,
@@ -82,11 +127,13 @@ static LabId  segId  = NULL;     /* and 
 static char * labDir = NULL;     /* label file directory */
 static char * labExt = "lab";    /* label file extension */
 static char * outDir = NULL;     /* output macro file directory, if any */
+static char * durFN  = NULL;     /* output duration file */
 static int  maxIter  = 20;       /* max iterations in parameter estimation */
 static float epsilon = 1.0E-4;   /* convergence criterion */
 static int minSeg    = 3;        /* min segments to train a model */
 static Boolean firstTime = TRUE; /* Flag used to enable InitSegStore */
 static Boolean saveBinary = FALSE;  /* save output in binary  */
+static Boolean calcDuration = FALSE; /* save duration */
 static FileFormat dff=UNDEFF;    /* data file format */
 static FileFormat lff=UNDEFF;    /* label file format */
 static float minVar  = 0.0;      /* minimum variance */
@@ -114,6 +161,9 @@ static int nTokUsed;       /* actual num
 static int maxT,minT,T;    /* max,min and current segment lengths */
 static DMatrix alpha;      /* array[1..nStates][1..maxT] of forward prob */
 static DMatrix beta;       /* array[1..nStates][1..maxT] of backward prob */
+static DVector durOcc;     /* array[1..nStates] of duration counter (occ) */
+static DVector durSum;     /* array[1..nStates] of duration counter (sum) */
+static DVector durSqr;     /* array[1..nStates] of duration counter (sqr) */
 static Matrix outprob;     /* array[2..nStates-1][1..maxT] of output prob */
 static Vector **stroutp;   /* array[1..maxT][2..nStates-1][1..nStreams] ...*/
                            /* ... of streamprob */
@@ -152,12 +202,15 @@ void SetConfParms(void)
 
 void ReportUsage(void)
 {
+   printf("\nModified for HTS\n");
    printf("\nUSAGE: HRest [options] hmmFile trainFiles...\n\n");
    printf(" Option                                       Default\n\n");
    printf(" -e f    Set convergence factor epsilon       1.0E-4\n");
+   printf(" -g s    output duration model to file s                   none\n");
    printf(" -i N    Set max iterations to N              20\n");
    printf(" -l s    Set segment label to s               none\n");
    printf(" -m N    Set min segments needed              3\n");
+   printf(" -o fn   Store new hmm def in fn (name only)               outDir/srcfn\n");
    printf(" -t      Disable short segment rejection      on\n");
    printf(" -u tmvw Update t)rans m)eans v)ars w)ghts    tmvw\n");
    printf(" -v f    Set minimum variance to f            0.0\n");
@@ -217,6 +270,11 @@ int main(int argc, char *argv[])
       switch(s[0]){      
       case 'e':
          epsilon = GetChkedFlt(0.0,1.0,s); break;
+      case 'g':
+         calcDuration = TRUE;
+         if (NextArg()!=STRINGARG)
+            HError(2219,"HRest: duration model file name expected");
+         durFN = GetStrArg(); break;
       case 'i':
          maxIter = GetChkedInt(1,100,s); break;
       case 'l':
@@ -235,6 +293,9 @@ int main(int argc, char *argv[])
          minVar = GetChkedFlt(0.0,100.0,s); break;
       case 'c':
          tMPruneThresh = GetChkedFlt(0.0,1000.0,s); break;
+      case 'o':
+         outfn = GetStrArg();
+         break;
       case 'w':
          mixWeightFloor = MINMIX * GetChkedFlt(0.0,10000.0,s); break;
       case 'B':
@@ -304,6 +365,20 @@ int main(int argc, char *argv[])
 
    if(SaveHMMSet(&hset,outDir,NULL,NULL,saveBinary)<SUCCESS)
       HError(2211,"HRest: SaveHMMSet failed");
+
+   ResetUtil();
+   ResetTrain();
+   ResetParm();
+   ResetModel();
+   ResetVQ();
+   ResetAudio();
+   ResetWave();
+   ResetSigP();
+   ResetMath();
+   ResetLabel();
+   ResetMem();
+   ResetShell();
+   
    Exit(0);
    return (0);          /* never reached -- make compiler happy */
 }
@@ -421,6 +496,12 @@ void Initialise2(void)
    }
    occr = CreateVector(&gstack,nStates-1);
    zot = CreateVector(&gstack,hset.vecSize);
+   
+   if (calcDuration) {
+      durOcc = CreateDVector(&accsStack, nStates);
+      durSum = CreateDVector(&accsStack, nStates);
+      durSqr = CreateDVector(&accsStack, nStates);
+   }
 }
 
 /* ---------------------------- Load Data ------------------------- */
@@ -449,7 +530,7 @@ void InitSegStore(BufferInfo *info)
 
    SetStreamWidths(info->tgtPK,info->tgtVecSize,hset.swidth,&eSep);
    obs = MakeObservation(&gstack,hset.swidth,info->tgtPK,
-                         hset.hsKind==DISCRETEHS,eSep);
+                         ((hset.hsKind==DISCRETEHS) ? TRUE:FALSE),eSep);
    segStore = CreateSegStore(&segmentStack,obs,10);
    firstTime = FALSE;
 }
@@ -458,7 +539,7 @@ void InitSegStore(BufferInfo *info)
 void LoadFile(char *fn)
 {
    BufferInfo info;
-   char labfn[80];
+   char labfn[MAXSTRLEN];
    Transcription *trans;
    long segStIdx,segEnIdx;
    static int segIdx=1;  /* Between call handle on latest seg in segStore */  
@@ -540,7 +621,7 @@ void LoadFile(char *fn)
 /* ------------------------ Trace Functions -------------------- */
 
 /* ShowSegNum: if not already printed, print seg number */
-void ShowSegNum(int seg)
+void ShowSegNum(const int seg)
 {
    static int lastseg = -1;
    
@@ -553,10 +634,11 @@ void ShowSegNum(int seg)
 /* ------------------------- Alpha-Beta ------------------------ */
 
 /* SetOutP: Set the output and mix prob matrices */                        
-void SetOutP(int seg)
+void SetOutP(const int seg)
 {
    int i,t,m,mx,s,nMix=0;
-   StreamElem *se;
+   StreamElem *ste;
+   StreamInfo *sti;
    MixtureElem *me;
    StateInfo *si;
    Matrix mixp;
@@ -576,10 +658,11 @@ void SetOutP(int seg)
          for (i=2;i<nStates;i++) {
             prob = 0.0;
             si = hmm->svec[i].info;
-            se = si->pdf+1; 
+            ste = si->pdf+1; 
             mixp = mixoutp[i][t];
             if (nStreams>1) strp = stroutp[t][i];
-            for (s=1;s<=nStreams;s++,se++){
+            for (s=1;s<=nStreams;s++,ste++){
+               sti = ste->info;
                switch (hsKind){         /* Get nMix */
                case TIEDHS:
                   tmRec = &(hset.tmRecs[s]);
@@ -587,7 +670,7 @@ void SetOutP(int seg)
                   break;
                case PLAINHS:
                case SHAREDHS:
-                  nMix = se->nMix;
+                  nMix = sti->nMix;
                   break;
                }
                streamP = LZERO;
@@ -595,12 +678,12 @@ void SetOutP(int seg)
                   m=(hsKind==TIEDHS)?tmRec->probs[mx].index:mx;
                   switch (hsKind){      /* Get wght and mpdf */
                   case TIEDHS:
-                     wght=se->spdf.tpdf[m];
+                     wght=sti->spdf.tpdf[m];
                      mpdf=tmRec->mixes[m];
                      break;
                   case PLAINHS:
                   case SHAREDHS:
-                     me = se->spdf.cpdf+m;
+                     me = sti->spdf.cpdf+m;
                      wght=me->weight;
                      mpdf=me->mpdf;
                      break;
@@ -632,9 +715,13 @@ void SetOutP(int seg)
                   } else
                      mixp[s][m]=LZERO;
                }               
-               if (nStreams>1)
-                  strp[s]=streamP;
-               prob += streamP; /* note stream weights ignored */
+               if (nStreams>1) {
+                  strp[s]=si->weights[s]*streamP;
+                  prob += si->weights[s]*streamP;
+               }
+               else {
+                  prob += streamP;
+               }
             }   
             outprob[i][t]=prob;
          }
@@ -643,21 +730,22 @@ void SetOutP(int seg)
             for (i=2;i<nStates;i++) {
                prob = 0.0;
                si = hmm->svec[i].info;
-               se = si->pdf+1;
+               ste = si->pdf+1;
                strp = stroutp[t][i];
-               for (s=1;s<=nStreams;s++,se++){
-                  streamP = SOutP(&hset,s,&obs,se);
-                  strp[s] = streamP;
-                  prob += streamP; /* note stream weights ignored */
+               for (s=1;s<=nStreams;s++,ste++){
+                  sti = ste->info;
+                  streamP = SOutP(&hset,s,&obs,sti);
+                  strp[s] = si->weights[s]*streamP;
+                  prob += si->weights[s]*streamP; /* note stream weights ignored */
                }
                outprob[i][t]=prob;
             }
          } else                 /* Single Mixture - Single Stream */
             for (i=2;i<nStates;i++){
                si = hmm->svec[i].info;
-               se = si->pdf+1;
+               ste = si->pdf+1;
                if (hsKind==DISCRETEHS)
-                  outprob[i][t]=SOutP(&hset,1,&obs,se);
+                  outprob[i][t]=SOutP(&hset,1,&obs,ste->info);
                else
                   outprob[i][t]=OutP(&obs,hmm,i);
             }
@@ -669,7 +757,7 @@ void SetOutP(int seg)
 }
 
 /* SetAlpha: compute alpha matrix and return prob of given sequence */
-LogDouble SetAlpha(int seg)
+LogDouble SetAlpha(const int seg)
 {
    int i,j,t;
    LogDouble x,a;
@@ -713,7 +801,7 @@ LogDouble SetAlpha(int seg)
 }
 
 /* SetBeta: compute beta matrix */
-LogDouble SetBeta(int seg)
+LogDouble SetBeta(const int seg)
 {
    int i,j,t;
    LogDouble x,a;
@@ -752,7 +840,7 @@ LogDouble SetBeta(int seg)
 /* --------------------- Record Statistics ---------------- */
 
 /* SetOccr: set the global occupation counters occr for current seg */
-void SetOccr(LogDouble pr, int seg)
+void SetOccr(const LogDouble pr, const int seg)
 {
    int i,t;
    DVector alpha_i,beta_i;
@@ -779,7 +867,7 @@ void SetOccr(LogDouble pr, int seg)
 }
 
 /* UpTranCounts: update the transition counters in ta */
-void UpTranCounts(LogDouble pr,int seg)
+void UpTranCounts(const LogDouble pr, const int seg)
 {
    int i,j,t;
    Matrix tran;
@@ -838,7 +926,8 @@ void UpTranCounts(LogDouble pr,int seg)
 }
 
 /* UpStreamCounts: update mean, cov & mixweight counts for given stream */
-void UpStreamCounts(int j, int s, StreamElem *se, int vSize, LogDouble pr, int seg,
+void UpStreamCounts(const int j, const int s, StreamInfo *sti, 
+                    int vSize, const LogDouble pr, const int seg,
                     DVector alphj, DVector betaj)
 {
    int i,m,nMix=0,k,l,t,ss,idx;
@@ -856,7 +945,7 @@ void UpStreamCounts(int j, int s, Stream
    TMixRec *tmRec = NULL;
    float wght=0.0;
    
-   wa = (WtAcc *)se->hook;
+   wa = (WtAcc *)sti->hook;
    switch (hsKind){       /* Get nMix */
    case TIEDHS:
       tmRec = &(hset.tmRecs[s]);
@@ -864,7 +953,7 @@ void UpStreamCounts(int j, int s, Stream
       break;
    case PLAINHS:
    case SHAREDHS:
-      nMix = se->nMix;
+      nMix = sti->nMix;
       break;      
    case DISCRETEHS:
       nMix = 1;                /* Only one code selected per observation */
@@ -874,7 +963,7 @@ void UpStreamCounts(int j, int s, Stream
    for (m=1; m<=nMix; m++) {
       switch (hsKind){            /* Get mpdf, wght */
       case TIEDHS:               
-         wght=se->spdf.tpdf[m];
+         wght=sti->spdf.tpdf[m];
          mpdf=tmRec->mixes[m];
          break;
       case DISCRETEHS:
@@ -883,9 +972,10 @@ void UpStreamCounts(int j, int s, Stream
          break;
       case PLAINHS:
       case SHAREDHS:
-         me = se->spdf.cpdf+m;
+         me = sti->spdf.cpdf+m;
          wght=me->weight;
          mpdf=me->mpdf;
+         if(hset.msdflag[s]) vSize = VectorSize(mpdf->mean);
          break;
       }
       if (hsKind!=DISCRETEHS){
@@ -984,23 +1074,76 @@ void UpStreamCounts(int j, int s, Stream
 }
    
 /* UpPDFCounts: update output PDF counts for each stream of each state */
-void UpPDFCounts(LogDouble pr, int seg)
+void UpPDFCounts(const LogDouble pr, const int seg)
 {
    int j,s;
    StateInfo *si;
-   StreamElem *se;
+   StreamElem *ste;
    DVector alj,betj;
 
    for (j=2; j<nStates; j++) {
       si = hmm->svec[j].info;
       alj = alpha[j]; betj = beta[j];
-      for (s=1,se = si->pdf+1; s<=nStreams; s++,se++)
-         UpStreamCounts(j,s,se,hset.swidth[s],pr,seg,alj,betj);
+      for (s=1,ste = si->pdf+1; s<=nStreams; s++,ste++)
+         UpStreamCounts(j,s,ste->info,hset.swidth[s],pr,seg,alj,betj);
    }
 }
 
+/* UpDurCounts: update duration counts */
+void UpDurCounts(const LogDouble pr, const int seq)
+{
+   int j,k,t0,t1;
+   LogDouble x,x0,Sumx;
+   
+   for (j=2;j<nStates;j++) { 
+      for (t0=1;t0<=T;t0++) {
+         if (t0 == 1) x0 = hmm->transP[1][j]; 
+         else {
+            x0 = LZERO;
+            for (k=2; k<nStates; k++)
+               if (k!=j && hmm->transP[k][j]>LSMALL)
+                  x0 = LAdd(x0, alpha[k][t0-1]+hmm->transP[k][j]);
+         }
+               
+         Sumx = x0;
+              
+         /* from t0 to t1 */ 
+         for (t1=t0; t1<=T; t1++) {  
+            if (Sumx>LSMALL) {
+               Sumx += outprob[j][t1];
+               if (t1!=t0) 
+                  Sumx += (double)hmm->transP[j][j];
+
+               if (t1==T) { 
+                  x = hmm->transP[j][nStates];
+               }
+               else {
+                  x = LZERO;
+                  for (k=2; k<nStates; k++)
+                     if (k!=j && hmm->transP[j][k]>LSMALL)
+                        x = LAdd(x, (double)hmm->transP[j][k]
+                                   +(double)outprob[k][t1+1]+beta[k][t1+1]);
+               } 
+                  
+               x = x+Sumx-pr;
+                  
+               /* update statistics */
+               if (x>LSMALL) {
+                  durSqr[j-1] = LAdd(durSqr[j-1], x+2*log(t1-t0+1)); 
+                  durSum[j-1] = LAdd(durSum[j-1], x+log(t1-t0+1)); 
+                  durOcc[j-1] = LAdd(durOcc[j-1], x);
+               }      
+            } 
+            else 
+               break; 
+         }
+      } 
+   }  
+} 
+ 
+
 /* UpdateCounters: update the various counters */
-void UpdateCounters(LogDouble pr, int seg)
+void UpdateCounters(const LogDouble pr, const int seg)
 {
    SetOccr(pr,seg);
    if (uFlags&UPTRANS) 
@@ -1040,7 +1183,7 @@ void RestTransP(void)
 }
 
 /* FloorMixes: apply floor to given mix set */
-void FloorMixes(MixtureElem *mixes, int M, float floor)
+void FloorMixes(MixtureElem *mixes, const int M, const float floor)
 {
    float sum,fsum,scale;
    MixtureElem *me;
@@ -1067,7 +1210,7 @@ void FloorMixes(MixtureElem *mixes, int 
 }  
 
 /* FloorTMMixes: apply floor to given tied mix set */
-void FloorTMMixes(Vector mixes, int M, float floor)
+void FloorTMMixes(Vector mixes, const int M, const float floor)
 {
    float sum,fsum,scale,fltWt;
    int m;
@@ -1094,7 +1237,7 @@ void FloorTMMixes(Vector mixes, int M, f
 }
 
 /* FloorDProbs: apply floor to given discrete prob set */
-void FloorDProbs(ShortVec mixes, int M, float floor)
+void FloorDProbs(ShortVec mixes, const int M, const float floor)
 {
    float sum,fsum,scale,fltWt;
    int m;
@@ -1121,14 +1264,14 @@ void FloorDProbs(ShortVec mixes, int M, 
 }
 
 /* RestMixWeights: reestimate the mixture weights */
-void RestMixWeights(int state, int s, StreamElem *se)
+void RestMixWeights(const int state, const int s, StreamInfo *sti)
 {
    WtAcc *wa;
    int m,M=0;
    float x;
    MixtureElem *me;
    
-   wa = (WtAcc *)se->hook;
+   wa = (WtAcc *)sti->hook;
    if (wa->occ == 0.0)
       HError(2222,"RestMixWeights: Zero weight occupation count");
    switch (hsKind){
@@ -1138,7 +1281,7 @@ void RestMixWeights(int state, int s, St
    case PLAINHS:
    case SHAREDHS:
    case DISCRETEHS:
-      M=se->nMix;
+      M=sti->nMix;
       break;
    }
    for (m=1; m<=M; m++){
@@ -1147,14 +1290,14 @@ void RestMixWeights(int state, int s, St
          HError(2290,"RestMixWeights: Mix wt>1 in %d.%d.%d",state,s,m);
       switch (hsKind){
       case DISCRETEHS:
-         se->spdf.dpdf[m] = (x>MINMIX) ? DProb2Short(x) : DLOGZERO;
+         sti->spdf.dpdf[m] = (x>MINMIX) ? DProb2Short(x) : DLOGZERO;
          break;
       case TIEDHS:
-         se->spdf.tpdf[m] = (x>MINMIX) ? x : 0.0;
+         sti->spdf.tpdf[m] = (x>MINMIX) ? x : 0.0;
          break;
       case PLAINHS:
       case SHAREDHS:
-         me=se->spdf.cpdf+m;
+         me=sti->spdf.cpdf+m;
          me->weight = (x>MINMIX) ? x : 0.0;
          break;
       }      
@@ -1162,7 +1305,7 @@ void RestMixWeights(int state, int s, St
 }
 
 /* RestMean: reestimate the given mean vector */
-void RestMean(Vector mean, int vSize)
+void RestMean(Vector mean, const int vSize)
 {
    int k;
    MuAcc *ma;
@@ -1182,8 +1325,8 @@ void RestMean(Vector mean, int vSize)
 
 /* RestCoVar: reestimate the given covariance and return FALSE
               if any diagonal component == 0.0 */
-Boolean RestCoVar(MixPDF *mp, int vSize, Vector minV,
-                  Vector oldMean, Vector newMean, Boolean shared)
+Boolean RestCoVar(MixPDF *mp, const int vSize, const Vector minV,
+                  Vector oldMean, Vector newMean, const Boolean shared)
 {
    int k,l;
    VaAcc *va;
@@ -1224,7 +1367,7 @@ Boolean RestCoVar(MixPDF *mp, int vSize,
 }
 
 /* RestStream: reestimate stream parameters */
-void RestStream(int state, int s, StreamElem *se, int vSize)
+void RestStream(const int state, const int s, StreamInfo *sti, int vSize)
 {
    int m,M;
    MixtureElem *me;
@@ -1236,13 +1379,14 @@ void RestStream(int state, int s, Stream
    if (trace&(T_WRE|T_MRE|T_VRE))
       printf("State %d, Stream %d\n",state,s);
    if (uFlags&UPMIXES)
-      RestMixWeights(state,s,se);
+      RestMixWeights(state,s,sti);
    if ((hsKind != DISCRETEHS)&&(hsKind != TIEDHS)){ /*wts only DI'ETE & TIED*/
-      M=se->nMix;
+      M=sti->nMix;
       for (m=1; m<=M; m++){
-         me = se->spdf.cpdf+m;
+         me = sti->spdf.cpdf+m;
          wght=me->weight;
          mp=me->mpdf;
+         if(hset.msdflag[s]) vSize = VectorSize(mp->mean);
          if (wght > MINMIX) {
             if (trace&(T_MRE|T_VRE) && M>1)
                printf("Mixture %d\n",m);
@@ -1250,7 +1394,7 @@ void RestStream(int state, int s, Stream
                RestMean(mp->mean,vSize);
             /* NB old mean left in ma->mu */
             if (uFlags&UPVARS){
-               shared = GetUse(mp->cov.var) > 1;
+               shared = (GetUse(mp->cov.var)>1) ? TRUE : FALSE;
                ma = (MuAcc *)GetHook(mp->mean);
                if ( !RestCoVar(mp,vSize,vFloor[s],ma->mu,mp->mean,shared)) {
                   if (M > 1) {
@@ -1266,18 +1410,18 @@ void RestStream(int state, int s, Stream
    if (hsKind == TIEDHS)
       M=hset.tmRecs[s].nMix;
    else
-      M=se->nMix;
+      M=sti->nMix;
    if (M>1){
       switch (hsKind){
       case DISCRETEHS:
-         FloorDProbs(se->spdf.dpdf,M,mixWeightFloor);
+         FloorDProbs(sti->spdf.dpdf,M,mixWeightFloor);
          break;
       case TIEDHS:
-         FloorTMMixes(se->spdf.tpdf,M,mixWeightFloor);
+         FloorTMMixes(sti->spdf.tpdf,M,mixWeightFloor);
          break;
       case PLAINHS:
       case SHAREDHS:
-         FloorMixes(se->spdf.cpdf+1,M,mixWeightFloor);
+         FloorMixes(sti->spdf.cpdf+1,M,mixWeightFloor);
          break;
       }     
    }
@@ -1288,20 +1432,83 @@ void UpdateTheModel(void)
 {
    int j,s;
    StateInfo *si;
-   StreamElem *se;
+   StreamElem *ste;
 
    if (uFlags&UPTRANS)
       RestTransP();
    if (uFlags&(UPMEANS|UPVARS|UPMIXES))
       for (j=2; j<nStates; j++) {
          si = hmm->svec[j].info;
-         for (s=1,se = si->pdf+1; s<=nStreams; s++,se++)
-            RestStream(j,s,se,hset.swidth[s]);
+         for (s=1,ste = si->pdf+1; s<=nStreams; s++,ste++)
+            RestStream(j,s,ste->info,hset.swidth[s]);
       }
    if (uFlags&UPVARS)
       FixAllGConsts(&hset);
 }
 
+/* SaveDuration: save duration distribution */ 
+void SaveDuration(void) 
+{ 
+   int i; 
+   double mean, var; 
+   char base[MAXSTRLEN],buf[MAXSTRLEN];
+   FILE *fp;
+   LabId hmmId;
+   
+   /* Get HMM name */
+   BaseOf(hmmfn,base);
+   hmmId = GetLabId(base,FALSE);
+   
+   if ((fp=fopen(durFN,"w")) == NULL)
+      HError(2260,"SaveDuration: Can not open duration model file %s.\n", durFN);
+
+   /* ---- Output duration model ---- */
+   /* output model definition */
+   fprintf(fp,"~o\n");
+   fprintf(fp,"<STREAMINFO> %d", nStates-2);
+   for (i=1; i<=nStates-2; i++)
+      fprintf(fp," 1");
+   fprintf(fp,"\n<MSDINFO> %d", nStates-2);
+   for (i=1; i<=nStates-2; i++)
+      fprintf(fp," 0");
+   fprintf(fp,"\n<VECSIZE> %d <NULLD><DIAGC><%s>\n",nStates-2,ParmKind2Str(hset.pkind,buf));
+   fprintf(fp,"~h \"%s\"\n",hmmId->name);
+   fprintf(fp,"<BEGINHMM>\n<NUMSTATES> 3\n<STATE> 2\n");
+               
+   /* output mean & variance */
+   for (i=2; i<nStates; i++) {
+      fprintf(fp,"<STREAM> %d\n", i-1);
+      
+      /* mean */
+      if (durOcc[i-1]<=LSMALL) mean = 0;
+      else mean = L2F(durSum[i-1]-durOcc[i-1]);
+      fprintf(fp,"<MEAN> 1\n");
+      fprintf(fp," %e\n",mean);
+      
+      /* variance */
+      if ( (durOcc[i-1]<=LSMALL) 
+           ||(durSqr[i-1]-durOcc[i-1]<2*(durSum[i-1]-durOcc[i-1])) )
+         var = minVar;
+      else {
+         var = LSub(durSqr[i-1]-durOcc[i-1], 2*(durSum[i-1]-durOcc[i-1]));
+         var = L2F(var);
+      }
+      /* floor variance */
+      if (var<minVar) var = minVar;
+      fprintf(fp,"<VARIANCE> 1\n");
+      fprintf(fp," %e\n",var);
+   }
+
+   /* output dummy transP */
+   fprintf(fp,"<TRANSP> 3\n");
+   fprintf(fp,"0 1 0\n0 0 1\n0 0 0\n");
+   fprintf(fp,"<ENDHMM>\n");
+
+   fclose(fp);
+   
+   return;
+}
+
 /* ------------------------- Top Level Control ----------------------- */
 
 
@@ -1310,13 +1517,17 @@ void ReEstimateModel(void)
 {
    LogFloat segProb,oldP,newP,delta;
    LogDouble ap,bp;
-   int converged,iteration,seg;
+   int i,converged,iteration,seg;
 
    iteration=0; 
    oldP=LZERO;
    do {        /*main re-est loop*/   
       ZeroAccs(&hset, uFlags); newP = 0.0; ++iteration;
       nTokUsed = 0;
+      if (calcDuration)
+         for (i=1;i<DVectorSize(durOcc);i++) 
+            durOcc[i] = durSum[i] = durSqr[i] = LZERO;
+      
       for (seg=1;seg<=nSeg;seg++) {
          T=SegLength(segStore,seg);
          SetOutP(seg);
@@ -1346,6 +1557,32 @@ void ReEstimateModel(void)
          fflush(stdout);
       }
    } while ((iteration < maxIter) && !converged);
+   
+   if (calcDuration) {
+      nTokUsed = 0;
+      for (i=1;i<DVectorSize(durOcc);i++) 
+         durOcc[i] = durSum[i] = durSqr[i] = LZERO;
+      
+      for (seg=1;seg<=nSeg;seg++) {
+         T=SegLength(segStore,seg);
+         SetOutP(seg);
+         if ((ap=SetAlpha(seg)) > LSMALL){
+            bp = SetBeta(seg);
+            if (trace & T_LGP)
+               printf("%d.  Pa = %e, Pb = %e, Diff = %e\n",seg,ap,bp,ap-bp);
+            segProb = (ap + bp) / 2.0;  /* reduce numeric error */
+            ++nTokUsed;
+            UpDurCounts(segProb,seg);
+         } else
+            if (trace&T_TOP) 
+               printf("Example %d skipped\n",seg);
+      }
+      if (nTokUsed==0)
+         HError(2226,"ReEstimateModel: No Usable Training Examples");
+
+      SaveDuration();
+   }
+   
    if (trace&T_TOP) {
       if (converged)
          printf("Estimation converged at iteration %d\n",iteration);
diff -pbBEwurNa --ignore-matching-lines='.*vc_id.*' HTK-3.4.1/HTKTools/HResults.c HTS-2.2_for_HTK-3.4.1/HTKTools/HResults.c
--- HTK-3.4.1/HTKTools/HResults.c	2009-03-13 03:53:43.000000000 +0900
+++ HTS-2.2_for_HTK-3.4.1/HTKTools/HResults.c	2011-06-16 13:18:30.000000000 +0900
@@ -19,8 +19,53 @@
 /*    File: HResults.c: gather statistics on results           */
 /* ----------------------------------------------------------- */
 
+/*  *** THIS IS A MODIFIED VERSION OF HTK ***                        */
+/* ----------------------------------------------------------------- */
+/*           The HMM-Based Speech Synthesis System (HTS)             */
+/*           developed by HTS Working Group                          */
+/*           http://hts.sp.nitech.ac.jp/                             */
+/* ----------------------------------------------------------------- */
+/*                                                                   */
+/*  Copyright (c) 2001-2011  Nagoya Institute of Technology          */
+/*                           Department of Computer Science          */
+/*                                                                   */
+/*                2001-2008  Tokyo Institute of Technology           */
+/*                           Interdisciplinary Graduate School of    */
+/*                           Science and Engineering                 */
+/*                                                                   */
+/* All rights reserved.                                              */
+/*                                                                   */
+/* Redistribution and use in source and binary forms, with or        */
+/* without modification, are permitted provided that the following   */
+/* conditions are met:                                               */
+/*                                                                   */
+/* - Redistributions of source code must retain the above copyright  */
+/*   notice, this list of conditions and the following disclaimer.   */
+/* - Redistributions in binary form must reproduce the above         */
+/*   copyright notice, this list of conditions and the following     */
+/*   disclaimer in the documentation and/or other materials provided */
+/*   with the distribution.                                          */
+/* - Neither the name of the HTS working group nor the names of its  */
+/*   contributors may be used to endorse or promote products derived */
+/*   from this software without specific prior written permission.   */
+/*                                                                   */
+/* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND            */
+/* CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,       */
+/* INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF          */
+/* MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE          */
+/* DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS */
+/* BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,          */
+/* EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED   */
+/* TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,     */
+/* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON */
+/* ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,   */
+/* OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY    */
+/* OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE           */
+/* POSSIBILITY OF SUCH DAMAGE.                                       */
+/* ----------------------------------------------------------------- */
+
 char *hresults_version = "!HVER!HResults:   3.4.1 [CUED 12/03/09]";
-char *hresults_vc_id = "$Id: HResults.c,v 1.1.1.1 2006/10/11 09:55:01 jal58 Exp $";
+char *hresults_vc_id = "$Id: HResults.c,v 1.13 2011/06/16 04:18:30 uratec Exp $";
 
 #include "HShell.h"
 #include "HMem.h"
@@ -89,7 +134,7 @@ MemHeap tempHeap;                     /*
 MemHeap permHeap;                     /* Stores global stats */
 
 static char *recfn;                   /* rec file name (test) */
-static char labfn[255];               /* lab file name (reference) */
+static char labfn[MAXSTRLEN];         /* lab file name (reference) */
 
 static int rlev=0;                    /* Label level to be used as ref */
 static int tlev=0;                    /* Label level to be scored */
@@ -97,7 +142,7 @@ static LabList *ref,*test;            /*
 static Transcription *ans;            /* the full set of answers */
 
 static char * refid=NULL;             /* identifiers for reference material */
-static char recid[5][255];            /* upto 5 identifiers for */
+static char recid[5][MAXSTRLEN];      /* upto 5 identifiers for */
 static int recidUsed = 0;             /* number of test identifiers set */
 
 
@@ -132,6 +177,7 @@ void SetConfParms(void)
 
 void ReportUsage(void)
 {
+   printf("\nModified for HTS\n");
    printf("\nUSAGE: HResults [options] labelList recFiles...\n\n");
    printf(" Option                                       Default\n\n");
    printf(" -a s    Redefine string level label          SENT\n");
@@ -151,7 +197,7 @@ void ReportUsage(void)
    printf(" -u f    False alarm time units (hours)       1.0\n");
    printf(" -w      Enable word spotting analysis        off\n");
    printf(" -z s    Redefine null class name to s        ???\n");
-   PrintStdOpts("GILX");
+   PrintStdOpts("GILXS");
    printf("\n\n");
 }
 
@@ -326,6 +372,12 @@ int main(int argc, char *argv[])
    else 
       printf("No transcriptions found\n");
 
+   ResetLabel();
+   ResetWave();
+   ResetMath();
+   ResetMem();
+   ResetShell();
+   
    Exit(0);
    return (0);          /* never reached -- make compiler happy */
 }
@@ -360,7 +412,7 @@ void NormaliseName(LabList *ll,int lev)
    LLink l;
    Equiv *p;
    int i,n,len;
-   char buf[256],*ptr;
+   char buf[MAXSTRLEN],*ptr;
 
    n=CountAuxLabs(ll,lev);
    for (p=eqlist; p!=NULL; p=p->next) {
@@ -442,9 +494,9 @@ static Boolean SpRMatch(char *s,char *p,
    else if ((numstars==0 && minplen!=slen) || minplen>slen)
       match=FALSE;
    else if (*p == '*') {
-      match=(SpRMatch(s+1,p,spkr,slen-1,minplen,numstars) ||
+      match=((SpRMatch(s+1,p,spkr,slen-1,minplen,numstars) ||
              SpRMatch(s,p+1,spkr,slen,minplen,numstars-1) ||
-             SpRMatch(s+1,p+1,spkr,slen-1,minplen,numstars-1));
+              SpRMatch(s+1,p+1,spkr,slen-1,minplen,numstars-1)) ? TRUE:FALSE);
    }
    else if (*p == '%') {
       *spkr=*s,spkr[1]=0;
@@ -535,7 +587,7 @@ Boolean RecordFileStats(CellPtr p)
    del += p->del;    ins += p->ins; /* update global counters */
    sub += p->sub;    hits += p->hit;
    nsyms += p->hit+p->del+p->sub; ++nphr;
-   error = !(p->del==0 && p->ins==0 && p->sub==0);
+   error = (!(p->del==0 && p->ins==0 && p->sub==0)) ? TRUE:FALSE;
    if (!error) ++phrcor;
    if (spkrMask != NULL){       /* update speaker if reqd */
       s = GetSpeaker();
@@ -608,10 +660,10 @@ void PClip(char * instr, char *outstr, i
 /* PrintHeader: print title information */
 void PrintHeader(void)
 {
-   char datestr[255];
+   char datestr[MAXSTRLEN];
    time_t clock = time(NULL);
    int i;
-   char buf[100];
+   char buf[MAXSTRLEN];
 
    strcpy(datestr,ctime(&clock));
    datestr[strlen(datestr)-1] = '\0';
@@ -658,7 +710,7 @@ void PrintFileStats(char *fn, int h, int
    float accuracy,correct;
    float psub,pdel,pins,perr;
    int nc;
-   char buf[100];
+   char buf[MAXSTRLEN];
    
    if (!headerPrinted) {
       PrintHeader();
@@ -888,9 +940,9 @@ void DoCompare(void)
 
    for (i=1;i<=nTest;i++){
       gridi = grid[i]; gridi1 = grid[i-1];
-      testnull = (lTest[i] == nulClass);
+      testnull = (lTest[i] == nulClass) ? TRUE:FALSE;
       for (j=1;j<=nRef;j++) {
-         refnull = (lRef[j] == nulClass);
+         refnull = (lRef[j] == nulClass) ? TRUE:FALSE;
          if (refnull && testnull) { /* both ref and test are null */
             h = gridi1[j].score; 
             d = gridi1[j-1].score; 
@@ -958,9 +1010,9 @@ void DoCompareNIST(void)
 
    for (i=1;i<=nTest;i++){
       gridi = grid[i]; gridi1 = grid[i-1];
-      testnull = (lTest[i] == nulClass);
+      testnull = (lTest[i] == nulClass) ? TRUE:FALSE;
       for (j=1;j<=nRef;j++) {
-         refnull = (lRef[j] == nulClass);
+         refnull = (lRef[j] == nulClass) ? TRUE:FALSE;
          if (refnull && testnull) { /* both ref and test are null */
             h = gridi1[j].score; 
             d = gridi1[j-1].score; 
@@ -1143,7 +1195,7 @@ void ReadHMMList(char *fn)
       ReadWordFromLine(&source,buf);
       labid=GetLabId(buf,TRUE);
       names[i]=labid;
-      labid->aux = (Ptr)i;
+      labid->aux = (Ptr)((long) i);
    }
    CloseSource(&source);
 }
@@ -1152,7 +1204,7 @@ int Index(LabId labid)
 {
    int i;
    
-   i=(int)labid->aux;
+   i=(int)((long)labid->aux);
    if (wSpot && i==0) return(0);
    if (i<1 || i>nLabs || names[i]!=labid)
       HError(3331,"Index: Label %s not in list[%d of %d]",
@@ -1299,7 +1351,7 @@ void MatchRecFiles(void)
 {
    Cell bp,*p;
    int i,n,err,berr,best;
-   char buf[255];
+   char buf[MAXSTRLEN];
    
    n=(ans->numLists>maxNDepth)?maxNDepth:ans->numLists;
    best=0;berr=INT_MAX;
@@ -1746,7 +1798,6 @@ void OutputStats(void)
       PrintGlobalStats();
 }
 
-/* ------------------------------------------------------------ */
+/* ----------------------------------------------------------- */
 /*                      END:  HResults.c                        */
-/* ------------------------------------------------------------ */
-
+/* ----------------------------------------------------------- */
diff -pbBEwurNa --ignore-matching-lines='.*vc_id.*' HTK-3.4.1/HTKTools/HSGen.c HTS-2.2_for_HTK-3.4.1/HTKTools/HSGen.c
--- HTK-3.4.1/HTKTools/HSGen.c	2009-03-13 03:53:52.000000000 +0900
+++ HTS-2.2_for_HTK-3.4.1/HTKTools/HSGen.c	2011-06-16 13:18:30.000000000 +0900
@@ -19,8 +19,53 @@
 /*    File: HSGen: Generate Sentences from a Lattice           */
 /* ----------------------------------------------------------- */
 
+/*  *** THIS IS A MODIFIED VERSION OF HTK ***                        */
+/* ----------------------------------------------------------------- */
+/*           The HMM-Based Speech Synthesis System (HTS)             */
+/*           developed by HTS Working Group                          */
+/*           http://hts.sp.nitech.ac.jp/                             */
+/* ----------------------------------------------------------------- */
+/*                                                                   */
+/*  Copyright (c) 2001-2011  Nagoya Institute of Technology          */
+/*                           Department of Computer Science          */
+/*                                                                   */
+/*                2001-2008  Tokyo Institute of Technology           */
+/*                           Interdisciplinary Graduate School of    */
+/*                           Science and Engineering                 */
+/*                                                                   */
+/* All rights reserved.                                              */
+/*                                                                   */
+/* Redistribution and use in source and binary forms, with or        */
+/* without modification, are permitted provided that the following   */
+/* conditions are met:                                               */
+/*                                                                   */
+/* - Redistributions of source code must retain the above copyright  */
+/*   notice, this list of conditions and the following disclaimer.   */
+/* - Redistributions in binary form must reproduce the above         */
+/*   copyright notice, this list of conditions and the following     */
+/*   disclaimer in the documentation and/or other materials provided */
+/*   with the distribution.                                          */
+/* - Neither the name of the HTS working group nor the names of its  */
+/*   contributors may be used to endorse or promote products derived */
+/*   from this software without specific prior written permission.   */
+/*                                                                   */
+/* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND            */
+/* CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,       */
+/* INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF          */
+/* MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE          */
+/* DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS */
+/* BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,          */
+/* EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED   */
+/* TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,     */
+/* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON */
+/* ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,   */
+/* OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY    */
+/* OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE           */
+/* POSSIBILITY OF SUCH DAMAGE.                                       */
+/* ----------------------------------------------------------------- */
+
 char *hsgen_version = "!HVER!HSGen:   3.4.1 [CUED 12/03/09]";
-char *hsgen_vc_id = "$Id: HSGen.c,v 1.1.1.1 2006/10/11 09:55:01 jal58 Exp $";
+char *hsgen_vc_id = "$Id: HSGen.c,v 1.8 2011/06/16 04:18:30 uratec Exp $";
 
 #include "HShell.h"
 #include "HMem.h"
@@ -71,6 +116,7 @@ void SetConfParms(void)
 
 void ReportUsage(void)
 {
+   printf("\nModified for HTS\n");
    printf("\nUSAGE: HSGen [options] latticeFile dictFile\n\n");
    printf(" Option                                       Default\n\n");
    printf(" -l      Include line numbers                 off\n");
@@ -129,6 +175,23 @@ int main(int argc, char *argv[])
       HError(3419, "dictionary file name expected");
    dfn = GetStrArg(); 
    GenSentences(lfn,dfn);
+   
+   if(InitShell(argc,argv,hsgen_version,hsgen_vc_id)<SUCCESS)
+      HError(3400,"HSGen: InitShell failed");
+
+   ResetNet();
+   ResetDict();
+   ResetParm();
+   ResetModel();
+   ResetVQ();
+   ResetAudio();
+   ResetWave();
+   ResetSigP();
+   ResetMath();
+   ResetLabel();
+   ResetMem();
+   ResetShell();
+   
    Exit(0);
    return (0);          /* never reached -- make compiler happy */
 }
@@ -305,7 +368,6 @@ void  GenSentences(char * latfn, char * 
    }
 }
 
-/* ------------------------------------------------------------ */
+/* ----------------------------------------------------------- */
 /*                      END:  HSGen.c                           */
-/* ------------------------------------------------------------ */
-
+/* ----------------------------------------------------------- */
diff -pbBEwurNa --ignore-matching-lines='.*vc_id.*' HTK-3.4.1/HTKTools/HSLab.c HTS-2.2_for_HTK-3.4.1/HTKTools/HSLab.c
--- HTK-3.4.1/HTKTools/HSLab.c	2009-03-13 03:53:59.000000000 +0900
+++ HTS-2.2_for_HTK-3.4.1/HTKTools/HSLab.c	2011-06-16 13:18:30.000000000 +0900
@@ -32,8 +32,53 @@
 /*         File: HSLab.c:   The Speech Label Editor            */
 /* ----------------------------------------------------------- */
 
+/*  *** THIS IS A MODIFIED VERSION OF HTK ***                        */
+/* ----------------------------------------------------------------- */
+/*           The HMM-Based Speech Synthesis System (HTS)             */
+/*           developed by HTS Working Group                          */
+/*           http://hts.sp.nitech.ac.jp/                             */
+/* ----------------------------------------------------------------- */
+/*                                                                   */
+/*  Copyright (c) 2001-2011  Nagoya Institute of Technology          */
+/*                           Department of Computer Science          */
+/*                                                                   */
+/*                2001-2008  Tokyo Institute of Technology           */
+/*                           Interdisciplinary Graduate School of    */
+/*                           Science and Engineering                 */
+/*                                                                   */
+/* All rights reserved.                                              */
+/*                                                                   */
+/* Redistribution and use in source and binary forms, with or        */
+/* without modification, are permitted provided that the following   */
+/* conditions are met:                                               */
+/*                                                                   */
+/* - Redistributions of source code must retain the above copyright  */
+/*   notice, this list of conditions and the following disclaimer.   */
+/* - Redistributions in binary form must reproduce the above         */
+/*   copyright notice, this list of conditions and the following     */
+/*   disclaimer in the documentation and/or other materials provided */
+/*   with the distribution.                                          */
+/* - Neither the name of the HTS working group nor the names of its  */
+/*   contributors may be used to endorse or promote products derived */
+/*   from this software without specific prior written permission.   */
+/*                                                                   */
+/* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND            */
+/* CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,       */
+/* INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF          */
+/* MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE          */
+/* DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS */
+/* BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,          */
+/* EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED   */
+/* TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,     */
+/* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON */
+/* ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,   */
+/* OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY    */
+/* OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE           */
+/* POSSIBILITY OF SUCH DAMAGE.                                       */
+/* ----------------------------------------------------------------- */
+
 char *hslab_version = "!HVER!HSLab:   3.4.1 [CUED 12/03/09]";
-char *hslab_vc_id = "$Id: HSLab.c,v 1.1.1.1 2006/10/11 09:55:01 jal58 Exp $";
+char *hslab_vc_id = "$Id: HSLab.c,v 1.10 2011/06/16 04:18:30 uratec Exp $";
 
 /* 
    --------------------------------------------------------------
@@ -229,6 +274,7 @@ static char spcl_str[SLEN] = "Command"; 
 
 void ReportUsage(void)
 {
+   printf("\nModified for HTS\n");
    printf("\nUSAGE: HSLab [options] waveformFile\n\n");
    printf(" Option                                       Default\n\n");
    printf(" -a      auto-increment global label          off\n");
@@ -322,6 +368,15 @@ int main(int argc, char *argv[])
       strcpy(spfn, ospfn=GetStrArg());
    Initialise(); LoadFiles(); hRedrawWindow(); 
    DecodeCommands(); TermHGraf();
+   
+   ResetGraf();
+   ResetAudio();
+   ResetLabel();
+   ResetWave();
+   ResetMath();
+   ResetMem();
+   ResetShell();
+   
    Exit(0);
    return (0);          /* never reached -- make compiler happy */
 }
@@ -381,7 +436,7 @@ Wave Record(long *nSamples, HTime *sampP
    Boolean done;
    HEventRec hev;
    BarType tm, vu;
-   char sbuf[256];
+   char sbuf[MAXSTRLEN];
    long i, chunk;
    long nWaiting, nToRecord;
    SampleType *buf, smin, smax;
@@ -617,7 +672,7 @@ void PlotGStripes(int x, int y, int widt
 void PrintMsg(RectWin *win, char *msg)
 {
    int sx, sy, pos, pad = 4;
-   char sbuf[256];
+   char sbuf[MAXSTRLEN];
 
    HSetXMode(GCOPY);
    DrawRectWin(win);
@@ -745,7 +800,7 @@ LLink GetLabT(LabList *ll, long t)
 /* Intersect: returns TRUE if the regions (a,b):{a<=b} and (a1,b1):{a1<=b1} intersect */
 Boolean Intersect(long a, long b, long a1, long b1)
 {
-   return !(((a1 < a) && (b1 < a)) || ((a1 >= b) && (b1 >= b)));
+   return ( (!(((a1 < a) && (b1 < a)) || ((a1 >= b) && (b1 >= b))) ) ? TRUE:FALSE);
 }
 
 
@@ -949,7 +1004,7 @@ void InvertRegion(RectWin *win, int a, i
    HSetXMode(GINVERT);
    HFillRectangle(a, win->y+1, b, win->y + win->h - 1);
    HSetXMode(GCOPY);
-   regnMarked = !regnMarked;
+   regnMarked = (!regnMarked) ? TRUE:FALSE;
    if (wasOn) WPtrOn();
 }
 
@@ -1111,7 +1166,7 @@ void MouseMark(int x, int *markA, int *m
    mmWPos = -1;
    do {
       hev = HGetEvent(TRUE, Drag);
-      done = (hev.event==HMOUSEUP);
+      done = (hev.event==HMOUSEUP) ? TRUE:FALSE;
    } while (!done);
    if (mmWPos >=0) PlotWaveWinPtr(mmWPos);
    *markB = hev.x;
@@ -1200,7 +1255,7 @@ Boolean GetString(RectWin *win, char *st
       }
    } while (!done);
    DrawRectWin(win);
-   return (!hitesc) && (strlen(str) > minlen); 
+   return ( ((!hitesc) && (strlen(str) > minlen) ) ? TRUE:FALSE); 
 }
 
 /* FileExists: check to see if a file exsists */
@@ -1303,7 +1358,7 @@ void RecordOp(OpType op, LLink p)
 void UndoOp(void)
 {
    Label p;
-   char sbuf[256];
+   char sbuf[MAXSTRLEN];
 
    if (undoEmpty)
       return;
@@ -1583,9 +1638,9 @@ void DoPlay(void)
 /* DoSpecial: execute external command if environment variable set */ 
 void DoSpecial(void)
 {
-   char strbuf[256];
-   char cmdstr[256];
-   char cmdfn[256];
+   char strbuf[MAXSTRLEN];
+   char cmdstr[MAXSTRLEN];
+   char cmdfn[MAXSTRLEN];
    
    if (CommandSet(HSLabCmd, cmdstr)){
       strcpy(cmdfn, PathOf(spfn, strbuf));
@@ -1683,7 +1738,7 @@ void IncLabStr(void)
       }
    if (isNum){    
       for (q=p+1; *q != '\0'; q++)
-         if (!isdigit((int) *q)) break;
+         if (!isdigit(*q)) break;
       num = atoi(p) +1; sprintf(nbuf,"%d",num);
       *p = '\0'; 
       strcpy(labstr,sbuf); strcat(labstr,nbuf); strcat(labstr,q);
@@ -1921,7 +1976,7 @@ void DoSave(void)
 /* CheckForSave: check to see if changes have to be saved */
 void CheckForSave(void)
 {
-   char sbuf[255], *prompt = "Save label file (Y/N): ", c;
+   char sbuf[MAXSTRLEN], *prompt = "Save label file (Y/N): ", c;
    Boolean is0;
 
    if (!labsModified)
@@ -1929,7 +1984,7 @@ void CheckForSave(void)
    do { 
       strcpy(sbuf, prompt);
       do 
-         is0 = !GetString(&io_Win, sbuf, strlen(prompt), MAX_LAB_LEN); 
+         is0 = (!GetString(&io_Win, sbuf, strlen(prompt), MAX_LAB_LEN)) ? TRUE:FALSE; 
       while (is0);
       c = sbuf[strlen(prompt)];
    } while ((c!='y') && (c!='Y') && (c!='n') && (c!='N'));
@@ -1982,7 +2037,7 @@ void CreateButtons(void)
    int btn_area_x;
    int btn_area_y;
    int x, y, w;
-   char cmdstr[256];
+   char cmdstr[MAXSTRLEN];
    HButton *btn;
 
    btn_area_w = (int) (WIDTH *BTN_AREA_W);
diff -pbBEwurNa --ignore-matching-lines='.*vc_id.*' HTK-3.4.1/HTKTools/HSMMAlign.c HTS-2.2_for_HTK-3.4.1/HTKTools/HSMMAlign.c
--- HTK-3.4.1/HTKTools/HSMMAlign.c	1970-01-01 09:00:00.000000000 +0900
+++ HTS-2.2_for_HTK-3.4.1/HTKTools/HSMMAlign.c	2011-06-16 13:27:17.000000000 +0900
@@ -0,0 +1,1089 @@
+/* ----------------------------------------------------------------- */
+/*           The HMM-Based Speech Synthesis System (HTS)             */
+/*           developed by HTS Working Group                          */
+/*           http://hts.sp.nitech.ac.jp/                             */
+/* ----------------------------------------------------------------- */
+/*                                                                   */
+/*  Copyright (c) 2008-2011  Nagoya Institute of Technology          */
+/*                           Department of Computer Science          */
+/*                                                                   */
+/* All rights reserved.                                              */
+/*                                                                   */
+/* Redistribution and use in source and binary forms, with or        */
+/* without modification, are permitted provided that the following   */
+/* conditions are met:                                               */
+/*                                                                   */
+/* - Redistributions of source code must retain the above copyright  */
+/*   notice, this list of conditions and the following disclaimer.   */
+/* - Redistributions in binary form must reproduce the above         */
+/*   copyright notice, this list of conditions and the following     */
+/*   disclaimer in the documentation and/or other materials provided */
+/*   with the distribution.                                          */
+/* - Neither the name of the HTS working group nor the names of its  */
+/*   contributors may be used to endorse or promote products derived */
+/*   from this software without specific prior written permission.   */
+/*                                                                   */
+/* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND            */
+/* CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,       */
+/* INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF          */
+/* MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE          */
+/* DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS */
+/* BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,          */
+/* EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED   */
+/* TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,     */
+/* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON */
+/* ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,   */
+/* OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY    */
+/* OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE           */
+/* POSSIBILITY OF SUCH DAMAGE.                                       */
+/* ----------------------------------------------------------------- */
+
+char *hsmmalign_version = "!HVER!HSMMAlign: 2.2 [NIT 07/07/11]";
+char *hsmmalign_vc_id = "$Id: HSMMAlign.c,v 1.7 2011/06/16 04:27:17 uratec Exp $";
+
+/*
+  This program is used for forced alignment of HSMMs.
+*/
+
+#include "HShell.h"
+#include "HMem.h"
+#include "HMath.h"
+#include "HAudio.h"
+#include "HWave.h"
+#include "HParm.h"
+#include "HLabel.h"
+#include "HModel.h"
+#include "HTrain.h"
+#include "HUtil.h"
+#include "HAdapt.h"
+#include "HFB.h"
+
+/* Trace Flags */
+#define T_TOP 0001              /* Top level tracing */
+
+/* Models */
+static char *hmmDir = NULL;     /* directory to look for hmm def files */
+static char *durDir = NULL;     /* directory to look for duration model def files */
+static char *hmmExt = NULL;     /* hmm def file extension */
+static char *durExt = NULL;     /* duration model def file extension */
+static HMMSet hset;             /* HMM set */
+static HMMSet dset;             /* Duration model set */
+
+/* Utterance */
+static UttInfo *utt;            /* utterance information storage */
+
+/* Transforms */
+static XFInfo xfInfo_hmm;
+static XFInfo xfInfo_dur;
+
+/* Label */
+static char *outLabDir = NULL;  /* directory to save label files */
+static char *outLabExt = "lab"; /* output label file extension */
+static char *inLabDir = NULL;   /* label (transcription) file directory */
+static char *inLabExt = "lab";  /* input label file extension */
+
+/* Global settings */
+static int trace = 0;           /* Trace level */
+static FileFormat dff = UNDEFF; /* data file format */
+static FileFormat lff = UNDEFF; /* label file format */
+static ConfParam *cParm[MAXGLOBS];      /* configuration parameters */
+static int nParm = 0;           /* total num params */
+Boolean keepOccm = FALSE;
+
+/* Search settings */
+static LogDouble pruneInit = NOPRUNE;   /* pruning threshold initially */
+static LogDouble pruneInc = 0.0;        /* pruning threshold increment */
+static LogDouble pruneLim = NOPRUNE;    /* pruning threshold limit */
+static double hsmmDurWeight = 1.0;      /* duration weight of state duration model */
+static Boolean stateAlign = FALSE;      /* align flag */
+static Boolean pruneFrame = FALSE;      /* prune hypo by using time information of label */
+
+/* Statistics */
+static Boolean stats = FALSE;   /* enable statistics reports */
+static char *statFN = NULL;     /* stats file, if any */
+
+/* Stack */
+static MemHeap hmmStack;
+static MemHeap durStack;
+static MemHeap uttStack;
+static MemHeap tmpStack;
+
+/* Hypo */
+typedef struct _HSMMAlignHypo {
+   int frame_index;             /* index of frame (1 ... T) */
+   double prob;                 /* total probability (feature + duration) */
+   int duration;                /* state duration */
+   struct _HSMMAlignHypo *up;
+   struct _HSMMAlignHypo *down;
+   struct _HSMMAlignHypo *right;
+   struct _HSMMAlignHypo *left;
+   struct _HSMMAlignHypo *next;
+   struct _HSMMAlignHypo *prev;
+   struct _HSMMAlignState *state;
+} HSMMAlignHypo;
+
+/* HSMMAlignHypoInitialize: initialize hypo */
+void HSMMAlignHypoInitialize(HSMMAlignHypo * h)
+{
+   h->frame_index = -1;
+   h->prob = LZERO;
+   h->up = NULL;
+   h->down = NULL;
+   h->right = NULL;
+   h->left = NULL;
+   h->next = NULL;
+   h->prev = NULL;
+   h->state = NULL;
+}
+
+/* Hypo sequence */
+typedef struct _HSMMAlignHypoSequence {
+   HSMMAlignHypo *head;
+   HSMMAlignHypo *tail;
+} HSMMAlignHypoSequence;
+
+/* HSMMAlignHypoSequenceInitialize: initialize hypo sequence */
+void HSMMAlignHypoSequenceInitialize(HSMMAlignHypoSequence * hs)
+{
+   hs->head = NULL;
+   hs->tail = NULL;
+}
+
+/* HSMMAlignHypoSequenceInitialize: create and add hypo */
+void HSMMAlignHypoSequencePush(HSMMAlignHypoSequence * hs)
+{
+   HSMMAlignHypo *tmp;
+
+   tmp = New(&tmpStack, sizeof(HSMMAlignHypo));
+   HSMMAlignHypoInitialize(tmp);
+
+   if (hs->head == NULL && hs->tail == NULL) {
+      hs->head = hs->tail = tmp;
+   } else {
+      hs->tail->next = tmp;
+      tmp->prev = hs->tail;
+      hs->tail = tmp;
+   }
+}
+
+/* HSMMAlignHypoSequenceClear: free hypo sequence */
+void HSMMAlignHypoSequenceClear(HSMMAlignHypoSequence * hs)
+{
+   HSMMAlignHypo *tmp1;
+   HSMMAlignHypo *tmp2;
+
+   if (hs->head != NULL && hs->tail != NULL) {
+      tmp1 = hs->tail;
+      while (tmp1 != NULL) {
+         tmp2 = tmp1->prev;
+         Dispose(&tmpStack, tmp1);
+         tmp1 = tmp2;
+      }
+   }
+   HSMMAlignHypoSequenceInitialize(hs);
+}
+
+/* State */
+typedef struct _HSMMAlignState {
+   char *name;                  /* name of model */
+   StateInfo *info;             /* state information */
+   int model_index;             /* index of model (0 ... M) */
+   int state_index;             /* index of state (2 ...) */
+   MixPDF *dur_pdf;             /* PDF of state duration */
+   long start;                  /* start frame for prune */
+   long end;                    /* end frame for prune */
+   struct _HSMMAlignState *next;
+   struct _HSMMAlignState *prev;
+   struct _HSMMAlignHypo *hypo_from_left;
+} HSMMAlignState;
+
+/* HSMMAlignStateInitialize: initialize state */
+void HSMMAlignStateInitialize(HSMMAlignState * s, char *name, StateInfo * info, int model_index, int state_index, MixPDF * dur_pdf, long start, long end)
+{
+   if (s == NULL || name == NULL || info == NULL || model_index < 0 || state_index < 2)
+      HError(2300, "HSMMAlign: faild");
+   s->name = name;
+   s->info = info;
+   s->model_index = model_index;
+   s->state_index = state_index;
+   s->dur_pdf = dur_pdf;
+   s->start = start;
+   s->end = end;
+   s->next = NULL;
+   s->prev = NULL;
+   s->hypo_from_left = NULL;
+}
+
+/* State sequence */
+typedef struct _HSMMAlignStateSequecne {
+   HSMMAlignState *head;
+   HSMMAlignState *tail;
+} HSMMAlignStateSequence;
+
+/* HSMMAlignStateSequenceInitialize: initialize state sequence */
+void HSMMAlignStateSequenceInitialize(HSMMAlignStateSequence * ss)
+{
+   ss->head = NULL;
+   ss->tail = NULL;
+}
+
+/* HSMMAlignStateSequencePush: create and add state */
+void HSMMAlignStateSequencePush(HSMMAlignStateSequence * ss, char *name, StateInfo * info, int model_index, int state_index, MixPDF * dur_pdf, long start, long end)
+{
+   HSMMAlignState *new_state;
+
+   new_state = New(&tmpStack, sizeof(HSMMAlignState));
+   HSMMAlignStateInitialize(new_state, name, info, model_index, state_index, dur_pdf, start, end);
+
+   if (ss->head == NULL && ss->tail == NULL) {
+      ss->head = ss->tail = new_state;
+   } else {
+      ss->tail->next = new_state;
+      new_state->prev = ss->tail;
+      ss->tail = new_state;
+   }
+}
+
+/* HSMMAlignStateSequenceClear: free state sequence */
+void HSMMAlignStateSequenceClear(HSMMAlignStateSequence * ss)
+{
+   HSMMAlignState *tmp1;
+   HSMMAlignState *tmp2;
+
+   if (ss->head != NULL && ss->tail != NULL) {
+      tmp1 = ss->tail;
+      while (tmp1 != NULL) {
+         tmp2 = tmp1->prev;
+         Dispose(&tmpStack, tmp1);
+         tmp1 = tmp2;
+      }
+   }
+   HSMMAlignStateSequenceInitialize(ss);
+}
+
+/* QuickSort: subfunction for sorting DVector */
+void QuickSort(DVector v, int s, int e)
+{
+   int i = s;
+   int j = e;
+   double tmp;
+   double x = v[(int) ((s + e) / 2)];
+
+   while (1) {
+      while (v[i] < x)
+         i++;
+      while (v[j] > x)
+         j--;
+      if (i >= j)
+         break;
+      tmp = v[i];
+      v[i] = v[j];
+      v[j] = tmp;
+      i++;
+      j--;
+   }
+   if (s + 1 < i)
+      QuickSort(v, s, i - 1);
+   if (j + 1 < e)
+      QuickSort(v, j + 1, e);
+}
+
+/* SortDVector: sort DVector */
+void SortDVector(DVector v)
+{
+   QuickSort(v, 1, DVectorSize(v));
+}
+
+/* ------------------ Process Command Line ------------------------- */
+
+/* SetConfParms: set conf parms relevant to HSMMAlign */
+void SetConfParms(void)
+{
+   int i;
+   char buf[MAXSTRLEN];
+
+   nParm = GetConfig("HSMMALIGN", TRUE, cParm, MAXGLOBS);
+   if (nParm > 0) {
+      if (GetConfInt(cParm, nParm, "TRACE", &i))
+         trace = i;
+      if (GetConfStr(cParm, nParm, "INXFORMMASK", buf))
+         xfInfo_hmm.inSpkrPat = CopyString(&tmpStack, buf);
+      if (GetConfStr(cParm, nParm, "PAXFORMMASK", buf))
+         xfInfo_hmm.paSpkrPat = CopyString(&tmpStack, buf);
+      if (GetConfStr(cParm, nParm, "DURINXFORMMASK", buf))
+         xfInfo_dur.inSpkrPat = CopyString(&durStack, buf);
+      if (GetConfStr(cParm, nParm, "DURPAXFORMMASK", buf))
+         xfInfo_dur.paSpkrPat = CopyString(&durStack, buf);
+   }
+}
+
+void ReportUsage(void)
+{
+   printf("\nUSAGE: HSMMAlign [options] hmmList durList dataFiles...\n\n");
+   printf(" Option                                                    Default\n\n");
+   printf(" -a      Use an input linear transform for HMMs            off\n");
+   printf(" -b      Use an input linear transform for dur models      off\n");
+   printf(" -c      Prune by time information of label                off\n");
+   printf(" -d s    Dir to find hmm definitions                       current\n");
+   printf(" -f      Output full state alignment                       off\n");
+   printf(" -h s [s] Set speaker name pattern to s,                   *.%%%%%%\n");
+   printf("         optionally set parent patterns                    \n");
+   printf(" -n s    Dir to find duration model definitions            current\n");
+   printf(" -m dir  Set output label dir                              current\n");
+   printf(" -r ext  Output label file extension                       lab\n");
+   printf(" -s s    print statistics to file s                        off\n");
+   printf(" -t i    Set pruning threshold                             off\n");
+   printf(" -w f    Duration weight                                   1.0\n");
+   printf(" -x s    Extension for hmm files                           none\n");
+   printf(" -y s    Extension for duration model files                none\n");
+   PrintStdOpts("AECDFGHIJLNSTWXY");
+   printf("\n\n");
+   Exit(0);
+}
+
+int main(int argc, char *argv[])
+{
+   char *datafn = NULL;
+   char *s;
+   int *maxMixInS;
+   int i;
+   LogDouble beam;
+
+   void Initialise();
+   Boolean HSMMAlign(UttInfo * utt, char *datafn, char *outLabDir, int beam, int *maxMixInS);
+   void StatReport(HMMSet * hset);
+
+   if (InitShell(argc, argv, hsmmalign_version, hsmmalign_vc_id) < SUCCESS)
+      HError(2300, "HSMMAlign: InitShell failed");
+   InitMem();
+   InitMath();
+   InitWave();
+   InitLabel();
+   InitModel();
+   if (InitParm() < SUCCESS)
+      HError(2300, "HSMMAlign: InitParm failed");
+   InitUtil();
+   InitFB();
+   InitAdapt(&xfInfo_hmm, &xfInfo_dur);
+
+   if (NumArgs() == 0)
+      ReportUsage();
+
+   CreateHeap(&hmmStack, "HmmStore", MSTAK, 1, 1.0, 50000, 500000);
+   CreateHeap(&durStack, "DurStore", MSTAK, 1, 1.0, 50000, 500000);
+   CreateHeap(&uttStack, "uttStore", MSTAK, 1, 0.5, 100, 1000);
+   CreateHeap(&tmpStack, "tmpStore", MSTAK, 1, 1.0, 50000, 500000);
+   SetConfParms();
+   CreateHMMSet(&hset, &hmmStack, TRUE);
+   CreateHMMSet(&dset, &durStack, TRUE);
+
+   utt = (UttInfo *) New(&uttStack, sizeof(UttInfo));
+
+   while (NextArg() == SWITCHARG) {
+      s = GetSwtArg();
+      if (strlen(s) != 1)
+         HError(2319, "HSMMAlign: Bad switch %s; must be single letter", s);
+      switch (s[0]) {
+      case 'a':
+         xfInfo_hmm.useInXForm = TRUE;
+         break;
+      case 'b':
+         xfInfo_dur.useInXForm = TRUE;
+         break;
+      case 'c':
+         pruneFrame = TRUE;
+         break;
+      case 'd':
+         if (NextArg() != STRINGARG)
+            HError(2319, "HSMMAlign: HMM definition directory expected");
+         hmmDir = GetStrArg();
+         break;
+      case 'f':
+         stateAlign = TRUE;
+         break;
+      case 'h':
+         if (NextArg() != STRINGARG)
+            HError(1, "HSMMAlign: Speaker name pattern expected");
+         xfInfo_hmm.inSpkrPat = xfInfo_dur.inSpkrPat = GetStrArg();
+         if (NextArg() == STRINGARG)
+            xfInfo_hmm.paSpkrPat = xfInfo_dur.paSpkrPat = GetStrArg();
+         if (NextArg() != SWITCHARG)
+            HError(2319, "HSMMAlign: Cannot have -h as the last option");
+         break;
+      case 'm':
+         if (NextArg() != STRINGARG)
+            HError(2319, "HSMMAlign: Output label file directory expected");
+         outLabDir = GetStrArg();
+         break;
+      case 'n':
+         if (NextArg() != STRINGARG)
+            HError(2319, "HSMMAlign: Duration model definition directory expected");
+         durDir = GetStrArg();
+         break;
+      case 'r':
+         if (NextArg() != STRINGARG)
+            HError(2319, "HSMMAlign: Output label file extension expected");
+         outLabExt = GetStrArg();
+         break;
+      case 's':
+         if (NextArg() != STRINGARG)
+            HError(2319, "HSMMAlign: Stats file name expected");
+         stats = TRUE;
+         statFN = GetStrArg();
+         break;
+      case 't':
+         pruneInit = GetChkedFlt(0.0, 1.0E20, s);
+         if (NextArg() == FLOATARG || NextArg() == INTARG) {
+            pruneInc = GetChkedFlt(0.0, 1.0E20, s);
+            pruneLim = GetChkedFlt(0.0, 1.0E20, s);
+         } else {
+            pruneInc = 0.0;
+            pruneLim = pruneInit;
+         }
+         break;
+      case 'w':
+         hsmmDurWeight = GetChkedFlt(0.0, 100000.0, s);
+         break;
+      case 'x':
+         if (NextArg() != STRINGARG)
+            HError(2319, "HSMMAlign: HMM file extension expected");
+         hmmExt = GetStrArg();
+         break;
+      case 'y':
+         if (NextArg() != STRINGARG)
+            HError(2319, "HSMMAlign: Duration model file extension expected");
+         durExt = GetStrArg();
+         break;
+      case 'E':
+         if (NextArg() != STRINGARG)
+            HError(2319, "HSMMAlign: Parent transform directory expected");
+         xfInfo_hmm.usePaXForm = TRUE;
+         xfInfo_hmm.paXFormDir = GetStrArg();
+         if (NextArg() == STRINGARG)
+            xfInfo_hmm.paXFormExt = GetStrArg();
+         if (NextArg() != SWITCHARG)
+            HError(2319, "HSMMAlign: Cannot have -E as the last option");
+         break;
+      case 'F':
+         if (NextArg() != STRINGARG)
+            HError(2319, "HSMMAlign: Data File format expected");
+         if ((dff = Str2Format(GetStrArg())) == ALIEN)
+            HError(-2389, "HSMMAlign: Warning ALIEN Data file format set");
+         break;
+      case 'G':
+         if (NextArg() != STRINGARG)
+            HError(2319, "HSMMAlign: Label File format expected");
+         if ((lff = Str2Format(GetStrArg())) == ALIEN)
+            HError(-2389, "HSMMAlign: Warning ALIEN Label file format set");
+         break;
+      case 'H':
+         if (NextArg() != STRINGARG)
+            HError(2319, "HSMMAlign: HMM MMF file name expected");
+         AddMMF(&hset, GetStrArg());
+         break;
+      case 'I':
+         if (NextArg() != STRINGARG)
+            HError(2319, "HSMMAlign: MLF file name expected");
+         LoadMasterFile(GetStrArg());
+         break;
+      case 'J':
+         if (NextArg() != STRINGARG)
+            HError(2319, "HSMMAlign: Input transform directory expected");
+         AddInXFormDir(&hset, GetStrArg());
+         if (NextArg() == STRINGARG)
+            xfInfo_hmm.inXFormExt = GetStrArg();
+         if (NextArg() != SWITCHARG)
+            HError(2319, "HSMMAlign: Cannot have -J as the last option");
+         break;
+      case 'L':
+         if (NextArg() != STRINGARG)
+            HError(2319, "HSMMAlign: Label file directory expected");
+         inLabDir = GetStrArg();
+         break;
+      case 'N':
+         if (NextArg() != STRINGARG)
+            HError(2319, "HSMMAlign: Duration MMF file name expected");
+         AddMMF(&dset, GetStrArg());
+         break;
+      case 'T':
+         if (NextArg() != INTARG)
+            HError(2119, "HSMMAlign: Trace value expected");
+         trace = GetChkedInt(0, 0002, s);
+         break;
+      case 'W':
+         if (NextArg() != STRINGARG)
+            HError(2319, "HSMMAlign: Parent duration transform directory expected");
+         xfInfo_dur.usePaXForm = TRUE;
+         xfInfo_dur.paXFormDir = GetStrArg();
+         if (NextArg() == STRINGARG)
+            xfInfo_dur.paXFormExt = GetStrArg();
+         if (NextArg() != SWITCHARG)
+            HError(2319, "HSMMAlign: Cannot have -W as the last option");
+         break;
+      case 'X':
+         if (NextArg() != STRINGARG)
+            HError(2319, "HSMMAlign: Input label file extension expected");
+         inLabExt = GetStrArg();
+         break;
+      case 'Y':
+         if (NextArg() != STRINGARG)
+            HError(2319, "HSMMAlign: Input duration transform directory expected");
+         AddInXFormDir(&dset, GetStrArg());
+         if (NextArg() == STRINGARG) {
+            if (xfInfo_dur.inXFormExt == NULL)
+               xfInfo_dur.inXFormExt = GetStrArg();
+            else
+               HError(2319, "HSMMAlign: Only one input duration transform extension may be specified");
+         }
+         if (NextArg() != SWITCHARG)
+            HError(2319, "HSMMAlign: Cannot have -Y as the last option");
+         break;
+      default:
+         HError(2319, "HSMMAlign: Unknown switch %s", s);
+      }
+   }
+   if (NextArg() != STRINGARG)
+      HError(2319, "HSMMAlign: File name of vocabulary list expected");
+
+   Initialise();
+   InitUttInfo(utt, FALSE);
+
+   /* generate parameter sequences */
+   maxMixInS = CreateIntVec(&tmpStack, hset.swidth[0]);
+   for (i = 1; i <= hset.swidth[0]; i++)
+      maxMixInS[i] = MaxMixInSetS(&hset, i);
+   do {
+      if (NextArg() != STRINGARG)
+         HError(2319, "HSMMAlign: Data file name expected");
+      datafn = GetStrArg();
+
+      if (UpdateSpkrStats(&hset, &xfInfo_hmm, datafn)) {
+         if (!xfInfo_hmm.useInXForm)
+            xfInfo_hmm.inXForm = NULL;
+      }
+      if (UpdateSpkrStats(&dset, &xfInfo_dur, datafn)) {
+         if (!xfInfo_dur.useInXForm)
+            xfInfo_dur.inXForm = NULL;
+         else
+            ResetDMMPreComps(&dset);
+      }
+
+      for (beam = pruneInit; beam <= pruneLim; beam += pruneInc) {
+         if (HSMMAlign(utt, datafn, outLabDir, (int) beam, maxMixInS) == TRUE)
+            break;
+         if (pruneInit == NOPRUNE || pruneInc <= 0.0)
+            break;
+      }
+   } while (NumArgs() > 0);
+
+   if (stats)
+      StatReport(&hset);
+
+   ResetHeap(&tmpStack);
+   Dispose(&uttStack, utt);
+   ResetHeap(&uttStack);
+   ResetHeap(&durStack);
+   ResetHeap(&hmmStack);
+
+   /* Reset modules */
+   ResetAdapt(&xfInfo_hmm, &xfInfo_dur);
+   ResetFB();
+   ResetUtil();
+   ResetParm();
+   ResetModel();
+   ResetLabel();
+   ResetWave();
+   ResetMath();
+   ResetMem();
+   ResetShell();
+
+   Exit(0);
+   return (0);
+}
+
+/* -------------------------- Initialization ----------------------- */
+
+void Initialise(void)
+{
+   /* load HMM mmf */
+   if (MakeHMMSet(&hset, GetStrArg()) < SUCCESS)
+      HError(9928, "HSMMAlign: MakeHMMSet failed");
+   if (LoadHMMSet(&hset, hmmDir, hmmExt) < SUCCESS)
+      HError(9928, "HSMMAlign: LoadHMMSet failed");
+   if (hset.hsKind == DISCRETEHS)
+      HError(9999, "HSMMAlign: Only continuous model is surpported");
+   ConvDiagC(&hset, TRUE);
+
+   /* load duration mmf */
+   if (MakeHMMSet(&dset, GetStrArg()) < SUCCESS)
+      HError(9928, "HSMMAlign: MakeHMMSet failed");
+   if (LoadHMMSet(&dset, durDir, durExt) < SUCCESS)
+      HError(9928, "HSMMAlign: LoadHMMSet failed");
+   if (hset.hsKind == DISCRETEHS)
+      HError(9999, "HSMMAlign: Only continuous duration model mmf is surpported");
+   ConvDiagC(&dset, TRUE);
+
+   /* setup EM-based parameter generation */
+   AttachAccs(&hset, &gstack, (UPDSet) 0);
+   ZeroAccs(&hset, (UPDSet) 0);
+
+   AttachAccs(&dset, &gstack, (UPDSet) 0);
+   ZeroAccs(&dset, (UPDSet) 0);
+
+   /* handle input xform */
+   xfInfo_hmm.inFullC = xfInfo_dur.inFullC = TRUE;
+}
+
+/* ---------------------------- Viterbi ---------------------------- */
+
+Boolean HSMMAlign(UttInfo * utt, char *datafn, char *outLabDir, int beam, int *maxMixInS)
+{
+   int i, j, l, t;
+   char ilabfn[MAXFNAMELEN];
+   char olabfn[MAXFNAMELEN];
+   char basefn[MAXFNAMELEN];
+   char namefn[MAXFNAMELEN];
+   FILE *fp;
+   char *name;
+   LLink llink;
+   MLink mlink_hset;
+   HLink hlink_hset;
+   MLink mlink_dset;
+   HLink hlink_dset;
+   MixPDF *pdf;
+   LogFloat p = LZERO;
+   LogFloat mixp, wt, x;
+   Boolean isPipe;
+
+   /* alignment */
+   HSMMAlignStateSequence sseq;
+   HSMMAlignState *prev_s = NULL;
+   HSMMAlignState *next_s = NULL;
+   HSMMAlignHypoSequence hseq;
+   HSMMAlignHypo *prev_h = NULL;
+   HSMMAlignHypo *next_h = NULL;
+   HSMMAlignHypo *initial_hypo = NULL;
+   HSMMAlignHypo *final_hypo = NULL;
+
+   /* pruning */
+   int q;
+   long *st = NULL, *en = NULL;
+   short *mindur = NULL;
+
+   DVector problist;
+   int size;
+   double threshold = 0.0;
+   Boolean threshold_flag = FALSE;
+
+   /* calculation */
+   StateInfo *si;
+   StreamElem *ste;
+   int s, S;
+   StreamInfo *sti;
+   Vector v;
+   int m, M;
+   MixtureElem *me;
+   MixPDF *mp;
+   LogFloat det;
+   Vector dur;
+
+   /* result */
+   HSMMAlignHypo *result_hypo = NULL;
+   HSMMAlignHypo *tmp1_hypo = NULL;
+   HSMMAlignHypo *tmp2_hypo = NULL;
+   IntVec framelist;
+   int total_nstate;
+   HSMMAlignState *tmp_state = NULL;
+   unsigned long tmp_ulong = 0;
+   Boolean ret = TRUE;
+
+   /* stats */
+   float tmp_f;
+   long tmp_l;
+
+   /* load utterance */
+   utt->twoDataFiles = FALSE;
+   utt->S = hset.swidth[0];
+   strcpy(ilabfn, datafn);
+   LoadLabs(utt, lff, ilabfn, inLabDir, inLabExt);
+   LoadData(&hset, utt, dff, datafn, NULL);
+   InitUttObservations(utt, &hset, datafn, maxMixInS);
+   BaseOf(datafn, basefn);
+
+   if (trace & T_TOP) {
+      printf(" Processing Data: %s ;", NameOf(datafn, namefn));
+      printf(" Label %s.%s\n", basefn, inLabExt);
+      fflush(stdout);
+   }
+
+   /* create state sequence */
+   HSMMAlignStateSequenceInitialize(&sseq);
+   total_nstate = 0;
+   for (llink = utt->tr->head->head, l = 0; llink != NULL; llink = llink->succ) {
+      if (llink->labid != NULL) {
+         name = llink->labid->name;
+         mlink_hset = FindMacroName(&hset, 'l', llink->labid);
+         hlink_hset = (HLink) mlink_hset->structure;
+         mlink_dset = FindMacroName(&dset, 'l', llink->labid);
+         hlink_dset = (HLink) mlink_dset->structure;
+         for (i = 2; i < hlink_hset->numStates; i++) {
+            pdf = hlink_dset->svec[2].info->pdf[i - 1].info->spdf.cpdf[1].mpdf;
+            HSMMAlignStateSequencePush(&sseq, name, hlink_hset->svec[i].info, l, i, pdf, 1, utt->T);
+            total_nstate++;
+         }
+         l++;
+      }
+   }
+
+   /* set alignment */
+   if (pruneFrame == TRUE) {
+      st = (long *) New(&tmpStack, utt->Q * sizeof(long));
+      en = (long *) New(&tmpStack, utt->Q * sizeof(long));
+      mindur = (short *) New(&tmpStack, utt->Q * sizeof(short));
+      st--;
+      en--;
+      mindur--;
+      for (llink = utt->tr->head->head, q = 1; llink != NULL; llink = llink->succ) {
+         if (llink->labid != NULL) {
+            st[q] = (long) llink->start * (1.0 / utt->tgtSampRate) + 1;
+            en[q] = (long) llink->end * (1.0 / utt->tgtSampRate);
+            if (en[q] > utt->T)
+               en[q] = utt->T;
+            mindur[q] = (short) total_nstate / utt->Q;
+            q++;
+         }
+      }
+      /* get time */
+      SetAlign(st, en, mindur, utt->Q, utt->T);
+      /* set time */
+      for (llink = utt->tr->head->head, tmp_state = sseq.head, q = 1; llink != NULL; llink = llink->succ) {
+         if (llink->labid != NULL) {
+            for (i = 0; i < total_nstate / utt->Q; i++) {
+               tmp_state->start = st[q];
+               tmp_state->end = en[q];
+               tmp_state = tmp_state->next;
+            }
+            q++;
+         }
+      }
+      mindur++;
+      en++;
+      st++;
+      Dispose(&tmpStack, mindur);
+      Dispose(&tmpStack, en);
+      Dispose(&tmpStack, st);
+   }
+
+   /* viterbi */
+   dur = CreateVector(&tmpStack, 1);
+   HSMMAlignHypoSequenceInitialize(&hseq);
+   for (t = 1; t <= utt->T; t++) {
+      if (t == 1) {
+         /* create */
+         HSMMAlignHypoSequencePush(&hseq);
+         next_h = hseq.tail;
+         next_s = sseq.head;
+         /* set */
+         next_h->frame_index = t;
+         next_h->state = next_s;
+         si = next_s->info;
+         ste = si->pdf + 1;
+         S = hset.swidth[0];
+         p = 0;
+         for (s = 1; s <= S; s++, ste++) {
+            sti = ste->info;
+            v = utt->o[t].fv[s];
+            M = sti->nMix;
+            me = sti->spdf.cpdf + 1;
+            x = LZERO;
+            for (m = 1; m <= M; m++, me++) {
+               mp = me->mpdf;
+               mixp = MOutP(ApplyCompFXForm(mp, v, xfInfo_hmm.inXForm, &det, t), mp);
+               mixp += det;
+               wt = MixLogWeight(&hset, me->weight);
+               x = LAdd(x, wt + mixp);
+            }
+            if (si->weights)
+               p += si->weights[s] * x;
+            else
+               p += x;
+         }
+         next_h->prob = p;
+         next_h->duration = 1;
+         next_s->hypo_from_left = next_h;
+         initial_hypo = next_h;
+         final_hypo = next_h;
+      } else {
+         /* transition */
+         prev_h = initial_hypo;
+         initial_hypo = NULL;
+         while (1) {
+            if (threshold_flag == FALSE || prev_h->prob >= threshold) {
+               /* go to next state */
+               prev_s = prev_h->state;
+               next_s = prev_s->next;
+               if (next_s != NULL) {
+                  dur[1] = (float) prev_h->duration;
+                  p = MOutP(ApplyCompFXForm(prev_s->dur_pdf, dur, xfInfo_dur.inXForm, &det, prev_h->duration), prev_s->dur_pdf);
+                  p += det;
+                  p = prev_h->prob + hsmmDurWeight * p;
+                  if (next_s->hypo_from_left != NULL && next_s->hypo_from_left->frame_index == t) {
+                     if (next_s->hypo_from_left->prob < p) {
+                        /* replace */
+                        next_h = next_s->hypo_from_left;
+                        next_h->prob = p;
+                        next_h->duration = 1;
+                        next_h->left = prev_h;
+                        prev_h->right = next_h;
+                     }
+                  } else if (next_s->start <= t && t <= next_s->end) {
+                     /* create */
+                     HSMMAlignHypoSequencePush(&hseq);
+                     next_h = hseq.tail;
+                     next_h->frame_index = t;
+                     next_h->state = next_s;
+                     next_h->prob = p;
+                     next_h->duration = 1;
+                     next_h->left = prev_h;
+                     prev_h->right = next_h;
+                     next_s->hypo_from_left = next_h;
+                     if (initial_hypo == NULL)
+                        initial_hypo = next_h;
+                  }
+               }
+               if (prev_s->start <= t && t <= prev_s->end) {
+                  /* stay current state */
+                  HSMMAlignHypoSequencePush(&hseq);
+                  next_h = hseq.tail;
+                  next_h->frame_index = t;
+                  next_h->state = prev_s;
+                  next_h->prob = prev_h->prob;
+                  next_h->duration = prev_h->duration + 1;
+                  next_h->up = prev_h;
+                  prev_h->down = next_h;
+                  if (initial_hypo == NULL)
+                     initial_hypo = next_h;
+               }
+            }
+            /* next hypo */
+            if (prev_h == final_hypo)
+               break;
+            prev_h = prev_h->next;
+         }
+         final_hypo = hseq.tail;
+         /* calc */
+         next_h = initial_hypo;
+         size = 0;
+         if (t == utt->T) {
+            p = LZERO;
+            result_hypo = NULL;
+         }
+         while (1) {
+            next_s = next_h->state;
+            si = next_s->info;
+            ste = si->pdf + 1;
+            S = hset.swidth[0];
+            p = 0;
+            for (s = 1; s <= S; s++, ste++) {
+               sti = ste->info;
+               v = utt->o[t].fv[s];
+               M = sti->nMix;
+               me = sti->spdf.cpdf + 1;
+               x = LZERO;
+               for (m = 1; m <= M; m++, me++) {
+                  mp = me->mpdf;
+                  mixp = MOutP(ApplyCompFXForm(mp, v, xfInfo_hmm.inXForm, &det, t), mp);
+                  mixp += det;
+                  wt = MixLogWeight(&hset, me->weight);
+                  x = LAdd(x, wt + mixp);
+               }
+               if (si->weights)
+                  p += si->weights[s] * x;
+               else
+                  p += x;
+            }
+            next_h->prob += p;
+            size++;
+            if (t == utt->T) {
+               if (next_s->next == NULL && (p < next_h->prob || result_hypo == NULL)) {
+                  p = next_h->prob;
+                  result_hypo = next_h;
+               }
+            }
+            /* next hypo */
+            if (next_h == final_hypo)
+               break;
+            next_h = next_h->next;
+         }
+         /* sort */
+         if (t != utt->T) {
+            if (beam > 0 && size > beam) {
+               problist = CreateDVector(&tmpStack, size);
+               next_h = initial_hypo;
+               for (i = 1;; i++) {
+                  problist[i] = next_h->prob;
+                  if (next_h == final_hypo)
+                     break;
+                  next_h = next_h->next;
+               }
+               SortDVector(problist);
+               threshold = problist[size - beam + 1];
+               FreeDVector(&tmpStack, problist);
+               threshold_flag = TRUE;
+            } else {
+               threshold_flag = FALSE;
+            }
+         }
+      }
+   }
+
+   /* save label file */
+   if (result_hypo == NULL) {
+      HError(-9999, "HSMMAlign: No tokens survived to final node of network at beam %d\n", beam);
+      ret = FALSE;
+   } else {
+      if (outLabDir != NULL)
+         sprintf(olabfn, "%s%c%s.%s", outLabDir, PATHCHAR, basefn, outLabExt);
+      else
+         sprintf(olabfn, "%s.%s", basefn, outLabExt);
+      if ((fp = FOpen(olabfn, NoOFilter, &isPipe)) == NULL)
+         HError(2611, "HSMMAlign: Cannot open label file %s", olabfn);
+
+      if (trace & T_TOP) {
+         printf(" Utterance prob per frame = %e\n", result_hypo->prob / utt->T);
+         fflush(stdout);
+      }
+
+      /* get state duration */
+      framelist = CreateIntVec(&tmpStack, total_nstate);
+      tmp1_hypo = result_hypo;
+      i = tmp1_hypo->frame_index;
+      j = total_nstate;
+      while (tmp1_hypo != NULL) {
+         if (tmp1_hypo->up != NULL)
+            tmp2_hypo = tmp1_hypo->up;
+         else
+            tmp2_hypo = tmp1_hypo->left;
+         if (tmp2_hypo == NULL || tmp1_hypo->state != tmp2_hypo->state) {
+            framelist[j--] = i - tmp1_hypo->frame_index + 1;
+            if (tmp2_hypo != NULL)
+               i = tmp2_hypo->frame_index;
+         }
+         tmp1_hypo = tmp2_hypo;
+      }
+
+      /* output */
+      if (stateAlign == TRUE) {
+         tmp_ulong = 0;
+         for (tmp_state = sseq.head, i = 1; tmp_state != NULL; tmp_state = tmp_state->next, i++) {
+            if (tmp_state->state_index == 2)
+               fprintf(fp, "%lu %lu %s[%d] %s\n", tmp_ulong, tmp_ulong + (unsigned long) (framelist[i] * utt->tgtSampRate), tmp_state->name, tmp_state->state_index, tmp_state->name);
+            else
+               fprintf(fp, "%lu %lu %s[%d]\n", tmp_ulong, tmp_ulong + (unsigned long) (framelist[i] * utt->tgtSampRate), tmp_state->name, tmp_state->state_index);
+            tmp_ulong += (unsigned long) (framelist[i] * utt->tgtSampRate);
+         }
+      } else {
+         j = 0;
+         tmp_ulong = 0;
+         for (tmp_state = sseq.head, i = 1; tmp_state != NULL; tmp_state = tmp_state->next, i++) {
+            j += framelist[i];
+            if (tmp_state->next == NULL || tmp_state->next->state_index <= tmp_state->state_index) {
+               fprintf(fp, "%lu %lu %s\n", tmp_ulong, tmp_ulong + (unsigned long) (j * utt->tgtSampRate), tmp_state->name);
+               tmp_ulong += (unsigned long) (j * utt->tgtSampRate);
+               j = 0;
+            }
+         }
+      }
+
+      /* store stats */
+      if (stats) {
+         j = 0;
+         for (llink = utt->tr->head->head; llink != NULL; llink = llink->succ) {
+            if (llink->labid != NULL) {
+               name = llink->labid->name;
+               mlink_hset = FindMacroName(&hset, 'l', llink->labid);
+               hlink_hset = (HLink) mlink_hset->structure;
+               tmp_l = (long) hlink_hset->hook;
+               hlink_hset->hook = (void *) (tmp_l + 1);
+               for (i = 2; i < hlink_hset->numStates; i++) {
+                  si = hlink_hset->svec[i].info;
+                  if (hset.numSharedStreams > 0) {
+                     memcpy(&tmp_f, &(si->hook), sizeof(float));
+                     tmp_f += (float) framelist[j];
+                     memcpy(&(si->hook), &tmp_f, sizeof(float));
+                  } else {
+                     tmp_f = ((WtAcc *) ((si->pdf + 1)->info->hook))->occ;
+                     ((WtAcc *) ((si->pdf + 1)->info->hook))->occ = tmp_f + (float) framelist[j];
+                  }
+                  j++;
+               }
+            }
+         }
+      }
+
+      FreeIntVec(&tmpStack, framelist);
+      FClose(fp, isPipe);
+   }
+
+   /* free hypo sequence */
+   HSMMAlignHypoSequenceClear(&hseq);
+
+   FreeVector(&tmpStack, dur);
+
+   /* free state sequence */
+   HSMMAlignStateSequenceClear(&sseq);
+
+   /* reset utterance */
+   ResetUttObservations(utt, &hset);
+
+   return ret;
+}
+
+/* PrintStats: for given hmm */
+void PrintStats(HMMSet * hset, FILE * f, int n, HLink hmm, long numEgs)
+{
+   char buf[MAXSTRLEN];
+   StateInfo *si;
+   int i, N;
+   float occ;
+
+   N = hmm->numStates;
+   ReWriteString(HMMPhysName(hset, hmm), buf, DBL_QUOTE);
+   fprintf(f, "%4d %14s %4ld ", n, buf, numEgs);
+   for (i = 2; i < N; i++) {
+      si = hmm->svec[i].info;
+      if (hset->numSharedStreams > 0)   /* if streams are shared, using wa->occ is not appropriate */
+         memcpy(&occ, &(si->hook), sizeof(float));
+      else
+         occ = ((WtAcc *) ((si->pdf + 1)->info->hook))->occ;
+      fprintf(f, " %10f", occ);
+   }
+   fprintf(f, "\n");
+}
+
+/* StatReport: print statistics report */
+void StatReport(HMMSet * hset)
+{
+   HMMScanState hss;
+   HLink hmm;
+   FILE *f;
+   int px;
+
+   if ((f = fopen(statFN, "w")) == NULL) {
+      HError(2311, "StatReport: Unable to open stats file %s", "hsmmalign.stats");
+      return;
+   }
+   NewHMMScan(hset, &hss);
+   px = 1;
+   do {
+      hmm = hss.hmm;
+      PrintStats(hset, f, px, hmm, (long) hmm->hook);
+      px++;
+   } while (GoNextHMM(&hss));
+   EndHMMScan(&hss);
+   fclose(f);
+}
+
+/* ----------------------------------------------------------- */
+/*                      END:  HSMMAlign.c                      */
+/* ----------------------------------------------------------- */
diff -pbBEwurNa --ignore-matching-lines='.*vc_id.*' HTK-3.4.1/HTKTools/HSmooth.c HTS-2.2_for_HTK-3.4.1/HTKTools/HSmooth.c
--- HTK-3.4.1/HTKTools/HSmooth.c	2009-03-13 03:54:08.000000000 +0900
+++ HTS-2.2_for_HTK-3.4.1/HTKTools/HSmooth.c	2011-06-16 13:18:30.000000000 +0900
@@ -19,8 +19,53 @@
 /* File: HSmooth.c: Perform Parameter Smoothing on a HMM Set   */
 /* ----------------------------------------------------------- */
 
+/*  *** THIS IS A MODIFIED VERSION OF HTK ***                        */
+/* ----------------------------------------------------------------- */
+/*           The HMM-Based Speech Synthesis System (HTS)             */
+/*           developed by HTS Working Group                          */
+/*           http://hts.sp.nitech.ac.jp/                             */
+/* ----------------------------------------------------------------- */
+/*                                                                   */
+/*  Copyright (c) 2001-2011  Nagoya Institute of Technology          */
+/*                           Department of Computer Science          */
+/*                                                                   */
+/*                2001-2008  Tokyo Institute of Technology           */
+/*                           Interdisciplinary Graduate School of    */
+/*                           Science and Engineering                 */
+/*                                                                   */
+/* All rights reserved.                                              */
+/*                                                                   */
+/* Redistribution and use in source and binary forms, with or        */
+/* without modification, are permitted provided that the following   */
+/* conditions are met:                                               */
+/*                                                                   */
+/* - Redistributions of source code must retain the above copyright  */
+/*   notice, this list of conditions and the following disclaimer.   */
+/* - Redistributions in binary form must reproduce the above         */
+/*   copyright notice, this list of conditions and the following     */
+/*   disclaimer in the documentation and/or other materials provided */
+/*   with the distribution.                                          */
+/* - Neither the name of the HTS working group nor the names of its  */
+/*   contributors may be used to endorse or promote products derived */
+/*   from this software without specific prior written permission.   */
+/*                                                                   */
+/* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND            */
+/* CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,       */
+/* INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF          */
+/* MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE          */
+/* DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS */
+/* BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,          */
+/* EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED   */
+/* TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,     */
+/* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON */
+/* ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,   */
+/* OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY    */
+/* OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE           */
+/* POSSIBILITY OF SUCH DAMAGE.                                       */
+/* ----------------------------------------------------------------- */
+
 char *hsmooth_version = "!HVER!HSmooth:   3.4.1 [CUED 12/03/09]";
-char *hsmooth_vc_id = "$Id: HSmooth.c,v 1.1.1.1 2006/10/11 09:55:01 jal58 Exp $";
+char *hsmooth_vc_id = "$Id: HSmooth.c,v 1.12 2011/06/16 04:18:30 uratec Exp $";
 
 
 #include "HShell.h"     /* HMM ToolKit Modules */
@@ -117,6 +162,7 @@ void SetConfParms(void)
 
 void ReportUsage(void)
 {
+   printf("\nModified for HTS\n");
    printf("\nUSAGE: HSmooth [options] hmmList AccFiles...\n\n");
    printf(" Option                                       Default\n\n");
    printf(" -b f    set convergence epsilon              0.0001\n");
@@ -261,6 +307,20 @@ int main(int argc, char *argv[])
    Interpolate();
    if (stats) StatReport();
    UpdateModels();
+   
+   ResetUtil();
+   ResetTrain();
+   ResetParm();
+   ResetModel();
+   ResetVQ();
+   ResetAudio();
+   ResetWave();
+   ResetSigP();
+   ResetMath();
+   ResetLabel();
+   ResetMem();
+   ResetShell();
+   
    Exit(0);
    return (0);          /* never reached -- make compiler happy */
 }
@@ -324,6 +384,7 @@ void MakeWtAccLists()
    WALink *w;
    StateElem *se;
    StreamElem *ste;
+   StreamInfo *sti;
    WtAcc *wa;
    
    NewHMMScan(&hset,&hss);
@@ -332,13 +393,14 @@ void MakeWtAccLists()
       hmm = hss.hmm;
       for (i=2,se = hmm->svec+2; i<hmm->numStates;i++,se++)
          for (s=1,ste = se->info->pdf+1; s<=nStreams; s++,ste++){
+            sti = ste->info;
             w = &(wtStore[ix][i][s]); n = 0;
             while (*w != NULL){
                ++n; w = &((*w)->next);
             }
-            nMix = (hset.hsKind==TIEDHS) ? hset.tmRecs[s].nMix : ste->nMix;
+            nMix = (hset.hsKind==TIEDHS) ? hset.tmRecs[s].nMix : sti->nMix;
             (*w) = CreateChWtAcc(&wtAccStack, nMix);
-            wa = (WtAcc *)ste->hook;
+            wa = (WtAcc *)sti->hook;
             CopyVector(wa->c,(*w)->c);
             (*w)->occ = wa->occ;
             wa->occ = 0;
@@ -364,7 +426,7 @@ void AttachWtAccLists()
       hmm = hss.hmm;
       for (i=2,se = hmm->svec+2; i<hmm->numStates;i++,se++)
          for (s=1,ste = se->info->pdf+1; s<=nStreams; s++,ste++){
-            ste->hook = wtStore[ix][i][s];
+            ste->info->hook = wtStore[ix][i][s];
             /* Note that this is known and tolerable memory leak */
          }
       ix++;
@@ -440,7 +502,7 @@ void Initialise(char *hmmListFn)
 /* ------------------- Statistics Reporting  -------------------- */
 
 /* PrintStats: for given hmm */
-void PrintStats(FILE *f, int n, HLink hmm, int numEgs)
+void PrintStats(FILE *f, int n, HLink hmm, long numEgs)
 {
    WtAcc *wa;
    char buf[MAXSTRLEN];
@@ -449,10 +511,10 @@ void PrintStats(FILE *f, int n, HLink hm
     
    N = hmm->numStates;
    ReWriteString(HMMPhysName(&hset,hmm),buf,DBL_QUOTE);
-   fprintf(f,"%4d %14s %4d ",n,buf,numEgs);
+   fprintf(f,"%4d %14s %4ld ",n,buf,numEgs);
    for (i=2;i<N;i++) {
       si = hmm->svec[i].info;
-      wa = (WtAcc *)((si->pdf+1)->hook);
+      wa = (WtAcc *)si->pdf[1].info->hook;
       fprintf(f," %10f",wa->occ);
    }
    fprintf(f,"\n");
@@ -474,7 +536,7 @@ void StatReport(void)
    px=1;
    do {
       hmm = hss.hmm;
-      PrintStats(f,px,hmm,(int)hmm->hook);
+      PrintStats(f,px,hmm,(long)hmm->hook);
       px++;
    } while (GoNextHMM(&hss));
    EndHMMScan(&hss);
@@ -504,7 +566,7 @@ void CreateMonoList(void)
    int i,j;
    Boolean found;
    LabId list[MAXMONOPHONES], id;
-   char buf[255];
+   char buf[MAXSTRLEN];
    MLink q;
 
    nPhones = 0;
@@ -541,7 +603,7 @@ int LoadASet(LabId x)
    HLink hmm;
    MLink q;
    LabId id;
-   char *aid,buf[255];
+   char *aid,buf[MAXSTRLEN];
    
    aSize = 0;
    for (i=0; i<MACHASHSIZE; i++)
@@ -613,7 +675,7 @@ void CalcWBar(Vector wb, int dBlk, int M
    
    ZeroVector(wb);
    for (i=1; i<=aSize; i++){
-      wa = (WALink)sSet[i]->hook;
+      wa = (WALink)sSet[i]->info->hook;
       occ += SumWtChain(wa,wb,dBlk,M);
    }
    if (occ==0.0)
@@ -624,14 +686,14 @@ void CalcWBar(Vector wb, int dBlk, int M
 
 /* CalcWCd: store context dependent weights in wc using all blocks
             of stream ste except the deleted block dBlk */
-void CalcWCd(Vector wc, int dBlk, StreamElem *ste, int M)
+void CalcWCd(Vector wc, int dBlk, StreamInfo *sti, int M)
 {
    WALink wa;
    float occ;
    int i;
    
    ZeroVector(wc);
-   wa = (WALink)ste->hook;
+   wa = (WALink)sti->hook;
    occ = SumWtChain(wa,wc,dBlk,M);
    if (occ==0.0)
       ZeroVector(wc);
@@ -640,12 +702,12 @@ void CalcWCd(Vector wc, int dBlk, Stream
 }
 
 /* SmoothWtAcc: change 1st WtAcc to l*wcd[0] + (1.0-l)*wbar[0] */
-void SmoothWtAcc(StreamElem *ste, float l, int M)
+void SmoothWtAcc(StreamInfo *sti, float l, int M)
 {
    int i;
    WALink wa;
    
-   wa = (WALink)ste->hook;
+   wa = (WALink)sti->hook;
    for (i=1; i<=M; i++)
       wa->c[i] = l*wcd[0][i] + (1.0-l)*wbar[0][i];
    wa->occ = 1.0;
@@ -676,13 +738,13 @@ float D(float l, WALink wa, int M)
 }
 
 /* LambdaOpt: perform binary chop optimisation */
-float LambdaOpt(StreamElem *ste, int M)
+float LambdaOpt(StreamInfo *sti, int M)
 {
    float l=0.0, r=1.0, m=0.5, Dm;
    WALink wa;
    int n;
 
-   wa = (WALink)ste->hook;
+   wa = (WALink)sti->hook;
    if (D(0.0,wa,M) <= 0.0) return 0.0;
    if (D(1.0,wa,M) >= 0.0) return 1.0;
    for (n = 1; n<=maxStep; n++) {
@@ -723,7 +785,7 @@ void Interpolate(void)
                M = hset.tmRecs[s].nMix;
                break;
             case DISCRETEHS:
-               M = sSet[1]->nMix;
+               M = sSet[1]->info->nMix;
                break;
             }
             CalcWBar(wbar[0],0,M);
@@ -731,11 +793,11 @@ void Interpolate(void)
                CalcWBar(wbar[b],b,M);
             for (j=1; j<=aSize; j++){
                ste = sSet[j];
-               CalcWCd(wcd[0],0,ste,M);
+               CalcWCd(wcd[0],0,ste->info,M);
                for (b=1; b<=nBlk; b++)
-                  CalcWCd(wcd[b],b,ste,M);
-               l = LambdaOpt(ste,M);
-               SmoothWtAcc(ste,l,M);
+                  CalcWCd(wcd[b],b,ste->info,M);
+               l = LambdaOpt(ste->info,M);
+               SmoothWtAcc(ste->info,l,M);
                if (trace&T_INT)
                   printf("   Model %s lambda = %f\n",HMMPhysName(&hset,aSet[j]),l);
             }
@@ -836,6 +898,7 @@ void UpdateWeights(HLink hmm)
    WALink wa;
    StateElem *se;
    StreamElem *ste;
+   StreamInfo *sti;
    MLink q;
 
    q=FindMacroStruct(&hset,'h',hmm);
@@ -844,14 +907,15 @@ void UpdateWeights(HLink hmm)
    for (i=2; i<N; i++,se++){
       ste = se->info->pdf+1;
       for (s=1;s<=nStreams; s++,ste++){
-         wa = (WALink)ste->hook;
+         sti = ste->info;
+         wa = (WALink)sti->hook;
          if (wa != NULL) {
             switch(hsKind){
             case TIEDHS:
                M = hset.tmRecs[s].nMix;
                break;
             case DISCRETEHS:
-               M = ste->nMix;
+               M = sti->nMix;
                break;
             }
             occi = wa->occ;
@@ -865,26 +929,26 @@ void UpdateWeights(HLink hmm)
                   }
                   switch (hsKind){
                   case TIEDHS:
-                     ste->spdf.tpdf[m] = (x>MINMIX) ? x : 0;
+                     sti->spdf.tpdf[m] = (x>MINMIX) ? x : 0;
                      break;
                   case DISCRETEHS:
-                     ste->spdf.dpdf[m] = (x>MINMIX) ? DProb2Short(x) :DLOGZERO;
+                     sti->spdf.dpdf[m] = (x>MINMIX) ? DProb2Short(x) :DLOGZERO;
                      break;
                   }
                }
                if (mixWeightFloor>0.0){
                   switch (hsKind){
                   case DISCRETEHS:
-                     FloorDProbs(ste->spdf.dpdf,M,mixWeightFloor);
+                     FloorDProbs(sti->spdf.dpdf,M,mixWeightFloor);
                      break;
                   case TIEDHS:
-                     FloorTMMixes(ste->spdf.tpdf,M,mixWeightFloor);
+                     FloorTMMixes(sti->spdf.tpdf,M,mixWeightFloor);
                      break;
                   }
                }
             }else
                HError(-2427,"UpdateWeights: Model [%s]: no use of mixtures in %d.%d",q->id->name,i,s);
-            ste->hook = NULL;
+            sti->hook = NULL;
          }
       }
    }
@@ -946,7 +1010,7 @@ void UpdateTMVars(void)
             occim = va->occ;
             mixFloored = FALSE;
             if (occim > 0.0){
-               shared=(GetUse(cov.var)>1 || ma==NULL || ma->occ<=0.0);
+               shared=((GetUse(cov.var)>1 || ma==NULL || ma->occ<=0.0) ? TRUE:FALSE);
                if ((mpdf->ckind==DIAGC)||(mpdf->ckind==INVDIAGC))
                   for (k=1; k<=vSize; k++){
                      muDiffk=(shared)?0.0:ma->mu[k]/ma->occ;
@@ -997,7 +1061,7 @@ void ResetHeaps(void)
    new files have newExt if set */
 void UpdateModels(void)
 {
-   int n;
+   long n;
    HLink hmm;
    HMMScanState hss;
    
@@ -1017,9 +1081,9 @@ void UpdateModels(void)
    NewHMMScan(&hset,&hss);
    do {
       hmm = hss.hmm;   
-      n = (int)hmm->hook;
+      n = (long)hmm->hook;
       if (n<minEgs && !(trace&T_OPT))
-         HError(-2428,"%s copied: only %d egs\n",HMMPhysName(&hset,hmm),n);
+         HError(-2428,"%s copied: only %ld egs\n",HMMPhysName(&hset,hmm),n);
       if (n>=minEgs) {
          if (uFlags & UPTRANS)
             UpdateTrans(hmm);
@@ -1028,10 +1092,10 @@ void UpdateModels(void)
       }
       if (trace&T_OPT) {
          if (n<minEgs)
-            printf("Model %s copied: only %d examples\n",
+            printf("Model %s copied: only %ld examples\n",
                    HMMPhysName(&hset,hmm),n);
          else
-            printf("Model %s updated with %d examples\n",
+            printf("Model %s updated with %ld examples\n",
                    HMMPhysName(&hset,hmm),n);
          fflush(stdout);
       }
diff -pbBEwurNa --ignore-matching-lines='.*vc_id.*' HTK-3.4.1/HTKTools/HVite.c HTS-2.2_for_HTK-3.4.1/HTKTools/HVite.c
--- HTK-3.4.1/HTKTools/HVite.c	2009-03-13 03:54:19.000000000 +0900
+++ HTS-2.2_for_HTK-3.4.1/HTKTools/HVite.c	2011-06-16 13:18:30.000000000 +0900
@@ -32,8 +32,53 @@
 /*      File: HVite.c: recognise or align file or audio        */
 /* ----------------------------------------------------------- */
 
+/*  *** THIS IS A MODIFIED VERSION OF HTK ***                        */
+/* ----------------------------------------------------------------- */
+/*           The HMM-Based Speech Synthesis System (HTS)             */
+/*           developed by HTS Working Group                          */
+/*           http://hts.sp.nitech.ac.jp/                             */
+/* ----------------------------------------------------------------- */
+/*                                                                   */
+/*  Copyright (c) 2001-2011  Nagoya Institute of Technology          */
+/*                           Department of Computer Science          */
+/*                                                                   */
+/*                2001-2008  Tokyo Institute of Technology           */
+/*                           Interdisciplinary Graduate School of    */
+/*                           Science and Engineering                 */
+/*                                                                   */
+/* All rights reserved.                                              */
+/*                                                                   */
+/* Redistribution and use in source and binary forms, with or        */
+/* without modification, are permitted provided that the following   */
+/* conditions are met:                                               */
+/*                                                                   */
+/* - Redistributions of source code must retain the above copyright  */
+/*   notice, this list of conditions and the following disclaimer.   */
+/* - Redistributions in binary form must reproduce the above         */
+/*   copyright notice, this list of conditions and the following     */
+/*   disclaimer in the documentation and/or other materials provided */
+/*   with the distribution.                                          */
+/* - Neither the name of the HTS working group nor the names of its  */
+/*   contributors may be used to endorse or promote products derived */
+/*   from this software without specific prior written permission.   */
+/*                                                                   */
+/* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND            */
+/* CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,       */
+/* INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF          */
+/* MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE          */
+/* DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS */
+/* BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,          */
+/* EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED   */
+/* TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,     */
+/* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON */
+/* ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,   */
+/* OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY    */
+/* OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE           */
+/* POSSIBILITY OF SUCH DAMAGE.                                       */
+/* ----------------------------------------------------------------- */
+
 char *hvite_version = "!HVER!HVite:   3.4.1 [CUED 12/03/09]";
-char *hvite_vc_id = "$Id: HVite.c,v 1.1.1.1 2006/10/11 09:55:02 jal58 Exp $";
+char *hvite_vc_id = "$Id: HVite.c,v 1.20 2011/06/16 04:18:30 uratec Exp $";
 
 #include "HShell.h"
 #include "HMem.h"
@@ -63,6 +108,7 @@ char *hvite_vc_id = "$Id: HVite.c,v 1.1.
 #define T_MMU 00020      /* Memory usage after each utterance */
 
 static int trace = 0;
+Boolean keepOccm = FALSE;        /* keep mixture-level occ prob */
 
 /* -------------------------- Global Variables etc ---------------------- */
 
@@ -117,6 +163,7 @@ static int maxActive = 0;         /* max
 
 /* Global variables */
 static Observation obs;           /* current observation */
+static Boolean eSep;              /* stream width information */
 static HMMSet hset;               /* the HMM set */
 static Vocab vocab;               /* the dictionary */
 static Lattice *wdNet;            /* the word level recognition network */
@@ -175,6 +222,7 @@ void SetConfParms(void)
 
 void ReportUsage(void)
 {
+   printf("\nModified for HTS\n");
    printf("\nUSAGE: HVite [options] VocabFile HMMList DataFiles...\n\n");
    printf(" Option                                       Default\n\n");
    printf(" -a      align from label files               off\n");
@@ -230,7 +278,7 @@ int main(int argc, char *argv[])
    InitDict();
    InitNet();   InitRec();
    InitUtil(); 
-   InitAdapt(&xfInfo); InitMap();
+   InitAdapt(&xfInfo,NULL); InitMap();
 
    if (!InfoPrinted() && NumArgs() == 0)
       ReportUsage();
@@ -270,14 +318,14 @@ int main(int argc, char *argv[])
             HError(3214,"HCopy: Cannot write to MLF"); */
          SaveToMasterfile(GetStrArg());
          break;
-      case 'k':
-	 xfInfo.useInXForm = TRUE;
-	 break;
       case 'j':
          if (NextArg()!=INTARG)
             HError(3219,"HVite: No. of files per online adaptation step expected");
          update = GetChkedInt(1,256,s);
          break;
+      case 'k':
+	 xfInfo.useInXForm = TRUE;
+	 break;
       case 'l':
          if (NextArg()!=STRINGARG)
             HError(3219,"HVite: Label file directory expected");
@@ -483,6 +531,24 @@ int main(int argc, char *argv[])
    UpdateSpkrStats(&hset,&xfInfo, NULL); 
    ResetHeap(&regHeap);
    ResetHeap(&modelHeap);
+   
+   ResetMap();
+   ResetAdapt(&xfInfo,NULL);
+   ResetUtil();
+   ResetRec();
+   ResetNet();
+   ResetDict();
+   ResetParm();
+   ResetModel();
+   ResetVQ();
+   ResetAudio();
+   ResetWave();
+   ResetSigP();
+   ResetMath();
+   ResetLabel();
+   ResetMem();
+   ResetShell();
+   
    Exit(0);
    return (0);          /* never reached -- make compiler happy */
 }
@@ -492,7 +558,6 @@ int main(int argc, char *argv[])
 /* Initialise: set up global data structures */
 void Initialise(void)
 {
-   Boolean eSep;
    int s;
 
    /* Load hmms, convert to inverse DiagC */
@@ -505,7 +570,7 @@ void Initialise(void)
    /* Create observation and storage for input buffer */
    SetStreamWidths(hset.pkind,hset.vecSize,hset.swidth,&eSep);
    obs=MakeObservation(&gstack,hset.swidth,hset.pkind,
-                       hset.hsKind==DISCRETEHS,eSep);
+                       ((hset.hsKind==DISCRETEHS) ? TRUE:FALSE),eSep);
 
    /* sort out masks just in case using adaptation */
    if (xfInfo.inSpkrPat == NULL) xfInfo.inSpkrPat = xfInfo.outSpkrPat; 
@@ -514,18 +579,19 @@ void Initialise(void)
    if (xfInfo.useOutXForm || (update>0)) {
       CreateHeap(&regHeap,   "regClassStore",  MSTAK, 1, 0.5, 1000, 8000 );
       /* This initialises things - temporary hack - THINK!! */
-      CreateAdaptXForm(&hset, "tmp");
+      CheckAdaptSetUp(&hset,&xfInfo);
+      CreateAdaptXForm(&hset,&xfInfo,"tmp");
       /* initialise structures for the f-b frame-state alignment pass */
       utt = (UttInfo *) New(&regHeap, sizeof(UttInfo));
       fbInfo = (FBInfo *) New(&regHeap, sizeof(FBInfo));
+      fbInfo->xfinfo_hmm = &xfInfo;
       /* initialise a recogniser for frame/state alignment purposes */
       alignpsi=InitPSetInfo(&hset);
       alignvri=InitVRecInfo(alignpsi,1,TRUE,FALSE);
       SetPruningLevels(alignvri,0,genBeam,-LZERO,0.0,tmBeam);
       InitUttInfo(utt, FALSE);
-      InitialiseForBack(fbInfo, &regHeap, &hset,
-                        (UPDSet) (UPXFORM), genBeam*2.0, genBeam*2.0, 
-                        genBeam*4.0+1.0, 10.0);
+      InitialiseForBack(fbInfo, &regHeap, &hset, (UPDSet) (UPXFORM), NULL, (UPDSet) 0, 
+                        genBeam*2.0, genBeam*2.0, genBeam*4.0+1.0, 10.0, FALSE, FALSE);
       utt->twoDataFiles = FALSE;
       utt->S = hset.swidth[0]; 
       AttachPreComps(&hset,hset.hmem);
@@ -581,7 +647,7 @@ int DoOnlineAdaptation(Lattice *lat, Par
    BufferInfo pbinfo;
    Lattice *alignLat, *wordNet;
    Network *alignNet;
-   int i;
+   int t;
 
    GetBufferInfo(pbuf,&pbinfo);
    trans=TranscriptionFromLattice(&netHeap,lat,1);
@@ -591,10 +657,13 @@ int DoOnlineAdaptation(Lattice *lat, Par
 
    StartRecognition(alignvri,alignNet,0.0,0.0,0.0);     
 
-   /* do forced alignment */
-   for (i = 0; i < nFrames; i++) {
-      ReadAsTable(pbuf, i, &obs);
-      ProcessObservation(alignvri,&obs,-1,xfInfo.inXForm);
+   /* do forced alignment and store obs to utt->o for the follwoing forward-backward */
+   utt->o = (Observation *) New(&gstack, nFrames*sizeof(Observation));
+   utt->o--;           
+   for (t=1; t<=nFrames; t++) {
+      utt->o[t] = MakeObservation(&gstack, hset.swidth, hset.pkind, ((hset.hsKind==DISCRETEHS) ? TRUE:FALSE), eSep);
+      ReadAsTable(pbuf, t-1, &utt->o[t]);
+      ProcessObservation(alignvri, &utt->o[t], -1, xfInfo.inXForm); 
    }
     
    alignLat=CompleteRecognition(alignvri,
@@ -618,15 +687,16 @@ int DoOnlineAdaptation(Lattice *lat, Par
    utt->pbuf = pbuf;
    utt->Q = CountLabs(utt->tr->head);
    utt->T = nFrames;
-   utt->ot = obs;
   
    /* do frame state alignment and accumulate statistics */
-   fbInfo->inXForm = xfInfo.inXForm;
-   fbInfo->al_inXForm = xfInfo.inXForm;
-   fbInfo->paXForm = xfInfo.paXForm;
-   if (!FBFile(fbInfo, utt, NULL))
+   if (!FBUtt(fbInfo, utt))
      nFrames = 0;
 
+   /* reset each observation */
+   for (t=nFrames; t>0; t--) {
+      ResetObservation(&gstack, &utt->o[t], hset.swidth, hset.pkind);
+   }
+   utt->o++;
    Dispose(&netHeap, trans);
 
    if (trace&T_TOP) {
@@ -651,7 +721,7 @@ Boolean ProcessFile(char *fn, Network *n
    LogFloat lmlk,aclk;
    int s,j,tact,nFrames;
    LatFormat form;
-   char *p,lfn[255],buf1[80],buf2[80],thisFN[MAXSTRLEN];
+   char *p,lfn[MAXSTRLEN],buf1[MAXSTRLEN],buf2[MAXSTRLEN],thisFN[MAXSTRLEN];
    Boolean enableOutput = TRUE, isPipe;
 
    if (fn!=NULL)
@@ -803,10 +873,13 @@ Boolean ProcessFile(char *fn, Network *n
       
       if (labForm!=NULL)
          FormatTranscription(trans,pbinfo.tgtSampRate,states,models,
-                             strchr(labForm,'X')!=NULL,
-                             strchr(labForm,'N')!=NULL,strchr(labForm,'S')!=NULL,
-                             strchr(labForm,'C')!=NULL,strchr(labForm,'T')!=NULL,
-                             strchr(labForm,'W')!=NULL,strchr(labForm,'M')!=NULL);
+                             ((strchr(labForm,'X')!=NULL) ? TRUE:FALSE),
+                             ((strchr(labForm,'N')!=NULL) ? TRUE:FALSE),
+                             ((strchr(labForm,'S')!=NULL) ? TRUE:FALSE),
+                             ((strchr(labForm,'C')!=NULL) ? TRUE:FALSE),
+                             ((strchr(labForm,'T')!=NULL) ? TRUE:FALSE),
+                             ((strchr(labForm,'W')!=NULL) ? TRUE:FALSE),
+                             ((strchr(labForm,'M')!=NULL) ? TRUE:FALSE));
 
       MakeFN(thisFN,labDir,labExt,lfn);
       /* if(LSave(lfn,trans,ofmt)<SUCCESS)
@@ -821,7 +894,7 @@ Boolean ProcessFile(char *fn, Network *n
       PrintAllHeapStats();
    }
 
-   return !vri->noTokenSurvived;
+   return ((!vri->noTokenSurvived) ? TRUE:FALSE);
 }
 
 /* --------------------- Top Level Processing --------------------- */
@@ -922,12 +995,12 @@ void DoAlignment(void)
 	    Estimate transform and then set it up as the 
 	    input XForm
 	 */
-	 incXForm = CreateAdaptXForm(&hset,"inc");
-         TidyBaseAccs();
-	 GenAdaptXForm(&hset,incXForm);
-         xfInfo.inXForm = GetMLLRDiagCov(incXForm);;
-	 SetXForm(&hset,xfInfo.inXForm);
-	 ApplyHMMSetXForm(&hset,xfInfo.inXForm);
+         incXForm = CreateAdaptXForm(&hset,&xfInfo,"inc");
+         TidyBaseAccs(&xfInfo);
+         GenAdaptXForm(&hset,&xfInfo);
+         xfInfo.inXForm = GetMLLRDiagCov(&xfInfo,incXForm);
+         SetXForm(&hset,&xfInfo,xfInfo.inXForm);
+         ApplyHMMSetXForm(&hset,xfInfo.inXForm,FALSE);
       }
       ResetHeap(&netHeap);
    }
@@ -981,12 +1054,12 @@ void DoRecognition(void)
 	       Estimate transform and then set it up as the 
 	       input XForm
 	    */
-	    incXForm = CreateAdaptXForm(&hset,"inc");
-            TidyBaseAccs();
-	    GenAdaptXForm(&hset,incXForm);
-            xfInfo.inXForm = GetMLLRDiagCov(incXForm);;
-            SetXForm(&hset,xfInfo.inXForm);
-	    ApplyHMMSetXForm(&hset,xfInfo.inXForm);
+            incXForm = CreateAdaptXForm(&hset,&xfInfo,"inc");
+            TidyBaseAccs(&xfInfo);
+            GenAdaptXForm(&hset,&xfInfo);
+            xfInfo.inXForm = GetMLLRDiagCov(&xfInfo,incXForm);
+            SetXForm(&hset,&xfInfo,xfInfo.inXForm);
+            ApplyHMMSetXForm(&hset,xfInfo.inXForm,FALSE);
          }
       }
    }
@@ -1000,7 +1073,7 @@ void DoRecognition(void)
          }
 	 /* This handles the initial input transform, parent transform setting
 	    and output transform creation */
-         if (UpdateSpkrStats(&hset, &xfInfo, datFN) && (!(xfInfo.useInXForm)) && (hset.semiTied == NULL)) {
+         if (UpdateSpkrStats(&hset, &xfInfo, datFN) && (!(xfInfo.useInXForm))) {
             xfInfo.inXForm = NULL;
          }
          ProcessFile(datFN,net,n++,genBeam,FALSE);
@@ -1014,12 +1087,12 @@ void DoRecognition(void)
 	       Estimate transform and then set it up as the 
 	       input XForm
 	    */
-	    incXForm = CreateAdaptXForm(&hset,"inc");
-            TidyBaseAccs();
-	    GenAdaptXForm(&hset,incXForm);
-            xfInfo.inXForm = GetMLLRDiagCov(incXForm);;
-            SetXForm(&hset,xfInfo.inXForm);
-	    ApplyHMMSetXForm(&hset,xfInfo.inXForm);
+            incXForm = CreateAdaptXForm(&hset,&xfInfo,"inc");
+            TidyBaseAccs(&xfInfo);
+            GenAdaptXForm(&hset,&xfInfo);
+            xfInfo.inXForm = GetMLLRDiagCov(&xfInfo,incXForm);
+            SetXForm(&hset,&xfInfo,xfInfo.inXForm);
+            ApplyHMMSetXForm(&hset,xfInfo.inXForm,FALSE);
          }
       }
    }
diff -pbBEwurNa --ignore-matching-lines='.*vc_id.*' HTK-3.4.1/HTKTools/Makefile.in HTS-2.2_for_HTK-3.4.1/HTKTools/Makefile.in
--- HTK-3.4.1/HTKTools/Makefile.in	2009-03-11 21:50:53.000000000 +0900
+++ HTS-2.2_for_HTK-3.4.1/HTKTools/Makefile.in	2011-06-16 13:15:50.000000000 +0900
@@ -20,6 +20,51 @@
 # File: @configure_input@
 # ----------------------------------------------------------- 
 
+#  *** THIS IS A MODIFIED VERSION OF HTK ***                        #
+# ----------------------------------------------------------------- #
+#           The HMM-Based Speech Synthesis System (HTS)             #
+#           developed by HTS Working Group                          #
+#           http://hts.sp.nitech.ac.jp/                             #
+# ----------------------------------------------------------------- #
+#                                                                   #
+#  Copyright (c) 2001-2011  Nagoya Institute of Technology          #
+#                           Department of Computer Science          #
+#                                                                   #
+#                2001-2008  Tokyo Institute of Technology           #
+#                           Interdisciplinary Graduate School of    #
+#                           Science and Engineering                 #
+#                                                                   #
+# All rights reserved.                                              #
+#                                                                   #
+# Redistribution and use in source and binary forms, with or        #
+# without modification, are permitted provided that the following   #
+# conditions are met:                                               #
+#                                                                   #
+# - Redistributions of source code must retain the above copyright  #
+#   notice, this list of conditions and the following disclaimer.   #
+# - Redistributions in binary form must reproduce the above         #
+#   copyright notice, this list of conditions and the following     #
+#   disclaimer in the documentation and/or other materials provided #
+#   with the distribution.                                          #
+# - Neither the name of the HTS working group nor the names of its  #
+#   contributors may be used to endorse or promote products derived #
+#   from this software without specific prior written permission.   #
+#                                                                   #
+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND            #
+# CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,       #
+# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF          #
+# MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE          #
+# DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS #
+# BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,          #
+# EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED   #
+# TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,     #
+# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON #
+# ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,   #
+# OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY    #
+# OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE           #
+# POSSIBILITY OF SUCH DAMAGE.                                       #
+# ----------------------------------------------------------------- #
+
 SHELL =	/bin/sh
 inc = ../HTKLib
 HTKLIB = $(inc)/HTKLib.a 
@@ -49,13 +94,17 @@ PROGS   = 	@HSLAB@ HBuild HCompV HCopy H
 		HERest HHEd HInit HLEd 	HList \
 		HLRescore HLStats HMMIRest HParse \
 		HQuant HRest HResults HSGen HSmooth \
-		HVite 
+		HVite HMGenS HSMMAlign HMgeTool
 all: $(PROGS)
 
 %: %.c $(HTKLIB) 
 	if [ ! -d $(bindir) -a X_@TRADHTK@ = X_yes ] ; then mkdir -p $(bindir) ; fi
 	if [ x$@ = xHSLab ] ; then \
 		$(CC) -o $@ $(CFLAGS) $^ $(LDFLAGS) -lX11 ; \
+	elif [ x$@ = xHMGenS ] ; then \
+		$(CC) -o $@ $(CFLAGS) $^ $(LDFLAGS) @FLIBS@ ; \
+	elif [ x$@ = xHMgeTool ] ; then \
+		$(CC) -o $@ $(CFLAGS) $^ $(LDFLAGS) @FLIBS@ ; \
 		else \
 		$(CC) -o $@ $(CFLAGS) $^ $(LDFLAGS) ; fi
 	if [ X_@TRADHTK@ = X_yes ] ; then $(INSTALL) -m 755 $@ $(bindir)  ; fi
@@ -76,7 +125,7 @@ install: mkinstalldir $(PROGS)
 	for program in $(PROGS) ; do $(INSTALL) -m 755 $${program} $(bindir) ; done
 
 mkinstalldir:
-	if [ ! -d $(bindir) ] ; then mkdir $(bindir) ; fi
+	if [ ! -d $(bindir) ] ; then mkdir -p $(bindir) ; fi
 
 
 .PHONY: all strip clean cleanup distclean install mkinstalldir
diff -pbBEwurNa --ignore-matching-lines='.*vc_id.*' HTK-3.4.1/Makefile.in HTS-2.2_for_HTK-3.4.1/Makefile.in
--- HTK-3.4.1/Makefile.in	2009-03-11 19:08:06.000000000 +0900
+++ HTS-2.2_for_HTK-3.4.1/Makefile.in	2011-06-20 09:01:28.000000000 +0900
@@ -20,6 +20,51 @@
 # File: @configure_input@
 # ----------------------------------------------------------- 
 
+#  *** THIS IS A MODIFIED VERSION OF HTK ***                        #
+# ----------------------------------------------------------------- #
+#           The HMM-Based Speech Synthesis System (HTS)             #
+#           developed by HTS Working Group                          #
+#           http://hts.sp.nitech.ac.jp/                             #
+# ----------------------------------------------------------------- #
+#                                                                   #
+#  Copyright (c) 2001-2011  Nagoya Institute of Technology          #
+#                           Department of Computer Science          #
+#                                                                   #
+#                2001-2008  Tokyo Institute of Technology           #
+#                           Interdisciplinary Graduate School of    #
+#                           Science and Engineering                 #
+#                                                                   #
+# All rights reserved.                                              #
+#                                                                   #
+# Redistribution and use in source and binary forms, with or        #
+# without modification, are permitted provided that the following   #
+# conditions are met:                                               #
+#                                                                   #
+# - Redistributions of source code must retain the above copyright  #
+#   notice, this list of conditions and the following disclaimer.   #
+# - Redistributions in binary form must reproduce the above         #
+#   copyright notice, this list of conditions and the following     #
+#   disclaimer in the documentation and/or other materials provided #
+#   with the distribution.                                          #
+# - Neither the name of the HTS working group nor the names of its  #
+#   contributors may be used to endorse or promote products derived #
+#   from this software without specific prior written permission.   #
+#                                                                   #
+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND            #
+# CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,       #
+# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF          #
+# MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE          #
+# DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS #
+# BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,          #
+# EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED   #
+# TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,     #
+# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON #
+# ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,   #
+# OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY    #
+# OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE           #
+# POSSIBILITY OF SUCH DAMAGE.                                       #
+# ----------------------------------------------------------------- #
+
 SHELL = /bin/sh
 srcdir = @srcdir@
 top_srcdir = @top_srcdir@
diff -pbBEwurNa --ignore-matching-lines='.*vc_id.*' HTK-3.4.1/README HTS-2.2_for_HTK-3.4.1/README
--- HTK-3.4.1/README	2009-03-13 03:57:28.000000000 +0900
+++ HTS-2.2_for_HTK-3.4.1/README	2011-06-20 09:01:28.000000000 +0900
@@ -54,8 +54,8 @@ to a configure option of "--prefix=/usr/
 1. decide which of the above methods you wish to use
 2. cd to htk, then run ./configure (with appropriate options, run
    "./configure --help" if unsure).
-   If you don't want to build the programs in HLMTools add the 
-   --disable-hlmtools option.
+   If you want to build the programs in HLMTools add the
+   --enable-hlmtools option.
 3. make all
 4. make install
 
diff -pbBEwurNa --ignore-matching-lines='.*vc_id.*' HTK-3.4.1/configure HTS-2.2_for_HTK-3.4.1/configure
--- HTK-3.4.1/configure	2009-03-25 23:45:42.000000000 +0900
+++ HTS-2.2_for_HTK-3.4.1/configure	2011-06-20 09:01:28.000000000 +0900
@@ -1,15 +1,19 @@
 #! /bin/sh
 # Guess values for system-dependent variables and create Makefiles.
-# Generated by GNU Autoconf 2.61 for HTK 3.4.1.
+# Generated by GNU Autoconf 2.63 for HTS 2.2.
 #
-# Report bugs to <htk-mgr@eng.cam.ac.uk>.
+# Report bugs to <hts-users@sp.nitech.ac.jp>.
 #
 # Copyright (C) 1992, 1993, 1994, 1995, 1996, 1998, 1999, 2000, 2001,
-# 2002, 2003, 2004, 2005, 2006 Free Software Foundation, Inc.
+# 2002, 2003, 2004, 2005, 2006, 2007, 2008 Free Software Foundation, Inc.
 # This configure script is free software; the Free Software Foundation
 # gives unlimited permission to copy, distribute and modify it.
 #
 # Copyright 2003-2009 University of Cambridge
+#
+# Copyright 2001-2011 Nagoya Institute of Technology
+#
+# Copyright 2001-2008 Tokyo Institute of Technology
 ## --------------------- ##
 ## M4sh Initialization.  ##
 ## --------------------- ##
@@ -19,7 +23,7 @@ DUALCASE=1; export DUALCASE # for MKS sh
 if test -n "${ZSH_VERSION+set}" && (emulate sh) >/dev/null 2>&1; then
   emulate sh
   NULLCMD=:
-  # Zsh 3.x and 4.x performs word splitting on ${1+"$@"}, which
+  # Pre-4.2 versions of Zsh do word splitting on ${1+"$@"}, which
   # is contrary to our usage.  Disable this feature.
   alias -g '${1+"$@"}'='"$@"'
   setopt NO_GLOB_SUBST
@@ -41,17 +45,45 @@ as_cr_Letters=$as_cr_letters$as_cr_LETTE
 as_cr_digits='0123456789'
 as_cr_alnum=$as_cr_Letters$as_cr_digits
 
+as_nl='
+'
+export as_nl
+# Printing a long string crashes Solaris 7 /usr/bin/printf.
+as_echo='\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'
+as_echo=$as_echo$as_echo$as_echo$as_echo$as_echo
+as_echo=$as_echo$as_echo$as_echo$as_echo$as_echo$as_echo
+if (test "X`printf %s $as_echo`" = "X$as_echo") 2>/dev/null; then
+  as_echo='printf %s\n'
+  as_echo_n='printf %s'
+else
+  if test "X`(/usr/ucb/echo -n -n $as_echo) 2>/dev/null`" = "X-n $as_echo"; then
+    as_echo_body='eval /usr/ucb/echo -n "$1$as_nl"'
+    as_echo_n='/usr/ucb/echo -n'
+  else
+    as_echo_body='eval expr "X$1" : "X\\(.*\\)"'
+    as_echo_n_body='eval
+      arg=$1;
+      case $arg in
+      *"$as_nl"*)
+	expr "X$arg" : "X\\(.*\\)$as_nl";
+	arg=`expr "X$arg" : ".*$as_nl\\(.*\\)"`;;
+      esac;
+      expr "X$arg" : "X\\(.*\\)" | tr -d "$as_nl"
+    '
+    export as_echo_n_body
+    as_echo_n='sh -c $as_echo_n_body as_echo'
+  fi
+  export as_echo_body
+  as_echo='sh -c $as_echo_body as_echo'
+fi
+
 # The user is always right.
 if test "${PATH_SEPARATOR+set}" != set; then
-  echo "#! /bin/sh" >conf$$.sh
-  echo  "exit 0"   >>conf$$.sh
-  chmod +x conf$$.sh
-  if (PATH="/nonexistent;."; conf$$.sh) >/dev/null 2>&1; then
-    PATH_SEPARATOR=';'
-  else
     PATH_SEPARATOR=:
-  fi
-  rm -f conf$$.sh
+  (PATH='/bin;/bin'; FPATH=$PATH; sh -c :) >/dev/null 2>&1 && {
+    (PATH='/bin:/bin'; FPATH=$PATH; sh -c :) >/dev/null 2>&1 ||
+      PATH_SEPARATOR=';'
+  }
 fi
 
 # Support unset when possible.
@@ -67,8 +99,6 @@ fi
 # there to prevent editors from complaining about space-tab.
 # (If _AS_PATH_WALK were called with IFS unset, it would disable word
 # splitting by setting IFS to empty value.)
-as_nl='
-'
 IFS=" ""	$as_nl"
 
 # Find who we are.  Look in the path if we contain no directory separator.
@@ -91,7 +121,7 @@ if test "x$as_myself" = x; then
   as_myself=$0
 fi
 if test ! -f "$as_myself"; then
-  echo "$as_myself: error: cannot find myself; rerun with an absolute file name" >&2
+  $as_echo "$as_myself: error: cannot find myself; rerun with an absolute file name" >&2
   { (exit 1); exit 1; }
 fi
 
@@ -104,17 +134,10 @@ PS2='> '
 PS4='+ '
 
 # NLS nuisances.
-for as_var in \
-  LANG LANGUAGE LC_ADDRESS LC_ALL LC_COLLATE LC_CTYPE LC_IDENTIFICATION \
-  LC_MEASUREMENT LC_MESSAGES LC_MONETARY LC_NAME LC_NUMERIC LC_PAPER \
-  LC_TELEPHONE LC_TIME
-do
-  if (set +x; test -z "`(eval $as_var=C; export $as_var) 2>&1`"); then
-    eval $as_var=C; export $as_var
-  else
-    ($as_unset $as_var) >/dev/null 2>&1 && $as_unset $as_var
-  fi
-done
+LC_ALL=C
+export LC_ALL
+LANGUAGE=C
+export LANGUAGE
 
 # Required to use basename.
 if expr a : '\(a\)' >/dev/null 2>&1 &&
@@ -136,7 +159,7 @@ as_me=`$as_basename -- "$0" ||
 $as_expr X/"$0" : '.*/\([^/][^/]*\)/*$' \| \
 	 X"$0" : 'X\(//\)$' \| \
 	 X"$0" : 'X\(/\)' \| . 2>/dev/null ||
-echo X/"$0" |
+$as_echo X/"$0" |
     sed '/^.*\/\([^/][^/]*\)\/*$/{
 	    s//\1/
 	    q
@@ -244,7 +267,7 @@ IFS=$as_save_IFS
 if test -n "${ZSH_VERSION+set}" && (emulate sh) >/dev/null 2>&1; then
   emulate sh
   NULLCMD=:
-  # Zsh 3.x and 4.x performs word splitting on ${1+"$@"}, which
+  # Pre-4.2 versions of Zsh do word splitting on ${1+"$@"}, which
   # is contrary to our usage.  Disable this feature.
   alias -g '${1+"$@"}'='"$@"'
   setopt NO_GLOB_SUBST
@@ -265,7 +288,7 @@ _ASEOF
 if test -n "${ZSH_VERSION+set}" && (emulate sh) >/dev/null 2>&1; then
   emulate sh
   NULLCMD=:
-  # Zsh 3.x and 4.x performs word splitting on ${1+"$@"}, which
+  # Pre-4.2 versions of Zsh do word splitting on ${1+"$@"}, which
   # is contrary to our usage.  Disable this feature.
   alias -g '${1+"$@"}'='"$@"'
   setopt NO_GLOB_SUBST
@@ -417,9 +440,10 @@ fi
 
 test \$exitcode = 0") || {
   echo No shell found that supports shell functions.
-  echo Please tell autoconf@gnu.org about your system,
-  echo including any error possibly output before this
-  echo message
+  echo Please tell bug-autoconf@gnu.org about your system,
+  echo including any error possibly output before this message.
+  echo This can help us improve future autoconf versions.
+  echo Configuration will now proceed without shell functions.
 }
 
 
@@ -455,7 +479,7 @@ test \$exitcode = 0") || {
       s/-\n.*//
     ' >$as_me.lineno &&
   chmod +x "$as_me.lineno" ||
-    { echo "$as_me: error: cannot create $as_me.lineno; rerun with a POSIX shell" >&2
+    { $as_echo "$as_me: error: cannot create $as_me.lineno; rerun with a POSIX shell" >&2
    { (exit 1); exit 1; }; }
 
   # Don't try to exec as it changes $[0], causing all sort of problems
@@ -496,9 +519,9 @@ if test -d conf$$.dir; then
   rm -f conf$$.dir/conf$$.file
 else
   rm -f conf$$.dir
-  mkdir conf$$.dir
+  mkdir conf$$.dir 2>/dev/null
 fi
-echo >conf$$.file
+if (echo >conf$$.file) 2>/dev/null; then
 if ln -s conf$$.file conf$$ 2>/dev/null; then
   as_ln_s='ln -s'
   # ... but there are two gotchas:
@@ -512,6 +535,9 @@ elif ln conf$$.file conf$$ 2>/dev/null; 
 else
   as_ln_s='cp -p'
 fi
+else
+  as_ln_s='cp -p'
+fi
 rm -f conf$$ conf$$.exe conf$$.dir/conf$$.file conf$$.file
 rmdir conf$$.dir 2>/dev/null
 
@@ -574,12 +600,13 @@ MAKEFLAGS=
 SHELL=${CONFIG_SHELL-/bin/sh}
 
 # Identity of this package.
-PACKAGE_NAME='HTK'
-PACKAGE_TARNAME='htk'
-PACKAGE_VERSION='3.4.1'
-PACKAGE_STRING='HTK 3.4.1'
-PACKAGE_BUGREPORT='htk-mgr@eng.cam.ac.uk'
+PACKAGE_NAME='HTS'
+PACKAGE_TARNAME='hts'
+PACKAGE_VERSION='2.2'
+PACKAGE_STRING='HTS 2.2'
+PACKAGE_BUGREPORT='hts-users@sp.nitech.ac.jp'
 
+ac_default_prefix=/usr/local/HTS-2.2beta
 # Factoring default headers for most tests.
 ac_includes_default="\
 #include <stdio.h>
@@ -616,80 +643,100 @@ ac_includes_default="\
 # include <unistd.h>
 #endif"
 
-ac_subst_vars='SHELL
-PATH_SEPARATOR
-PACKAGE_NAME
-PACKAGE_TARNAME
-PACKAGE_VERSION
-PACKAGE_STRING
-PACKAGE_BUGREPORT
-exec_prefix
-prefix
-program_transform_name
-bindir
-sbindir
-libexecdir
-datarootdir
-datadir
-sysconfdir
-sharedstatedir
-localstatedir
-includedir
-oldincludedir
-docdir
-infodir
-htmldir
-dvidir
-pdfdir
-psdir
-libdir
-localedir
-mandir
-DEFS
-ECHO_C
-ECHO_N
-ECHO_T
-LIBS
-build_alias
-host_alias
-target_alias
-SET_MAKE
-AWK
-CC
-CFLAGS
-LDFLAGS
-CPPFLAGS
-ac_ct_CC
-EXEEXT
-OBJEXT
-INSTALL_PROGRAM
-INSTALL_SCRIPT
-INSTALL_DATA
-LN_S
-RANLIB
-XMKMF
-CPP
-GREP
-EGREP
-LIBOBJS
-POW_LIB
-build
-build_cpu
-build_vendor
-build_os
-host
-host_cpu
-host_vendor
-host_os
-TRADHTK
-TRADHTKBIN
-make_all
-make_install
-HSLAB
-HGRAF
+ac_subst_vars='LTLIBOBJS
+LIBLV
 BINARY_EXTENSION
-LTLIBOBJS'
+HGRAF
+HSLAB
+make_install
+make_all
+TRADHTKBIN
+TRADHTK
+SMAX
+PAT_LEN
+MAXFNAMELEN
+MAXSTRLEN
+host_os
+host_vendor
+host_cpu
+host
+build_os
+build_vendor
+build_cpu
+build
+POW_LIB
+LIBOBJS
+EGREP
+GREP
+CPP
+XMKMF
+LBFGS
+FLIBS
+ac_ct_F77
+FFLAGS
+F77
+AR
+RANLIB
+LN_S
+INSTALL_DATA
+INSTALL_SCRIPT
+INSTALL_PROGRAM
+OBJEXT
+EXEEXT
+ac_ct_CC
+CPPFLAGS
+LDFLAGS
+CFLAGS
+CC
+AWK
+SET_MAKE
+target_alias
+host_alias
+build_alias
+LIBS
+ECHO_T
+ECHO_N
+ECHO_C
+DEFS
+mandir
+localedir
+libdir
+psdir
+pdfdir
+dvidir
+htmldir
+infodir
+docdir
+oldincludedir
+includedir
+localstatedir
+sharedstatedir
+sysconfdir
+datadir
+datarootdir
+libexecdir
+sbindir
+bindir
+program_transform_name
+prefix
+exec_prefix
+PACKAGE_BUGREPORT
+PACKAGE_STRING
+PACKAGE_VERSION
+PACKAGE_TARNAME
+PACKAGE_NAME
+PATH_SEPARATOR
+SHELL'
 ac_subst_files=''
+ac_user_opts='
+enable_option_checking
+with_x
+enable_trad_htk
+enable_hdecode
+enable_hlmtools
+enable_hslab
+enable_htkbook
+'
       ac_precious_vars='build_alias
 host_alias
 target_alias
@@ -698,13 +745,21 @@ CFLAGS
 LDFLAGS
 LIBS
 CPPFLAGS
+F77
+FFLAGS
 XMKMF
-CPP'
+CPP
+MAXSTRLEN
+MAXFNAMELEN
+PAT_LEN
+SMAX'
 
 
 # Initialize some variables set by options.
 ac_init_help=
 ac_init_version=false
+ac_unrecognized_opts=
+ac_unrecognized_sep=
 # The variables have the same names as the options, with
 # dashes changed to underlines.
 cache_file=/dev/null
@@ -803,13 +858,21 @@ do
     datarootdir=$ac_optarg ;;
 
   -disable-* | --disable-*)
-    ac_feature=`expr "x$ac_option" : 'x-*disable-\(.*\)'`
+    ac_useropt=`expr "x$ac_option" : 'x-*disable-\(.*\)'`
     # Reject names that are not valid shell variable names.
-    expr "x$ac_feature" : ".*[^-._$as_cr_alnum]" >/dev/null &&
-      { echo "$as_me: error: invalid feature name: $ac_feature" >&2
+    expr "x$ac_useropt" : ".*[^-+._$as_cr_alnum]" >/dev/null &&
+      { $as_echo "$as_me: error: invalid feature name: $ac_useropt" >&2
    { (exit 1); exit 1; }; }
-    ac_feature=`echo $ac_feature | sed 's/[-.]/_/g'`
-    eval enable_$ac_feature=no ;;
+    ac_useropt_orig=$ac_useropt
+    ac_useropt=`$as_echo "$ac_useropt" | sed 's/[-+.]/_/g'`
+    case $ac_user_opts in
+      *"
+"enable_$ac_useropt"
+"*) ;;
+      *) ac_unrecognized_opts="$ac_unrecognized_opts$ac_unrecognized_sep--disable-$ac_useropt_orig"
+	 ac_unrecognized_sep=', ';;
+    esac
+    eval enable_$ac_useropt=no ;;
 
   -docdir | --docdir | --docdi | --doc | --do)
     ac_prev=docdir ;;
@@ -822,13 +885,21 @@ do
     dvidir=$ac_optarg ;;
 
   -enable-* | --enable-*)
-    ac_feature=`expr "x$ac_option" : 'x-*enable-\([^=]*\)'`
+    ac_useropt=`expr "x$ac_option" : 'x-*enable-\([^=]*\)'`
     # Reject names that are not valid shell variable names.
-    expr "x$ac_feature" : ".*[^-._$as_cr_alnum]" >/dev/null &&
-      { echo "$as_me: error: invalid feature name: $ac_feature" >&2
+    expr "x$ac_useropt" : ".*[^-+._$as_cr_alnum]" >/dev/null &&
+      { $as_echo "$as_me: error: invalid feature name: $ac_useropt" >&2
    { (exit 1); exit 1; }; }
-    ac_feature=`echo $ac_feature | sed 's/[-.]/_/g'`
-    eval enable_$ac_feature=\$ac_optarg ;;
+    ac_useropt_orig=$ac_useropt
+    ac_useropt=`$as_echo "$ac_useropt" | sed 's/[-+.]/_/g'`
+    case $ac_user_opts in
+      *"
+"enable_$ac_useropt"
+"*) ;;
+      *) ac_unrecognized_opts="$ac_unrecognized_opts$ac_unrecognized_sep--enable-$ac_useropt_orig"
+	 ac_unrecognized_sep=', ';;
+    esac
+    eval enable_$ac_useropt=\$ac_optarg ;;
 
   -exec-prefix | --exec_prefix | --exec-prefix | --exec-prefi \
   | --exec-pref | --exec-pre | --exec-pr | --exec-p | --exec- \
@@ -1019,22 +1090,38 @@ do
     ac_init_version=: ;;
 
   -with-* | --with-*)
-    ac_package=`expr "x$ac_option" : 'x-*with-\([^=]*\)'`
+    ac_useropt=`expr "x$ac_option" : 'x-*with-\([^=]*\)'`
     # Reject names that are not valid shell variable names.
-    expr "x$ac_package" : ".*[^-._$as_cr_alnum]" >/dev/null &&
-      { echo "$as_me: error: invalid package name: $ac_package" >&2
+    expr "x$ac_useropt" : ".*[^-+._$as_cr_alnum]" >/dev/null &&
+      { $as_echo "$as_me: error: invalid package name: $ac_useropt" >&2
    { (exit 1); exit 1; }; }
-    ac_package=`echo $ac_package | sed 's/[-.]/_/g'`
-    eval with_$ac_package=\$ac_optarg ;;
+    ac_useropt_orig=$ac_useropt
+    ac_useropt=`$as_echo "$ac_useropt" | sed 's/[-+.]/_/g'`
+    case $ac_user_opts in
+      *"
+"with_$ac_useropt"
+"*) ;;
+      *) ac_unrecognized_opts="$ac_unrecognized_opts$ac_unrecognized_sep--with-$ac_useropt_orig"
+	 ac_unrecognized_sep=', ';;
+    esac
+    eval with_$ac_useropt=\$ac_optarg ;;
 
   -without-* | --without-*)
-    ac_package=`expr "x$ac_option" : 'x-*without-\(.*\)'`
+    ac_useropt=`expr "x$ac_option" : 'x-*without-\(.*\)'`
     # Reject names that are not valid shell variable names.
-    expr "x$ac_package" : ".*[^-._$as_cr_alnum]" >/dev/null &&
-      { echo "$as_me: error: invalid package name: $ac_package" >&2
+    expr "x$ac_useropt" : ".*[^-+._$as_cr_alnum]" >/dev/null &&
+      { $as_echo "$as_me: error: invalid package name: $ac_useropt" >&2
    { (exit 1); exit 1; }; }
-    ac_package=`echo $ac_package | sed 's/[-.]/_/g'`
-    eval with_$ac_package=no ;;
+    ac_useropt_orig=$ac_useropt
+    ac_useropt=`$as_echo "$ac_useropt" | sed 's/[-+.]/_/g'`
+    case $ac_user_opts in
+      *"
+"with_$ac_useropt"
+"*) ;;
+      *) ac_unrecognized_opts="$ac_unrecognized_opts$ac_unrecognized_sep--without-$ac_useropt_orig"
+	 ac_unrecognized_sep=', ';;
+    esac
+    eval with_$ac_useropt=no ;;
 
   --x)
     # Obsolete; use --with-x.
@@ -1054,7 +1141,7 @@ do
   | --x-librar=* | --x-libra=* | --x-libr=* | --x-lib=* | --x-li=* | --x-l=*)
     x_libraries=$ac_optarg ;;
 
-  -*) { echo "$as_me: error: unrecognized option: $ac_option
+  -*) { $as_echo "$as_me: error: unrecognized option: $ac_option
 Try \`$0 --help' for more information." >&2
    { (exit 1); exit 1; }; }
     ;;
@@ -1063,16 +1150,16 @@ Try \`$0 --help' for more information." 
     ac_envvar=`expr "x$ac_option" : 'x\([^=]*\)='`
     # Reject names that are not valid shell variable names.
     expr "x$ac_envvar" : ".*[^_$as_cr_alnum]" >/dev/null &&
-      { echo "$as_me: error: invalid variable name: $ac_envvar" >&2
+      { $as_echo "$as_me: error: invalid variable name: $ac_envvar" >&2
    { (exit 1); exit 1; }; }
     eval $ac_envvar=\$ac_optarg
     export $ac_envvar ;;
 
   *)
     # FIXME: should be removed in autoconf 3.0.
-    echo "$as_me: WARNING: you should use --build, --host, --target" >&2
+    $as_echo "$as_me: WARNING: you should use --build, --host, --target" >&2
     expr "x$ac_option" : ".*[^-._$as_cr_alnum]" >/dev/null &&
-      echo "$as_me: WARNING: invalid host type: $ac_option" >&2
+      $as_echo "$as_me: WARNING: invalid host type: $ac_option" >&2
     : ${build_alias=$ac_option} ${host_alias=$ac_option} ${target_alias=$ac_option}
     ;;
 
@@ -1081,22 +1168,38 @@ done
 
 if test -n "$ac_prev"; then
   ac_option=--`echo $ac_prev | sed 's/_/-/g'`
-  { echo "$as_me: error: missing argument to $ac_option" >&2
+  { $as_echo "$as_me: error: missing argument to $ac_option" >&2
    { (exit 1); exit 1; }; }
 fi
 
-# Be sure to have absolute directory names.
+if test -n "$ac_unrecognized_opts"; then
+  case $enable_option_checking in
+    no) ;;
+    fatal) { $as_echo "$as_me: error: unrecognized options: $ac_unrecognized_opts" >&2
+   { (exit 1); exit 1; }; } ;;
+    *)     $as_echo "$as_me: WARNING: unrecognized options: $ac_unrecognized_opts" >&2 ;;
+  esac
+fi
+
+# Check all directory arguments for consistency.
 for ac_var in	exec_prefix prefix bindir sbindir libexecdir datarootdir \
 		datadir sysconfdir sharedstatedir localstatedir includedir \
 		oldincludedir docdir infodir htmldir dvidir pdfdir psdir \
 		libdir localedir mandir
 do
   eval ac_val=\$$ac_var
+  # Remove trailing slashes.
+  case $ac_val in
+    */ )
+      ac_val=`expr "X$ac_val" : 'X\(.*[^/]\)' \| "X$ac_val" : 'X\(.*\)'`
+      eval $ac_var=\$ac_val;;
+  esac
+  # Be sure to have absolute directory names.
   case $ac_val in
     [\\/$]* | ?:[\\/]* )  continue;;
     NONE | '' ) case $ac_var in *prefix ) continue;; esac;;
   esac
-  { echo "$as_me: error: expected an absolute directory name for --$ac_var: $ac_val" >&2
+  { $as_echo "$as_me: error: expected an absolute directory name for --$ac_var: $ac_val" >&2
    { (exit 1); exit 1; }; }
 done
 
@@ -1111,7 +1214,7 @@ target=$target_alias
 if test "x$host_alias" != x; then
   if test "x$build_alias" = x; then
     cross_compiling=maybe
-    echo "$as_me: WARNING: If you wanted to set the --build type, don't use --host.
+    $as_echo "$as_me: WARNING: If you wanted to set the --build type, don't use --host.
     If a cross compiler is detected then cross compile mode will be used." >&2
   elif test "x$build_alias" != "x$host_alias"; then
     cross_compiling=yes
@@ -1127,10 +1230,10 @@ test "$silent" = yes && exec 6>/dev/null
 ac_pwd=`pwd` && test -n "$ac_pwd" &&
 ac_ls_di=`ls -di .` &&
 ac_pwd_ls_di=`cd "$ac_pwd" && ls -di .` ||
-  { echo "$as_me: error: Working directory cannot be determined" >&2
+  { $as_echo "$as_me: error: working directory cannot be determined" >&2
    { (exit 1); exit 1; }; }
 test "X$ac_ls_di" = "X$ac_pwd_ls_di" ||
-  { echo "$as_me: error: pwd does not report name of working directory" >&2
+  { $as_echo "$as_me: error: pwd does not report name of working directory" >&2
    { (exit 1); exit 1; }; }
 
 
@@ -1138,12 +1241,12 @@ test "X$ac_ls_di" = "X$ac_pwd_ls_di" ||
 if test -z "$srcdir"; then
   ac_srcdir_defaulted=yes
   # Try the directory containing this script, then the parent directory.
-  ac_confdir=`$as_dirname -- "$0" ||
-$as_expr X"$0" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
-	 X"$0" : 'X\(//\)[^/]' \| \
-	 X"$0" : 'X\(//\)$' \| \
-	 X"$0" : 'X\(/\)' \| . 2>/dev/null ||
-echo X"$0" |
+  ac_confdir=`$as_dirname -- "$as_myself" ||
+$as_expr X"$as_myself" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
+	 X"$as_myself" : 'X\(//\)[^/]' \| \
+	 X"$as_myself" : 'X\(//\)$' \| \
+	 X"$as_myself" : 'X\(/\)' \| . 2>/dev/null ||
+$as_echo X"$as_myself" |
     sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{
 	    s//\1/
 	    q
@@ -1170,12 +1273,12 @@ else
 fi
 if test ! -r "$srcdir/$ac_unique_file"; then
   test "$ac_srcdir_defaulted" = yes && srcdir="$ac_confdir or .."
-  { echo "$as_me: error: cannot find sources ($ac_unique_file) in $srcdir" >&2
+  { $as_echo "$as_me: error: cannot find sources ($ac_unique_file) in $srcdir" >&2
    { (exit 1); exit 1; }; }
 fi
 ac_msg="sources are in $srcdir, but \`cd $srcdir' does not work"
 ac_abs_confdir=`(
-	cd "$srcdir" && test -r "./$ac_unique_file" || { echo "$as_me: error: $ac_msg" >&2
+	cd "$srcdir" && test -r "./$ac_unique_file" || { $as_echo "$as_me: error: $ac_msg" >&2
    { (exit 1); exit 1; }; }
 	pwd)`
 # When building in place, set srcdir=.
@@ -1202,7 +1305,7 @@ if test "$ac_init_help" = "long"; then
   # Omit some internal or obsolete options to make the list less imposing.
   # This message is too long to be a string in the A/UX 3.1 sh.
   cat <<_ACEOF
-\`configure' configures HTK 3.4.1 to adapt to many kinds of systems.
+\`configure' configures HTS 2.2 to adapt to many kinds of systems.
 
 Usage: $0 [OPTION]... [VAR=VALUE]...
 
@@ -1250,7 +1353,7 @@ Fine tuning of the installation director
   --infodir=DIR          info documentation [DATAROOTDIR/info]
   --localedir=DIR        locale-dependent data [DATAROOTDIR/locale]
   --mandir=DIR           man documentation [DATAROOTDIR/man]
-  --docdir=DIR           documentation root [DATAROOTDIR/doc/htk]
+  --docdir=DIR            documentation root [DATAROOTDIR/doc/hts]
   --htmldir=DIR          html documentation [DOCDIR]
   --dvidir=DIR           dvi documentation [DOCDIR]
   --pdfdir=DIR           pdf documentation [DOCDIR]
@@ -1271,17 +1374,18 @@ fi
 
 if test -n "$ac_init_help"; then
   case $ac_init_help in
-     short | recursive ) echo "Configuration of HTK 3.4.1:";;
+     short | recursive ) echo "Configuration of HTS 2.2:";;
    esac
   cat <<\_ACEOF
 
 Optional Features:
+  --disable-option-checking  ignore unrecognized --enable/--with options
   --disable-FEATURE       do not include FEATURE (same as --enable-FEATURE=no)
   --enable-FEATURE[=ARG]  include FEATURE [ARG=yes]
   --enable-trad-htk       HTK installed into $prefix/bin.$cpu and installed
                           when compiled
   --enable-hdecode        build large vocabulary recognition system (HDecode)
-  --disable-hlmtools      don't build Language Modelling tools
+  --enable-hlmtools       build Language Modelling tools
   --disable-hslab         don't build HSLab
   --enable-htkbook        build HTK book
 
@@ -1298,13 +1402,19 @@ Some influential environment variables:
   LIBS        libraries to pass to the linker, e.g. -l<library>
   CPPFLAGS    C/C++/Objective C preprocessor flags, e.g. -I<include dir> if
               you have headers in a nonstandard directory <include dir>
+  F77         Fortran 77 compiler command
+  FFLAGS      Fortran 77 compiler flags
   XMKMF       Path to xmkmf, Makefile generator for X Window System
   CPP         C preprocessor
+  MAXSTRLEN   max length of strings (default=1024)
+  MAXFNAMELEN max length of file names (default=1024)
+  PAT_LEN     max length of patterns (default=2048)
+  SMAX        max number of streams (default=30)
 
 Use these variables to override the choices made by `configure' or to help
 it to find libraries and programs with nonstandard names/locations.
 
-Report bugs to <htk-mgr@eng.cam.ac.uk>.
+Report bugs to <hts-users@sp.nitech.ac.jp>.
 _ACEOF
 ac_status=$?
 fi
@@ -1312,15 +1422,17 @@ fi
 if test "$ac_init_help" = "recursive"; then
   # If there are subdirs, report their specific --help.
   for ac_dir in : $ac_subdirs_all; do test "x$ac_dir" = x: && continue
-    test -d "$ac_dir" || continue
+    test -d "$ac_dir" ||
+      { cd "$srcdir" && ac_pwd=`pwd` && srcdir=. && test -d "$ac_dir"; } ||
+      continue
     ac_builddir=.
 
 case "$ac_dir" in
 .) ac_dir_suffix= ac_top_builddir_sub=. ac_top_build_prefix= ;;
 *)
-  ac_dir_suffix=/`echo "$ac_dir" | sed 's,^\.[\\/],,'`
+  ac_dir_suffix=/`$as_echo "$ac_dir" | sed 's|^\.[\\/]||'`
   # A ".." for each directory in $ac_dir_suffix.
-  ac_top_builddir_sub=`echo "$ac_dir_suffix" | sed 's,/[^\\/]*,/..,g;s,/,,'`
+  ac_top_builddir_sub=`$as_echo "$ac_dir_suffix" | sed 's|/[^\\/]*|/..|g;s|/||'`
   case $ac_top_builddir_sub in
   "") ac_top_builddir_sub=. ac_top_build_prefix= ;;
   *)  ac_top_build_prefix=$ac_top_builddir_sub/ ;;
@@ -1356,7 +1468,7 @@ ac_abs_srcdir=$ac_abs_top_srcdir$ac_dir_
       echo &&
       $SHELL "$ac_srcdir/configure" --help=recursive
     else
-      echo "$as_me: WARNING: no configuration information is in $ac_dir" >&2
+      $as_echo "$as_me: WARNING: no configuration information is in $ac_dir" >&2
     fi || ac_status=$?
     cd "$ac_pwd" || { ac_status=$?; break; }
   done
@@ -1365,15 +1477,19 @@ fi
 test -n "$ac_init_help" && exit $ac_status
 if $ac_init_version; then
   cat <<\_ACEOF
-HTK configure 3.4.1
-generated by GNU Autoconf 2.61
+HTS configure 2.2
+generated by GNU Autoconf 2.63
 
 Copyright (C) 1992, 1993, 1994, 1995, 1996, 1998, 1999, 2000, 2001,
-2002, 2003, 2004, 2005, 2006 Free Software Foundation, Inc.
+2002, 2003, 2004, 2005, 2006, 2007, 2008 Free Software Foundation, Inc.
 This configure script is free software; the Free Software Foundation
 gives unlimited permission to copy, distribute and modify it.
 
 Copyright 2003-2009 University of Cambridge
+
+Copyright 2001-2011 Nagoya Institute of Technology
+
+Copyright 2001-2008 Tokyo Institute of Technology
 _ACEOF
   exit
 fi
@@ -1381,8 +1497,8 @@ cat >config.log <<_ACEOF
 This file contains any messages produced by compilers while
 running configure, to aid debugging if configure makes a mistake.
 
-It was created by HTK $as_me 3.4.1, which was
-generated by GNU Autoconf 2.61.  Invocation command line was
+It was created by HTS $as_me 2.2, which was
+generated by GNU Autoconf 2.63.  Invocation command line was
 
   $ $0 $@
 
@@ -1418,7 +1534,7 @@ for as_dir in $PATH
 do
   IFS=$as_save_IFS
   test -z "$as_dir" && as_dir=.
-  echo "PATH: $as_dir"
+  $as_echo "PATH: $as_dir"
 done
 IFS=$as_save_IFS
 
@@ -1453,7 +1569,7 @@ do
     | -silent | --silent | --silen | --sile | --sil)
       continue ;;
     *\'*)
-      ac_arg=`echo "$ac_arg" | sed "s/'/'\\\\\\\\''/g"` ;;
+      ac_arg=`$as_echo "$ac_arg" | sed "s/'/'\\\\\\\\''/g"` ;;
     esac
     case $ac_pass in
     1) ac_configure_args0="$ac_configure_args0 '$ac_arg'" ;;
@@ -1505,11 +1621,12 @@ _ASBOX
     case $ac_val in #(
     *${as_nl}*)
       case $ac_var in #(
-      *_cv_*) { echo "$as_me:$LINENO: WARNING: Cache variable $ac_var contains a newline." >&5
-echo "$as_me: WARNING: Cache variable $ac_var contains a newline." >&2;} ;;
+      *_cv_*) { $as_echo "$as_me:$LINENO: WARNING: cache variable $ac_var contains a newline" >&5
+$as_echo "$as_me: WARNING: cache variable $ac_var contains a newline" >&2;} ;;
       esac
       case $ac_var in #(
       _ | IFS | as_nl) ;; #(
+      BASH_ARGV | BASH_SOURCE) eval $ac_var= ;; #(
       *) $as_unset $ac_var ;;
       esac ;;
     esac
@@ -1539,9 +1656,9 @@ _ASBOX
     do
       eval ac_val=\$$ac_var
       case $ac_val in
-      *\'\''*) ac_val=`echo "$ac_val" | sed "s/'\''/'\''\\\\\\\\'\'''\''/g"`;;
+      *\'\''*) ac_val=`$as_echo "$ac_val" | sed "s/'\''/'\''\\\\\\\\'\'''\''/g"`;;
       esac
-      echo "$ac_var='\''$ac_val'\''"
+      $as_echo "$ac_var='\''$ac_val'\''"
     done | sort
     echo
 
@@ -1556,9 +1673,9 @@ _ASBOX
       do
 	eval ac_val=\$$ac_var
 	case $ac_val in
-	*\'\''*) ac_val=`echo "$ac_val" | sed "s/'\''/'\''\\\\\\\\'\'''\''/g"`;;
+	*\'\''*) ac_val=`$as_echo "$ac_val" | sed "s/'\''/'\''\\\\\\\\'\'''\''/g"`;;
 	esac
-	echo "$ac_var='\''$ac_val'\''"
+	$as_echo "$ac_var='\''$ac_val'\''"
       done | sort
       echo
     fi
@@ -1574,8 +1691,8 @@ _ASBOX
       echo
     fi
     test "$ac_signal" != 0 &&
-      echo "$as_me: caught signal $ac_signal"
-    echo "$as_me: exit $exit_status"
+      $as_echo "$as_me: caught signal $ac_signal"
+    $as_echo "$as_me: exit $exit_status"
   } >&5
   rm -f core *.core core.conftest.* &&
     rm -f -r conftest* confdefs* conf$$* $ac_clean_files &&
@@ -1617,21 +1734,24 @@ _ACEOF
 
 
 # Let the site file select an alternate cache file if it wants to.
-# Prefer explicitly selected file to automatically selected ones.
+# Prefer an explicitly selected file to automatically selected ones.
+ac_site_file1=NONE
+ac_site_file2=NONE
 if test -n "$CONFIG_SITE"; then
-  set x "$CONFIG_SITE"
+  ac_site_file1=$CONFIG_SITE
 elif test "x$prefix" != xNONE; then
-  set x "$prefix/share/config.site" "$prefix/etc/config.site"
+  ac_site_file1=$prefix/share/config.site
+  ac_site_file2=$prefix/etc/config.site
 else
-  set x "$ac_default_prefix/share/config.site" \
-	"$ac_default_prefix/etc/config.site"
+  ac_site_file1=$ac_default_prefix/share/config.site
+  ac_site_file2=$ac_default_prefix/etc/config.site
 fi
-shift
-for ac_site_file
+for ac_site_file in "$ac_site_file1" "$ac_site_file2"
 do
+  test "x$ac_site_file" = xNONE && continue
   if test -r "$ac_site_file"; then
-    { echo "$as_me:$LINENO: loading site script $ac_site_file" >&5
-echo "$as_me: loading site script $ac_site_file" >&6;}
+    { $as_echo "$as_me:$LINENO: loading site script $ac_site_file" >&5
+$as_echo "$as_me: loading site script $ac_site_file" >&6;}
     sed 's/^/| /' "$ac_site_file" >&5
     . "$ac_site_file"
   fi
@@ -1641,16 +1761,16 @@ if test -r "$cache_file"; then
   # Some versions of bash will fail to source /dev/null (special
   # files actually), so we avoid doing that.
   if test -f "$cache_file"; then
-    { echo "$as_me:$LINENO: loading cache $cache_file" >&5
-echo "$as_me: loading cache $cache_file" >&6;}
+    { $as_echo "$as_me:$LINENO: loading cache $cache_file" >&5
+$as_echo "$as_me: loading cache $cache_file" >&6;}
     case $cache_file in
       [\\/]* | ?:[\\/]* ) . "$cache_file";;
       *)                      . "./$cache_file";;
     esac
   fi
 else
-  { echo "$as_me:$LINENO: creating cache $cache_file" >&5
-echo "$as_me: creating cache $cache_file" >&6;}
+  { $as_echo "$as_me:$LINENO: creating cache $cache_file" >&5
+$as_echo "$as_me: creating cache $cache_file" >&6;}
   >$cache_file
 fi
 
@@ -1664,29 +1784,38 @@ for ac_var in $ac_precious_vars; do
   eval ac_new_val=\$ac_env_${ac_var}_value
   case $ac_old_set,$ac_new_set in
     set,)
-      { echo "$as_me:$LINENO: error: \`$ac_var' was set to \`$ac_old_val' in the previous run" >&5
-echo "$as_me: error: \`$ac_var' was set to \`$ac_old_val' in the previous run" >&2;}
+      { $as_echo "$as_me:$LINENO: error: \`$ac_var' was set to \`$ac_old_val' in the previous run" >&5
+$as_echo "$as_me: error: \`$ac_var' was set to \`$ac_old_val' in the previous run" >&2;}
       ac_cache_corrupted=: ;;
     ,set)
-      { echo "$as_me:$LINENO: error: \`$ac_var' was not set in the previous run" >&5
-echo "$as_me: error: \`$ac_var' was not set in the previous run" >&2;}
+      { $as_echo "$as_me:$LINENO: error: \`$ac_var' was not set in the previous run" >&5
+$as_echo "$as_me: error: \`$ac_var' was not set in the previous run" >&2;}
       ac_cache_corrupted=: ;;
     ,);;
     *)
       if test "x$ac_old_val" != "x$ac_new_val"; then
-	{ echo "$as_me:$LINENO: error: \`$ac_var' has changed since the previous run:" >&5
-echo "$as_me: error: \`$ac_var' has changed since the previous run:" >&2;}
-	{ echo "$as_me:$LINENO:   former value:  $ac_old_val" >&5
-echo "$as_me:   former value:  $ac_old_val" >&2;}
-	{ echo "$as_me:$LINENO:   current value: $ac_new_val" >&5
-echo "$as_me:   current value: $ac_new_val" >&2;}
+	# differences in whitespace do not lead to failure.
+	ac_old_val_w=`echo x $ac_old_val`
+	ac_new_val_w=`echo x $ac_new_val`
+	if test "$ac_old_val_w" != "$ac_new_val_w"; then
+	  { $as_echo "$as_me:$LINENO: error: \`$ac_var' has changed since the previous run:" >&5
+$as_echo "$as_me: error: \`$ac_var' has changed since the previous run:" >&2;}
 	ac_cache_corrupted=:
+	else
+	  { $as_echo "$as_me:$LINENO: warning: ignoring whitespace changes in \`$ac_var' since the previous run:" >&5
+$as_echo "$as_me: warning: ignoring whitespace changes in \`$ac_var' since the previous run:" >&2;}
+	  eval $ac_var=\$ac_old_val
+	fi
+	{ $as_echo "$as_me:$LINENO:   former value:  \`$ac_old_val'" >&5
+$as_echo "$as_me:   former value:  \`$ac_old_val'" >&2;}
+	{ $as_echo "$as_me:$LINENO:   current value: \`$ac_new_val'" >&5
+$as_echo "$as_me:   current value: \`$ac_new_val'" >&2;}
       fi;;
   esac
   # Pass precious variables to config.status.
   if test "$ac_new_set" = set; then
     case $ac_new_val in
-    *\'*) ac_arg=$ac_var=`echo "$ac_new_val" | sed "s/'/'\\\\\\\\''/g"` ;;
+    *\'*) ac_arg=$ac_var=`$as_echo "$ac_new_val" | sed "s/'/'\\\\\\\\''/g"` ;;
     *) ac_arg=$ac_var=$ac_new_val ;;
     esac
     case " $ac_configure_args " in
@@ -1696,10 +1825,12 @@ echo "$as_me:   current value: $ac_new_v
   fi
 done
 if $ac_cache_corrupted; then
-  { echo "$as_me:$LINENO: error: changes in the environment can compromise the build" >&5
-echo "$as_me: error: changes in the environment can compromise the build" >&2;}
-  { { echo "$as_me:$LINENO: error: run \`make distclean' and/or \`rm $cache_file' and start over" >&5
-echo "$as_me: error: run \`make distclean' and/or \`rm $cache_file' and start over" >&2;}
+  { $as_echo "$as_me:$LINENO: error: in \`$ac_pwd':" >&5
+$as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
+  { $as_echo "$as_me:$LINENO: error: changes in the environment can compromise the build" >&5
+$as_echo "$as_me: error: changes in the environment can compromise the build" >&2;}
+  { { $as_echo "$as_me:$LINENO: error: run \`make distclean' and/or \`rm $cache_file' and start over" >&5
+$as_echo "$as_me: error: run \`make distclean' and/or \`rm $cache_file' and start over" >&2;}
    { (exit 1); exit 1; }; }
 fi
 
@@ -1736,11 +1867,16 @@ ac_compiler_gnu=$ac_cv_c_compiler_gnu
 
 
 
-{ echo "$as_me:$LINENO: checking whether ${MAKE-make} sets \$(MAKE)" >&5
-echo $ECHO_N "checking whether ${MAKE-make} sets \$(MAKE)... $ECHO_C" >&6; }
-set x ${MAKE-make}; ac_make=`echo "$2" | sed 's/+/p/g; s/[^a-zA-Z0-9_]/_/g'`
+
+
+
+
+{ $as_echo "$as_me:$LINENO: checking whether ${MAKE-make} sets \$(MAKE)" >&5
+$as_echo_n "checking whether ${MAKE-make} sets \$(MAKE)... " >&6; }
+set x ${MAKE-make}
+ac_make=`$as_echo "$2" | sed 's/+/p/g; s/[^a-zA-Z0-9_]/_/g'`
 if { as_var=ac_cv_prog_make_${ac_make}_set; eval "test \"\${$as_var+set}\" = set"; }; then
-  echo $ECHO_N "(cached) $ECHO_C" >&6
+  $as_echo_n "(cached) " >&6
 else
   cat >conftest.make <<\_ACEOF
 SHELL = /bin/sh
@@ -1757,12 +1893,12 @@ esac
 rm -f conftest.make
 fi
 if eval test \$ac_cv_prog_make_${ac_make}_set = yes; then
-  { echo "$as_me:$LINENO: result: yes" >&5
-echo "${ECHO_T}yes" >&6; }
+  { $as_echo "$as_me:$LINENO: result: yes" >&5
+$as_echo "yes" >&6; }
   SET_MAKE=
 else
-  { echo "$as_me:$LINENO: result: no" >&5
-echo "${ECHO_T}no" >&6; }
+  { $as_echo "$as_me:$LINENO: result: no" >&5
+$as_echo "no" >&6; }
   SET_MAKE="MAKE=${MAKE-make}"
 fi
 
@@ -1770,10 +1906,10 @@ for ac_prog in gawk mawk nawk awk
 do
   # Extract the first word of "$ac_prog", so it can be a program name with args.
 set dummy $ac_prog; ac_word=$2
-{ echo "$as_me:$LINENO: checking for $ac_word" >&5
-echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6; }
+{ $as_echo "$as_me:$LINENO: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
 if test "${ac_cv_prog_AWK+set}" = set; then
-  echo $ECHO_N "(cached) $ECHO_C" >&6
+  $as_echo_n "(cached) " >&6
 else
   if test -n "$AWK"; then
   ac_cv_prog_AWK="$AWK" # Let the user override the test.
@@ -1786,7 +1922,7 @@ do
   for ac_exec_ext in '' $ac_executable_extensions; do
   if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
     ac_cv_prog_AWK="$ac_prog"
-    echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
+    $as_echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
     break 2
   fi
 done
@@ -1797,11 +1933,11 @@ fi
 fi
 AWK=$ac_cv_prog_AWK
 if test -n "$AWK"; then
-  { echo "$as_me:$LINENO: result: $AWK" >&5
-echo "${ECHO_T}$AWK" >&6; }
+  { $as_echo "$as_me:$LINENO: result: $AWK" >&5
+$as_echo "$AWK" >&6; }
 else
-  { echo "$as_me:$LINENO: result: no" >&5
-echo "${ECHO_T}no" >&6; }
+  { $as_echo "$as_me:$LINENO: result: no" >&5
+$as_echo "no" >&6; }
 fi
 
 
@@ -1816,10 +1952,10 @@ ac_compiler_gnu=$ac_cv_c_compiler_gnu
 if test -n "$ac_tool_prefix"; then
   # Extract the first word of "${ac_tool_prefix}gcc", so it can be a program name with args.
 set dummy ${ac_tool_prefix}gcc; ac_word=$2
-{ echo "$as_me:$LINENO: checking for $ac_word" >&5
-echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6; }
+{ $as_echo "$as_me:$LINENO: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
 if test "${ac_cv_prog_CC+set}" = set; then
-  echo $ECHO_N "(cached) $ECHO_C" >&6
+  $as_echo_n "(cached) " >&6
 else
   if test -n "$CC"; then
   ac_cv_prog_CC="$CC" # Let the user override the test.
@@ -1832,7 +1968,7 @@ do
   for ac_exec_ext in '' $ac_executable_extensions; do
   if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
     ac_cv_prog_CC="${ac_tool_prefix}gcc"
-    echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
+    $as_echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
     break 2
   fi
 done
@@ -1843,11 +1979,11 @@ fi
 fi
 CC=$ac_cv_prog_CC
 if test -n "$CC"; then
-  { echo "$as_me:$LINENO: result: $CC" >&5
-echo "${ECHO_T}$CC" >&6; }
+  { $as_echo "$as_me:$LINENO: result: $CC" >&5
+$as_echo "$CC" >&6; }
 else
-  { echo "$as_me:$LINENO: result: no" >&5
-echo "${ECHO_T}no" >&6; }
+  { $as_echo "$as_me:$LINENO: result: no" >&5
+$as_echo "no" >&6; }
 fi
 
 
@@ -1856,10 +1992,10 @@ if test -z "$ac_cv_prog_CC"; then
   ac_ct_CC=$CC
   # Extract the first word of "gcc", so it can be a program name with args.
 set dummy gcc; ac_word=$2
-{ echo "$as_me:$LINENO: checking for $ac_word" >&5
-echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6; }
+{ $as_echo "$as_me:$LINENO: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
 if test "${ac_cv_prog_ac_ct_CC+set}" = set; then
-  echo $ECHO_N "(cached) $ECHO_C" >&6
+  $as_echo_n "(cached) " >&6
 else
   if test -n "$ac_ct_CC"; then
   ac_cv_prog_ac_ct_CC="$ac_ct_CC" # Let the user override the test.
@@ -1872,7 +2008,7 @@ do
   for ac_exec_ext in '' $ac_executable_extensions; do
   if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
     ac_cv_prog_ac_ct_CC="gcc"
-    echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
+    $as_echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
     break 2
   fi
 done
@@ -1883,11 +2019,11 @@ fi
 fi
 ac_ct_CC=$ac_cv_prog_ac_ct_CC
 if test -n "$ac_ct_CC"; then
-  { echo "$as_me:$LINENO: result: $ac_ct_CC" >&5
-echo "${ECHO_T}$ac_ct_CC" >&6; }
+  { $as_echo "$as_me:$LINENO: result: $ac_ct_CC" >&5
+$as_echo "$ac_ct_CC" >&6; }
 else
-  { echo "$as_me:$LINENO: result: no" >&5
-echo "${ECHO_T}no" >&6; }
+  { $as_echo "$as_me:$LINENO: result: no" >&5
+$as_echo "no" >&6; }
 fi
 
   if test "x$ac_ct_CC" = x; then
@@ -1895,12 +2031,8 @@ fi
   else
     case $cross_compiling:$ac_tool_warned in
 yes:)
-{ echo "$as_me:$LINENO: WARNING: In the future, Autoconf will not detect cross-tools
-whose name does not start with the host triplet.  If you think this
-configuration is useful to you, please write to autoconf@gnu.org." >&5
-echo "$as_me: WARNING: In the future, Autoconf will not detect cross-tools
-whose name does not start with the host triplet.  If you think this
-configuration is useful to you, please write to autoconf@gnu.org." >&2;}
+{ $as_echo "$as_me:$LINENO: WARNING: using cross tools not prefixed with host triplet" >&5
+$as_echo "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
 ac_tool_warned=yes ;;
 esac
     CC=$ac_ct_CC
@@ -1913,10 +2045,10 @@ if test -z "$CC"; then
           if test -n "$ac_tool_prefix"; then
     # Extract the first word of "${ac_tool_prefix}cc", so it can be a program name with args.
 set dummy ${ac_tool_prefix}cc; ac_word=$2
-{ echo "$as_me:$LINENO: checking for $ac_word" >&5
-echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6; }
+{ $as_echo "$as_me:$LINENO: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
 if test "${ac_cv_prog_CC+set}" = set; then
-  echo $ECHO_N "(cached) $ECHO_C" >&6
+  $as_echo_n "(cached) " >&6
 else
   if test -n "$CC"; then
   ac_cv_prog_CC="$CC" # Let the user override the test.
@@ -1929,7 +2061,7 @@ do
   for ac_exec_ext in '' $ac_executable_extensions; do
   if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
     ac_cv_prog_CC="${ac_tool_prefix}cc"
-    echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
+    $as_echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
     break 2
   fi
 done
@@ -1940,11 +2072,11 @@ fi
 fi
 CC=$ac_cv_prog_CC
 if test -n "$CC"; then
-  { echo "$as_me:$LINENO: result: $CC" >&5
-echo "${ECHO_T}$CC" >&6; }
+  { $as_echo "$as_me:$LINENO: result: $CC" >&5
+$as_echo "$CC" >&6; }
 else
-  { echo "$as_me:$LINENO: result: no" >&5
-echo "${ECHO_T}no" >&6; }
+  { $as_echo "$as_me:$LINENO: result: no" >&5
+$as_echo "no" >&6; }
 fi
 
 
@@ -1953,10 +2085,10 @@ fi
 if test -z "$CC"; then
   # Extract the first word of "cc", so it can be a program name with args.
 set dummy cc; ac_word=$2
-{ echo "$as_me:$LINENO: checking for $ac_word" >&5
-echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6; }
+{ $as_echo "$as_me:$LINENO: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
 if test "${ac_cv_prog_CC+set}" = set; then
-  echo $ECHO_N "(cached) $ECHO_C" >&6
+  $as_echo_n "(cached) " >&6
 else
   if test -n "$CC"; then
   ac_cv_prog_CC="$CC" # Let the user override the test.
@@ -1974,7 +2106,7 @@ do
        continue
      fi
     ac_cv_prog_CC="cc"
-    echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
+    $as_echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
     break 2
   fi
 done
@@ -1997,11 +2129,11 @@ fi
 fi
 CC=$ac_cv_prog_CC
 if test -n "$CC"; then
-  { echo "$as_me:$LINENO: result: $CC" >&5
-echo "${ECHO_T}$CC" >&6; }
+  { $as_echo "$as_me:$LINENO: result: $CC" >&5
+$as_echo "$CC" >&6; }
 else
-  { echo "$as_me:$LINENO: result: no" >&5
-echo "${ECHO_T}no" >&6; }
+  { $as_echo "$as_me:$LINENO: result: no" >&5
+$as_echo "no" >&6; }
 fi
 
 
@@ -2012,10 +2144,10 @@ if test -z "$CC"; then
   do
     # Extract the first word of "$ac_tool_prefix$ac_prog", so it can be a program name with args.
 set dummy $ac_tool_prefix$ac_prog; ac_word=$2
-{ echo "$as_me:$LINENO: checking for $ac_word" >&5
-echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6; }
+{ $as_echo "$as_me:$LINENO: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
 if test "${ac_cv_prog_CC+set}" = set; then
-  echo $ECHO_N "(cached) $ECHO_C" >&6
+  $as_echo_n "(cached) " >&6
 else
   if test -n "$CC"; then
   ac_cv_prog_CC="$CC" # Let the user override the test.
@@ -2028,7 +2160,7 @@ do
   for ac_exec_ext in '' $ac_executable_extensions; do
   if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
     ac_cv_prog_CC="$ac_tool_prefix$ac_prog"
-    echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
+    $as_echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
     break 2
   fi
 done
@@ -2039,11 +2171,11 @@ fi
 fi
 CC=$ac_cv_prog_CC
 if test -n "$CC"; then
-  { echo "$as_me:$LINENO: result: $CC" >&5
-echo "${ECHO_T}$CC" >&6; }
+  { $as_echo "$as_me:$LINENO: result: $CC" >&5
+$as_echo "$CC" >&6; }
 else
-  { echo "$as_me:$LINENO: result: no" >&5
-echo "${ECHO_T}no" >&6; }
+  { $as_echo "$as_me:$LINENO: result: no" >&5
+$as_echo "no" >&6; }
 fi
 
 
@@ -2056,10 +2188,10 @@ if test -z "$CC"; then
 do
   # Extract the first word of "$ac_prog", so it can be a program name with args.
 set dummy $ac_prog; ac_word=$2
-{ echo "$as_me:$LINENO: checking for $ac_word" >&5
-echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6; }
+{ $as_echo "$as_me:$LINENO: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
 if test "${ac_cv_prog_ac_ct_CC+set}" = set; then
-  echo $ECHO_N "(cached) $ECHO_C" >&6
+  $as_echo_n "(cached) " >&6
 else
   if test -n "$ac_ct_CC"; then
   ac_cv_prog_ac_ct_CC="$ac_ct_CC" # Let the user override the test.
@@ -2072,7 +2204,7 @@ do
   for ac_exec_ext in '' $ac_executable_extensions; do
   if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
     ac_cv_prog_ac_ct_CC="$ac_prog"
-    echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
+    $as_echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
     break 2
   fi
 done
@@ -2083,11 +2215,11 @@ fi
 fi
 ac_ct_CC=$ac_cv_prog_ac_ct_CC
 if test -n "$ac_ct_CC"; then
-  { echo "$as_me:$LINENO: result: $ac_ct_CC" >&5
-echo "${ECHO_T}$ac_ct_CC" >&6; }
+  { $as_echo "$as_me:$LINENO: result: $ac_ct_CC" >&5
+$as_echo "$ac_ct_CC" >&6; }
 else
-  { echo "$as_me:$LINENO: result: no" >&5
-echo "${ECHO_T}no" >&6; }
+  { $as_echo "$as_me:$LINENO: result: no" >&5
+$as_echo "no" >&6; }
 fi
 
 
@@ -2099,12 +2231,8 @@ done
   else
     case $cross_compiling:$ac_tool_warned in
 yes:)
-{ echo "$as_me:$LINENO: WARNING: In the future, Autoconf will not detect cross-tools
-whose name does not start with the host triplet.  If you think this
-configuration is useful to you, please write to autoconf@gnu.org." >&5
-echo "$as_me: WARNING: In the future, Autoconf will not detect cross-tools
-whose name does not start with the host triplet.  If you think this
-configuration is useful to you, please write to autoconf@gnu.org." >&2;}
+{ $as_echo "$as_me:$LINENO: WARNING: using cross tools not prefixed with host triplet" >&5
+$as_echo "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
 ac_tool_warned=yes ;;
 esac
     CC=$ac_ct_CC
@@ -2114,44 +2242,50 @@ fi
 fi
 
 
-test -z "$CC" && { { echo "$as_me:$LINENO: error: no acceptable C compiler found in \$PATH
+test -z "$CC" && { { $as_echo "$as_me:$LINENO: error: in \`$ac_pwd':" >&5
+$as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
+{ { $as_echo "$as_me:$LINENO: error: no acceptable C compiler found in \$PATH
 See \`config.log' for more details." >&5
-echo "$as_me: error: no acceptable C compiler found in \$PATH
+$as_echo "$as_me: error: no acceptable C compiler found in \$PATH
 See \`config.log' for more details." >&2;}
-   { (exit 1); exit 1; }; }
+   { (exit 1); exit 1; }; }; }
 
 # Provide some information about the compiler.
-echo "$as_me:$LINENO: checking for C compiler version" >&5
-ac_compiler=`set X $ac_compile; echo $2`
+$as_echo "$as_me:$LINENO: checking for C compiler version" >&5
+set X $ac_compile
+ac_compiler=$2
 { (ac_try="$ac_compiler --version >&5"
 case "(($ac_try" in
   *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
   *) ac_try_echo=$ac_try;;
 esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
   (eval "$ac_compiler --version >&5") 2>&5
   ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }
 { (ac_try="$ac_compiler -v >&5"
 case "(($ac_try" in
   *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
   *) ac_try_echo=$ac_try;;
 esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
   (eval "$ac_compiler -v >&5") 2>&5
   ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }
 { (ac_try="$ac_compiler -V >&5"
 case "(($ac_try" in
   *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
   *) ac_try_echo=$ac_try;;
 esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
   (eval "$ac_compiler -V >&5") 2>&5
   ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }
 
 cat >conftest.$ac_ext <<_ACEOF
@@ -2170,27 +2304,22 @@ main ()
 }
 _ACEOF
 ac_clean_files_save=$ac_clean_files
-ac_clean_files="$ac_clean_files a.out a.exe b.out"
+ac_clean_files="$ac_clean_files a.out a.out.dSYM a.exe b.out"
 # Try to create an executable without -o first, disregard a.out.
 # It will help us diagnose broken compilers, and finding out an intuition
 # of exeext.
-{ echo "$as_me:$LINENO: checking for C compiler default output file name" >&5
-echo $ECHO_N "checking for C compiler default output file name... $ECHO_C" >&6; }
-ac_link_default=`echo "$ac_link" | sed 's/ -o *conftest[^ ]*//'`
-#
-# List of possible output files, starting from the most likely.
-# The algorithm is not robust to junk in `.', hence go to wildcards (a.*)
-# only as a last resort.  b.out is created by i960 compilers.
-ac_files='a_out.exe a.exe conftest.exe a.out conftest a.* conftest.* b.out'
-#
-# The IRIX 6 linker writes into existing files which may not be
-# executable, retaining their permissions.  Remove them first so a
-# subsequent execution test works.
+{ $as_echo "$as_me:$LINENO: checking for C compiler default output file name" >&5
+$as_echo_n "checking for C compiler default output file name... " >&6; }
+ac_link_default=`$as_echo "$ac_link" | sed 's/ -o *conftest[^ ]*//'`
+
+# The possible output files:
+ac_files="a.out conftest.exe conftest a.exe a_out.exe b.out conftest.*"
+
 ac_rmfiles=
 for ac_file in $ac_files
 do
   case $ac_file in
-    *.$ac_ext | *.xcoff | *.tds | *.d | *.pdb | *.xSYM | *.bb | *.bbg | *.map | *.inf | *.o | *.obj ) ;;
+    *.$ac_ext | *.xcoff | *.tds | *.d | *.pdb | *.xSYM | *.bb | *.bbg | *.map | *.inf | *.dSYM | *.o | *.obj ) ;;
     * ) ac_rmfiles="$ac_rmfiles $ac_file";;
   esac
 done
@@ -2201,10 +2330,11 @@ case "(($ac_try" in
   *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
   *) ac_try_echo=$ac_try;;
 esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
   (eval "$ac_link_default") 2>&5
   ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }; then
   # Autoconf-2.13 could set the ac_cv_exeext variable to `no'.
 # So ignore a value of `no', otherwise this would lead to `EXEEXT = no'
@@ -2215,7 +2345,7 @@ for ac_file in $ac_files ''
 do
   test -f "$ac_file" || continue
   case $ac_file in
-    *.$ac_ext | *.xcoff | *.tds | *.d | *.pdb | *.xSYM | *.bb | *.bbg | *.map | *.inf | *.o | *.obj )
+    *.$ac_ext | *.xcoff | *.tds | *.d | *.pdb | *.xSYM | *.bb | *.bbg | *.map | *.inf | *.dSYM | *.o | *.obj )
 	;;
     [ab].out )
 	# We found the default executable, but exeext='' is most
@@ -2242,25 +2372,27 @@ else
   ac_file=''
 fi
 
-{ echo "$as_me:$LINENO: result: $ac_file" >&5
-echo "${ECHO_T}$ac_file" >&6; }
+{ $as_echo "$as_me:$LINENO: result: $ac_file" >&5
+$as_echo "$ac_file" >&6; }
 if test -z "$ac_file"; then
-  echo "$as_me: failed program was:" >&5
+  $as_echo "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
-{ { echo "$as_me:$LINENO: error: C compiler cannot create executables
+{ { $as_echo "$as_me:$LINENO: error: in \`$ac_pwd':" >&5
+$as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
+{ { $as_echo "$as_me:$LINENO: error: C compiler cannot create executables
 See \`config.log' for more details." >&5
-echo "$as_me: error: C compiler cannot create executables
+$as_echo "$as_me: error: C compiler cannot create executables
 See \`config.log' for more details." >&2;}
-   { (exit 77); exit 77; }; }
+   { (exit 77); exit 77; }; }; }
 fi
 
 ac_exeext=$ac_cv_exeext
 
 # Check that the compiler produces executables we can run.  If not, either
 # the compiler is broken, or we cross compile.
-{ echo "$as_me:$LINENO: checking whether the C compiler works" >&5
-echo $ECHO_N "checking whether the C compiler works... $ECHO_C" >&6; }
+{ $as_echo "$as_me:$LINENO: checking whether the C compiler works" >&5
+$as_echo_n "checking whether the C compiler works... " >&6; }
 # FIXME: These cross compiler hacks should be removed for Autoconf 3.0
 # If not cross compiling, check that we can run a simple program.
 if test "$cross_compiling" != yes; then
@@ -2269,49 +2401,53 @@ if test "$cross_compiling" != yes; then
   *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
   *) ac_try_echo=$ac_try;;
 esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
   (eval "$ac_try") 2>&5
   ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
     cross_compiling=no
   else
     if test "$cross_compiling" = maybe; then
 	cross_compiling=yes
     else
-	{ { echo "$as_me:$LINENO: error: cannot run C compiled programs.
+	{ { $as_echo "$as_me:$LINENO: error: in \`$ac_pwd':" >&5
+$as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
+{ { $as_echo "$as_me:$LINENO: error: cannot run C compiled programs.
 If you meant to cross compile, use \`--host'.
 See \`config.log' for more details." >&5
-echo "$as_me: error: cannot run C compiled programs.
+$as_echo "$as_me: error: cannot run C compiled programs.
 If you meant to cross compile, use \`--host'.
 See \`config.log' for more details." >&2;}
-   { (exit 1); exit 1; }; }
+   { (exit 1); exit 1; }; }; }
     fi
   fi
 fi
-{ echo "$as_me:$LINENO: result: yes" >&5
-echo "${ECHO_T}yes" >&6; }
+{ $as_echo "$as_me:$LINENO: result: yes" >&5
+$as_echo "yes" >&6; }
 
-rm -f a.out a.exe conftest$ac_cv_exeext b.out
+rm -f -r a.out a.out.dSYM a.exe conftest$ac_cv_exeext b.out
 ac_clean_files=$ac_clean_files_save
 # Check that the compiler produces executables we can run.  If not, either
 # the compiler is broken, or we cross compile.
-{ echo "$as_me:$LINENO: checking whether we are cross compiling" >&5
-echo $ECHO_N "checking whether we are cross compiling... $ECHO_C" >&6; }
-{ echo "$as_me:$LINENO: result: $cross_compiling" >&5
-echo "${ECHO_T}$cross_compiling" >&6; }
+{ $as_echo "$as_me:$LINENO: checking whether we are cross compiling" >&5
+$as_echo_n "checking whether we are cross compiling... " >&6; }
+{ $as_echo "$as_me:$LINENO: result: $cross_compiling" >&5
+$as_echo "$cross_compiling" >&6; }
 
-{ echo "$as_me:$LINENO: checking for suffix of executables" >&5
-echo $ECHO_N "checking for suffix of executables... $ECHO_C" >&6; }
+{ $as_echo "$as_me:$LINENO: checking for suffix of executables" >&5
+$as_echo_n "checking for suffix of executables... " >&6; }
 if { (ac_try="$ac_link"
 case "(($ac_try" in
   *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
   *) ac_try_echo=$ac_try;;
 esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
   (eval "$ac_link") 2>&5
   ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }; then
   # If both `conftest.exe' and `conftest' are `present' (well, observable)
 # catch `conftest.exe'.  For instance with Cygwin, `ls conftest' will
@@ -2320,31 +2456,33 @@ eval "echo \"\$as_me:$LINENO: $ac_try_ec
 for ac_file in conftest.exe conftest conftest.*; do
   test -f "$ac_file" || continue
   case $ac_file in
-    *.$ac_ext | *.xcoff | *.tds | *.d | *.pdb | *.xSYM | *.bb | *.bbg | *.map | *.inf | *.o | *.obj ) ;;
+    *.$ac_ext | *.xcoff | *.tds | *.d | *.pdb | *.xSYM | *.bb | *.bbg | *.map | *.inf | *.dSYM | *.o | *.obj ) ;;
     *.* ) ac_cv_exeext=`expr "$ac_file" : '[^.]*\(\..*\)'`
 	  break;;
     * ) break;;
   esac
 done
 else
-  { { echo "$as_me:$LINENO: error: cannot compute suffix of executables: cannot compile and link
+  { { $as_echo "$as_me:$LINENO: error: in \`$ac_pwd':" >&5
+$as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
+{ { $as_echo "$as_me:$LINENO: error: cannot compute suffix of executables: cannot compile and link
 See \`config.log' for more details." >&5
-echo "$as_me: error: cannot compute suffix of executables: cannot compile and link
+$as_echo "$as_me: error: cannot compute suffix of executables: cannot compile and link
 See \`config.log' for more details." >&2;}
-   { (exit 1); exit 1; }; }
+   { (exit 1); exit 1; }; }; }
 fi
 
 rm -f conftest$ac_cv_exeext
-{ echo "$as_me:$LINENO: result: $ac_cv_exeext" >&5
-echo "${ECHO_T}$ac_cv_exeext" >&6; }
+{ $as_echo "$as_me:$LINENO: result: $ac_cv_exeext" >&5
+$as_echo "$ac_cv_exeext" >&6; }
 
 rm -f conftest.$ac_ext
 EXEEXT=$ac_cv_exeext
 ac_exeext=$EXEEXT
-{ echo "$as_me:$LINENO: checking for suffix of object files" >&5
-echo $ECHO_N "checking for suffix of object files... $ECHO_C" >&6; }
+{ $as_echo "$as_me:$LINENO: checking for suffix of object files" >&5
+$as_echo_n "checking for suffix of object files... " >&6; }
 if test "${ac_cv_objext+set}" = set; then
-  echo $ECHO_N "(cached) $ECHO_C" >&6
+  $as_echo_n "(cached) " >&6
 else
   cat >conftest.$ac_ext <<_ACEOF
 /* confdefs.h.  */
@@ -2367,40 +2505,43 @@ case "(($ac_try" in
   *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
   *) ac_try_echo=$ac_try;;
 esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
   (eval "$ac_compile") 2>&5
   ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }; then
   for ac_file in conftest.o conftest.obj conftest.*; do
   test -f "$ac_file" || continue;
   case $ac_file in
-    *.$ac_ext | *.xcoff | *.tds | *.d | *.pdb | *.xSYM | *.bb | *.bbg | *.map | *.inf ) ;;
+    *.$ac_ext | *.xcoff | *.tds | *.d | *.pdb | *.xSYM | *.bb | *.bbg | *.map | *.inf | *.dSYM ) ;;
     *) ac_cv_objext=`expr "$ac_file" : '.*\.\(.*\)'`
        break;;
   esac
 done
 else
-  echo "$as_me: failed program was:" >&5
+  $as_echo "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
-{ { echo "$as_me:$LINENO: error: cannot compute suffix of object files: cannot compile
+{ { $as_echo "$as_me:$LINENO: error: in \`$ac_pwd':" >&5
+$as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
+{ { $as_echo "$as_me:$LINENO: error: cannot compute suffix of object files: cannot compile
 See \`config.log' for more details." >&5
-echo "$as_me: error: cannot compute suffix of object files: cannot compile
+$as_echo "$as_me: error: cannot compute suffix of object files: cannot compile
 See \`config.log' for more details." >&2;}
-   { (exit 1); exit 1; }; }
+   { (exit 1); exit 1; }; }; }
 fi
 
 rm -f conftest.$ac_cv_objext conftest.$ac_ext
 fi
-{ echo "$as_me:$LINENO: result: $ac_cv_objext" >&5
-echo "${ECHO_T}$ac_cv_objext" >&6; }
+{ $as_echo "$as_me:$LINENO: result: $ac_cv_objext" >&5
+$as_echo "$ac_cv_objext" >&6; }
 OBJEXT=$ac_cv_objext
 ac_objext=$OBJEXT
-{ echo "$as_me:$LINENO: checking whether we are using the GNU C compiler" >&5
-echo $ECHO_N "checking whether we are using the GNU C compiler... $ECHO_C" >&6; }
+{ $as_echo "$as_me:$LINENO: checking whether we are using the GNU C compiler" >&5
+$as_echo_n "checking whether we are using the GNU C compiler... " >&6; }
 if test "${ac_cv_c_compiler_gnu+set}" = set; then
-  echo $ECHO_N "(cached) $ECHO_C" >&6
+  $as_echo_n "(cached) " >&6
 else
   cat >conftest.$ac_ext <<_ACEOF
 /* confdefs.h.  */
@@ -2426,20 +2567,21 @@ case "(($ac_try" in
   *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
   *) ac_try_echo=$ac_try;;
 esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
   (eval "$ac_compile") 2>conftest.er1
   ac_status=$?
   grep -v '^ *+' conftest.er1 >conftest.err
   rm -f conftest.er1
   cat conftest.err >&5
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } && {
 	 test -z "$ac_c_werror_flag" ||
 	 test ! -s conftest.err
        } && test -s conftest.$ac_objext; then
   ac_compiler_gnu=yes
 else
-  echo "$as_me: failed program was:" >&5
+  $as_echo "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
 	ac_compiler_gnu=no
@@ -2449,15 +2591,19 @@ rm -f core conftest.err conftest.$ac_obj
 ac_cv_c_compiler_gnu=$ac_compiler_gnu
 
 fi
-{ echo "$as_me:$LINENO: result: $ac_cv_c_compiler_gnu" >&5
-echo "${ECHO_T}$ac_cv_c_compiler_gnu" >&6; }
-GCC=`test $ac_compiler_gnu = yes && echo yes`
+{ $as_echo "$as_me:$LINENO: result: $ac_cv_c_compiler_gnu" >&5
+$as_echo "$ac_cv_c_compiler_gnu" >&6; }
+if test $ac_compiler_gnu = yes; then
+  GCC=yes
+else
+  GCC=
+fi
 ac_test_CFLAGS=${CFLAGS+set}
 ac_save_CFLAGS=$CFLAGS
-{ echo "$as_me:$LINENO: checking whether $CC accepts -g" >&5
-echo $ECHO_N "checking whether $CC accepts -g... $ECHO_C" >&6; }
+{ $as_echo "$as_me:$LINENO: checking whether $CC accepts -g" >&5
+$as_echo_n "checking whether $CC accepts -g... " >&6; }
 if test "${ac_cv_prog_cc_g+set}" = set; then
-  echo $ECHO_N "(cached) $ECHO_C" >&6
+  $as_echo_n "(cached) " >&6
 else
   ac_save_c_werror_flag=$ac_c_werror_flag
    ac_c_werror_flag=yes
@@ -2484,20 +2630,21 @@ case "(($ac_try" in
   *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
   *) ac_try_echo=$ac_try;;
 esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
   (eval "$ac_compile") 2>conftest.er1
   ac_status=$?
   grep -v '^ *+' conftest.er1 >conftest.err
   rm -f conftest.er1
   cat conftest.err >&5
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } && {
 	 test -z "$ac_c_werror_flag" ||
 	 test ! -s conftest.err
        } && test -s conftest.$ac_objext; then
   ac_cv_prog_cc_g=yes
 else
-  echo "$as_me: failed program was:" >&5
+  $as_echo "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
 	CFLAGS=""
@@ -2522,20 +2669,21 @@ case "(($ac_try" in
   *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
   *) ac_try_echo=$ac_try;;
 esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
   (eval "$ac_compile") 2>conftest.er1
   ac_status=$?
   grep -v '^ *+' conftest.er1 >conftest.err
   rm -f conftest.er1
   cat conftest.err >&5
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } && {
 	 test -z "$ac_c_werror_flag" ||
 	 test ! -s conftest.err
        } && test -s conftest.$ac_objext; then
   :
 else
-  echo "$as_me: failed program was:" >&5
+  $as_echo "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
 	ac_c_werror_flag=$ac_save_c_werror_flag
@@ -2561,20 +2709,21 @@ case "(($ac_try" in
   *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
   *) ac_try_echo=$ac_try;;
 esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
   (eval "$ac_compile") 2>conftest.er1
   ac_status=$?
   grep -v '^ *+' conftest.er1 >conftest.err
   rm -f conftest.er1
   cat conftest.err >&5
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } && {
 	 test -z "$ac_c_werror_flag" ||
 	 test ! -s conftest.err
        } && test -s conftest.$ac_objext; then
   ac_cv_prog_cc_g=yes
 else
-  echo "$as_me: failed program was:" >&5
+  $as_echo "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
 
@@ -2589,8 +2738,8 @@ fi
 rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
    ac_c_werror_flag=$ac_save_c_werror_flag
 fi
-{ echo "$as_me:$LINENO: result: $ac_cv_prog_cc_g" >&5
-echo "${ECHO_T}$ac_cv_prog_cc_g" >&6; }
+{ $as_echo "$as_me:$LINENO: result: $ac_cv_prog_cc_g" >&5
+$as_echo "$ac_cv_prog_cc_g" >&6; }
 if test "$ac_test_CFLAGS" = set; then
   CFLAGS=$ac_save_CFLAGS
 elif test $ac_cv_prog_cc_g = yes; then
@@ -2606,10 +2755,10 @@ else
     CFLAGS=
   fi
 fi
-{ echo "$as_me:$LINENO: checking for $CC option to accept ISO C89" >&5
-echo $ECHO_N "checking for $CC option to accept ISO C89... $ECHO_C" >&6; }
+{ $as_echo "$as_me:$LINENO: checking for $CC option to accept ISO C89" >&5
+$as_echo_n "checking for $CC option to accept ISO C89... " >&6; }
 if test "${ac_cv_prog_cc_c89+set}" = set; then
-  echo $ECHO_N "(cached) $ECHO_C" >&6
+  $as_echo_n "(cached) " >&6
 else
   ac_cv_prog_cc_c89=no
 ac_save_CC=$CC
@@ -2680,20 +2829,21 @@ case "(($ac_try" in
   *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
   *) ac_try_echo=$ac_try;;
 esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
   (eval "$ac_compile") 2>conftest.er1
   ac_status=$?
   grep -v '^ *+' conftest.er1 >conftest.err
   rm -f conftest.er1
   cat conftest.err >&5
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } && {
 	 test -z "$ac_c_werror_flag" ||
 	 test ! -s conftest.err
        } && test -s conftest.$ac_objext; then
   ac_cv_prog_cc_c89=$ac_arg
 else
-  echo "$as_me: failed program was:" >&5
+  $as_echo "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
 
@@ -2709,15 +2859,15 @@ fi
 # AC_CACHE_VAL
 case "x$ac_cv_prog_cc_c89" in
   x)
-    { echo "$as_me:$LINENO: result: none needed" >&5
-echo "${ECHO_T}none needed" >&6; } ;;
+    { $as_echo "$as_me:$LINENO: result: none needed" >&5
+$as_echo "none needed" >&6; } ;;
   xno)
-    { echo "$as_me:$LINENO: result: unsupported" >&5
-echo "${ECHO_T}unsupported" >&6; } ;;
+    { $as_echo "$as_me:$LINENO: result: unsupported" >&5
+$as_echo "unsupported" >&6; } ;;
   *)
     CC="$CC $ac_cv_prog_cc_c89"
-    { echo "$as_me:$LINENO: result: $ac_cv_prog_cc_c89" >&5
-echo "${ECHO_T}$ac_cv_prog_cc_c89" >&6; } ;;
+    { $as_echo "$as_me:$LINENO: result: $ac_cv_prog_cc_c89" >&5
+$as_echo "$ac_cv_prog_cc_c89" >&6; } ;;
 esac
 
 
@@ -2744,8 +2894,8 @@ for ac_dir in "$srcdir" "$srcdir/.." "$s
   fi
 done
 if test -z "$ac_aux_dir"; then
-  { { echo "$as_me:$LINENO: error: cannot find install-sh or install.sh in \"$srcdir\" \"$srcdir/..\" \"$srcdir/../..\"" >&5
-echo "$as_me: error: cannot find install-sh or install.sh in \"$srcdir\" \"$srcdir/..\" \"$srcdir/../..\"" >&2;}
+  { { $as_echo "$as_me:$LINENO: error: cannot find install-sh or install.sh in \"$srcdir\" \"$srcdir/..\" \"$srcdir/../..\"" >&5
+$as_echo "$as_me: error: cannot find install-sh or install.sh in \"$srcdir\" \"$srcdir/..\" \"$srcdir/../..\"" >&2;}
    { (exit 1); exit 1; }; }
 fi
 
@@ -2771,11 +2921,12 @@ ac_configure="$SHELL $ac_aux_dir/configu
 # SVR4 /usr/ucb/install, which tries to use the nonexistent group "staff"
 # OS/2's system install, which has a completely different semantic
 # ./install, which can be erroneously created by make from ./install.sh.
-{ echo "$as_me:$LINENO: checking for a BSD-compatible install" >&5
-echo $ECHO_N "checking for a BSD-compatible install... $ECHO_C" >&6; }
+# Reject install programs that cannot install multiple files.
+{ $as_echo "$as_me:$LINENO: checking for a BSD-compatible install" >&5
+$as_echo_n "checking for a BSD-compatible install... " >&6; }
 if test -z "$INSTALL"; then
 if test "${ac_cv_path_install+set}" = set; then
-  echo $ECHO_N "(cached) $ECHO_C" >&6
+  $as_echo_n "(cached) " >&6
 else
   as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
 for as_dir in $PATH
@@ -2804,10 +2955,20 @@ case $as_dir/ in
 	    # program-specific install script used by HP pwplus--don't use.
 	    :
 	  else
+	    rm -rf conftest.one conftest.two conftest.dir
+	    echo one > conftest.one
+	    echo two > conftest.two
+	    mkdir conftest.dir
+	    if "$as_dir/$ac_prog$ac_exec_ext" -c conftest.one conftest.two "`pwd`/conftest.dir" &&
+	      test -s conftest.one && test -s conftest.two &&
+	      test -s conftest.dir/conftest.one &&
+	      test -s conftest.dir/conftest.two
+	    then
 	    ac_cv_path_install="$as_dir/$ac_prog$ac_exec_ext -c"
 	    break 3
 	  fi
 	fi
+	fi
       done
     done
     ;;
@@ -2815,6 +2977,7 @@ esac
 done
 IFS=$as_save_IFS
 
+rm -rf conftest.one conftest.two conftest.dir
 
 fi
   if test "${ac_cv_path_install+set}" = set; then
@@ -2827,8 +2990,8 @@ fi
     INSTALL=$ac_install_sh
   fi
 fi
-{ echo "$as_me:$LINENO: result: $INSTALL" >&5
-echo "${ECHO_T}$INSTALL" >&6; }
+{ $as_echo "$as_me:$LINENO: result: $INSTALL" >&5
+$as_echo "$INSTALL" >&6; }
 
 # Use test -z because SunOS4 sh mishandles braces in ${var-val}.
 # It thinks the first close brace ends the variable substitution.
@@ -2838,24 +3001,24 @@ test -z "$INSTALL_SCRIPT" && INSTALL_SCR
 
 test -z "$INSTALL_DATA" && INSTALL_DATA='${INSTALL} -m 644'
 
-{ echo "$as_me:$LINENO: checking whether ln -s works" >&5
-echo $ECHO_N "checking whether ln -s works... $ECHO_C" >&6; }
+{ $as_echo "$as_me:$LINENO: checking whether ln -s works" >&5
+$as_echo_n "checking whether ln -s works... " >&6; }
 LN_S=$as_ln_s
 if test "$LN_S" = "ln -s"; then
-  { echo "$as_me:$LINENO: result: yes" >&5
-echo "${ECHO_T}yes" >&6; }
+  { $as_echo "$as_me:$LINENO: result: yes" >&5
+$as_echo "yes" >&6; }
 else
-  { echo "$as_me:$LINENO: result: no, using $LN_S" >&5
-echo "${ECHO_T}no, using $LN_S" >&6; }
+  { $as_echo "$as_me:$LINENO: result: no, using $LN_S" >&5
+$as_echo "no, using $LN_S" >&6; }
 fi
 
 if test -n "$ac_tool_prefix"; then
   # Extract the first word of "${ac_tool_prefix}ranlib", so it can be a program name with args.
 set dummy ${ac_tool_prefix}ranlib; ac_word=$2
-{ echo "$as_me:$LINENO: checking for $ac_word" >&5
-echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6; }
+{ $as_echo "$as_me:$LINENO: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
 if test "${ac_cv_prog_RANLIB+set}" = set; then
-  echo $ECHO_N "(cached) $ECHO_C" >&6
+  $as_echo_n "(cached) " >&6
 else
   if test -n "$RANLIB"; then
   ac_cv_prog_RANLIB="$RANLIB" # Let the user override the test.
@@ -2868,7 +3031,7 @@ do
   for ac_exec_ext in '' $ac_executable_extensions; do
   if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
     ac_cv_prog_RANLIB="${ac_tool_prefix}ranlib"
-    echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
+    $as_echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
     break 2
   fi
 done
@@ -2879,11 +3042,11 @@ fi
 fi
 RANLIB=$ac_cv_prog_RANLIB
 if test -n "$RANLIB"; then
-  { echo "$as_me:$LINENO: result: $RANLIB" >&5
-echo "${ECHO_T}$RANLIB" >&6; }
+  { $as_echo "$as_me:$LINENO: result: $RANLIB" >&5
+$as_echo "$RANLIB" >&6; }
 else
-  { echo "$as_me:$LINENO: result: no" >&5
-echo "${ECHO_T}no" >&6; }
+  { $as_echo "$as_me:$LINENO: result: no" >&5
+$as_echo "no" >&6; }
 fi
 
 
@@ -2892,10 +3055,10 @@ if test -z "$ac_cv_prog_RANLIB"; then
   ac_ct_RANLIB=$RANLIB
   # Extract the first word of "ranlib", so it can be a program name with args.
 set dummy ranlib; ac_word=$2
-{ echo "$as_me:$LINENO: checking for $ac_word" >&5
-echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6; }
+{ $as_echo "$as_me:$LINENO: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
 if test "${ac_cv_prog_ac_ct_RANLIB+set}" = set; then
-  echo $ECHO_N "(cached) $ECHO_C" >&6
+  $as_echo_n "(cached) " >&6
 else
   if test -n "$ac_ct_RANLIB"; then
   ac_cv_prog_ac_ct_RANLIB="$ac_ct_RANLIB" # Let the user override the test.
@@ -2908,7 +3071,7 @@ do
   for ac_exec_ext in '' $ac_executable_extensions; do
   if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
     ac_cv_prog_ac_ct_RANLIB="ranlib"
-    echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
+    $as_echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
     break 2
   fi
 done
@@ -2919,11 +3082,11 @@ fi
 fi
 ac_ct_RANLIB=$ac_cv_prog_ac_ct_RANLIB
 if test -n "$ac_ct_RANLIB"; then
-  { echo "$as_me:$LINENO: result: $ac_ct_RANLIB" >&5
-echo "${ECHO_T}$ac_ct_RANLIB" >&6; }
+  { $as_echo "$as_me:$LINENO: result: $ac_ct_RANLIB" >&5
+$as_echo "$ac_ct_RANLIB" >&6; }
 else
-  { echo "$as_me:$LINENO: result: no" >&5
-echo "${ECHO_T}no" >&6; }
+  { $as_echo "$as_me:$LINENO: result: no" >&5
+$as_echo "no" >&6; }
 fi
 
   if test "x$ac_ct_RANLIB" = x; then
@@ -2931,12 +3094,8 @@ fi
   else
     case $cross_compiling:$ac_tool_warned in
 yes:)
-{ echo "$as_me:$LINENO: WARNING: In the future, Autoconf will not detect cross-tools
-whose name does not start with the host triplet.  If you think this
-configuration is useful to you, please write to autoconf@gnu.org." >&5
-echo "$as_me: WARNING: In the future, Autoconf will not detect cross-tools
-whose name does not start with the host triplet.  If you think this
-configuration is useful to you, please write to autoconf@gnu.org." >&2;}
+{ $as_echo "$as_me:$LINENO: WARNING: using cross tools not prefixed with host triplet" >&5
+$as_echo "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
 ac_tool_warned=yes ;;
 esac
     RANLIB=$ac_ct_RANLIB
@@ -2948,62 +3107,162 @@ fi
 
 
 
-{ echo "$as_me:$LINENO: checking for main in -lX11" >&5
-echo $ECHO_N "checking for main in -lX11... $ECHO_C" >&6; }
-if test "${ac_cv_lib_X11_main+set}" = set; then
-  echo $ECHO_N "(cached) $ECHO_C" >&6
-else
-  ac_check_lib_save_LIBS=$LIBS
-LIBS="-lX11  $LIBS"
-cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-
 
-int
-main ()
-{
-return main ();
-  ;
-  return 0;
-}
-_ACEOF
-rm -f conftest.$ac_objext conftest$ac_exeext
-if { (ac_try="$ac_link"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_link") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest$ac_exeext &&
-       $as_test_x conftest$ac_exeext; then
-  ac_cv_lib_X11_main=yes
+if test -n "$ac_tool_prefix"; then
+  # Extract the first word of "${ac_tool_prefix}ar", so it can be a program name with args.
+set dummy ${ac_tool_prefix}ar; ac_word=$2
+{ $as_echo "$as_me:$LINENO: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if test "${ac_cv_prog_AR+set}" = set; then
+  $as_echo_n "(cached) " >&6
 else
-  echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	ac_cv_lib_X11_main=no
+  if test -n "$AR"; then
+  ac_cv_prog_AR="$AR" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  for ac_exec_ext in '' $ac_executable_extensions; do
+  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+    ac_cv_prog_AR="${ac_tool_prefix}ar"
+    $as_echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
 fi
+done
+done
+IFS=$as_save_IFS
 
-rm -f core conftest.err conftest.$ac_objext conftest_ipa8_conftest.oo \
+fi
+fi
+AR=$ac_cv_prog_AR
+if test -n "$AR"; then
+  { $as_echo "$as_me:$LINENO: result: $AR" >&5
+$as_echo "$AR" >&6; }
+else
+  { $as_echo "$as_me:$LINENO: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+
+fi
+if test -z "$ac_cv_prog_AR"; then
+  ac_ct_AR=$AR
+  # Extract the first word of "ar", so it can be a program name with args.
+set dummy ar; ac_word=$2
+{ $as_echo "$as_me:$LINENO: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if test "${ac_cv_prog_ac_ct_AR+set}" = set; then
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$ac_ct_AR"; then
+  ac_cv_prog_ac_ct_AR="$ac_ct_AR" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  for ac_exec_ext in '' $ac_executable_extensions; do
+  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+    ac_cv_prog_ac_ct_AR="ar"
+    $as_echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+done
+IFS=$as_save_IFS
+
+fi
+fi
+ac_ct_AR=$ac_cv_prog_ac_ct_AR
+if test -n "$ac_ct_AR"; then
+  { $as_echo "$as_me:$LINENO: result: $ac_ct_AR" >&5
+$as_echo "$ac_ct_AR" >&6; }
+else
+  { $as_echo "$as_me:$LINENO: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+  if test "x$ac_ct_AR" = x; then
+    AR=":"
+  else
+    case $cross_compiling:$ac_tool_warned in
+yes:)
+{ $as_echo "$as_me:$LINENO: WARNING: using cross tools not prefixed with host triplet" >&5
+$as_echo "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
+ac_tool_warned=yes ;;
+esac
+    AR=$ac_ct_AR
+  fi
+else
+  AR="$ac_cv_prog_AR"
+fi
+
+
+
+
+{ $as_echo "$as_me:$LINENO: checking for main in -lX11" >&5
+$as_echo_n "checking for main in -lX11... " >&6; }
+if test "${ac_cv_lib_X11_main+set}" = set; then
+  $as_echo_n "(cached) " >&6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-lX11  $LIBS"
+cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+
+int
+main ()
+{
+return main ();
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (ac_try="$ac_link"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
+  (eval "$ac_link") 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && {
+	 test -z "$ac_c_werror_flag" ||
+	 test ! -s conftest.err
+       } && test -s conftest$ac_exeext && {
+	 test "$cross_compiling" = yes ||
+	 $as_test_x conftest$ac_exeext
+       }; then
+  ac_cv_lib_X11_main=yes
+else
+  $as_echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+	ac_cv_lib_X11_main=no
+fi
+
+rm -rf conftest.dSYM
+rm -f core conftest.err conftest.$ac_objext conftest_ipa8_conftest.oo \
       conftest$ac_exeext conftest.$ac_ext
 LIBS=$ac_check_lib_save_LIBS
 fi
-{ echo "$as_me:$LINENO: result: $ac_cv_lib_X11_main" >&5
-echo "${ECHO_T}$ac_cv_lib_X11_main" >&6; }
-if test $ac_cv_lib_X11_main = yes; then
+{ $as_echo "$as_me:$LINENO: result: $ac_cv_lib_X11_main" >&5
+$as_echo "$ac_cv_lib_X11_main" >&6; }
+if test "x$ac_cv_lib_X11_main" = x""yes; then
   cat >>confdefs.h <<_ACEOF
 #define HAVE_LIBX11 1
 _ACEOF
@@ -3013,10 +3272,10 @@ _ACEOF
 fi
 
 
-{ echo "$as_me:$LINENO: checking for main in -lm" >&5
-echo $ECHO_N "checking for main in -lm... $ECHO_C" >&6; }
+{ $as_echo "$as_me:$LINENO: checking for main in -lm" >&5
+$as_echo_n "checking for main in -lm... " >&6; }
 if test "${ac_cv_lib_m_main+set}" = set; then
-  echo $ECHO_N "(cached) $ECHO_C" >&6
+  $as_echo_n "(cached) " >&6
 else
   ac_check_lib_save_LIBS=$LIBS
 LIBS="-lm  $LIBS"
@@ -3042,167 +3301,787 @@ case "(($ac_try" in
   *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
   *) ac_try_echo=$ac_try;;
 esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
   (eval "$ac_link") 2>conftest.er1
   ac_status=$?
   grep -v '^ *+' conftest.er1 >conftest.err
   rm -f conftest.er1
   cat conftest.err >&5
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } && {
 	 test -z "$ac_c_werror_flag" ||
 	 test ! -s conftest.err
-       } && test -s conftest$ac_exeext &&
-       $as_test_x conftest$ac_exeext; then
+       } && test -s conftest$ac_exeext && {
+	 test "$cross_compiling" = yes ||
+	 $as_test_x conftest$ac_exeext
+       }; then
   ac_cv_lib_m_main=yes
 else
-  echo "$as_me: failed program was:" >&5
+  $as_echo "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
 	ac_cv_lib_m_main=no
 fi
 
+rm -rf conftest.dSYM
 rm -f core conftest.err conftest.$ac_objext conftest_ipa8_conftest.oo \
       conftest$ac_exeext conftest.$ac_ext
 LIBS=$ac_check_lib_save_LIBS
 fi
-{ echo "$as_me:$LINENO: result: $ac_cv_lib_m_main" >&5
-echo "${ECHO_T}$ac_cv_lib_m_main" >&6; }
-if test $ac_cv_lib_m_main = yes; then
+{ $as_echo "$as_me:$LINENO: result: $ac_cv_lib_m_main" >&5
+$as_echo "$ac_cv_lib_m_main" >&6; }
+if test "x$ac_cv_lib_m_main" = x""yes; then
   cat >>confdefs.h <<_ACEOF
 #define HAVE_LIBM 1
 _ACEOF
 
   LIBS="-lm $LIBS"
 
+else
+  { { $as_echo "$as_me:$LINENO: error: Cannot find libm" >&5
+$as_echo "$as_me: error: Cannot find libm" >&2;}
+   { (exit 1); exit 1; }; }
 fi
 
 
-ac_config_headers="$ac_config_headers "
+ac_ext=f
+ac_compile='$F77 -c $FFLAGS conftest.$ac_ext >&5'
+ac_link='$F77 -o conftest$ac_exeext $FFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
+ac_compiler_gnu=$ac_cv_f77_compiler_gnu
+if test -n "$ac_tool_prefix"; then
+  for ac_prog in g77 xlf f77 frt pgf77 cf77 fort77 fl32 af77 xlf90 f90 pgf90 pghpf epcf90 gfortran g95 xlf95 f95 fort ifort ifc efc pgf95 lf95 ftn
+  do
+    # Extract the first word of "$ac_tool_prefix$ac_prog", so it can be a program name with args.
+set dummy $ac_tool_prefix$ac_prog; ac_word=$2
+{ $as_echo "$as_me:$LINENO: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if test "${ac_cv_prog_F77+set}" = set; then
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$F77"; then
+  ac_cv_prog_F77="$F77" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  for ac_exec_ext in '' $ac_executable_extensions; do
+  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+    ac_cv_prog_F77="$ac_tool_prefix$ac_prog"
+    $as_echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+done
+IFS=$as_save_IFS
 
-ac_ext=c
-ac_cpp='$CPP $CPPFLAGS'
-ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
-ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
-ac_compiler_gnu=$ac_cv_c_compiler_gnu
-{ echo "$as_me:$LINENO: checking how to run the C preprocessor" >&5
-echo $ECHO_N "checking how to run the C preprocessor... $ECHO_C" >&6; }
-# On Suns, sometimes $CPP names a directory.
-if test -n "$CPP" && test -d "$CPP"; then
-  CPP=
 fi
-if test -z "$CPP"; then
-  if test "${ac_cv_prog_CPP+set}" = set; then
-  echo $ECHO_N "(cached) $ECHO_C" >&6
+fi
+F77=$ac_cv_prog_F77
+if test -n "$F77"; then
+  { $as_echo "$as_me:$LINENO: result: $F77" >&5
+$as_echo "$F77" >&6; }
 else
-      # Double quotes because CPP needs to be expanded
-    for CPP in "$CC -E" "$CC -E -traditional-cpp" "/lib/cpp"
+  { $as_echo "$as_me:$LINENO: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+
+    test -n "$F77" && break
+  done
+fi
+if test -z "$F77"; then
+  ac_ct_F77=$F77
+  for ac_prog in g77 xlf f77 frt pgf77 cf77 fort77 fl32 af77 xlf90 f90 pgf90 pghpf epcf90 gfortran g95 xlf95 f95 fort ifort ifc efc pgf95 lf95 ftn
     do
-      ac_preproc_ok=false
-for ac_c_preproc_warn_flag in '' yes
+  # Extract the first word of "$ac_prog", so it can be a program name with args.
+set dummy $ac_prog; ac_word=$2
+{ $as_echo "$as_me:$LINENO: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if test "${ac_cv_prog_ac_ct_F77+set}" = set; then
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$ac_ct_F77"; then
+  ac_cv_prog_ac_ct_F77="$ac_ct_F77" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
 do
-  # Use a header file that comes with gcc, so configuring glibc
-  # with a fresh cross-compiler works.
-  # Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
-  # <limits.h> exists even on freestanding compilers.
-  # On the NeXT, cc -E runs the code through the compiler's parser,
-  # not just through cpp. "Syntax error" is here to catch this case.
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  for ac_exec_ext in '' $ac_executable_extensions; do
+  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+    ac_cv_prog_ac_ct_F77="$ac_prog"
+    $as_echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+done
+IFS=$as_save_IFS
+
+fi
+fi
+ac_ct_F77=$ac_cv_prog_ac_ct_F77
+if test -n "$ac_ct_F77"; then
+  { $as_echo "$as_me:$LINENO: result: $ac_ct_F77" >&5
+$as_echo "$ac_ct_F77" >&6; }
+else
+  { $as_echo "$as_me:$LINENO: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+
+  test -n "$ac_ct_F77" && break
+done
+
+  if test "x$ac_ct_F77" = x; then
+    F77=""
+  else
+    case $cross_compiling:$ac_tool_warned in
+yes:)
+{ $as_echo "$as_me:$LINENO: WARNING: using cross tools not prefixed with host triplet" >&5
+$as_echo "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
+ac_tool_warned=yes ;;
+esac
+    F77=$ac_ct_F77
+  fi
+fi
+
+
+# Provide some information about the compiler.
+$as_echo "$as_me:$LINENO: checking for Fortran 77 compiler version" >&5
+set X $ac_compile
+ac_compiler=$2
+{ (ac_try="$ac_compiler --version >&5"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
+  (eval "$ac_compiler --version >&5") 2>&5
+  ac_status=$?
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }
+{ (ac_try="$ac_compiler -v >&5"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
+  (eval "$ac_compiler -v >&5") 2>&5
+  ac_status=$?
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }
+{ (ac_try="$ac_compiler -V >&5"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
+  (eval "$ac_compiler -V >&5") 2>&5
+  ac_status=$?
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }
+rm -f a.out
+
+# If we don't use `.F' as extension, the preprocessor is not run on the
+# input file.  (Note that this only needs to work for GNU compilers.)
+ac_save_ext=$ac_ext
+ac_ext=F
+{ $as_echo "$as_me:$LINENO: checking whether we are using the GNU Fortran 77 compiler" >&5
+$as_echo_n "checking whether we are using the GNU Fortran 77 compiler... " >&6; }
+if test "${ac_cv_f77_compiler_gnu+set}" = set; then
+  $as_echo_n "(cached) " >&6
+else
   cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-#ifdef __STDC__
-# include <limits.h>
-#else
-# include <assert.h>
+      program main
+#ifndef __GNUC__
+       choke me
 #endif
-		     Syntax error
+
+      end
 _ACEOF
-if { (ac_try="$ac_cpp conftest.$ac_ext"
+rm -f conftest.$ac_objext
+if { (ac_try="$ac_compile"
 case "(($ac_try" in
   *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
   *) ac_try_echo=$ac_try;;
 esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_cpp conftest.$ac_ext") 2>conftest.er1
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
+  (eval "$ac_compile") 2>conftest.er1
   ac_status=$?
   grep -v '^ *+' conftest.er1 >conftest.err
   rm -f conftest.er1
   cat conftest.err >&5
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } >/dev/null && {
-	 test -z "$ac_c_preproc_warn_flag$ac_c_werror_flag" ||
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && {
+	 test -z "$ac_f77_werror_flag" ||
 	 test ! -s conftest.err
-       }; then
-  :
+       } && test -s conftest.$ac_objext; then
+  ac_compiler_gnu=yes
 else
-  echo "$as_me: failed program was:" >&5
+  $as_echo "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
-  # Broken: fails on valid input.
-continue
+	ac_compiler_gnu=no
 fi
 
-rm -f conftest.err conftest.$ac_ext
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+ac_cv_f77_compiler_gnu=$ac_compiler_gnu
 
-  # OK, works on sane cases.  Now check whether nonexistent headers
-  # can be detected and how.
+fi
+{ $as_echo "$as_me:$LINENO: result: $ac_cv_f77_compiler_gnu" >&5
+$as_echo "$ac_cv_f77_compiler_gnu" >&6; }
+ac_ext=$ac_save_ext
+ac_test_FFLAGS=${FFLAGS+set}
+ac_save_FFLAGS=$FFLAGS
+FFLAGS=
+{ $as_echo "$as_me:$LINENO: checking whether $F77 accepts -g" >&5
+$as_echo_n "checking whether $F77 accepts -g... " >&6; }
+if test "${ac_cv_prog_f77_g+set}" = set; then
+  $as_echo_n "(cached) " >&6
+else
+  FFLAGS=-g
   cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-#include <ac_nonexistent.h>
+      program main
+
+      end
 _ACEOF
-if { (ac_try="$ac_cpp conftest.$ac_ext"
+rm -f conftest.$ac_objext
+if { (ac_try="$ac_compile"
 case "(($ac_try" in
   *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
   *) ac_try_echo=$ac_try;;
 esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_cpp conftest.$ac_ext") 2>conftest.er1
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
+  (eval "$ac_compile") 2>conftest.er1
   ac_status=$?
   grep -v '^ *+' conftest.er1 >conftest.err
   rm -f conftest.er1
   cat conftest.err >&5
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } >/dev/null && {
-	 test -z "$ac_c_preproc_warn_flag$ac_c_werror_flag" ||
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && {
+	 test -z "$ac_f77_werror_flag" ||
 	 test ! -s conftest.err
-       }; then
-  # Broken: success on invalid input.
-continue
+       } && test -s conftest.$ac_objext; then
+  ac_cv_prog_f77_g=yes
 else
-  echo "$as_me: failed program was:" >&5
+  $as_echo "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
-  # Passes both tests.
-ac_preproc_ok=:
-break
+	ac_cv_prog_f77_g=no
 fi
 
-rm -f conftest.err conftest.$ac_ext
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
 
-done
-# Because of `break', _AC_PREPROC_IFELSE's cleaning code was skipped.
-rm -f conftest.err conftest.$ac_ext
-if $ac_preproc_ok; then
-  break
 fi
+{ $as_echo "$as_me:$LINENO: result: $ac_cv_prog_f77_g" >&5
+$as_echo "$ac_cv_prog_f77_g" >&6; }
+if test "$ac_test_FFLAGS" = set; then
+  FFLAGS=$ac_save_FFLAGS
+elif test $ac_cv_prog_f77_g = yes; then
+  if test "x$ac_cv_f77_compiler_gnu" = xyes; then
+    FFLAGS="-g -O2"
+  else
+    FFLAGS="-g"
+  fi
+else
+  if test "x$ac_cv_f77_compiler_gnu" = xyes; then
+    FFLAGS="-O2"
+  else
+    FFLAGS=
+  fi
+fi
+
+if test $ac_compiler_gnu = yes; then
+  G77=yes
+else
+  G77=
+fi
+ac_ext=c
+ac_cpp='$CPP $CPPFLAGS'
+ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
+ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
+ac_compiler_gnu=$ac_cv_c_compiler_gnu
+
+if test -z "$F77"; then
+	LBFGS=''
+	FLIBS=''
+else
+	LBFGS='lbfgs.o'
+
+ac_ext=f
+ac_compile='$F77 -c $FFLAGS conftest.$ac_ext >&5'
+ac_link='$F77 -o conftest$ac_exeext $FFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
+ac_compiler_gnu=$ac_cv_f77_compiler_gnu
+{ $as_echo "$as_me:$LINENO: checking how to get verbose linking output from $F77" >&5
+$as_echo_n "checking how to get verbose linking output from $F77... " >&6; }
+if test "${ac_cv_prog_f77_v+set}" = set; then
+  $as_echo_n "(cached) " >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+      program main
+
+      end
+_ACEOF
+rm -f conftest.$ac_objext
+if { (ac_try="$ac_compile"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
+  (eval "$ac_compile") 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && {
+	 test -z "$ac_f77_werror_flag" ||
+	 test ! -s conftest.err
+       } && test -s conftest.$ac_objext; then
+  ac_cv_prog_f77_v=
+# Try some options frequently used verbose output
+for ac_verb in -v -verbose --verbose -V -\#\#\#; do
+  cat >conftest.$ac_ext <<_ACEOF
+      program main
+
+      end
+_ACEOF
+
+# Compile and link our simple test program by passing a flag (argument
+# 1 to this macro) to the Fortran compiler in order to get
+# "verbose" output that we can then parse for the Fortran linker
+# flags.
+ac_save_FFLAGS=$FFLAGS
+FFLAGS="$FFLAGS $ac_verb"
+eval "set x $ac_link"
+shift
+$as_echo "$as_me:$LINENO: $*" >&5
+# gfortran 4.3 outputs lines setting COLLECT_GCC_OPTIONS, COMPILER_PATH,
+# LIBRARY_PATH; skip all such settings.
+ac_f77_v_output=`eval $ac_link 5>&1 2>&1 |
+  grep -v 'Driving:' | grep -v "^[_$as_cr_Letters][_$as_cr_alnum]*="`
+$as_echo "$ac_f77_v_output" >&5
+FFLAGS=$ac_save_FFLAGS
+
+rm -rf conftest*
+
+# On HP/UX there is a line like: "LPATH is: /foo:/bar:/baz" where
+# /foo, /bar, and /baz are search directories for the Fortran linker.
+# Here, we change these into -L/foo -L/bar -L/baz (and put it first):
+ac_f77_v_output="`echo $ac_f77_v_output |
+	grep 'LPATH is:' |
+	sed 's|.*LPATH is\(: *[^ ]*\).*|\1|;s|: */| -L/|g'` $ac_f77_v_output"
+
+# FIXME: we keep getting bitten by quoted arguments; a more general fix
+#        that detects unbalanced quotes in FLIBS should be implemented
+#        and (ugh) tested at some point.
+case $ac_f77_v_output in
+  # If we are using xlf then replace all the commas with spaces.
+  *xlfentry*)
+    ac_f77_v_output=`echo $ac_f77_v_output | sed 's/,/ /g'` ;;
+
+  # With Intel ifc, ignore the quoted -mGLOB_options_string stuff (quoted
+  # $LIBS confuse us, and the libraries appear later in the output anyway).
+  *mGLOB_options_string*)
+    ac_f77_v_output=`echo $ac_f77_v_output | sed 's/"-mGLOB[^"]*"/ /g'` ;;
+
+  # Portland Group compiler has singly- or doubly-quoted -cmdline argument
+  # Singly-quoted arguments were reported for versions 5.2-4 and 6.0-4.
+  # Doubly-quoted arguments were reported for "PGF90/x86 Linux/x86 5.0-2".
+  *-cmdline\ * | *-ignore\ * | *-def\ *)
+    ac_f77_v_output=`echo $ac_f77_v_output | sed "\
+        s/-cmdline  *'[^']*'/ /g; s/-cmdline  *\"[^\"]*\"/ /g
+        s/-ignore  *'[^']*'/ /g; s/-ignore  *\"[^\"]*\"/ /g
+        s/-def  *'[^']*'/ /g; s/-def  *\"[^\"]*\"/ /g"` ;;
+
+  # If we are using Cray Fortran then delete quotes.
+  *cft90*)
+    ac_f77_v_output=`echo $ac_f77_v_output | sed 's/"//g'` ;;
+esac
+
+
+  # look for -l* and *.a constructs in the output
+  for ac_arg in $ac_f77_v_output; do
+     case $ac_arg in
+        [\\/]*.a | ?:[\\/]*.a | -[lLRu]*)
+          ac_cv_prog_f77_v=$ac_verb
+          break 2 ;;
+     esac
+  done
+done
+if test -z "$ac_cv_prog_f77_v"; then
+   { $as_echo "$as_me:$LINENO: WARNING: cannot determine how to obtain linking information from $F77" >&5
+$as_echo "$as_me: WARNING: cannot determine how to obtain linking information from $F77" >&2;}
+fi
+else
+  $as_echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+	{ $as_echo "$as_me:$LINENO: WARNING: compilation failed" >&5
+$as_echo "$as_me: WARNING: compilation failed" >&2;}
+fi
+
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+
+fi
+{ $as_echo "$as_me:$LINENO: result: $ac_cv_prog_f77_v" >&5
+$as_echo "$ac_cv_prog_f77_v" >&6; }
+{ $as_echo "$as_me:$LINENO: checking for Fortran 77 libraries of $F77" >&5
+$as_echo_n "checking for Fortran 77 libraries of $F77... " >&6; }
+if test "${ac_cv_f77_libs+set}" = set; then
+  $as_echo_n "(cached) " >&6
+else
+  if test "x$FLIBS" != "x"; then
+  ac_cv_f77_libs="$FLIBS" # Let the user override the test.
+else
+
+cat >conftest.$ac_ext <<_ACEOF
+      program main
+
+      end
+_ACEOF
+
+# Compile and link our simple test program by passing a flag (argument
+# 1 to this macro) to the Fortran compiler in order to get
+# "verbose" output that we can then parse for the Fortran linker
+# flags.
+ac_save_FFLAGS=$FFLAGS
+FFLAGS="$FFLAGS $ac_cv_prog_f77_v"
+eval "set x $ac_link"
+shift
+$as_echo "$as_me:$LINENO: $*" >&5
+# gfortran 4.3 outputs lines setting COLLECT_GCC_OPTIONS, COMPILER_PATH,
+# LIBRARY_PATH; skip all such settings.
+ac_f77_v_output=`eval $ac_link 5>&1 2>&1 |
+  grep -v 'Driving:' | grep -v "^[_$as_cr_Letters][_$as_cr_alnum]*="`
+$as_echo "$ac_f77_v_output" >&5
+FFLAGS=$ac_save_FFLAGS
+
+rm -rf conftest*
+
+# On HP/UX there is a line like: "LPATH is: /foo:/bar:/baz" where
+# /foo, /bar, and /baz are search directories for the Fortran linker.
+# Here, we change these into -L/foo -L/bar -L/baz (and put it first):
+ac_f77_v_output="`echo $ac_f77_v_output |
+	grep 'LPATH is:' |
+	sed 's|.*LPATH is\(: *[^ ]*\).*|\1|;s|: */| -L/|g'` $ac_f77_v_output"
+
+# FIXME: we keep getting bitten by quoted arguments; a more general fix
+#        that detects unbalanced quotes in FLIBS should be implemented
+#        and (ugh) tested at some point.
+case $ac_f77_v_output in
+  # If we are using xlf then replace all the commas with spaces.
+  *xlfentry*)
+    ac_f77_v_output=`echo $ac_f77_v_output | sed 's/,/ /g'` ;;
+
+  # With Intel ifc, ignore the quoted -mGLOB_options_string stuff (quoted
+  # $LIBS confuse us, and the libraries appear later in the output anyway).
+  *mGLOB_options_string*)
+    ac_f77_v_output=`echo $ac_f77_v_output | sed 's/"-mGLOB[^"]*"/ /g'` ;;
+
+  # Portland Group compiler has singly- or doubly-quoted -cmdline argument
+  # Singly-quoted arguments were reported for versions 5.2-4 and 6.0-4.
+  # Doubly-quoted arguments were reported for "PGF90/x86 Linux/x86 5.0-2".
+  *-cmdline\ * | *-ignore\ * | *-def\ *)
+    ac_f77_v_output=`echo $ac_f77_v_output | sed "\
+        s/-cmdline  *'[^']*'/ /g; s/-cmdline  *\"[^\"]*\"/ /g
+        s/-ignore  *'[^']*'/ /g; s/-ignore  *\"[^\"]*\"/ /g
+        s/-def  *'[^']*'/ /g; s/-def  *\"[^\"]*\"/ /g"` ;;
+
+  # If we are using Cray Fortran then delete quotes.
+  *cft90*)
+    ac_f77_v_output=`echo $ac_f77_v_output | sed 's/"//g'` ;;
+esac
+
+
+
+ac_cv_f77_libs=
+
+# Save positional arguments (if any)
+ac_save_positional="$@"
+
+set X $ac_f77_v_output
+while test $# != 1; do
+  shift
+  ac_arg=$1
+  case $ac_arg in
+        [\\/]*.a | ?:[\\/]*.a)
+            ac_exists=false
+  for ac_i in $ac_cv_f77_libs; do
+    if test x"$ac_arg" = x"$ac_i"; then
+      ac_exists=true
+      break
+    fi
+  done
+
+  if test x"$ac_exists" = xtrue; then
+  :
+else
+  ac_cv_f77_libs="$ac_cv_f77_libs $ac_arg"
+fi
+
+          ;;
+        -bI:*)
+            ac_exists=false
+  for ac_i in $ac_cv_f77_libs; do
+    if test x"$ac_arg" = x"$ac_i"; then
+      ac_exists=true
+      break
+    fi
+  done
+
+  if test x"$ac_exists" = xtrue; then
+  :
+else
+  if test "$ac_compiler_gnu" = yes; then
+  for ac_link_opt in $ac_arg; do
+    ac_cv_f77_libs="$ac_cv_f77_libs -Xlinker $ac_link_opt"
+  done
+else
+  ac_cv_f77_libs="$ac_cv_f77_libs $ac_arg"
+fi
+fi
+
+          ;;
+          # Ignore these flags.
+        -lang* | -lcrt*.o | -lc | -lgcc* | -lSystem | -libmil | -LANG:=* | -LIST:* | -LNO:*)
+          ;;
+        -lkernel32)
+          test x"$CYGWIN" != xyes && ac_cv_f77_libs="$ac_cv_f77_libs $ac_arg"
+          ;;
+        -[LRuYz])
+          # These flags, when seen by themselves, take an argument.
+          # We remove the space between option and argument and re-iterate
+          # unless we find an empty arg or a new option (starting with -)
+	  case $2 in
+	     "" | -*);;
+	     *)
+		ac_arg="$ac_arg$2"
+		shift; shift
+		set X $ac_arg "$@"
+		;;
+	  esac
+          ;;
+        -YP,*)
+          for ac_j in `$as_echo "$ac_arg" | sed -e 's/-YP,/-L/;s/:/ -L/g'`; do
+              ac_exists=false
+  for ac_i in $ac_cv_f77_libs; do
+    if test x"$ac_j" = x"$ac_i"; then
+      ac_exists=true
+      break
+    fi
+  done
+
+  if test x"$ac_exists" = xtrue; then
+  :
+else
+  ac_arg="$ac_arg $ac_j"
+                               ac_cv_f77_libs="$ac_cv_f77_libs $ac_j"
+fi
+
+          done
+          ;;
+        -[lLR]*)
+            ac_exists=false
+  for ac_i in $ac_cv_f77_libs; do
+    if test x"$ac_arg" = x"$ac_i"; then
+      ac_exists=true
+      break
+    fi
+  done
+
+  if test x"$ac_exists" = xtrue; then
+  :
+else
+  ac_cv_f77_libs="$ac_cv_f77_libs $ac_arg"
+fi
+
+          ;;
+	-zallextract*| -zdefaultextract)
+	  ac_cv_f77_libs="$ac_cv_f77_libs $ac_arg"
+	  ;;
+          # Ignore everything else.
+  esac
+done
+# restore positional arguments
+set X $ac_save_positional; shift
+
+# We only consider "LD_RUN_PATH" on Solaris systems.  If this is seen,
+# then we insist that the "run path" must be an absolute path (i.e. it
+# must begin with a "/").
+case `(uname -sr) 2>/dev/null` in
+   "SunOS 5"*)
+      ac_ld_run_path=`$as_echo "$ac_f77_v_output" |
+                        sed -n 's,^.*LD_RUN_PATH *= *\(/[^ ]*\).*$,-R\1,p'`
+      test "x$ac_ld_run_path" != x &&
+        if test "$ac_compiler_gnu" = yes; then
+  for ac_link_opt in $ac_ld_run_path; do
+    ac_cv_f77_libs="$ac_cv_f77_libs -Xlinker $ac_link_opt"
+  done
+else
+  ac_cv_f77_libs="$ac_cv_f77_libs $ac_ld_run_path"
+fi
+      ;;
+esac
+fi # test "x$[]_AC_LANG_PREFIX[]LIBS" = "x"
+
+fi
+{ $as_echo "$as_me:$LINENO: result: $ac_cv_f77_libs" >&5
+$as_echo "$ac_cv_f77_libs" >&6; }
+FLIBS="$ac_cv_f77_libs"
+
+
+ac_ext=c
+ac_cpp='$CPP $CPPFLAGS'
+ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
+ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
+ac_compiler_gnu=$ac_cv_c_compiler_gnu
+
+	CFLAGS="$CFLAGS -D_HAS_FORTRAN"
+fi
+FLIBS=$FLIBS
+
+LBFGS=$LBFGS
+
+
+ac_config_headers="$ac_config_headers "
+
+ac_ext=c
+ac_cpp='$CPP $CPPFLAGS'
+ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
+ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
+ac_compiler_gnu=$ac_cv_c_compiler_gnu
+{ $as_echo "$as_me:$LINENO: checking how to run the C preprocessor" >&5
+$as_echo_n "checking how to run the C preprocessor... " >&6; }
+# On Suns, sometimes $CPP names a directory.
+if test -n "$CPP" && test -d "$CPP"; then
+  CPP=
+fi
+if test -z "$CPP"; then
+  if test "${ac_cv_prog_CPP+set}" = set; then
+  $as_echo_n "(cached) " >&6
+else
+      # Double quotes because CPP needs to be expanded
+    for CPP in "$CC -E" "$CC -E -traditional-cpp" "/lib/cpp"
+    do
+      ac_preproc_ok=false
+for ac_c_preproc_warn_flag in '' yes
+do
+  # Use a header file that comes with gcc, so configuring glibc
+  # with a fresh cross-compiler works.
+  # Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
+  # <limits.h> exists even on freestanding compilers.
+  # On the NeXT, cc -E runs the code through the compiler's parser,
+  # not just through cpp. "Syntax error" is here to catch this case.
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#ifdef __STDC__
+# include <limits.h>
+#else
+# include <assert.h>
+#endif
+		     Syntax error
+_ACEOF
+if { (ac_try="$ac_cpp conftest.$ac_ext"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
+  (eval "$ac_cpp conftest.$ac_ext") 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } >/dev/null && {
+	 test -z "$ac_c_preproc_warn_flag$ac_c_werror_flag" ||
+	 test ! -s conftest.err
+       }; then
+  :
+else
+  $as_echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+  # Broken: fails on valid input.
+continue
+fi
+
+rm -f conftest.err conftest.$ac_ext
+
+  # OK, works on sane cases.  Now check whether nonexistent headers
+  # can be detected and how.
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <ac_nonexistent.h>
+_ACEOF
+if { (ac_try="$ac_cpp conftest.$ac_ext"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
+  (eval "$ac_cpp conftest.$ac_ext") 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } >/dev/null && {
+	 test -z "$ac_c_preproc_warn_flag$ac_c_werror_flag" ||
+	 test ! -s conftest.err
+       }; then
+  # Broken: success on invalid input.
+continue
+else
+  $as_echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+  # Passes both tests.
+ac_preproc_ok=:
+break
+fi
+
+rm -f conftest.err conftest.$ac_ext
+
+done
+# Because of `break', _AC_PREPROC_IFELSE's cleaning code was skipped.
+rm -f conftest.err conftest.$ac_ext
+if $ac_preproc_ok; then
+  break
+fi
+
+    done
+    ac_cv_prog_CPP=$CPP
 
-    done
-    ac_cv_prog_CPP=$CPP
-
 fi
   CPP=$ac_cv_prog_CPP
 else
   ac_cv_prog_CPP=$CPP
 fi
-{ echo "$as_me:$LINENO: result: $CPP" >&5
-echo "${ECHO_T}$CPP" >&6; }
+{ $as_echo "$as_me:$LINENO: result: $CPP" >&5
+$as_echo "$CPP" >&6; }
 ac_preproc_ok=false
 for ac_c_preproc_warn_flag in '' yes
 do
@@ -3230,20 +4109,21 @@ case "(($ac_try" in
   *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
   *) ac_try_echo=$ac_try;;
 esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
   (eval "$ac_cpp conftest.$ac_ext") 2>conftest.er1
   ac_status=$?
   grep -v '^ *+' conftest.er1 >conftest.err
   rm -f conftest.er1
   cat conftest.err >&5
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } >/dev/null && {
 	 test -z "$ac_c_preproc_warn_flag$ac_c_werror_flag" ||
 	 test ! -s conftest.err
        }; then
   :
 else
-  echo "$as_me: failed program was:" >&5
+  $as_echo "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
   # Broken: fails on valid input.
@@ -3267,13 +4147,14 @@ case "(($ac_try" in
   *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
   *) ac_try_echo=$ac_try;;
 esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
   (eval "$ac_cpp conftest.$ac_ext") 2>conftest.er1
   ac_status=$?
   grep -v '^ *+' conftest.er1 >conftest.err
   rm -f conftest.er1
   cat conftest.err >&5
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } >/dev/null && {
 	 test -z "$ac_c_preproc_warn_flag$ac_c_werror_flag" ||
 	 test ! -s conftest.err
@@ -3281,7 +4162,7 @@ eval "echo \"\$as_me:$LINENO: $ac_try_ec
   # Broken: success on invalid input.
 continue
 else
-  echo "$as_me: failed program was:" >&5
+  $as_echo "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
   # Passes both tests.
@@ -3297,11 +4178,13 @@ rm -f conftest.err conftest.$ac_ext
 if $ac_preproc_ok; then
   :
 else
-  { { echo "$as_me:$LINENO: error: C preprocessor \"$CPP\" fails sanity check
+  { { $as_echo "$as_me:$LINENO: error: in \`$ac_pwd':" >&5
+$as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
+{ { $as_echo "$as_me:$LINENO: error: C preprocessor \"$CPP\" fails sanity check
 See \`config.log' for more details." >&5
-echo "$as_me: error: C preprocessor \"$CPP\" fails sanity check
+$as_echo "$as_me: error: C preprocessor \"$CPP\" fails sanity check
 See \`config.log' for more details." >&2;}
-   { (exit 1); exit 1; }; }
+   { (exit 1); exit 1; }; }; }
 fi
 
 ac_ext=c
@@ -3311,8 +4194,8 @@ ac_link='$CC -o conftest$ac_exeext $CFLA
 ac_compiler_gnu=$ac_cv_c_compiler_gnu
 
 
-{ echo "$as_me:$LINENO: checking for X" >&5
-echo $ECHO_N "checking for X... $ECHO_C" >&6; }
+{ $as_echo "$as_me:$LINENO: checking for X" >&5
+$as_echo_n "checking for X... " >&6; }
 
 
 # Check whether --with-x was given.
@@ -3326,11 +4209,11 @@ if test "x$with_x" = xno; then
   have_x=disabled
 else
   case $x_includes,$x_libraries in #(
-    *\'*) { { echo "$as_me:$LINENO: error: Cannot use X directory names containing '" >&5
-echo "$as_me: error: Cannot use X directory names containing '" >&2;}
+    *\'*) { { $as_echo "$as_me:$LINENO: error: cannot use X directory names containing '" >&5
+$as_echo "$as_me: error: cannot use X directory names containing '" >&2;}
    { (exit 1); exit 1; }; };; #(
     *,NONE | NONE,*) if test "${ac_cv_have_x+set}" = set; then
-  echo $ECHO_N "(cached) $ECHO_C" >&6
+  $as_echo_n "(cached) " >&6
 else
   # One or both of the vars are not set, and there is no cached value.
 ac_x_includes=no ac_x_libraries=no
@@ -3351,7 +4234,7 @@ _ACEOF
       eval "ac_im_$ac_var=\`\${MAKE-make} $ac_var 2>/dev/null | sed -n 's/^$ac_var=//p'\`"
     done
     # Open Windows xmkmf reportedly sets LIBDIR instead of USRLIBDIR.
-    for ac_extension in a so sl; do
+    for ac_extension in a so sl dylib la dll; do
       if test ! -f "$ac_im_usrlibdir/libX11.$ac_extension" &&
 	 test -f "$ac_im_libdir/libX11.$ac_extension"; then
 	ac_im_usrlibdir=$ac_im_libdir; break
@@ -3365,7 +4248,7 @@ _ACEOF
 	*) test -f "$ac_im_incroot/X11/Xos.h" && ac_x_includes=$ac_im_incroot;;
     esac
     case $ac_im_usrlibdir in
-	/usr/lib | /lib) ;;
+	/usr/lib | /usr/lib64 | /lib | /lib64) ;;
 	*) test -d "$ac_im_usrlibdir" && ac_x_libraries=$ac_im_usrlibdir ;;
     esac
   fi
@@ -3426,13 +4309,14 @@ case "(($ac_try" in
   *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
   *) ac_try_echo=$ac_try;;
 esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
   (eval "$ac_cpp conftest.$ac_ext") 2>conftest.er1
   ac_status=$?
   grep -v '^ *+' conftest.er1 >conftest.err
   rm -f conftest.er1
   cat conftest.err >&5
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } >/dev/null && {
 	 test -z "$ac_c_preproc_warn_flag$ac_c_werror_flag" ||
 	 test ! -s conftest.err
@@ -3440,7 +4324,7 @@ eval "echo \"\$as_me:$LINENO: $ac_try_ec
   # We can compile using X headers with no special include directory.
 ac_x_includes=
 else
-  echo "$as_me: failed program was:" >&5
+  $as_echo "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
   for ac_dir in $ac_x_header_dirs; do
@@ -3481,30 +4365,33 @@ case "(($ac_try" in
   *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
   *) ac_try_echo=$ac_try;;
 esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
   (eval "$ac_link") 2>conftest.er1
   ac_status=$?
   grep -v '^ *+' conftest.er1 >conftest.err
   rm -f conftest.er1
   cat conftest.err >&5
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } && {
 	 test -z "$ac_c_werror_flag" ||
 	 test ! -s conftest.err
-       } && test -s conftest$ac_exeext &&
-       $as_test_x conftest$ac_exeext; then
+       } && test -s conftest$ac_exeext && {
+	 test "$cross_compiling" = yes ||
+	 $as_test_x conftest$ac_exeext
+       }; then
   LIBS=$ac_save_LIBS
 # We can link X programs with no special library path.
 ac_x_libraries=
 else
-  echo "$as_me: failed program was:" >&5
+  $as_echo "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
 	LIBS=$ac_save_LIBS
-for ac_dir in `echo "$ac_x_includes $ac_x_header_dirs" | sed s/include/lib/g`
+for ac_dir in `$as_echo "$ac_x_includes $ac_x_header_dirs" | sed s/include/lib/g`
 do
   # Don't even attempt the hair of trying to link an X program!
-  for ac_extension in a so sl; do
+  for ac_extension in a so sl dylib la dll; do
     if test -r "$ac_dir/libX11.$ac_extension"; then
       ac_x_libraries=$ac_dir
       break 2
@@ -3513,6 +4400,7 @@ do
 done
 fi
 
+rm -rf conftest.dSYM
 rm -f core conftest.err conftest.$ac_objext conftest_ipa8_conftest.oo \
       conftest$ac_exeext conftest.$ac_ext
 fi # $ac_x_libraries = no
@@ -3535,8 +4423,8 @@ fi
 fi # $with_x != no
 
 if test "$have_x" != yes; then
-  { echo "$as_me:$LINENO: result: $have_x" >&5
-echo "${ECHO_T}$have_x" >&6; }
+  { $as_echo "$as_me:$LINENO: result: $have_x" >&5
+$as_echo "$have_x" >&6; }
   no_x=yes
 else
   # If each of the values was on the command line, it overrides each guess.
@@ -3546,21 +4434,16 @@ else
   ac_cv_have_x="have_x=yes\
 	ac_x_includes='$x_includes'\
 	ac_x_libraries='$x_libraries'"
-  { echo "$as_me:$LINENO: result: libraries $x_libraries, headers $x_includes" >&5
-echo "${ECHO_T}libraries $x_libraries, headers $x_includes" >&6; }
+  { $as_echo "$as_me:$LINENO: result: libraries $x_libraries, headers $x_includes" >&5
+$as_echo "libraries $x_libraries, headers $x_includes" >&6; }
 fi
 
-{ echo "$as_me:$LINENO: checking for grep that handles long lines and -e" >&5
-echo $ECHO_N "checking for grep that handles long lines and -e... $ECHO_C" >&6; }
+{ $as_echo "$as_me:$LINENO: checking for grep that handles long lines and -e" >&5
+$as_echo_n "checking for grep that handles long lines and -e... " >&6; }
 if test "${ac_cv_path_GREP+set}" = set; then
-  echo $ECHO_N "(cached) $ECHO_C" >&6
+  $as_echo_n "(cached) " >&6
 else
-  # Extract the first word of "grep ggrep" to use in msg output
 if test -z "$GREP"; then
-set dummy grep ggrep; ac_prog_name=$2
-if test "${ac_cv_path_GREP+set}" = set; then
-  echo $ECHO_N "(cached) $ECHO_C" >&6
-else
   ac_path_GREP_found=false
 # Loop through the user's path and test for each of PROGNAME-LIST
 as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
@@ -3579,13 +4462,13 @@ case `"$ac_path_GREP" --version 2>&1` in
   ac_cv_path_GREP="$ac_path_GREP" ac_path_GREP_found=:;;
 *)
   ac_count=0
-  echo $ECHO_N "0123456789$ECHO_C" >"conftest.in"
+  $as_echo_n 0123456789 >"conftest.in"
   while :
   do
     cat "conftest.in" "conftest.in" >"conftest.tmp"
     mv "conftest.tmp" "conftest.in"
     cp "conftest.in" "conftest.nl"
-    echo 'GREP' >> "conftest.nl"
+    $as_echo 'GREP' >> "conftest.nl"
     "$ac_path_GREP" -e 'GREP$' -e '-(cannot match)-' < "conftest.nl" >"conftest.out" 2>/dev/null || break
     diff "conftest.out" "conftest.nl" >/dev/null 2>&1 || break
     ac_count=`expr $ac_count + 1`
@@ -3604,20 +4486,13 @@ esac
     $ac_path_GREP_found && break 3
   done
 done
-
 done
 IFS=$as_save_IFS
-
-
-fi
-
-GREP="$ac_cv_path_GREP"
-if test -z "$GREP"; then
-  { { echo "$as_me:$LINENO: error: no acceptable $ac_prog_name could be found in $PATH$PATH_SEPARATOR/usr/xpg4/bin" >&5
-echo "$as_me: error: no acceptable $ac_prog_name could be found in $PATH$PATH_SEPARATOR/usr/xpg4/bin" >&2;}
+  if test -z "$ac_cv_path_GREP"; then
+    { { $as_echo "$as_me:$LINENO: error: no acceptable grep could be found in $PATH$PATH_SEPARATOR/usr/xpg4/bin" >&5
+$as_echo "$as_me: error: no acceptable grep could be found in $PATH$PATH_SEPARATOR/usr/xpg4/bin" >&2;}
    { (exit 1); exit 1; }; }
 fi
-
 else
   ac_cv_path_GREP=$GREP
 fi
@@ -3622,27 +4497,21 @@ else
   ac_cv_path_GREP=$GREP
 fi
 
-
 fi
-{ echo "$as_me:$LINENO: result: $ac_cv_path_GREP" >&5
-echo "${ECHO_T}$ac_cv_path_GREP" >&6; }
+{ $as_echo "$as_me:$LINENO: result: $ac_cv_path_GREP" >&5
+$as_echo "$ac_cv_path_GREP" >&6; }
  GREP="$ac_cv_path_GREP"
 
 
-{ echo "$as_me:$LINENO: checking for egrep" >&5
-echo $ECHO_N "checking for egrep... $ECHO_C" >&6; }
+{ $as_echo "$as_me:$LINENO: checking for egrep" >&5
+$as_echo_n "checking for egrep... " >&6; }
 if test "${ac_cv_path_EGREP+set}" = set; then
-  echo $ECHO_N "(cached) $ECHO_C" >&6
+  $as_echo_n "(cached) " >&6
 else
   if echo a | $GREP -E '(a|b)' >/dev/null 2>&1
    then ac_cv_path_EGREP="$GREP -E"
    else
-     # Extract the first word of "egrep" to use in msg output
 if test -z "$EGREP"; then
-set dummy egrep; ac_prog_name=$2
-if test "${ac_cv_path_EGREP+set}" = set; then
-  echo $ECHO_N "(cached) $ECHO_C" >&6
-else
   ac_path_EGREP_found=false
 # Loop through the user's path and test for each of PROGNAME-LIST
 as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
@@ -3661,13 +4530,13 @@ case `"$ac_path_EGREP" --version 2>&1` i
   ac_cv_path_EGREP="$ac_path_EGREP" ac_path_EGREP_found=:;;
 *)
   ac_count=0
-  echo $ECHO_N "0123456789$ECHO_C" >"conftest.in"
+  $as_echo_n 0123456789 >"conftest.in"
   while :
   do
     cat "conftest.in" "conftest.in" >"conftest.tmp"
     mv "conftest.tmp" "conftest.in"
     cp "conftest.in" "conftest.nl"
-    echo 'EGREP' >> "conftest.nl"
+    $as_echo 'EGREP' >> "conftest.nl"
     "$ac_path_EGREP" 'EGREP$' < "conftest.nl" >"conftest.out" 2>/dev/null || break
     diff "conftest.out" "conftest.nl" >/dev/null 2>&1 || break
     ac_count=`expr $ac_count + 1`
@@ -3686,20 +4554,13 @@ esac
     $ac_path_EGREP_found && break 3
   done
 done
-
 done
 IFS=$as_save_IFS
-
-
-fi
-
-EGREP="$ac_cv_path_EGREP"
-if test -z "$EGREP"; then
-  { { echo "$as_me:$LINENO: error: no acceptable $ac_prog_name could be found in $PATH$PATH_SEPARATOR/usr/xpg4/bin" >&5
-echo "$as_me: error: no acceptable $ac_prog_name could be found in $PATH$PATH_SEPARATOR/usr/xpg4/bin" >&2;}
+  if test -z "$ac_cv_path_EGREP"; then
+    { { $as_echo "$as_me:$LINENO: error: no acceptable egrep could be found in $PATH$PATH_SEPARATOR/usr/xpg4/bin" >&5
+$as_echo "$as_me: error: no acceptable egrep could be found in $PATH$PATH_SEPARATOR/usr/xpg4/bin" >&2;}
    { (exit 1); exit 1; }; }
 fi
-
 else
   ac_cv_path_EGREP=$EGREP
 fi
@@ -3704,18 +4565,17 @@ else
   ac_cv_path_EGREP=$EGREP
 fi
 
-
    fi
 fi
-{ echo "$as_me:$LINENO: result: $ac_cv_path_EGREP" >&5
-echo "${ECHO_T}$ac_cv_path_EGREP" >&6; }
+{ $as_echo "$as_me:$LINENO: result: $ac_cv_path_EGREP" >&5
+$as_echo "$ac_cv_path_EGREP" >&6; }
  EGREP="$ac_cv_path_EGREP"
 
 
-{ echo "$as_me:$LINENO: checking for ANSI C header files" >&5
-echo $ECHO_N "checking for ANSI C header files... $ECHO_C" >&6; }
+{ $as_echo "$as_me:$LINENO: checking for ANSI C header files" >&5
+$as_echo_n "checking for ANSI C header files... " >&6; }
 if test "${ac_cv_header_stdc+set}" = set; then
-  echo $ECHO_N "(cached) $ECHO_C" >&6
+  $as_echo_n "(cached) " >&6
 else
   cat >conftest.$ac_ext <<_ACEOF
 /* confdefs.h.  */
@@ -3742,20 +4602,21 @@ case "(($ac_try" in
   *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
   *) ac_try_echo=$ac_try;;
 esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
   (eval "$ac_compile") 2>conftest.er1
   ac_status=$?
   grep -v '^ *+' conftest.er1 >conftest.err
   rm -f conftest.er1
   cat conftest.err >&5
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } && {
 	 test -z "$ac_c_werror_flag" ||
 	 test ! -s conftest.err
        } && test -s conftest.$ac_objext; then
   ac_cv_header_stdc=yes
 else
-  echo "$as_me: failed program was:" >&5
+  $as_echo "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
 	ac_cv_header_stdc=no
@@ -3847,37 +4708,40 @@ case "(($ac_try" in
   *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
   *) ac_try_echo=$ac_try;;
 esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
   (eval "$ac_link") 2>&5
   ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } && { ac_try='./conftest$ac_exeext'
   { (case "(($ac_try" in
   *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
   *) ac_try_echo=$ac_try;;
 esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
   (eval "$ac_try") 2>&5
   ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
   :
 else
-  echo "$as_me: program exited with status $ac_status" >&5
-echo "$as_me: failed program was:" >&5
+  $as_echo "$as_me: program exited with status $ac_status" >&5
+$as_echo "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
 ( exit $ac_status )
 ac_cv_header_stdc=no
 fi
+rm -rf conftest.dSYM
 rm -f core *.core core.conftest.* gmon.out bb.out conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
 fi
 
 
 fi
 fi
-{ echo "$as_me:$LINENO: result: $ac_cv_header_stdc" >&5
-echo "${ECHO_T}$ac_cv_header_stdc" >&6; }
+{ $as_echo "$as_me:$LINENO: result: $ac_cv_header_stdc" >&5
+$as_echo "$ac_cv_header_stdc" >&6; }
 if test $ac_cv_header_stdc = yes; then
 
 cat >>confdefs.h <<\_ACEOF
@@ -3896,24 +4760,1855 @@ fi
 
 
 
-for ac_header in sys/types.h sys/stat.h stdlib.h string.h memory.h strings.h \
-		  inttypes.h stdint.h unistd.h
-do
-as_ac_Header=`echo "ac_cv_header_$ac_header" | $as_tr_sh`
-{ echo "$as_me:$LINENO: checking for $ac_header" >&5
-echo $ECHO_N "checking for $ac_header... $ECHO_C" >&6; }
-if { as_var=$as_ac_Header; eval "test \"\${$as_var+set}\" = set"; }; then
-  echo $ECHO_N "(cached) $ECHO_C" >&6
-else
-  cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-$ac_includes_default
+for ac_header in sys/types.h sys/stat.h stdlib.h string.h memory.h strings.h \
+		  inttypes.h stdint.h unistd.h
+do
+as_ac_Header=`$as_echo "ac_cv_header_$ac_header" | $as_tr_sh`
+{ $as_echo "$as_me:$LINENO: checking for $ac_header" >&5
+$as_echo_n "checking for $ac_header... " >&6; }
+if { as_var=$as_ac_Header; eval "test \"\${$as_var+set}\" = set"; }; then
+  $as_echo_n "(cached) " >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+$ac_includes_default
+
+#include <$ac_header>
+_ACEOF
+rm -f conftest.$ac_objext
+if { (ac_try="$ac_compile"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
+  (eval "$ac_compile") 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && {
+	 test -z "$ac_c_werror_flag" ||
+	 test ! -s conftest.err
+       } && test -s conftest.$ac_objext; then
+  eval "$as_ac_Header=yes"
+else
+  $as_echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+	eval "$as_ac_Header=no"
+fi
+
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+fi
+ac_res=`eval 'as_val=${'$as_ac_Header'}
+		 $as_echo "$as_val"'`
+	       { $as_echo "$as_me:$LINENO: result: $ac_res" >&5
+$as_echo "$ac_res" >&6; }
+as_val=`eval 'as_val=${'$as_ac_Header'}
+		 $as_echo "$as_val"'`
+   if test "x$as_val" = x""yes; then
+  cat >>confdefs.h <<_ACEOF
+#define `$as_echo "HAVE_$ac_header" | $as_tr_cpp` 1
+_ACEOF
+
+fi
+
+done
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+for ac_header in errno.h fcntl.h float.h limits.h malloc.h memory.h stdlib.h string.h sys/ioctl.h sys/socket.h sys/time.h unistd.h
+do
+as_ac_Header=`$as_echo "ac_cv_header_$ac_header" | $as_tr_sh`
+if { as_var=$as_ac_Header; eval "test \"\${$as_var+set}\" = set"; }; then
+  { $as_echo "$as_me:$LINENO: checking for $ac_header" >&5
+$as_echo_n "checking for $ac_header... " >&6; }
+if { as_var=$as_ac_Header; eval "test \"\${$as_var+set}\" = set"; }; then
+  $as_echo_n "(cached) " >&6
+fi
+ac_res=`eval 'as_val=${'$as_ac_Header'}
+		 $as_echo "$as_val"'`
+	       { $as_echo "$as_me:$LINENO: result: $ac_res" >&5
+$as_echo "$ac_res" >&6; }
+else
+  # Is the header compilable?
+{ $as_echo "$as_me:$LINENO: checking $ac_header usability" >&5
+$as_echo_n "checking $ac_header usability... " >&6; }
+cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+$ac_includes_default
+#include <$ac_header>
+_ACEOF
+rm -f conftest.$ac_objext
+if { (ac_try="$ac_compile"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
+  (eval "$ac_compile") 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && {
+	 test -z "$ac_c_werror_flag" ||
+	 test ! -s conftest.err
+       } && test -s conftest.$ac_objext; then
+  ac_header_compiler=yes
+else
+  $as_echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+	ac_header_compiler=no
+fi
+
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+{ $as_echo "$as_me:$LINENO: result: $ac_header_compiler" >&5
+$as_echo "$ac_header_compiler" >&6; }
+
+# Is the header present?
+{ $as_echo "$as_me:$LINENO: checking $ac_header presence" >&5
+$as_echo_n "checking $ac_header presence... " >&6; }
+cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <$ac_header>
+_ACEOF
+if { (ac_try="$ac_cpp conftest.$ac_ext"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
+  (eval "$ac_cpp conftest.$ac_ext") 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } >/dev/null && {
+	 test -z "$ac_c_preproc_warn_flag$ac_c_werror_flag" ||
+	 test ! -s conftest.err
+       }; then
+  ac_header_preproc=yes
+else
+  $as_echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+  ac_header_preproc=no
+fi
+
+rm -f conftest.err conftest.$ac_ext
+{ $as_echo "$as_me:$LINENO: result: $ac_header_preproc" >&5
+$as_echo "$ac_header_preproc" >&6; }
+
+# So?  What about this header?
+case $ac_header_compiler:$ac_header_preproc:$ac_c_preproc_warn_flag in
+  yes:no: )
+    { $as_echo "$as_me:$LINENO: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&5
+$as_echo "$as_me: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&2;}
+    { $as_echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the compiler's result" >&5
+$as_echo "$as_me: WARNING: $ac_header: proceeding with the compiler's result" >&2;}
+    ac_header_preproc=yes
+    ;;
+  no:yes:* )
+    { $as_echo "$as_me:$LINENO: WARNING: $ac_header: present but cannot be compiled" >&5
+$as_echo "$as_me: WARNING: $ac_header: present but cannot be compiled" >&2;}
+    { $as_echo "$as_me:$LINENO: WARNING: $ac_header:     check for missing prerequisite headers?" >&5
+$as_echo "$as_me: WARNING: $ac_header:     check for missing prerequisite headers?" >&2;}
+    { $as_echo "$as_me:$LINENO: WARNING: $ac_header: see the Autoconf documentation" >&5
+$as_echo "$as_me: WARNING: $ac_header: see the Autoconf documentation" >&2;}
+    { $as_echo "$as_me:$LINENO: WARNING: $ac_header:     section \"Present But Cannot Be Compiled\"" >&5
+$as_echo "$as_me: WARNING: $ac_header:     section \"Present But Cannot Be Compiled\"" >&2;}
+    { $as_echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the preprocessor's result" >&5
+$as_echo "$as_me: WARNING: $ac_header: proceeding with the preprocessor's result" >&2;}
+    { $as_echo "$as_me:$LINENO: WARNING: $ac_header: in the future, the compiler will take precedence" >&5
+$as_echo "$as_me: WARNING: $ac_header: in the future, the compiler will take precedence" >&2;}
+    ( cat <<\_ASBOX
+## ---------------------------------------- ##
+## Report this to hts-users@sp.nitech.ac.jp ##
+## ---------------------------------------- ##
+_ASBOX
+     ) | sed "s/^/$as_me: WARNING:     /" >&2
+    ;;
+esac
+{ $as_echo "$as_me:$LINENO: checking for $ac_header" >&5
+$as_echo_n "checking for $ac_header... " >&6; }
+if { as_var=$as_ac_Header; eval "test \"\${$as_var+set}\" = set"; }; then
+  $as_echo_n "(cached) " >&6
+else
+  eval "$as_ac_Header=\$ac_header_preproc"
+fi
+ac_res=`eval 'as_val=${'$as_ac_Header'}
+		 $as_echo "$as_val"'`
+	       { $as_echo "$as_me:$LINENO: result: $ac_res" >&5
+$as_echo "$ac_res" >&6; }
+
+fi
+as_val=`eval 'as_val=${'$as_ac_Header'}
+		 $as_echo "$as_val"'`
+   if test "x$as_val" = x""yes; then
+  cat >>confdefs.h <<_ACEOF
+#define `$as_echo "HAVE_$ac_header" | $as_tr_cpp` 1
+_ACEOF
+
+fi
+
+done
+
+
+{ $as_echo "$as_me:$LINENO: checking for an ANSI C-conforming const" >&5
+$as_echo_n "checking for an ANSI C-conforming const... " >&6; }
+if test "${ac_cv_c_const+set}" = set; then
+  $as_echo_n "(cached) " >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+int
+main ()
+{
+/* FIXME: Include the comments suggested by Paul. */
+#ifndef __cplusplus
+  /* Ultrix mips cc rejects this.  */
+  typedef int charset[2];
+  const charset cs;
+  /* SunOS 4.1.1 cc rejects this.  */
+  char const *const *pcpcc;
+  char **ppc;
+  /* NEC SVR4.0.2 mips cc rejects this.  */
+  struct point {int x, y;};
+  static struct point const zero = {0,0};
+  /* AIX XL C 1.02.0.0 rejects this.
+     It does not let you subtract one const X* pointer from another in
+     an arm of an if-expression whose if-part is not a constant
+     expression */
+  const char *g = "string";
+  pcpcc = &g + (g ? g-g : 0);
+  /* HPUX 7.0 cc rejects these. */
+  ++pcpcc;
+  ppc = (char**) pcpcc;
+  pcpcc = (char const *const *) ppc;
+  { /* SCO 3.2v4 cc rejects this.  */
+    char *t;
+    char const *s = 0 ? (char *) 0 : (char const *) 0;
+
+    *t++ = 0;
+    if (s) return 0;
+  }
+  { /* Someone thinks the Sun supposedly-ANSI compiler will reject this.  */
+    int x[] = {25, 17};
+    const int *foo = &x[0];
+    ++foo;
+  }
+  { /* Sun SC1.0 ANSI compiler rejects this -- but not the above. */
+    typedef const int *iptr;
+    iptr p = 0;
+    ++p;
+  }
+  { /* AIX XL C 1.02.0.0 rejects this saying
+       "k.c", line 2.27: 1506-025 (S) Operand must be a modifiable lvalue. */
+    struct s { int j; const int *ap[3]; };
+    struct s *b; b->j = 5;
+  }
+  { /* ULTRIX-32 V3.1 (Rev 9) vcc rejects this */
+    const int foo = 10;
+    if (!foo) return 0;
+  }
+  return !cs[0] && !zero.x;
+#endif
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (ac_try="$ac_compile"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
+  (eval "$ac_compile") 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && {
+	 test -z "$ac_c_werror_flag" ||
+	 test ! -s conftest.err
+       } && test -s conftest.$ac_objext; then
+  ac_cv_c_const=yes
+else
+  $as_echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+	ac_cv_c_const=no
+fi
+
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+fi
+{ $as_echo "$as_me:$LINENO: result: $ac_cv_c_const" >&5
+$as_echo "$ac_cv_c_const" >&6; }
+if test $ac_cv_c_const = no; then
+
+cat >>confdefs.h <<\_ACEOF
+#define const /**/
+_ACEOF
+
+fi
+
+{ $as_echo "$as_me:$LINENO: checking for working volatile" >&5
+$as_echo_n "checking for working volatile... " >&6; }
+if test "${ac_cv_c_volatile+set}" = set; then
+  $as_echo_n "(cached) " >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+int
+main ()
+{
+
+volatile int x;
+int * volatile y = (int *) 0;
+return !x && !y;
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (ac_try="$ac_compile"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
+  (eval "$ac_compile") 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && {
+	 test -z "$ac_c_werror_flag" ||
+	 test ! -s conftest.err
+       } && test -s conftest.$ac_objext; then
+  ac_cv_c_volatile=yes
+else
+  $as_echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+	ac_cv_c_volatile=no
+fi
+
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+fi
+{ $as_echo "$as_me:$LINENO: result: $ac_cv_c_volatile" >&5
+$as_echo "$ac_cv_c_volatile" >&6; }
+if test $ac_cv_c_volatile = no; then
+
+cat >>confdefs.h <<\_ACEOF
+#define volatile /**/
+_ACEOF
+
+fi
+
+{ $as_echo "$as_me:$LINENO: checking for size_t" >&5
+$as_echo_n "checking for size_t... " >&6; }
+if test "${ac_cv_type_size_t+set}" = set; then
+  $as_echo_n "(cached) " >&6
+else
+  ac_cv_type_size_t=no
+cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+$ac_includes_default
+int
+main ()
+{
+if (sizeof (size_t))
+       return 0;
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (ac_try="$ac_compile"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
+  (eval "$ac_compile") 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && {
+	 test -z "$ac_c_werror_flag" ||
+	 test ! -s conftest.err
+       } && test -s conftest.$ac_objext; then
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+$ac_includes_default
+int
+main ()
+{
+if (sizeof ((size_t)))
+	  return 0;
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (ac_try="$ac_compile"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
+  (eval "$ac_compile") 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && {
+	 test -z "$ac_c_werror_flag" ||
+	 test ! -s conftest.err
+       } && test -s conftest.$ac_objext; then
+  :
+else
+  $as_echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+	ac_cv_type_size_t=yes
+fi
+
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+else
+  $as_echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+
+fi
+
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+fi
+{ $as_echo "$as_me:$LINENO: result: $ac_cv_type_size_t" >&5
+$as_echo "$ac_cv_type_size_t" >&6; }
+if test "x$ac_cv_type_size_t" = x""yes; then
+  :
+else
+
+cat >>confdefs.h <<_ACEOF
+#define size_t unsigned int
+_ACEOF
+
+fi
+
+{ $as_echo "$as_me:$LINENO: checking whether time.h and sys/time.h may both be included" >&5
+$as_echo_n "checking whether time.h and sys/time.h may both be included... " >&6; }
+if test "${ac_cv_header_time+set}" = set; then
+  $as_echo_n "(cached) " >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <sys/types.h>
+#include <sys/time.h>
+#include <time.h>
+
+int
+main ()
+{
+if ((struct tm *) 0)
+return 0;
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (ac_try="$ac_compile"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
+  (eval "$ac_compile") 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && {
+	 test -z "$ac_c_werror_flag" ||
+	 test ! -s conftest.err
+       } && test -s conftest.$ac_objext; then
+  ac_cv_header_time=yes
+else
+  $as_echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+	ac_cv_header_time=no
+fi
+
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+fi
+{ $as_echo "$as_me:$LINENO: result: $ac_cv_header_time" >&5
+$as_echo "$ac_cv_header_time" >&6; }
+if test $ac_cv_header_time = yes; then
+
+cat >>confdefs.h <<\_ACEOF
+#define TIME_WITH_SYS_TIME 1
+_ACEOF
+
+fi
+
+{ $as_echo "$as_me:$LINENO: checking whether struct tm is in sys/time.h or time.h" >&5
+$as_echo_n "checking whether struct tm is in sys/time.h or time.h... " >&6; }
+if test "${ac_cv_struct_tm+set}" = set; then
+  $as_echo_n "(cached) " >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <sys/types.h>
+#include <time.h>
+
+int
+main ()
+{
+struct tm tm;
+				     int *p = &tm.tm_sec;
+				     return !p;
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (ac_try="$ac_compile"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
+  (eval "$ac_compile") 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && {
+	 test -z "$ac_c_werror_flag" ||
+	 test ! -s conftest.err
+       } && test -s conftest.$ac_objext; then
+  ac_cv_struct_tm=time.h
+else
+  $as_echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+	ac_cv_struct_tm=sys/time.h
+fi
+
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+fi
+{ $as_echo "$as_me:$LINENO: result: $ac_cv_struct_tm" >&5
+$as_echo "$ac_cv_struct_tm" >&6; }
+if test $ac_cv_struct_tm = sys/time.h; then
+
+cat >>confdefs.h <<\_ACEOF
+#define TM_IN_SYS_TIME 1
+_ACEOF
+
+fi
+
+
+if test $ac_cv_c_compiler_gnu = yes; then
+    { $as_echo "$as_me:$LINENO: checking whether $CC needs -traditional" >&5
+$as_echo_n "checking whether $CC needs -traditional... " >&6; }
+if test "${ac_cv_prog_gcc_traditional+set}" = set; then
+  $as_echo_n "(cached) " >&6
+else
+    ac_pattern="Autoconf.*'x'"
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <sgtty.h>
+Autoconf TIOCGETP
+_ACEOF
+if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
+  $EGREP "$ac_pattern" >/dev/null 2>&1; then
+  ac_cv_prog_gcc_traditional=yes
+else
+  ac_cv_prog_gcc_traditional=no
+fi
+rm -f conftest*
+
+
+  if test $ac_cv_prog_gcc_traditional = no; then
+    cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <termio.h>
+Autoconf TCGETA
+_ACEOF
+if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
+  $EGREP "$ac_pattern" >/dev/null 2>&1; then
+  ac_cv_prog_gcc_traditional=yes
+fi
+rm -f conftest*
+
+  fi
+fi
+{ $as_echo "$as_me:$LINENO: result: $ac_cv_prog_gcc_traditional" >&5
+$as_echo "$ac_cv_prog_gcc_traditional" >&6; }
+  if test $ac_cv_prog_gcc_traditional = yes; then
+    CC="$CC -traditional"
+  fi
+fi
+
+{ $as_echo "$as_me:$LINENO: checking for working memcmp" >&5
+$as_echo_n "checking for working memcmp... " >&6; }
+if test "${ac_cv_func_memcmp_working+set}" = set; then
+  $as_echo_n "(cached) " >&6
+else
+  if test "$cross_compiling" = yes; then
+  ac_cv_func_memcmp_working=no
+else
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+$ac_includes_default
+int
+main ()
+{
+
+  /* Some versions of memcmp are not 8-bit clean.  */
+  char c0 = '\100', c1 = '\200', c2 = '\201';
+  if (memcmp(&c0, &c2, 1) >= 0 || memcmp(&c1, &c2, 1) >= 0)
+    return 1;
+
+  /* The Next x86 OpenStep bug shows up only when comparing 16 bytes
+     or more and with at least one buffer not starting on a 4-byte boundary.
+     William Lewis provided this test program.   */
+  {
+    char foo[21];
+    char bar[21];
+    int i;
+    for (i = 0; i < 4; i++)
+      {
+	char *a = foo + i;
+	char *b = bar + i;
+	strcpy (a, "--------01111111");
+	strcpy (b, "--------10000000");
+	if (memcmp (a, b, 16) >= 0)
+	  return 1;
+      }
+    return 0;
+  }
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest$ac_exeext
+if { (ac_try="$ac_link"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
+  (eval "$ac_link") 2>&5
+  ac_status=$?
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && { ac_try='./conftest$ac_exeext'
+  { (case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
+  (eval "$ac_try") 2>&5
+  ac_status=$?
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_func_memcmp_working=yes
+else
+  $as_echo "$as_me: program exited with status $ac_status" >&5
+$as_echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+( exit $ac_status )
+ac_cv_func_memcmp_working=no
+fi
+rm -rf conftest.dSYM
+rm -f core *.core core.conftest.* gmon.out bb.out conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
+fi
+
+
+fi
+{ $as_echo "$as_me:$LINENO: result: $ac_cv_func_memcmp_working" >&5
+$as_echo "$ac_cv_func_memcmp_working" >&6; }
+test $ac_cv_func_memcmp_working = no && case " $LIBOBJS " in
+  *" memcmp.$ac_objext "* ) ;;
+  *) LIBOBJS="$LIBOBJS memcmp.$ac_objext"
+ ;;
+esac
+
+
+
+for ac_header in stdlib.h
+do
+as_ac_Header=`$as_echo "ac_cv_header_$ac_header" | $as_tr_sh`
+if { as_var=$as_ac_Header; eval "test \"\${$as_var+set}\" = set"; }; then
+  { $as_echo "$as_me:$LINENO: checking for $ac_header" >&5
+$as_echo_n "checking for $ac_header... " >&6; }
+if { as_var=$as_ac_Header; eval "test \"\${$as_var+set}\" = set"; }; then
+  $as_echo_n "(cached) " >&6
+fi
+ac_res=`eval 'as_val=${'$as_ac_Header'}
+		 $as_echo "$as_val"'`
+	       { $as_echo "$as_me:$LINENO: result: $ac_res" >&5
+$as_echo "$ac_res" >&6; }
+else
+  # Is the header compilable?
+{ $as_echo "$as_me:$LINENO: checking $ac_header usability" >&5
+$as_echo_n "checking $ac_header usability... " >&6; }
+cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+$ac_includes_default
+#include <$ac_header>
+_ACEOF
+rm -f conftest.$ac_objext
+if { (ac_try="$ac_compile"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
+  (eval "$ac_compile") 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && {
+	 test -z "$ac_c_werror_flag" ||
+	 test ! -s conftest.err
+       } && test -s conftest.$ac_objext; then
+  ac_header_compiler=yes
+else
+  $as_echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+	ac_header_compiler=no
+fi
+
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+{ $as_echo "$as_me:$LINENO: result: $ac_header_compiler" >&5
+$as_echo "$ac_header_compiler" >&6; }
+
+# Is the header present?
+{ $as_echo "$as_me:$LINENO: checking $ac_header presence" >&5
+$as_echo_n "checking $ac_header presence... " >&6; }
+cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <$ac_header>
+_ACEOF
+if { (ac_try="$ac_cpp conftest.$ac_ext"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
+  (eval "$ac_cpp conftest.$ac_ext") 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } >/dev/null && {
+	 test -z "$ac_c_preproc_warn_flag$ac_c_werror_flag" ||
+	 test ! -s conftest.err
+       }; then
+  ac_header_preproc=yes
+else
+  $as_echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+  ac_header_preproc=no
+fi
+
+rm -f conftest.err conftest.$ac_ext
+{ $as_echo "$as_me:$LINENO: result: $ac_header_preproc" >&5
+$as_echo "$ac_header_preproc" >&6; }
+
+# So?  What about this header?
+case $ac_header_compiler:$ac_header_preproc:$ac_c_preproc_warn_flag in
+  yes:no: )
+    { $as_echo "$as_me:$LINENO: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&5
+$as_echo "$as_me: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&2;}
+    { $as_echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the compiler's result" >&5
+$as_echo "$as_me: WARNING: $ac_header: proceeding with the compiler's result" >&2;}
+    ac_header_preproc=yes
+    ;;
+  no:yes:* )
+    { $as_echo "$as_me:$LINENO: WARNING: $ac_header: present but cannot be compiled" >&5
+$as_echo "$as_me: WARNING: $ac_header: present but cannot be compiled" >&2;}
+    { $as_echo "$as_me:$LINENO: WARNING: $ac_header:     check for missing prerequisite headers?" >&5
+$as_echo "$as_me: WARNING: $ac_header:     check for missing prerequisite headers?" >&2;}
+    { $as_echo "$as_me:$LINENO: WARNING: $ac_header: see the Autoconf documentation" >&5
+$as_echo "$as_me: WARNING: $ac_header: see the Autoconf documentation" >&2;}
+    { $as_echo "$as_me:$LINENO: WARNING: $ac_header:     section \"Present But Cannot Be Compiled\"" >&5
+$as_echo "$as_me: WARNING: $ac_header:     section \"Present But Cannot Be Compiled\"" >&2;}
+    { $as_echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the preprocessor's result" >&5
+$as_echo "$as_me: WARNING: $ac_header: proceeding with the preprocessor's result" >&2;}
+    { $as_echo "$as_me:$LINENO: WARNING: $ac_header: in the future, the compiler will take precedence" >&5
+$as_echo "$as_me: WARNING: $ac_header: in the future, the compiler will take precedence" >&2;}
+    ( cat <<\_ASBOX
+## ---------------------------------------- ##
+## Report this to hts-users@sp.nitech.ac.jp ##
+## ---------------------------------------- ##
+_ASBOX
+     ) | sed "s/^/$as_me: WARNING:     /" >&2
+    ;;
+esac
+{ $as_echo "$as_me:$LINENO: checking for $ac_header" >&5
+$as_echo_n "checking for $ac_header... " >&6; }
+if { as_var=$as_ac_Header; eval "test \"\${$as_var+set}\" = set"; }; then
+  $as_echo_n "(cached) " >&6
+else
+  eval "$as_ac_Header=\$ac_header_preproc"
+fi
+ac_res=`eval 'as_val=${'$as_ac_Header'}
+		 $as_echo "$as_val"'`
+	       { $as_echo "$as_me:$LINENO: result: $ac_res" >&5
+$as_echo "$ac_res" >&6; }
+
+fi
+as_val=`eval 'as_val=${'$as_ac_Header'}
+		 $as_echo "$as_val"'`
+   if test "x$as_val" = x""yes; then
+  cat >>confdefs.h <<_ACEOF
+#define `$as_echo "HAVE_$ac_header" | $as_tr_cpp` 1
+_ACEOF
+
+fi
+
+done
+
+{ $as_echo "$as_me:$LINENO: checking for GNU libc compatible malloc" >&5
+$as_echo_n "checking for GNU libc compatible malloc... " >&6; }
+if test "${ac_cv_func_malloc_0_nonnull+set}" = set; then
+  $as_echo_n "(cached) " >&6
+else
+  if test "$cross_compiling" = yes; then
+  ac_cv_func_malloc_0_nonnull=no
+else
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#if defined STDC_HEADERS || defined HAVE_STDLIB_H
+# include <stdlib.h>
+#else
+char *malloc ();
+#endif
+
+int
+main ()
+{
+return ! malloc (0);
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest$ac_exeext
+if { (ac_try="$ac_link"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
+  (eval "$ac_link") 2>&5
+  ac_status=$?
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && { ac_try='./conftest$ac_exeext'
+  { (case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
+  (eval "$ac_try") 2>&5
+  ac_status=$?
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_func_malloc_0_nonnull=yes
+else
+  $as_echo "$as_me: program exited with status $ac_status" >&5
+$as_echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+( exit $ac_status )
+ac_cv_func_malloc_0_nonnull=no
+fi
+rm -rf conftest.dSYM
+rm -f core *.core core.conftest.* gmon.out bb.out conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
+fi
+
+
+fi
+{ $as_echo "$as_me:$LINENO: result: $ac_cv_func_malloc_0_nonnull" >&5
+$as_echo "$ac_cv_func_malloc_0_nonnull" >&6; }
+if test $ac_cv_func_malloc_0_nonnull = yes; then
+
+cat >>confdefs.h <<\_ACEOF
+#define HAVE_MALLOC 1
+_ACEOF
+
+else
+  cat >>confdefs.h <<\_ACEOF
+#define HAVE_MALLOC 0
+_ACEOF
+
+   case " $LIBOBJS " in
+  *" malloc.$ac_objext "* ) ;;
+  *) LIBOBJS="$LIBOBJS malloc.$ac_objext"
+ ;;
+esac
+
+
+cat >>confdefs.h <<\_ACEOF
+#define malloc rpl_malloc
+_ACEOF
+
+fi
+
+
+
+
+for ac_header in stdlib.h
+do
+as_ac_Header=`$as_echo "ac_cv_header_$ac_header" | $as_tr_sh`
+if { as_var=$as_ac_Header; eval "test \"\${$as_var+set}\" = set"; }; then
+  { $as_echo "$as_me:$LINENO: checking for $ac_header" >&5
+$as_echo_n "checking for $ac_header... " >&6; }
+if { as_var=$as_ac_Header; eval "test \"\${$as_var+set}\" = set"; }; then
+  $as_echo_n "(cached) " >&6
+fi
+ac_res=`eval 'as_val=${'$as_ac_Header'}
+		 $as_echo "$as_val"'`
+	       { $as_echo "$as_me:$LINENO: result: $ac_res" >&5
+$as_echo "$ac_res" >&6; }
+else
+  # Is the header compilable?
+{ $as_echo "$as_me:$LINENO: checking $ac_header usability" >&5
+$as_echo_n "checking $ac_header usability... " >&6; }
+cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+$ac_includes_default
+#include <$ac_header>
+_ACEOF
+rm -f conftest.$ac_objext
+if { (ac_try="$ac_compile"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
+  (eval "$ac_compile") 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && {
+	 test -z "$ac_c_werror_flag" ||
+	 test ! -s conftest.err
+       } && test -s conftest.$ac_objext; then
+  ac_header_compiler=yes
+else
+  $as_echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+	ac_header_compiler=no
+fi
+
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+{ $as_echo "$as_me:$LINENO: result: $ac_header_compiler" >&5
+$as_echo "$ac_header_compiler" >&6; }
+
+# Is the header present?
+{ $as_echo "$as_me:$LINENO: checking $ac_header presence" >&5
+$as_echo_n "checking $ac_header presence... " >&6; }
+cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <$ac_header>
+_ACEOF
+if { (ac_try="$ac_cpp conftest.$ac_ext"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
+  (eval "$ac_cpp conftest.$ac_ext") 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } >/dev/null && {
+	 test -z "$ac_c_preproc_warn_flag$ac_c_werror_flag" ||
+	 test ! -s conftest.err
+       }; then
+  ac_header_preproc=yes
+else
+  $as_echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+  ac_header_preproc=no
+fi
+
+rm -f conftest.err conftest.$ac_ext
+{ $as_echo "$as_me:$LINENO: result: $ac_header_preproc" >&5
+$as_echo "$ac_header_preproc" >&6; }
+
+# So?  What about this header?
+case $ac_header_compiler:$ac_header_preproc:$ac_c_preproc_warn_flag in
+  yes:no: )
+    { $as_echo "$as_me:$LINENO: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&5
+$as_echo "$as_me: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&2;}
+    { $as_echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the compiler's result" >&5
+$as_echo "$as_me: WARNING: $ac_header: proceeding with the compiler's result" >&2;}
+    ac_header_preproc=yes
+    ;;
+  no:yes:* )
+    { $as_echo "$as_me:$LINENO: WARNING: $ac_header: present but cannot be compiled" >&5
+$as_echo "$as_me: WARNING: $ac_header: present but cannot be compiled" >&2;}
+    { $as_echo "$as_me:$LINENO: WARNING: $ac_header:     check for missing prerequisite headers?" >&5
+$as_echo "$as_me: WARNING: $ac_header:     check for missing prerequisite headers?" >&2;}
+    { $as_echo "$as_me:$LINENO: WARNING: $ac_header: see the Autoconf documentation" >&5
+$as_echo "$as_me: WARNING: $ac_header: see the Autoconf documentation" >&2;}
+    { $as_echo "$as_me:$LINENO: WARNING: $ac_header:     section \"Present But Cannot Be Compiled\"" >&5
+$as_echo "$as_me: WARNING: $ac_header:     section \"Present But Cannot Be Compiled\"" >&2;}
+    { $as_echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the preprocessor's result" >&5
+$as_echo "$as_me: WARNING: $ac_header: proceeding with the preprocessor's result" >&2;}
+    { $as_echo "$as_me:$LINENO: WARNING: $ac_header: in the future, the compiler will take precedence" >&5
+$as_echo "$as_me: WARNING: $ac_header: in the future, the compiler will take precedence" >&2;}
+    ( cat <<\_ASBOX
+## ---------------------------------------- ##
+## Report this to hts-users@sp.nitech.ac.jp ##
+## ---------------------------------------- ##
+_ASBOX
+     ) | sed "s/^/$as_me: WARNING:     /" >&2
+    ;;
+esac
+{ $as_echo "$as_me:$LINENO: checking for $ac_header" >&5
+$as_echo_n "checking for $ac_header... " >&6; }
+if { as_var=$as_ac_Header; eval "test \"\${$as_var+set}\" = set"; }; then
+  $as_echo_n "(cached) " >&6
+else
+  eval "$as_ac_Header=\$ac_header_preproc"
+fi
+ac_res=`eval 'as_val=${'$as_ac_Header'}
+		 $as_echo "$as_val"'`
+	       { $as_echo "$as_me:$LINENO: result: $ac_res" >&5
+$as_echo "$ac_res" >&6; }
+
+fi
+as_val=`eval 'as_val=${'$as_ac_Header'}
+		 $as_echo "$as_val"'`
+   if test "x$as_val" = x""yes; then
+  cat >>confdefs.h <<_ACEOF
+#define `$as_echo "HAVE_$ac_header" | $as_tr_cpp` 1
+_ACEOF
+
+fi
+
+done
+
+{ $as_echo "$as_me:$LINENO: checking for GNU libc compatible realloc" >&5
+$as_echo_n "checking for GNU libc compatible realloc... " >&6; }
+if test "${ac_cv_func_realloc_0_nonnull+set}" = set; then
+  $as_echo_n "(cached) " >&6
+else
+  if test "$cross_compiling" = yes; then
+  ac_cv_func_realloc_0_nonnull=no
+else
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#if defined STDC_HEADERS || defined HAVE_STDLIB_H
+# include <stdlib.h>
+#else
+char *realloc ();
+#endif
+
+int
+main ()
+{
+return ! realloc (0, 0);
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest$ac_exeext
+if { (ac_try="$ac_link"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
+  (eval "$ac_link") 2>&5
+  ac_status=$?
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && { ac_try='./conftest$ac_exeext'
+  { (case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
+  (eval "$ac_try") 2>&5
+  ac_status=$?
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_func_realloc_0_nonnull=yes
+else
+  $as_echo "$as_me: program exited with status $ac_status" >&5
+$as_echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+( exit $ac_status )
+ac_cv_func_realloc_0_nonnull=no
+fi
+rm -rf conftest.dSYM
+rm -f core *.core core.conftest.* gmon.out bb.out conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
+fi
+
+
+fi
+{ $as_echo "$as_me:$LINENO: result: $ac_cv_func_realloc_0_nonnull" >&5
+$as_echo "$ac_cv_func_realloc_0_nonnull" >&6; }
+if test $ac_cv_func_realloc_0_nonnull = yes; then
+
+cat >>confdefs.h <<\_ACEOF
+#define HAVE_REALLOC 1
+_ACEOF
+
+else
+  cat >>confdefs.h <<\_ACEOF
+#define HAVE_REALLOC 0
+_ACEOF
+
+   case " $LIBOBJS " in
+  *" realloc.$ac_objext "* ) ;;
+  *) LIBOBJS="$LIBOBJS realloc.$ac_objext"
+ ;;
+esac
+
+
+cat >>confdefs.h <<\_ACEOF
+#define realloc rpl_realloc
+_ACEOF
+
+fi
+
+
+
+{ $as_echo "$as_me:$LINENO: checking for working strtod" >&5
+$as_echo_n "checking for working strtod... " >&6; }
+if test "${ac_cv_func_strtod+set}" = set; then
+  $as_echo_n "(cached) " >&6
+else
+  if test "$cross_compiling" = yes; then
+  ac_cv_func_strtod=no
+else
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+$ac_includes_default
+#ifndef strtod
+double strtod ();
+#endif
+int
+main()
+{
+  {
+    /* Some versions of Linux strtod mis-parse strings with leading '+'.  */
+    char *string = " +69";
+    char *term;
+    double value;
+    value = strtod (string, &term);
+    if (value != 69 || term != (string + 4))
+      return 1;
+  }
+
+  {
+    /* Under Solaris 2.4, strtod returns the wrong value for the
+       terminating character under some conditions.  */
+    char *string = "NaN";
+    char *term;
+    strtod (string, &term);
+    if (term != string && *(term - 1) == 0)
+      return 1;
+  }
+  return 0;
+}
+
+_ACEOF
+rm -f conftest$ac_exeext
+if { (ac_try="$ac_link"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
+  (eval "$ac_link") 2>&5
+  ac_status=$?
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && { ac_try='./conftest$ac_exeext'
+  { (case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
+  (eval "$ac_try") 2>&5
+  ac_status=$?
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_func_strtod=yes
+else
+  $as_echo "$as_me: program exited with status $ac_status" >&5
+$as_echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+( exit $ac_status )
+ac_cv_func_strtod=no
+fi
+rm -rf conftest.dSYM
+rm -f core *.core core.conftest.* gmon.out bb.out conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
+fi
+
+
+fi
+{ $as_echo "$as_me:$LINENO: result: $ac_cv_func_strtod" >&5
+$as_echo "$ac_cv_func_strtod" >&6; }
+if test $ac_cv_func_strtod = no; then
+  case " $LIBOBJS " in
+  *" strtod.$ac_objext "* ) ;;
+  *) LIBOBJS="$LIBOBJS strtod.$ac_objext"
+ ;;
+esac
+
+{ $as_echo "$as_me:$LINENO: checking for pow" >&5
+$as_echo_n "checking for pow... " >&6; }
+if test "${ac_cv_func_pow+set}" = set; then
+  $as_echo_n "(cached) " >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+/* Define pow to an innocuous variant, in case <limits.h> declares pow.
+   For example, HP-UX 11i <limits.h> declares gettimeofday.  */
+#define pow innocuous_pow
+
+/* System header to define __stub macros and hopefully few prototypes,
+    which can conflict with char pow (); below.
+    Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
+    <limits.h> exists even on freestanding compilers.  */
+
+#ifdef __STDC__
+# include <limits.h>
+#else
+# include <assert.h>
+#endif
+
+#undef pow
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char pow ();
+/* The GNU C library defines this for functions which it implements
+    to always fail with ENOSYS.  Some functions are actually named
+    something starting with __ and the normal name is an alias.  */
+#if defined __stub_pow || defined __stub___pow
+choke me
+#endif
+
+int
+main ()
+{
+return pow ();
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (ac_try="$ac_link"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
+  (eval "$ac_link") 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && {
+	 test -z "$ac_c_werror_flag" ||
+	 test ! -s conftest.err
+       } && test -s conftest$ac_exeext && {
+	 test "$cross_compiling" = yes ||
+	 $as_test_x conftest$ac_exeext
+       }; then
+  ac_cv_func_pow=yes
+else
+  $as_echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+	ac_cv_func_pow=no
+fi
+
+rm -rf conftest.dSYM
+rm -f core conftest.err conftest.$ac_objext conftest_ipa8_conftest.oo \
+      conftest$ac_exeext conftest.$ac_ext
+fi
+{ $as_echo "$as_me:$LINENO: result: $ac_cv_func_pow" >&5
+$as_echo "$ac_cv_func_pow" >&6; }
+
+if test $ac_cv_func_pow = no; then
+  { $as_echo "$as_me:$LINENO: checking for pow in -lm" >&5
+$as_echo_n "checking for pow in -lm... " >&6; }
+if test "${ac_cv_lib_m_pow+set}" = set; then
+  $as_echo_n "(cached) " >&6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-lm  $LIBS"
+cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char pow ();
+int
+main ()
+{
+return pow ();
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (ac_try="$ac_link"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
+  (eval "$ac_link") 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && {
+	 test -z "$ac_c_werror_flag" ||
+	 test ! -s conftest.err
+       } && test -s conftest$ac_exeext && {
+	 test "$cross_compiling" = yes ||
+	 $as_test_x conftest$ac_exeext
+       }; then
+  ac_cv_lib_m_pow=yes
+else
+  $as_echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+	ac_cv_lib_m_pow=no
+fi
+
+rm -rf conftest.dSYM
+rm -f core conftest.err conftest.$ac_objext conftest_ipa8_conftest.oo \
+      conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+{ $as_echo "$as_me:$LINENO: result: $ac_cv_lib_m_pow" >&5
+$as_echo "$ac_cv_lib_m_pow" >&6; }
+if test "x$ac_cv_lib_m_pow" = x""yes; then
+  POW_LIB=-lm
+else
+  { $as_echo "$as_me:$LINENO: WARNING: cannot find library containing definition of pow" >&5
+$as_echo "$as_me: WARNING: cannot find library containing definition of pow" >&2;}
+fi
+
+fi
+
+fi
+
+{ $as_echo "$as_me:$LINENO: checking return type of signal handlers" >&5
+$as_echo_n "checking return type of signal handlers... " >&6; }
+if test "${ac_cv_type_signal+set}" = set; then
+  $as_echo_n "(cached) " >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <sys/types.h>
+#include <signal.h>
+
+int
+main ()
+{
+return *(signal (0, 0)) (0) == 1;
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (ac_try="$ac_compile"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
+  (eval "$ac_compile") 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && {
+	 test -z "$ac_c_werror_flag" ||
+	 test ! -s conftest.err
+       } && test -s conftest.$ac_objext; then
+  ac_cv_type_signal=int
+else
+  $as_echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+	ac_cv_type_signal=void
+fi
+
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+fi
+{ $as_echo "$as_me:$LINENO: result: $ac_cv_type_signal" >&5
+$as_echo "$ac_cv_type_signal" >&6; }
+
+cat >>confdefs.h <<_ACEOF
+#define RETSIGTYPE $ac_cv_type_signal
+_ACEOF
+
+
+
+for ac_func in vprintf
+do
+as_ac_var=`$as_echo "ac_cv_func_$ac_func" | $as_tr_sh`
+{ $as_echo "$as_me:$LINENO: checking for $ac_func" >&5
+$as_echo_n "checking for $ac_func... " >&6; }
+if { as_var=$as_ac_var; eval "test \"\${$as_var+set}\" = set"; }; then
+  $as_echo_n "(cached) " >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+/* Define $ac_func to an innocuous variant, in case <limits.h> declares $ac_func.
+   For example, HP-UX 11i <limits.h> declares gettimeofday.  */
+#define $ac_func innocuous_$ac_func
+
+/* System header to define __stub macros and hopefully few prototypes,
+    which can conflict with char $ac_func (); below.
+    Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
+    <limits.h> exists even on freestanding compilers.  */
+
+#ifdef __STDC__
+# include <limits.h>
+#else
+# include <assert.h>
+#endif
+
+#undef $ac_func
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char $ac_func ();
+/* The GNU C library defines this for functions which it implements
+    to always fail with ENOSYS.  Some functions are actually named
+    something starting with __ and the normal name is an alias.  */
+#if defined __stub_$ac_func || defined __stub___$ac_func
+choke me
+#endif
+
+int
+main ()
+{
+return $ac_func ();
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (ac_try="$ac_link"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
+  (eval "$ac_link") 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && {
+	 test -z "$ac_c_werror_flag" ||
+	 test ! -s conftest.err
+       } && test -s conftest$ac_exeext && {
+	 test "$cross_compiling" = yes ||
+	 $as_test_x conftest$ac_exeext
+       }; then
+  eval "$as_ac_var=yes"
+else
+  $as_echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+	eval "$as_ac_var=no"
+fi
+
+rm -rf conftest.dSYM
+rm -f core conftest.err conftest.$ac_objext conftest_ipa8_conftest.oo \
+      conftest$ac_exeext conftest.$ac_ext
+fi
+ac_res=`eval 'as_val=${'$as_ac_var'}
+		 $as_echo "$as_val"'`
+	       { $as_echo "$as_me:$LINENO: result: $ac_res" >&5
+$as_echo "$ac_res" >&6; }
+as_val=`eval 'as_val=${'$as_ac_var'}
+		 $as_echo "$as_val"'`
+   if test "x$as_val" = x""yes; then
+  cat >>confdefs.h <<_ACEOF
+#define `$as_echo "HAVE_$ac_func" | $as_tr_cpp` 1
+_ACEOF
+
+{ $as_echo "$as_me:$LINENO: checking for _doprnt" >&5
+$as_echo_n "checking for _doprnt... " >&6; }
+if test "${ac_cv_func__doprnt+set}" = set; then
+  $as_echo_n "(cached) " >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+/* Define _doprnt to an innocuous variant, in case <limits.h> declares _doprnt.
+   For example, HP-UX 11i <limits.h> declares gettimeofday.  */
+#define _doprnt innocuous__doprnt
+
+/* System header to define __stub macros and hopefully few prototypes,
+    which can conflict with char _doprnt (); below.
+    Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
+    <limits.h> exists even on freestanding compilers.  */
+
+#ifdef __STDC__
+# include <limits.h>
+#else
+# include <assert.h>
+#endif
+
+#undef _doprnt
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char _doprnt ();
+/* The GNU C library defines this for functions which it implements
+    to always fail with ENOSYS.  Some functions are actually named
+    something starting with __ and the normal name is an alias.  */
+#if defined __stub__doprnt || defined __stub____doprnt
+choke me
+#endif
+
+int
+main ()
+{
+return _doprnt ();
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (ac_try="$ac_link"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
+  (eval "$ac_link") 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && {
+	 test -z "$ac_c_werror_flag" ||
+	 test ! -s conftest.err
+       } && test -s conftest$ac_exeext && {
+	 test "$cross_compiling" = yes ||
+	 $as_test_x conftest$ac_exeext
+       }; then
+  ac_cv_func__doprnt=yes
+else
+  $as_echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+	ac_cv_func__doprnt=no
+fi
+
+rm -rf conftest.dSYM
+rm -f core conftest.err conftest.$ac_objext conftest_ipa8_conftest.oo \
+      conftest$ac_exeext conftest.$ac_ext
+fi
+{ $as_echo "$as_me:$LINENO: result: $ac_cv_func__doprnt" >&5
+$as_echo "$ac_cv_func__doprnt" >&6; }
+if test "x$ac_cv_func__doprnt" = x""yes; then
+
+cat >>confdefs.h <<\_ACEOF
+#define HAVE_DOPRNT 1
+_ACEOF
+
+fi
+
+fi
+done
+
+
+{ $as_echo "$as_me:$LINENO: checking for stdbool.h that conforms to C99" >&5
+$as_echo_n "checking for stdbool.h that conforms to C99... " >&6; }
+if test "${ac_cv_header_stdbool_h+set}" = set; then
+  $as_echo_n "(cached) " >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+#include <stdbool.h>
+#ifndef bool
+ "error: bool is not defined"
+#endif
+#ifndef false
+ "error: false is not defined"
+#endif
+#if false
+ "error: false is not 0"
+#endif
+#ifndef true
+ "error: true is not defined"
+#endif
+#if true != 1
+ "error: true is not 1"
+#endif
+#ifndef __bool_true_false_are_defined
+ "error: __bool_true_false_are_defined is not defined"
+#endif
+
+	struct s { _Bool s: 1; _Bool t; } s;
+
+	char a[true == 1 ? 1 : -1];
+	char b[false == 0 ? 1 : -1];
+	char c[__bool_true_false_are_defined == 1 ? 1 : -1];
+	char d[(bool) 0.5 == true ? 1 : -1];
+	bool e = &s;
+	char f[(_Bool) 0.0 == false ? 1 : -1];
+	char g[true];
+	char h[sizeof (_Bool)];
+	char i[sizeof s.t];
+	enum { j = false, k = true, l = false * true, m = true * 256 };
+	/* The following fails for
+	   HP aC++/ANSI C B3910B A.05.55 [Dec 04 2003]. */
+	_Bool n[m];
+	char o[sizeof n == m * sizeof n[0] ? 1 : -1];
+	char p[-1 - (_Bool) 0 < 0 && -1 - (bool) 0 < 0 ? 1 : -1];
+#	if defined __xlc__ || defined __GNUC__
+	 /* Catch a bug in IBM AIX xlc compiler version 6.0.0.0
+	    reported by James Lemley on 2005-10-05; see
+	    http://lists.gnu.org/archive/html/bug-coreutils/2005-10/msg00086.html
+	    This test is not quite right, since xlc is allowed to
+	    reject this program, as the initializer for xlcbug is
+	    not one of the forms that C requires support for.
+	    However, doing the test right would require a runtime
+	    test, and that would make cross-compilation harder.
+	    Let us hope that IBM fixes the xlc bug, and also adds
+	    support for this kind of constant expression.  In the
+	    meantime, this test will reject xlc, which is OK, since
+	    our stdbool.h substitute should suffice.  We also test
+	    this with GCC, where it should work, to detect more
+	    quickly whether someone messes up the test in the
+	    future.  */
+	 char digs[] = "0123456789";
+	 int xlcbug = 1 / (&(digs + 5)[-2 + (bool) 1] == &digs[4] ? 1 : -1);
+#	endif
+	/* Catch a bug in an HP-UX C compiler.  See
+	   http://gcc.gnu.org/ml/gcc-patches/2003-12/msg02303.html
+	   http://lists.gnu.org/archive/html/bug-coreutils/2005-11/msg00161.html
+	 */
+	_Bool q = true;
+	_Bool *pq = &q;
+
+int
+main ()
+{
+
+	*pq |= q;
+	*pq |= ! q;
+	/* Refer to every declared value, to avoid compiler optimizations.  */
+	return (!a + !b + !c + !d + !e + !f + !g + !h + !i + !!j + !k + !!l
+		+ !m + !n + !o + !p + !q + !pq);
 
-#include <$ac_header>
+  ;
+  return 0;
+}
 _ACEOF
 rm -f conftest.$ac_objext
 if { (ac_try="$ac_compile"
@@ -3921,68 +6616,36 @@ case "(($ac_try" in
   *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
   *) ac_try_echo=$ac_try;;
 esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
   (eval "$ac_compile") 2>conftest.er1
   ac_status=$?
   grep -v '^ *+' conftest.er1 >conftest.err
   rm -f conftest.er1
   cat conftest.err >&5
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } && {
 	 test -z "$ac_c_werror_flag" ||
 	 test ! -s conftest.err
        } && test -s conftest.$ac_objext; then
-  eval "$as_ac_Header=yes"
+  ac_cv_header_stdbool_h=yes
 else
-  echo "$as_me: failed program was:" >&5
+  $as_echo "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
-	eval "$as_ac_Header=no"
+	ac_cv_header_stdbool_h=no
 fi
 
 rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
 fi
-ac_res=`eval echo '${'$as_ac_Header'}'`
-	       { echo "$as_me:$LINENO: result: $ac_res" >&5
-echo "${ECHO_T}$ac_res" >&6; }
-if test `eval echo '${'$as_ac_Header'}'` = yes; then
-  cat >>confdefs.h <<_ACEOF
-#define `echo "HAVE_$ac_header" | $as_tr_cpp` 1
-_ACEOF
-
-fi
-
-done
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-for ac_header in errno.h fcntl.h float.h limits.h malloc.h memory.h stdlib.h string.h sys/ioctl.h sys/socket.h sys/time.h unistd.h
-do
-as_ac_Header=`echo "ac_cv_header_$ac_header" | $as_tr_sh`
-if { as_var=$as_ac_Header; eval "test \"\${$as_var+set}\" = set"; }; then
-  { echo "$as_me:$LINENO: checking for $ac_header" >&5
-echo $ECHO_N "checking for $ac_header... $ECHO_C" >&6; }
-if { as_var=$as_ac_Header; eval "test \"\${$as_var+set}\" = set"; }; then
-  echo $ECHO_N "(cached) $ECHO_C" >&6
-fi
-ac_res=`eval echo '${'$as_ac_Header'}'`
-	       { echo "$as_me:$LINENO: result: $ac_res" >&5
-echo "${ECHO_T}$ac_res" >&6; }
+{ $as_echo "$as_me:$LINENO: result: $ac_cv_header_stdbool_h" >&5
+$as_echo "$ac_cv_header_stdbool_h" >&6; }
+{ $as_echo "$as_me:$LINENO: checking for _Bool" >&5
+$as_echo_n "checking for _Bool... " >&6; }
+if test "${ac_cv_type__Bool+set}" = set; then
+  $as_echo_n "(cached) " >&6
 else
-  # Is the header compilable?
-{ echo "$as_me:$LINENO: checking $ac_header usability" >&5
-echo $ECHO_N "checking $ac_header usability... $ECHO_C" >&6; }
+  ac_cv_type__Bool=no
 cat >conftest.$ac_ext <<_ACEOF
 /* confdefs.h.  */
 _ACEOF
@@ -3990,7 +6653,14 @@ cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
 $ac_includes_default
-#include <$ac_header>
+int
+main ()
+{
+if (sizeof (_Bool))
+       return 0;
+  ;
+  return 0;
+}
 _ACEOF
 rm -f conftest.$ac_objext
 if { (ac_try="$ac_compile"
@@ -3998,124 +6668,110 @@ case "(($ac_try" in
   *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
   *) ac_try_echo=$ac_try;;
 esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
   (eval "$ac_compile") 2>conftest.er1
   ac_status=$?
   grep -v '^ *+' conftest.er1 >conftest.err
   rm -f conftest.er1
   cat conftest.err >&5
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } && {
 	 test -z "$ac_c_werror_flag" ||
 	 test ! -s conftest.err
        } && test -s conftest.$ac_objext; then
-  ac_header_compiler=yes
-else
-  echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	ac_header_compiler=no
-fi
-
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-{ echo "$as_me:$LINENO: result: $ac_header_compiler" >&5
-echo "${ECHO_T}$ac_header_compiler" >&6; }
-
-# Is the header present?
-{ echo "$as_me:$LINENO: checking $ac_header presence" >&5
-echo $ECHO_N "checking $ac_header presence... $ECHO_C" >&6; }
 cat >conftest.$ac_ext <<_ACEOF
 /* confdefs.h.  */
 _ACEOF
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
-#include <$ac_header>
+$ac_includes_default
+int
+main ()
+{
+if (sizeof ((_Bool)))
+	  return 0;
+  ;
+  return 0;
+}
 _ACEOF
-if { (ac_try="$ac_cpp conftest.$ac_ext"
+rm -f conftest.$ac_objext
+if { (ac_try="$ac_compile"
 case "(($ac_try" in
   *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
   *) ac_try_echo=$ac_try;;
 esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_cpp conftest.$ac_ext") 2>conftest.er1
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
+  (eval "$ac_compile") 2>conftest.er1
   ac_status=$?
   grep -v '^ *+' conftest.er1 >conftest.err
   rm -f conftest.er1
   cat conftest.err >&5
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } >/dev/null && {
-	 test -z "$ac_c_preproc_warn_flag$ac_c_werror_flag" ||
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && {
+	 test -z "$ac_c_werror_flag" ||
 	 test ! -s conftest.err
-       }; then
-  ac_header_preproc=yes
+       } && test -s conftest.$ac_objext; then
+  :
 else
-  echo "$as_me: failed program was:" >&5
+  $as_echo "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
-  ac_header_preproc=no
+	ac_cv_type__Bool=yes
 fi
 
-rm -f conftest.err conftest.$ac_ext
-{ echo "$as_me:$LINENO: result: $ac_header_preproc" >&5
-echo "${ECHO_T}$ac_header_preproc" >&6; }
-
-# So?  What about this header?
-case $ac_header_compiler:$ac_header_preproc:$ac_c_preproc_warn_flag in
-  yes:no: )
-    { echo "$as_me:$LINENO: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&5
-echo "$as_me: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&2;}
-    { echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the compiler's result" >&5
-echo "$as_me: WARNING: $ac_header: proceeding with the compiler's result" >&2;}
-    ac_header_preproc=yes
-    ;;
-  no:yes:* )
-    { echo "$as_me:$LINENO: WARNING: $ac_header: present but cannot be compiled" >&5
-echo "$as_me: WARNING: $ac_header: present but cannot be compiled" >&2;}
-    { echo "$as_me:$LINENO: WARNING: $ac_header:     check for missing prerequisite headers?" >&5
-echo "$as_me: WARNING: $ac_header:     check for missing prerequisite headers?" >&2;}
-    { echo "$as_me:$LINENO: WARNING: $ac_header: see the Autoconf documentation" >&5
-echo "$as_me: WARNING: $ac_header: see the Autoconf documentation" >&2;}
-    { echo "$as_me:$LINENO: WARNING: $ac_header:     section \"Present But Cannot Be Compiled\"" >&5
-echo "$as_me: WARNING: $ac_header:     section \"Present But Cannot Be Compiled\"" >&2;}
-    { echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the preprocessor's result" >&5
-echo "$as_me: WARNING: $ac_header: proceeding with the preprocessor's result" >&2;}
-    { echo "$as_me:$LINENO: WARNING: $ac_header: in the future, the compiler will take precedence" >&5
-echo "$as_me: WARNING: $ac_header: in the future, the compiler will take precedence" >&2;}
-    ( cat <<\_ASBOX
-## ------------------------------------ ##
-## Report this to htk-mgr@eng.cam.ac.uk ##
-## ------------------------------------ ##
-_ASBOX
-     ) | sed "s/^/$as_me: WARNING:     /" >&2
-    ;;
-esac
-{ echo "$as_me:$LINENO: checking for $ac_header" >&5
-echo $ECHO_N "checking for $ac_header... $ECHO_C" >&6; }
-if { as_var=$as_ac_Header; eval "test \"\${$as_var+set}\" = set"; }; then
-  echo $ECHO_N "(cached) $ECHO_C" >&6
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
 else
-  eval "$as_ac_Header=\$ac_header_preproc"
+  $as_echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+
 fi
-ac_res=`eval echo '${'$as_ac_Header'}'`
-	       { echo "$as_me:$LINENO: result: $ac_res" >&5
-echo "${ECHO_T}$ac_res" >&6; }
 
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
 fi
-if test `eval echo '${'$as_ac_Header'}'` = yes; then
+{ $as_echo "$as_me:$LINENO: result: $ac_cv_type__Bool" >&5
+$as_echo "$ac_cv_type__Bool" >&6; }
+if test "x$ac_cv_type__Bool" = x""yes; then
+
   cat >>confdefs.h <<_ACEOF
-#define `echo "HAVE_$ac_header" | $as_tr_cpp` 1
+#define HAVE__BOOL 1
 _ACEOF
 
+
 fi
 
-done
+if test $ac_cv_header_stdbool_h = yes; then
 
+cat >>confdefs.h <<\_ACEOF
+#define HAVE_STDBOOL_H 1
+_ACEOF
 
-{ echo "$as_me:$LINENO: checking for an ANSI C-conforming const" >&5
-echo $ECHO_N "checking for an ANSI C-conforming const... $ECHO_C" >&6; }
-if test "${ac_cv_c_const+set}" = set; then
-  echo $ECHO_N "(cached) $ECHO_C" >&6
+fi
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+for ac_func in floor gettimeofday memmove memset modf pow socket sqrt strchr strcspn strrchr strspn strstr strtol
+do
+as_ac_var=`$as_echo "ac_cv_func_$ac_func" | $as_tr_sh`
+{ $as_echo "$as_me:$LINENO: checking for $ac_func" >&5
+$as_echo_n "checking for $ac_func... " >&6; }
+if { as_var=$as_ac_var; eval "test \"\${$as_var+set}\" = set"; }; then
+  $as_echo_n "(cached) " >&6
 else
   cat >conftest.$ac_ext <<_ACEOF
 /* confdefs.h.  */
@@ -4123,187 +6779,297 @@ _ACEOF
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
+/* Define $ac_func to an innocuous variant, in case <limits.h> declares $ac_func.
+   For example, HP-UX 11i <limits.h> declares gettimeofday.  */
+#define $ac_func innocuous_$ac_func
 
-int
-main ()
-{
-/* FIXME: Include the comments suggested by Paul. */
-#ifndef __cplusplus
-  /* Ultrix mips cc rejects this.  */
-  typedef int charset[2];
-  const charset cs;
-  /* SunOS 4.1.1 cc rejects this.  */
-  char const *const *pcpcc;
-  char **ppc;
-  /* NEC SVR4.0.2 mips cc rejects this.  */
-  struct point {int x, y;};
-  static struct point const zero = {0,0};
-  /* AIX XL C 1.02.0.0 rejects this.
-     It does not let you subtract one const X* pointer from another in
-     an arm of an if-expression whose if-part is not a constant
-     expression */
-  const char *g = "string";
-  pcpcc = &g + (g ? g-g : 0);
-  /* HPUX 7.0 cc rejects these. */
-  ++pcpcc;
-  ppc = (char**) pcpcc;
-  pcpcc = (char const *const *) ppc;
-  { /* SCO 3.2v4 cc rejects this.  */
-    char *t;
-    char const *s = 0 ? (char *) 0 : (char const *) 0;
+/* System header to define __stub macros and hopefully few prototypes,
+    which can conflict with char $ac_func (); below.
+    Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
+    <limits.h> exists even on freestanding compilers.  */
 
-    *t++ = 0;
-    if (s) return 0;
-  }
-  { /* Someone thinks the Sun supposedly-ANSI compiler will reject this.  */
-    int x[] = {25, 17};
-    const int *foo = &x[0];
-    ++foo;
-  }
-  { /* Sun SC1.0 ANSI compiler rejects this -- but not the above. */
-    typedef const int *iptr;
-    iptr p = 0;
-    ++p;
-  }
-  { /* AIX XL C 1.02.0.0 rejects this saying
-       "k.c", line 2.27: 1506-025 (S) Operand must be a modifiable lvalue. */
-    struct s { int j; const int *ap[3]; };
-    struct s *b; b->j = 5;
-  }
-  { /* ULTRIX-32 V3.1 (Rev 9) vcc rejects this */
-    const int foo = 10;
-    if (!foo) return 0;
-  }
-  return !cs[0] && !zero.x;
+#ifdef __STDC__
+# include <limits.h>
+#else
+# include <assert.h>
+#endif
+
+#undef $ac_func
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char $ac_func ();
+/* The GNU C library defines this for functions which it implements
+    to always fail with ENOSYS.  Some functions are actually named
+    something starting with __ and the normal name is an alias.  */
+#if defined __stub_$ac_func || defined __stub___$ac_func
+choke me
 #endif
 
+int
+main ()
+{
+return $ac_func ();
   ;
   return 0;
 }
 _ACEOF
-rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (ac_try="$ac_link"
 case "(($ac_try" in
   *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
   *) ac_try_echo=$ac_try;;
 esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_compile") 2>conftest.er1
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
+  (eval "$ac_link") 2>conftest.er1
   ac_status=$?
   grep -v '^ *+' conftest.er1 >conftest.err
   rm -f conftest.er1
   cat conftest.err >&5
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } && {
 	 test -z "$ac_c_werror_flag" ||
 	 test ! -s conftest.err
-       } && test -s conftest.$ac_objext; then
-  ac_cv_c_const=yes
+       } && test -s conftest$ac_exeext && {
+	 test "$cross_compiling" = yes ||
+	 $as_test_x conftest$ac_exeext
+       }; then
+  eval "$as_ac_var=yes"
 else
-  echo "$as_me: failed program was:" >&5
+  $as_echo "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
-	ac_cv_c_const=no
+	eval "$as_ac_var=no"
 fi
 
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+rm -rf conftest.dSYM
+rm -f core conftest.err conftest.$ac_objext conftest_ipa8_conftest.oo \
+      conftest$ac_exeext conftest.$ac_ext
 fi
-{ echo "$as_me:$LINENO: result: $ac_cv_c_const" >&5
-echo "${ECHO_T}$ac_cv_c_const" >&6; }
-if test $ac_cv_c_const = no; then
+ac_res=`eval 'as_val=${'$as_ac_var'}
+		 $as_echo "$as_val"'`
+	       { $as_echo "$as_me:$LINENO: result: $ac_res" >&5
+$as_echo "$ac_res" >&6; }
+as_val=`eval 'as_val=${'$as_ac_var'}
+		 $as_echo "$as_val"'`
+   if test "x$as_val" = x""yes; then
+  cat >>confdefs.h <<_ACEOF
+#define `$as_echo "HAVE_$ac_func" | $as_tr_cpp` 1
+_ACEOF
 
-cat >>confdefs.h <<\_ACEOF
-#define const
+fi
+done
+
+
+for ac_func in strdup
+do
+as_ac_var=`$as_echo "ac_cv_func_$ac_func" | $as_tr_sh`
+{ $as_echo "$as_me:$LINENO: checking for $ac_func" >&5
+$as_echo_n "checking for $ac_func... " >&6; }
+if { as_var=$as_ac_var; eval "test \"\${$as_var+set}\" = set"; }; then
+  $as_echo_n "(cached) " >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
 _ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+/* Define $ac_func to an innocuous variant, in case <limits.h> declares $ac_func.
+   For example, HP-UX 11i <limits.h> declares gettimeofday.  */
+#define $ac_func innocuous_$ac_func
+
+/* System header to define __stub macros and hopefully few prototypes,
+    which can conflict with char $ac_func (); below.
+    Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
+    <limits.h> exists even on freestanding compilers.  */
+
+#ifdef __STDC__
+# include <limits.h>
+#else
+# include <assert.h>
+#endif
 
-fi
+#undef $ac_func
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char $ac_func ();
+/* The GNU C library defines this for functions which it implements
+    to always fail with ENOSYS.  Some functions are actually named
+    something starting with __ and the normal name is an alias.  */
+#if defined __stub_$ac_func || defined __stub___$ac_func
+choke me
+#endif
 
-{ echo "$as_me:$LINENO: checking for size_t" >&5
-echo $ECHO_N "checking for size_t... $ECHO_C" >&6; }
-if test "${ac_cv_type_size_t+set}" = set; then
-  echo $ECHO_N "(cached) $ECHO_C" >&6
-else
-  cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-$ac_includes_default
-typedef size_t ac__type_new_;
 int
 main ()
 {
-if ((ac__type_new_ *) 0)
-  return 0;
-if (sizeof (ac__type_new_))
-  return 0;
+return $ac_func ();
   ;
   return 0;
 }
 _ACEOF
-rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (ac_try="$ac_link"
 case "(($ac_try" in
   *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
   *) ac_try_echo=$ac_try;;
 esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_compile") 2>conftest.er1
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
+  (eval "$ac_link") 2>conftest.er1
   ac_status=$?
   grep -v '^ *+' conftest.er1 >conftest.err
   rm -f conftest.er1
   cat conftest.err >&5
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } && {
 	 test -z "$ac_c_werror_flag" ||
 	 test ! -s conftest.err
-       } && test -s conftest.$ac_objext; then
-  ac_cv_type_size_t=yes
+       } && test -s conftest$ac_exeext && {
+	 test "$cross_compiling" = yes ||
+	 $as_test_x conftest$ac_exeext
+       }; then
+  eval "$as_ac_var=yes"
 else
-  echo "$as_me: failed program was:" >&5
+  $as_echo "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
-	ac_cv_type_size_t=no
+	eval "$as_ac_var=no"
 fi
 
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+rm -rf conftest.dSYM
+rm -f core conftest.err conftest.$ac_objext conftest_ipa8_conftest.oo \
+      conftest$ac_exeext conftest.$ac_ext
 fi
-{ echo "$as_me:$LINENO: result: $ac_cv_type_size_t" >&5
-echo "${ECHO_T}$ac_cv_type_size_t" >&6; }
-if test $ac_cv_type_size_t = yes; then
-  :
-else
-
+ac_res=`eval 'as_val=${'$as_ac_var'}
+		 $as_echo "$as_val"'`
+	       { $as_echo "$as_me:$LINENO: result: $ac_res" >&5
+$as_echo "$ac_res" >&6; }
+as_val=`eval 'as_val=${'$as_ac_var'}
+		 $as_echo "$as_val"'`
+   if test "x$as_val" = x""yes; then
 cat >>confdefs.h <<_ACEOF
-#define size_t unsigned int
+#define `$as_echo "HAVE_$ac_func" | $as_tr_cpp` 1
 _ACEOF
 
 fi
+done
 
-{ echo "$as_me:$LINENO: checking whether time.h and sys/time.h may both be included" >&5
-echo $ECHO_N "checking whether time.h and sys/time.h may both be included... $ECHO_C" >&6; }
-if test "${ac_cv_header_time+set}" = set; then
-  echo $ECHO_N "(cached) $ECHO_C" >&6
+
+
+# Make sure we can run config.sub.
+$SHELL "$ac_aux_dir/config.sub" sun4 >/dev/null 2>&1 ||
+  { { $as_echo "$as_me:$LINENO: error: cannot run $SHELL $ac_aux_dir/config.sub" >&5
+$as_echo "$as_me: error: cannot run $SHELL $ac_aux_dir/config.sub" >&2;}
+   { (exit 1); exit 1; }; }
+
+{ $as_echo "$as_me:$LINENO: checking build system type" >&5
+$as_echo_n "checking build system type... " >&6; }
+if test "${ac_cv_build+set}" = set; then
+  $as_echo_n "(cached) " >&6
+else
+  ac_build_alias=$build_alias
+test "x$ac_build_alias" = x &&
+  ac_build_alias=`$SHELL "$ac_aux_dir/config.guess"`
+test "x$ac_build_alias" = x &&
+  { { $as_echo "$as_me:$LINENO: error: cannot guess build type; you must specify one" >&5
+$as_echo "$as_me: error: cannot guess build type; you must specify one" >&2;}
+   { (exit 1); exit 1; }; }
+ac_cv_build=`$SHELL "$ac_aux_dir/config.sub" $ac_build_alias` ||
+  { { $as_echo "$as_me:$LINENO: error: $SHELL $ac_aux_dir/config.sub $ac_build_alias failed" >&5
+$as_echo "$as_me: error: $SHELL $ac_aux_dir/config.sub $ac_build_alias failed" >&2;}
+   { (exit 1); exit 1; }; }
+
+fi
+{ $as_echo "$as_me:$LINENO: result: $ac_cv_build" >&5
+$as_echo "$ac_cv_build" >&6; }
+case $ac_cv_build in
+*-*-*) ;;
+*) { { $as_echo "$as_me:$LINENO: error: invalid value of canonical build" >&5
+$as_echo "$as_me: error: invalid value of canonical build" >&2;}
+   { (exit 1); exit 1; }; };;
+esac
+build=$ac_cv_build
+ac_save_IFS=$IFS; IFS='-'
+set x $ac_cv_build
+shift
+build_cpu=$1
+build_vendor=$2
+shift; shift
+# Remember, the first character of IFS is used to create $*,
+# except with old shells:
+build_os=$*
+IFS=$ac_save_IFS
+case $build_os in *\ *) build_os=`echo "$build_os" | sed 's/ /-/g'`;; esac
+
+
+{ $as_echo "$as_me:$LINENO: checking host system type" >&5
+$as_echo_n "checking host system type... " >&6; }
+if test "${ac_cv_host+set}" = set; then
+  $as_echo_n "(cached) " >&6
+else
+  if test "x$host_alias" = x; then
+  ac_cv_host=$ac_cv_build
+else
+  ac_cv_host=`$SHELL "$ac_aux_dir/config.sub" $host_alias` ||
+    { { $as_echo "$as_me:$LINENO: error: $SHELL $ac_aux_dir/config.sub $host_alias failed" >&5
+$as_echo "$as_me: error: $SHELL $ac_aux_dir/config.sub $host_alias failed" >&2;}
+   { (exit 1); exit 1; }; }
+fi
+
+fi
+{ $as_echo "$as_me:$LINENO: result: $ac_cv_host" >&5
+$as_echo "$ac_cv_host" >&6; }
+case $ac_cv_host in
+*-*-*) ;;
+*) { { $as_echo "$as_me:$LINENO: error: invalid value of canonical host" >&5
+$as_echo "$as_me: error: invalid value of canonical host" >&2;}
+   { (exit 1); exit 1; }; };;
+esac
+host=$ac_cv_host
+ac_save_IFS=$IFS; IFS='-'
+set x $ac_cv_host
+shift
+host_cpu=$1
+host_vendor=$2
+shift; shift
+# Remember, the first character of IFS is used to create $*,
+# except with old shells:
+host_os=$*
+IFS=$ac_save_IFS
+case $host_os in *\ *) host_os=`echo "$host_os" | sed 's/ /-/g'`;; esac
+
+
+
+ { $as_echo "$as_me:$LINENO: checking whether byte ordering is bigendian" >&5
+$as_echo_n "checking whether byte ordering is bigendian... " >&6; }
+if test "${ac_cv_c_bigendian+set}" = set; then
+  $as_echo_n "(cached) " >&6
 else
+  ac_cv_c_bigendian=unknown
+    # See if we're dealing with a universal compiler.
   cat >conftest.$ac_ext <<_ACEOF
 /* confdefs.h.  */
 _ACEOF
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
-#include <sys/types.h>
-#include <sys/time.h>
-#include <time.h>
+#ifndef __APPLE_CC__
+	       not a universal capable compiler
+	     #endif
+	     typedef int dummy;
 
-int
-main ()
-{
-if ((struct tm *) 0)
-return 0;
-  ;
-  return 0;
-}
 _ACEOF
 rm -f conftest.$ac_objext
 if { (ac_try="$ac_compile"
@@ -4311,42 +7077,35 @@ case "(($ac_try" in
   *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
   *) ac_try_echo=$ac_try;;
 esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
   (eval "$ac_compile") 2>conftest.er1
   ac_status=$?
   grep -v '^ *+' conftest.er1 >conftest.err
   rm -f conftest.er1
   cat conftest.err >&5
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } && {
 	 test -z "$ac_c_werror_flag" ||
 	 test ! -s conftest.err
        } && test -s conftest.$ac_objext; then
-  ac_cv_header_time=yes
+
+	# Check for potential -arch flags.  It is not universal unless
+	# there are some -arch flags.  Note that *ppc* also matches
+	# ppc64.  This check is also rather less than ideal.
+	case "${CC} ${CFLAGS} ${CPPFLAGS} ${LDFLAGS}" in  #(
+	  *-arch*ppc*|*-arch*i386*|*-arch*x86_64*) ac_cv_c_bigendian=universal;;
+	esac
 else
-  echo "$as_me: failed program was:" >&5
+  $as_echo "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
-	ac_cv_header_time=no
-fi
-
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-fi
-{ echo "$as_me:$LINENO: result: $ac_cv_header_time" >&5
-echo "${ECHO_T}$ac_cv_header_time" >&6; }
-if test $ac_cv_header_time = yes; then
-
-cat >>confdefs.h <<\_ACEOF
-#define TIME_WITH_SYS_TIME 1
-_ACEOF
 
 fi
 
-{ echo "$as_me:$LINENO: checking whether struct tm is in sys/time.h or time.h" >&5
-echo $ECHO_N "checking whether struct tm is in sys/time.h or time.h... $ECHO_C" >&6; }
-if test "${ac_cv_struct_tm+set}" = set; then
-  echo $ECHO_N "(cached) $ECHO_C" >&6
-else
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+    if test $ac_cv_c_bigendian = unknown; then
+      # See if sys/param.h defines the BYTE_ORDER macro.
   cat >conftest.$ac_ext <<_ACEOF
 /* confdefs.h.  */
 _ACEOF
@@ -4354,14 +7113,17 @@ cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
 #include <sys/types.h>
-#include <time.h>
+	     #include <sys/param.h>
 
 int
 main ()
 {
-struct tm tm;
-				     int *p = &tm.tm_sec;
- 				     return !p;
+#if ! (defined BYTE_ORDER && defined BIG_ENDIAN \
+		     && defined LITTLE_ENDIAN && BYTE_ORDER && BIG_ENDIAN \
+		     && LITTLE_ENDIAN)
+	      bogus endian macros
+	     #endif
+
   ;
   return 0;
 }
@@ -4372,203 +7134,95 @@ case "(($ac_try" in
   *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
   *) ac_try_echo=$ac_try;;
 esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
   (eval "$ac_compile") 2>conftest.er1
   ac_status=$?
   grep -v '^ *+' conftest.er1 >conftest.err
   rm -f conftest.er1
   cat conftest.err >&5
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } && {
 	 test -z "$ac_c_werror_flag" ||
 	 test ! -s conftest.err
        } && test -s conftest.$ac_objext; then
-  ac_cv_struct_tm=time.h
-else
-  echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	ac_cv_struct_tm=sys/time.h
-fi
-
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-fi
-{ echo "$as_me:$LINENO: result: $ac_cv_struct_tm" >&5
-echo "${ECHO_T}$ac_cv_struct_tm" >&6; }
-if test $ac_cv_struct_tm = sys/time.h; then
-
-cat >>confdefs.h <<\_ACEOF
-#define TM_IN_SYS_TIME 1
-_ACEOF
-
-fi
-
-
-if test $ac_cv_c_compiler_gnu = yes; then
-    { echo "$as_me:$LINENO: checking whether $CC needs -traditional" >&5
-echo $ECHO_N "checking whether $CC needs -traditional... $ECHO_C" >&6; }
-if test "${ac_cv_prog_gcc_traditional+set}" = set; then
-  echo $ECHO_N "(cached) $ECHO_C" >&6
-else
-    ac_pattern="Autoconf.*'x'"
-  cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-#include <sgtty.h>
-Autoconf TIOCGETP
-_ACEOF
-if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
-  $EGREP "$ac_pattern" >/dev/null 2>&1; then
-  ac_cv_prog_gcc_traditional=yes
-else
-  ac_cv_prog_gcc_traditional=no
-fi
-rm -f conftest*
-
-
-  if test $ac_cv_prog_gcc_traditional = no; then
+  # It does; now see whether it defined to BIG_ENDIAN or not.
     cat >conftest.$ac_ext <<_ACEOF
 /* confdefs.h.  */
 _ACEOF
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
-#include <termio.h>
-Autoconf TCGETA
-_ACEOF
-if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
-  $EGREP "$ac_pattern" >/dev/null 2>&1; then
-  ac_cv_prog_gcc_traditional=yes
-fi
-rm -f conftest*
-
-  fi
-fi
-{ echo "$as_me:$LINENO: result: $ac_cv_prog_gcc_traditional" >&5
-echo "${ECHO_T}$ac_cv_prog_gcc_traditional" >&6; }
-  if test $ac_cv_prog_gcc_traditional = yes; then
-    CC="$CC -traditional"
-  fi
-fi
+#include <sys/types.h>
+		#include <sys/param.h>
 
-{ echo "$as_me:$LINENO: checking for working memcmp" >&5
-echo $ECHO_N "checking for working memcmp... $ECHO_C" >&6; }
-if test "${ac_cv_func_memcmp_working+set}" = set; then
-  echo $ECHO_N "(cached) $ECHO_C" >&6
-else
-  if test "$cross_compiling" = yes; then
-  ac_cv_func_memcmp_working=no
-else
-  cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-$ac_includes_default
 int
 main ()
 {
-
-  /* Some versions of memcmp are not 8-bit clean.  */
-  char c0 = '\100', c1 = '\200', c2 = '\201';
-  if (memcmp(&c0, &c2, 1) >= 0 || memcmp(&c1, &c2, 1) >= 0)
-    return 1;
-
-  /* The Next x86 OpenStep bug shows up only when comparing 16 bytes
-     or more and with at least one buffer not starting on a 4-byte boundary.
-     William Lewis provided this test program.   */
-  {
-    char foo[21];
-    char bar[21];
-    int i;
-    for (i = 0; i < 4; i++)
-      {
-	char *a = foo + i;
-	char *b = bar + i;
-	strcpy (a, "--------01111111");
-	strcpy (b, "--------10000000");
-	if (memcmp (a, b, 16) >= 0)
-	  return 1;
-      }
-    return 0;
-  }
+#if BYTE_ORDER != BIG_ENDIAN
+		 not big endian
+		#endif
 
   ;
   return 0;
 }
 _ACEOF
-rm -f conftest$ac_exeext
-if { (ac_try="$ac_link"
+rm -f conftest.$ac_objext
+if { (ac_try="$ac_compile"
 case "(($ac_try" in
   *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
   *) ac_try_echo=$ac_try;;
 esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_link") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && { ac_try='./conftest$ac_exeext'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_try") 2>&5
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
+  (eval "$ac_compile") 2>conftest.er1
   ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; }; then
-  ac_cv_func_memcmp_working=yes
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && {
+	 test -z "$ac_c_werror_flag" ||
+	 test ! -s conftest.err
+       } && test -s conftest.$ac_objext; then
+  ac_cv_c_bigendian=yes
 else
-  echo "$as_me: program exited with status $ac_status" >&5
-echo "$as_me: failed program was:" >&5
+  $as_echo "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
-( exit $ac_status )
-ac_cv_func_memcmp_working=no
-fi
-rm -f core *.core core.conftest.* gmon.out bb.out conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
+	ac_cv_c_bigendian=no
 fi
 
-
-fi
-{ echo "$as_me:$LINENO: result: $ac_cv_func_memcmp_working" >&5
-echo "${ECHO_T}$ac_cv_func_memcmp_working" >&6; }
-test $ac_cv_func_memcmp_working = no && case " $LIBOBJS " in
-  *" memcmp.$ac_objext "* ) ;;
-  *) LIBOBJS="$LIBOBJS memcmp.$ac_objext"
- ;;
-esac
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+else
+  $as_echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
 
 
+fi
 
-for ac_header in stdlib.h
-do
-as_ac_Header=`echo "ac_cv_header_$ac_header" | $as_tr_sh`
-if { as_var=$as_ac_Header; eval "test \"\${$as_var+set}\" = set"; }; then
-  { echo "$as_me:$LINENO: checking for $ac_header" >&5
-echo $ECHO_N "checking for $ac_header... $ECHO_C" >&6; }
-if { as_var=$as_ac_Header; eval "test \"\${$as_var+set}\" = set"; }; then
-  echo $ECHO_N "(cached) $ECHO_C" >&6
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
 fi
-ac_res=`eval echo '${'$as_ac_Header'}'`
-	       { echo "$as_me:$LINENO: result: $ac_res" >&5
-echo "${ECHO_T}$ac_res" >&6; }
-else
-  # Is the header compilable?
-{ echo "$as_me:$LINENO: checking $ac_header usability" >&5
-echo $ECHO_N "checking $ac_header usability... $ECHO_C" >&6; }
+    if test $ac_cv_c_bigendian = unknown; then
+      # See if <limits.h> defines _LITTLE_ENDIAN or _BIG_ENDIAN (e.g., Solaris).
 cat >conftest.$ac_ext <<_ACEOF
 /* confdefs.h.  */
 _ACEOF
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
-$ac_includes_default
-#include <$ac_header>
+#include <limits.h>
+
+int
+main ()
+{
+#if ! (defined _LITTLE_ENDIAN || defined _BIG_ENDIAN)
+	      bogus endian macros
+	     #endif
+
+  ;
+  return 0;
+}
 _ACEOF
 rm -f conftest.$ac_objext
 if { (ac_try="$ac_compile"
@@ -4576,216 +7230,145 @@ case "(($ac_try" in
   *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
   *) ac_try_echo=$ac_try;;
 esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
   (eval "$ac_compile") 2>conftest.er1
   ac_status=$?
   grep -v '^ *+' conftest.er1 >conftest.err
   rm -f conftest.er1
   cat conftest.err >&5
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } && {
 	 test -z "$ac_c_werror_flag" ||
 	 test ! -s conftest.err
        } && test -s conftest.$ac_objext; then
-  ac_header_compiler=yes
-else
-  echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	ac_header_compiler=no
-fi
-
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-{ echo "$as_me:$LINENO: result: $ac_header_compiler" >&5
-echo "${ECHO_T}$ac_header_compiler" >&6; }
-
-# Is the header present?
-{ echo "$as_me:$LINENO: checking $ac_header presence" >&5
-echo $ECHO_N "checking $ac_header presence... $ECHO_C" >&6; }
+  # It does; now see whether it defined to _BIG_ENDIAN or not.
 cat >conftest.$ac_ext <<_ACEOF
 /* confdefs.h.  */
 _ACEOF
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
-#include <$ac_header>
+#include <limits.h>
+
+int
+main ()
+{
+#ifndef _BIG_ENDIAN
+		 not big endian
+		#endif
+
+  ;
+  return 0;
+}
 _ACEOF
-if { (ac_try="$ac_cpp conftest.$ac_ext"
+rm -f conftest.$ac_objext
+if { (ac_try="$ac_compile"
 case "(($ac_try" in
   *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
   *) ac_try_echo=$ac_try;;
 esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_cpp conftest.$ac_ext") 2>conftest.er1
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
+  (eval "$ac_compile") 2>conftest.er1
   ac_status=$?
   grep -v '^ *+' conftest.er1 >conftest.err
   rm -f conftest.er1
   cat conftest.err >&5
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } >/dev/null && {
-	 test -z "$ac_c_preproc_warn_flag$ac_c_werror_flag" ||
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && {
+	 test -z "$ac_c_werror_flag" ||
 	 test ! -s conftest.err
-       }; then
-  ac_header_preproc=yes
+       } && test -s conftest.$ac_objext; then
+  ac_cv_c_bigendian=yes
 else
-  echo "$as_me: failed program was:" >&5
+  $as_echo "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
-  ac_header_preproc=no
+	ac_cv_c_bigendian=no
 fi
 
-rm -f conftest.err conftest.$ac_ext
-{ echo "$as_me:$LINENO: result: $ac_header_preproc" >&5
-echo "${ECHO_T}$ac_header_preproc" >&6; }
-
-# So?  What about this header?
-case $ac_header_compiler:$ac_header_preproc:$ac_c_preproc_warn_flag in
-  yes:no: )
-    { echo "$as_me:$LINENO: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&5
-echo "$as_me: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&2;}
-    { echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the compiler's result" >&5
-echo "$as_me: WARNING: $ac_header: proceeding with the compiler's result" >&2;}
-    ac_header_preproc=yes
-    ;;
-  no:yes:* )
-    { echo "$as_me:$LINENO: WARNING: $ac_header: present but cannot be compiled" >&5
-echo "$as_me: WARNING: $ac_header: present but cannot be compiled" >&2;}
-    { echo "$as_me:$LINENO: WARNING: $ac_header:     check for missing prerequisite headers?" >&5
-echo "$as_me: WARNING: $ac_header:     check for missing prerequisite headers?" >&2;}
-    { echo "$as_me:$LINENO: WARNING: $ac_header: see the Autoconf documentation" >&5
-echo "$as_me: WARNING: $ac_header: see the Autoconf documentation" >&2;}
-    { echo "$as_me:$LINENO: WARNING: $ac_header:     section \"Present But Cannot Be Compiled\"" >&5
-echo "$as_me: WARNING: $ac_header:     section \"Present But Cannot Be Compiled\"" >&2;}
-    { echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the preprocessor's result" >&5
-echo "$as_me: WARNING: $ac_header: proceeding with the preprocessor's result" >&2;}
-    { echo "$as_me:$LINENO: WARNING: $ac_header: in the future, the compiler will take precedence" >&5
-echo "$as_me: WARNING: $ac_header: in the future, the compiler will take precedence" >&2;}
-    ( cat <<\_ASBOX
-## ------------------------------------ ##
-## Report this to htk-mgr@eng.cam.ac.uk ##
-## ------------------------------------ ##
-_ASBOX
-     ) | sed "s/^/$as_me: WARNING:     /" >&2
-    ;;
-esac
-{ echo "$as_me:$LINENO: checking for $ac_header" >&5
-echo $ECHO_N "checking for $ac_header... $ECHO_C" >&6; }
-if { as_var=$as_ac_Header; eval "test \"\${$as_var+set}\" = set"; }; then
-  echo $ECHO_N "(cached) $ECHO_C" >&6
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
 else
-  eval "$as_ac_Header=\$ac_header_preproc"
-fi
-ac_res=`eval echo '${'$as_ac_Header'}'`
-	       { echo "$as_me:$LINENO: result: $ac_res" >&5
-echo "${ECHO_T}$ac_res" >&6; }
+  $as_echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
 
-fi
-if test `eval echo '${'$as_ac_Header'}'` = yes; then
-  cat >>confdefs.h <<_ACEOF
-#define `echo "HAVE_$ac_header" | $as_tr_cpp` 1
-_ACEOF
 
 fi
 
-done
-
-{ echo "$as_me:$LINENO: checking for GNU libc compatible malloc" >&5
-echo $ECHO_N "checking for GNU libc compatible malloc... $ECHO_C" >&6; }
-if test "${ac_cv_func_malloc_0_nonnull+set}" = set; then
-  echo $ECHO_N "(cached) $ECHO_C" >&6
-else
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+    fi
+    if test $ac_cv_c_bigendian = unknown; then
+      # Compile a test program.
   if test "$cross_compiling" = yes; then
-  ac_cv_func_malloc_0_nonnull=no
-else
+  # Try to guess by grepping values from an object file.
   cat >conftest.$ac_ext <<_ACEOF
 /* confdefs.h.  */
 _ACEOF
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
-#if defined STDC_HEADERS || defined HAVE_STDLIB_H
-# include <stdlib.h>
-#else
-char *malloc ();
-#endif
+short int ascii_mm[] =
+		  { 0x4249, 0x4765, 0x6E44, 0x6961, 0x6E53, 0x7953, 0 };
+		short int ascii_ii[] =
+		  { 0x694C, 0x5454, 0x656C, 0x6E45, 0x6944, 0x6E61, 0 };
+		int use_ascii (int i) {
+		  return ascii_mm[i] + ascii_ii[i];
+		}
+		short int ebcdic_ii[] =
+		  { 0x89D3, 0xE3E3, 0x8593, 0x95C5, 0x89C4, 0x9581, 0 };
+		short int ebcdic_mm[] =
+		  { 0xC2C9, 0xC785, 0x95C4, 0x8981, 0x95E2, 0xA8E2, 0 };
+		int use_ebcdic (int i) {
+		  return ebcdic_mm[i] + ebcdic_ii[i];
+		}
+		extern int foo;
 
 int
 main ()
 {
-return ! malloc (0);
+return use_ascii (foo) == use_ebcdic (foo);
   ;
   return 0;
 }
 _ACEOF
-rm -f conftest$ac_exeext
-if { (ac_try="$ac_link"
+rm -f conftest.$ac_objext
+if { (ac_try="$ac_compile"
 case "(($ac_try" in
   *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
   *) ac_try_echo=$ac_try;;
 esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_link") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && { ac_try='./conftest$ac_exeext'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_try") 2>&5
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
+  (eval "$ac_compile") 2>conftest.er1
   ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; }; then
-  ac_cv_func_malloc_0_nonnull=yes
-else
-  echo "$as_me: program exited with status $ac_status" >&5
-echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-( exit $ac_status )
-ac_cv_func_malloc_0_nonnull=no
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && {
+	 test -z "$ac_c_werror_flag" ||
+	 test ! -s conftest.err
+       } && test -s conftest.$ac_objext; then
+  if grep BIGenDianSyS conftest.$ac_objext >/dev/null; then
+	      ac_cv_c_bigendian=yes
 fi
-rm -f core *.core core.conftest.* gmon.out bb.out conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
+	    if grep LiTTleEnDian conftest.$ac_objext >/dev/null ; then
+	      if test "$ac_cv_c_bigendian" = unknown; then
+		ac_cv_c_bigendian=no
+	      else
+		# finding both strings is unlikely to happen, but who knows?
+		ac_cv_c_bigendian=unknown
 fi
-
-
 fi
-{ echo "$as_me:$LINENO: result: $ac_cv_func_malloc_0_nonnull" >&5
-echo "${ECHO_T}$ac_cv_func_malloc_0_nonnull" >&6; }
-if test $ac_cv_func_malloc_0_nonnull = yes; then
-
-cat >>confdefs.h <<\_ACEOF
-#define HAVE_MALLOC 1
-_ACEOF
-
 else
-  cat >>confdefs.h <<\_ACEOF
-#define HAVE_MALLOC 0
-_ACEOF
-
-   case " $LIBOBJS " in
-  *" malloc.$ac_objext "* ) ;;
-  *) LIBOBJS="$LIBOBJS malloc.$ac_objext"
- ;;
-esac
-
+  $as_echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
 
-cat >>confdefs.h <<\_ACEOF
-#define malloc rpl_malloc
-_ACEOF
 
 fi
 
-
-
-{ echo "$as_me:$LINENO: checking for working strtod" >&5
-echo $ECHO_N "checking for working strtod... $ECHO_C" >&6; }
-if test "${ac_cv_func_strtod+set}" = set; then
-  echo $ECHO_N "(cached) $ECHO_C" >&6
-else
-  if test "$cross_compiling" = yes; then
-  ac_cv_func_strtod=no
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
 else
   cat >conftest.$ac_ext <<_ACEOF
 /* confdefs.h.  */
@@ -4793,36 +7376,23 @@ _ACEOF
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
-
 $ac_includes_default
-#ifndef strtod
-double strtod ();
-#endif
 int
 main()
 {
-  {
-    /* Some versions of Linux strtod mis-parse strings with leading '+'.  */
-    char *string = " +69";
-    char *term;
-    double value;
-    value = strtod (string, &term);
-    if (value != 69 || term != (string + 4))
-      return 1;
-  }
 
+	     /* Are we little or big endian?  From Harbison&Steele.  */
+	     union
   {
-    /* Under Solaris 2.4, strtod returns the wrong value for the
-       terminating character under some conditions.  */
-    char *string = "NaN";
-    char *term;
-    strtod (string, &term);
-    if (term != string && *(term - 1) == 0)
-      return 1;
-  }
+	       long int l;
+	       char c[sizeof (long int)];
+	     } u;
+	     u.l = 1;
+	     return u.c[sizeof (long int) - 1] == 1;
+
+  ;
   return 0;
 }
-
 _ACEOF
 rm -f conftest$ac_exeext
 if { (ac_try="$ac_link"
@@ -4830,216 +7400,178 @@ case "(($ac_try" in
   *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
   *) ac_try_echo=$ac_try;;
 esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
   (eval "$ac_link") 2>&5
   ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } && { ac_try='./conftest$ac_exeext'
   { (case "(($ac_try" in
   *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
   *) ac_try_echo=$ac_try;;
 esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
   (eval "$ac_try") 2>&5
   ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
-  ac_cv_func_strtod=yes
+  ac_cv_c_bigendian=no
 else
-  echo "$as_me: program exited with status $ac_status" >&5
-echo "$as_me: failed program was:" >&5
+  $as_echo "$as_me: program exited with status $ac_status" >&5
+$as_echo "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
 ( exit $ac_status )
-ac_cv_func_strtod=no
+ac_cv_c_bigendian=yes
 fi
+rm -rf conftest.dSYM
 rm -f core *.core core.conftest.* gmon.out bb.out conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
 fi
 
 
 fi
-{ echo "$as_me:$LINENO: result: $ac_cv_func_strtod" >&5
-echo "${ECHO_T}$ac_cv_func_strtod" >&6; }
-if test $ac_cv_func_strtod = no; then
-  case " $LIBOBJS " in
-  *" strtod.$ac_objext "* ) ;;
-  *) LIBOBJS="$LIBOBJS strtod.$ac_objext"
- ;;
+fi
+{ $as_echo "$as_me:$LINENO: result: $ac_cv_c_bigendian" >&5
+$as_echo "$ac_cv_c_bigendian" >&6; }
+ case $ac_cv_c_bigendian in #(
+   yes)
+     cat >>confdefs.h <<\_ACEOF
+#define WORDS_BIGENDIAN 1
+_ACEOF
+;; #(
+   no)
+      ;; #(
+   universal)
+
+cat >>confdefs.h <<\_ACEOF
+#define AC_APPLE_UNIVERSAL_BUILD 1
+_ACEOF
+
+     ;; #(
+   *)
+     { { $as_echo "$as_me:$LINENO: error: unknown endianness
+ presetting ac_cv_c_bigendian=no (or yes) will help" >&5
+$as_echo "$as_me: error: unknown endianness
+ presetting ac_cv_c_bigendian=no (or yes) will help" >&2;}
+   { (exit 1); exit 1; }; } ;;
 esac
 
-{ echo "$as_me:$LINENO: checking for pow" >&5
-echo $ECHO_N "checking for pow... $ECHO_C" >&6; }
-if test "${ac_cv_func_pow+set}" = set; then
-  echo $ECHO_N "(cached) $ECHO_C" >&6
+# The cast to long int works around a bug in the HP C Compiler
+# version HP92453-01 B.11.11.23709.GP, which incorrectly rejects
+# declarations like `int a3[[(sizeof (unsigned char)) >= 0]];'.
+# This bug is HP SR number 8606223364.
+{ $as_echo "$as_me:$LINENO: checking size of int *" >&5
+$as_echo_n "checking size of int *... " >&6; }
+if test "${ac_cv_sizeof_int_p+set}" = set; then
+  $as_echo_n "(cached) " >&6
 else
+  if test "$cross_compiling" = yes; then
+  # Depending upon the size, compute the lo and hi bounds.
   cat >conftest.$ac_ext <<_ACEOF
 /* confdefs.h.  */
 _ACEOF
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
-/* Define pow to an innocuous variant, in case <limits.h> declares pow.
-   For example, HP-UX 11i <limits.h> declares gettimeofday.  */
-#define pow innocuous_pow
-
-/* System header to define __stub macros and hopefully few prototypes,
-    which can conflict with char pow (); below.
-    Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
-    <limits.h> exists even on freestanding compilers.  */
-
-#ifdef __STDC__
-# include <limits.h>
-#else
-# include <assert.h>
-#endif
-
-#undef pow
-
-/* Override any GCC internal prototype to avoid an error.
-   Use char because int might match the return type of a GCC
-   builtin and then its argument prototype would still apply.  */
-#ifdef __cplusplus
-extern "C"
-#endif
-char pow ();
-/* The GNU C library defines this for functions which it implements
-    to always fail with ENOSYS.  Some functions are actually named
-    something starting with __ and the normal name is an alias.  */
-#if defined __stub_pow || defined __stub___pow
-choke me
-#endif
-
+$ac_includes_default
 int
 main ()
 {
-return pow ();
+static int test_array [1 - 2 * !(((long int) (sizeof (int *))) >= 0)];
+test_array [0] = 0
+
   ;
   return 0;
 }
 _ACEOF
-rm -f conftest.$ac_objext conftest$ac_exeext
-if { (ac_try="$ac_link"
+rm -f conftest.$ac_objext
+if { (ac_try="$ac_compile"
 case "(($ac_try" in
   *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
   *) ac_try_echo=$ac_try;;
 esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_link") 2>conftest.er1
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
+  (eval "$ac_compile") 2>conftest.er1
   ac_status=$?
   grep -v '^ *+' conftest.er1 >conftest.err
   rm -f conftest.er1
   cat conftest.err >&5
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } && {
 	 test -z "$ac_c_werror_flag" ||
 	 test ! -s conftest.err
-       } && test -s conftest$ac_exeext &&
-       $as_test_x conftest$ac_exeext; then
-  ac_cv_func_pow=yes
-else
-  echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	ac_cv_func_pow=no
-fi
-
-rm -f core conftest.err conftest.$ac_objext conftest_ipa8_conftest.oo \
-      conftest$ac_exeext conftest.$ac_ext
-fi
-{ echo "$as_me:$LINENO: result: $ac_cv_func_pow" >&5
-echo "${ECHO_T}$ac_cv_func_pow" >&6; }
-
-if test $ac_cv_func_pow = no; then
-  { echo "$as_me:$LINENO: checking for pow in -lm" >&5
-echo $ECHO_N "checking for pow in -lm... $ECHO_C" >&6; }
-if test "${ac_cv_lib_m_pow+set}" = set; then
-  echo $ECHO_N "(cached) $ECHO_C" >&6
-else
-  ac_check_lib_save_LIBS=$LIBS
-LIBS="-lm  $LIBS"
+       } && test -s conftest.$ac_objext; then
+  ac_lo=0 ac_mid=0
+  while :; do
 cat >conftest.$ac_ext <<_ACEOF
 /* confdefs.h.  */
 _ACEOF
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
-
-/* Override any GCC internal prototype to avoid an error.
-   Use char because int might match the return type of a GCC
-   builtin and then its argument prototype would still apply.  */
-#ifdef __cplusplus
-extern "C"
-#endif
-char pow ();
+$ac_includes_default
 int
 main ()
 {
-return pow ();
+static int test_array [1 - 2 * !(((long int) (sizeof (int *))) <= $ac_mid)];
+test_array [0] = 0
+
   ;
   return 0;
 }
 _ACEOF
-rm -f conftest.$ac_objext conftest$ac_exeext
-if { (ac_try="$ac_link"
+rm -f conftest.$ac_objext
+if { (ac_try="$ac_compile"
 case "(($ac_try" in
   *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
   *) ac_try_echo=$ac_try;;
 esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_link") 2>conftest.er1
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
+  (eval "$ac_compile") 2>conftest.er1
   ac_status=$?
   grep -v '^ *+' conftest.er1 >conftest.err
   rm -f conftest.er1
   cat conftest.err >&5
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } && {
 	 test -z "$ac_c_werror_flag" ||
 	 test ! -s conftest.err
-       } && test -s conftest$ac_exeext &&
-       $as_test_x conftest$ac_exeext; then
-  ac_cv_lib_m_pow=yes
+       } && test -s conftest.$ac_objext; then
+  ac_hi=$ac_mid; break
 else
-  echo "$as_me: failed program was:" >&5
+  $as_echo "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
-	ac_cv_lib_m_pow=no
-fi
-
-rm -f core conftest.err conftest.$ac_objext conftest_ipa8_conftest.oo \
-      conftest$ac_exeext conftest.$ac_ext
-LIBS=$ac_check_lib_save_LIBS
-fi
-{ echo "$as_me:$LINENO: result: $ac_cv_lib_m_pow" >&5
-echo "${ECHO_T}$ac_cv_lib_m_pow" >&6; }
-if test $ac_cv_lib_m_pow = yes; then
-  POW_LIB=-lm
-else
-  { echo "$as_me:$LINENO: WARNING: cannot find library containing definition of pow" >&5
-echo "$as_me: WARNING: cannot find library containing definition of pow" >&2;}
-fi
-
+	ac_lo=`expr $ac_mid + 1`
+			if test $ac_lo -le $ac_mid; then
+			  ac_lo= ac_hi=
+			  break
 fi
-
+			ac_mid=`expr 2 '*' $ac_mid + 1`
 fi
 
-{ echo "$as_me:$LINENO: checking return type of signal handlers" >&5
-echo $ECHO_N "checking return type of signal handlers... $ECHO_C" >&6; }
-if test "${ac_cv_type_signal+set}" = set; then
-  echo $ECHO_N "(cached) $ECHO_C" >&6
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+  done
 else
+  $as_echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
   cat >conftest.$ac_ext <<_ACEOF
 /* confdefs.h.  */
 _ACEOF
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
-#include <sys/types.h>
-#include <signal.h>
-
+$ac_includes_default
 int
 main ()
 {
-return *(signal (0, 0)) (0) == 1;
+static int test_array [1 - 2 * !(((long int) (sizeof (int *))) < 0)];
+test_array [0] = 0
+
   ;
   return 0;
 }
@@ -5050,240 +7582,143 @@ case "(($ac_try" in
   *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
   *) ac_try_echo=$ac_try;;
 esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
   (eval "$ac_compile") 2>conftest.er1
   ac_status=$?
   grep -v '^ *+' conftest.er1 >conftest.err
   rm -f conftest.er1
   cat conftest.err >&5
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } && {
 	 test -z "$ac_c_werror_flag" ||
 	 test ! -s conftest.err
        } && test -s conftest.$ac_objext; then
-  ac_cv_type_signal=int
-else
-  echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	ac_cv_type_signal=void
-fi
-
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-fi
-{ echo "$as_me:$LINENO: result: $ac_cv_type_signal" >&5
-echo "${ECHO_T}$ac_cv_type_signal" >&6; }
-
-cat >>confdefs.h <<_ACEOF
-#define RETSIGTYPE $ac_cv_type_signal
-_ACEOF
-
-
-
-for ac_func in vprintf
-do
-as_ac_var=`echo "ac_cv_func_$ac_func" | $as_tr_sh`
-{ echo "$as_me:$LINENO: checking for $ac_func" >&5
-echo $ECHO_N "checking for $ac_func... $ECHO_C" >&6; }
-if { as_var=$as_ac_var; eval "test \"\${$as_var+set}\" = set"; }; then
-  echo $ECHO_N "(cached) $ECHO_C" >&6
-else
+  ac_hi=-1 ac_mid=-1
+  while :; do
   cat >conftest.$ac_ext <<_ACEOF
 /* confdefs.h.  */
 _ACEOF
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
-/* Define $ac_func to an innocuous variant, in case <limits.h> declares $ac_func.
-   For example, HP-UX 11i <limits.h> declares gettimeofday.  */
-#define $ac_func innocuous_$ac_func
-
-/* System header to define __stub macros and hopefully few prototypes,
-    which can conflict with char $ac_func (); below.
-    Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
-    <limits.h> exists even on freestanding compilers.  */
-
-#ifdef __STDC__
-# include <limits.h>
-#else
-# include <assert.h>
-#endif
-
-#undef $ac_func
-
-/* Override any GCC internal prototype to avoid an error.
-   Use char because int might match the return type of a GCC
-   builtin and then its argument prototype would still apply.  */
-#ifdef __cplusplus
-extern "C"
-#endif
-char $ac_func ();
-/* The GNU C library defines this for functions which it implements
-    to always fail with ENOSYS.  Some functions are actually named
-    something starting with __ and the normal name is an alias.  */
-#if defined __stub_$ac_func || defined __stub___$ac_func
-choke me
-#endif
-
+$ac_includes_default
 int
 main ()
 {
-return $ac_func ();
+static int test_array [1 - 2 * !(((long int) (sizeof (int *))) >= $ac_mid)];
+test_array [0] = 0
+
   ;
   return 0;
 }
 _ACEOF
-rm -f conftest.$ac_objext conftest$ac_exeext
-if { (ac_try="$ac_link"
+rm -f conftest.$ac_objext
+if { (ac_try="$ac_compile"
 case "(($ac_try" in
   *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
   *) ac_try_echo=$ac_try;;
 esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_link") 2>conftest.er1
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
+  (eval "$ac_compile") 2>conftest.er1
   ac_status=$?
   grep -v '^ *+' conftest.er1 >conftest.err
   rm -f conftest.er1
   cat conftest.err >&5
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } && {
 	 test -z "$ac_c_werror_flag" ||
 	 test ! -s conftest.err
-       } && test -s conftest$ac_exeext &&
-       $as_test_x conftest$ac_exeext; then
-  eval "$as_ac_var=yes"
+       } && test -s conftest.$ac_objext; then
+  ac_lo=$ac_mid; break
 else
-  echo "$as_me: failed program was:" >&5
+  $as_echo "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
-	eval "$as_ac_var=no"
+	ac_hi=`expr '(' $ac_mid ')' - 1`
+			if test $ac_mid -le $ac_hi; then
+			  ac_lo= ac_hi=
+			  break
 fi
-
-rm -f core conftest.err conftest.$ac_objext conftest_ipa8_conftest.oo \
-      conftest$ac_exeext conftest.$ac_ext
+			ac_mid=`expr 2 '*' $ac_mid`
 fi
-ac_res=`eval echo '${'$as_ac_var'}'`
-	       { echo "$as_me:$LINENO: result: $ac_res" >&5
-echo "${ECHO_T}$ac_res" >&6; }
-if test `eval echo '${'$as_ac_var'}'` = yes; then
-  cat >>confdefs.h <<_ACEOF
-#define `echo "HAVE_$ac_func" | $as_tr_cpp` 1
-_ACEOF
 
-{ echo "$as_me:$LINENO: checking for _doprnt" >&5
-echo $ECHO_N "checking for _doprnt... $ECHO_C" >&6; }
-if test "${ac_cv_func__doprnt+set}" = set; then
-  echo $ECHO_N "(cached) $ECHO_C" >&6
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+  done
 else
+  $as_echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+	ac_lo= ac_hi=
+fi
+
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+fi
+
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+# Binary search between lo and hi bounds.
+while test "x$ac_lo" != "x$ac_hi"; do
+  ac_mid=`expr '(' $ac_hi - $ac_lo ')' / 2 + $ac_lo`
   cat >conftest.$ac_ext <<_ACEOF
 /* confdefs.h.  */
 _ACEOF
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
-/* Define _doprnt to an innocuous variant, in case <limits.h> declares _doprnt.
-   For example, HP-UX 11i <limits.h> declares gettimeofday.  */
-#define _doprnt innocuous__doprnt
-
-/* System header to define __stub macros and hopefully few prototypes,
-    which can conflict with char _doprnt (); below.
-    Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
-    <limits.h> exists even on freestanding compilers.  */
-
-#ifdef __STDC__
-# include <limits.h>
-#else
-# include <assert.h>
-#endif
-
-#undef _doprnt
-
-/* Override any GCC internal prototype to avoid an error.
-   Use char because int might match the return type of a GCC
-   builtin and then its argument prototype would still apply.  */
-#ifdef __cplusplus
-extern "C"
-#endif
-char _doprnt ();
-/* The GNU C library defines this for functions which it implements
-    to always fail with ENOSYS.  Some functions are actually named
-    something starting with __ and the normal name is an alias.  */
-#if defined __stub__doprnt || defined __stub____doprnt
-choke me
-#endif
-
+$ac_includes_default
 int
 main ()
 {
-return _doprnt ();
+static int test_array [1 - 2 * !(((long int) (sizeof (int *))) <= $ac_mid)];
+test_array [0] = 0
+
   ;
   return 0;
 }
 _ACEOF
-rm -f conftest.$ac_objext conftest$ac_exeext
-if { (ac_try="$ac_link"
+rm -f conftest.$ac_objext
+if { (ac_try="$ac_compile"
 case "(($ac_try" in
   *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
   *) ac_try_echo=$ac_try;;
 esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_link") 2>conftest.er1
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
+  (eval "$ac_compile") 2>conftest.er1
   ac_status=$?
   grep -v '^ *+' conftest.er1 >conftest.err
   rm -f conftest.er1
   cat conftest.err >&5
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } && {
 	 test -z "$ac_c_werror_flag" ||
 	 test ! -s conftest.err
-       } && test -s conftest$ac_exeext &&
-       $as_test_x conftest$ac_exeext; then
-  ac_cv_func__doprnt=yes
+       } && test -s conftest.$ac_objext; then
+  ac_hi=$ac_mid
 else
-  echo "$as_me: failed program was:" >&5
+  $as_echo "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
-	ac_cv_func__doprnt=no
-fi
-
-rm -f core conftest.err conftest.$ac_objext conftest_ipa8_conftest.oo \
-      conftest$ac_exeext conftest.$ac_ext
-fi
-{ echo "$as_me:$LINENO: result: $ac_cv_func__doprnt" >&5
-echo "${ECHO_T}$ac_cv_func__doprnt" >&6; }
-if test $ac_cv_func__doprnt = yes; then
-
-cat >>confdefs.h <<\_ACEOF
-#define HAVE_DOPRNT 1
-_ACEOF
-
+	ac_lo=`expr '(' $ac_mid ')' + 1`
 fi
 
-fi
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
 done
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-for ac_func in floor gettimeofday memmove memset modf pow socket sqrt strchr strcspn strrchr strspn strstr strtol
-do
-as_ac_var=`echo "ac_cv_func_$ac_func" | $as_tr_sh`
-{ echo "$as_me:$LINENO: checking for $ac_func" >&5
-echo $ECHO_N "checking for $ac_func... $ECHO_C" >&6; }
-if { as_var=$as_ac_var; eval "test \"\${$as_var+set}\" = set"; }; then
-  echo $ECHO_N "(cached) $ECHO_C" >&6
+case $ac_lo in
+?*) ac_cv_sizeof_int_p=$ac_lo;;
+'') if test "$ac_cv_type_int_p" = yes; then
+     { { $as_echo "$as_me:$LINENO: error: in \`$ac_pwd':" >&5
+$as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
+{ { $as_echo "$as_me:$LINENO: error: cannot compute sizeof (int *)
+See \`config.log' for more details." >&5
+$as_echo "$as_me: error: cannot compute sizeof (int *)
+See \`config.log' for more details." >&2;}
+   { (exit 77); exit 77; }; }; }
+   else
+     ac_cv_sizeof_int_p=0
+   fi ;;
+esac
 else
   cat >conftest.$ac_ext <<_ACEOF
 /* confdefs.h.  */
@@ -5291,168 +7726,94 @@ _ACEOF
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
-/* Define $ac_func to an innocuous variant, in case <limits.h> declares $ac_func.
-   For example, HP-UX 11i <limits.h> declares gettimeofday.  */
-#define $ac_func innocuous_$ac_func
-
-/* System header to define __stub macros and hopefully few prototypes,
-    which can conflict with char $ac_func (); below.
-    Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
-    <limits.h> exists even on freestanding compilers.  */
-
-#ifdef __STDC__
-# include <limits.h>
-#else
-# include <assert.h>
-#endif
-
-#undef $ac_func
-
-/* Override any GCC internal prototype to avoid an error.
-   Use char because int might match the return type of a GCC
-   builtin and then its argument prototype would still apply.  */
-#ifdef __cplusplus
-extern "C"
-#endif
-char $ac_func ();
-/* The GNU C library defines this for functions which it implements
-    to always fail with ENOSYS.  Some functions are actually named
-    something starting with __ and the normal name is an alias.  */
-#if defined __stub_$ac_func || defined __stub___$ac_func
-choke me
-#endif
-
+$ac_includes_default
+static long int longval () { return (long int) (sizeof (int *)); }
+static unsigned long int ulongval () { return (long int) (sizeof (int *)); }
+#include <stdio.h>
+#include <stdlib.h>
 int
 main ()
 {
-return $ac_func ();
+
+  FILE *f = fopen ("conftest.val", "w");
+  if (! f)
+    return 1;
+  if (((long int) (sizeof (int *))) < 0)
+    {
+      long int i = longval ();
+      if (i != ((long int) (sizeof (int *))))
+	return 1;
+      fprintf (f, "%ld", i);
+    }
+  else
+    {
+      unsigned long int i = ulongval ();
+      if (i != ((long int) (sizeof (int *))))
+	return 1;
+      fprintf (f, "%lu", i);
+    }
+  /* Do not output a trailing newline, as this causes \r\n confusion
+     on some platforms.  */
+  return ferror (f) || fclose (f) != 0;
+
   ;
   return 0;
 }
 _ACEOF
-rm -f conftest.$ac_objext conftest$ac_exeext
+rm -f conftest$ac_exeext
 if { (ac_try="$ac_link"
 case "(($ac_try" in
   *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
   *) ac_try_echo=$ac_try;;
 esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_link") 2>conftest.er1
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
+  (eval "$ac_link") 2>&5
   ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest$ac_exeext &&
-       $as_test_x conftest$ac_exeext; then
-  eval "$as_ac_var=yes"
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && { ac_try='./conftest$ac_exeext'
+  { (case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
+  (eval "$ac_try") 2>&5
+  ac_status=$?
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_sizeof_int_p=`cat conftest.val`
 else
-  echo "$as_me: failed program was:" >&5
+  $as_echo "$as_me: program exited with status $ac_status" >&5
+$as_echo "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
-	eval "$as_ac_var=no"
+( exit $ac_status )
+if test "$ac_cv_type_int_p" = yes; then
+     { { $as_echo "$as_me:$LINENO: error: in \`$ac_pwd':" >&5
+$as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
+{ { $as_echo "$as_me:$LINENO: error: cannot compute sizeof (int *)
+See \`config.log' for more details." >&5
+$as_echo "$as_me: error: cannot compute sizeof (int *)
+See \`config.log' for more details." >&2;}
+   { (exit 77); exit 77; }; }; }
+   else
+     ac_cv_sizeof_int_p=0
 fi
-
-rm -f core conftest.err conftest.$ac_objext conftest_ipa8_conftest.oo \
-      conftest$ac_exeext conftest.$ac_ext
 fi
-ac_res=`eval echo '${'$as_ac_var'}'`
-	       { echo "$as_me:$LINENO: result: $ac_res" >&5
-echo "${ECHO_T}$ac_res" >&6; }
-if test `eval echo '${'$as_ac_var'}'` = yes; then
-  cat >>confdefs.h <<_ACEOF
-#define `echo "HAVE_$ac_func" | $as_tr_cpp` 1
-_ACEOF
-
+rm -rf conftest.dSYM
+rm -f core *.core core.conftest.* gmon.out bb.out conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
 fi
-done
-
-
-
-# Make sure we can run config.sub.
-$SHELL "$ac_aux_dir/config.sub" sun4 >/dev/null 2>&1 ||
-  { { echo "$as_me:$LINENO: error: cannot run $SHELL $ac_aux_dir/config.sub" >&5
-echo "$as_me: error: cannot run $SHELL $ac_aux_dir/config.sub" >&2;}
-   { (exit 1); exit 1; }; }
-
-{ echo "$as_me:$LINENO: checking build system type" >&5
-echo $ECHO_N "checking build system type... $ECHO_C" >&6; }
-if test "${ac_cv_build+set}" = set; then
-  echo $ECHO_N "(cached) $ECHO_C" >&6
-else
-  ac_build_alias=$build_alias
-test "x$ac_build_alias" = x &&
-  ac_build_alias=`$SHELL "$ac_aux_dir/config.guess"`
-test "x$ac_build_alias" = x &&
-  { { echo "$as_me:$LINENO: error: cannot guess build type; you must specify one" >&5
-echo "$as_me: error: cannot guess build type; you must specify one" >&2;}
-   { (exit 1); exit 1; }; }
-ac_cv_build=`$SHELL "$ac_aux_dir/config.sub" $ac_build_alias` ||
-  { { echo "$as_me:$LINENO: error: $SHELL $ac_aux_dir/config.sub $ac_build_alias failed" >&5
-echo "$as_me: error: $SHELL $ac_aux_dir/config.sub $ac_build_alias failed" >&2;}
-   { (exit 1); exit 1; }; }
-
+rm -f conftest.val
 fi
-{ echo "$as_me:$LINENO: result: $ac_cv_build" >&5
-echo "${ECHO_T}$ac_cv_build" >&6; }
-case $ac_cv_build in
-*-*-*) ;;
-*) { { echo "$as_me:$LINENO: error: invalid value of canonical build" >&5
-echo "$as_me: error: invalid value of canonical build" >&2;}
-   { (exit 1); exit 1; }; };;
-esac
-build=$ac_cv_build
-ac_save_IFS=$IFS; IFS='-'
-set x $ac_cv_build
-shift
-build_cpu=$1
-build_vendor=$2
-shift; shift
-# Remember, the first character of IFS is used to create $*,
-# except with old shells:
-build_os=$*
-IFS=$ac_save_IFS
-case $build_os in *\ *) build_os=`echo "$build_os" | sed 's/ /-/g'`;; esac
+{ $as_echo "$as_me:$LINENO: result: $ac_cv_sizeof_int_p" >&5
+$as_echo "$ac_cv_sizeof_int_p" >&6; }
 
 
-{ echo "$as_me:$LINENO: checking host system type" >&5
-echo $ECHO_N "checking host system type... $ECHO_C" >&6; }
-if test "${ac_cv_host+set}" = set; then
-  echo $ECHO_N "(cached) $ECHO_C" >&6
-else
-  if test "x$host_alias" = x; then
-  ac_cv_host=$ac_cv_build
-else
-  ac_cv_host=`$SHELL "$ac_aux_dir/config.sub" $host_alias` ||
-    { { echo "$as_me:$LINENO: error: $SHELL $ac_aux_dir/config.sub $host_alias failed" >&5
-echo "$as_me: error: $SHELL $ac_aux_dir/config.sub $host_alias failed" >&2;}
-   { (exit 1); exit 1; }; }
-fi
 
-fi
-{ echo "$as_me:$LINENO: result: $ac_cv_host" >&5
-echo "${ECHO_T}$ac_cv_host" >&6; }
-case $ac_cv_host in
-*-*-*) ;;
-*) { { echo "$as_me:$LINENO: error: invalid value of canonical host" >&5
-echo "$as_me: error: invalid value of canonical host" >&2;}
-   { (exit 1); exit 1; }; };;
-esac
-host=$ac_cv_host
-ac_save_IFS=$IFS; IFS='-'
-set x $ac_cv_host
-shift
-host_cpu=$1
-host_vendor=$2
-shift; shift
-# Remember, the first character of IFS is used to create $*,
-# except with old shells:
-host_os=$*
-IFS=$ac_save_IFS
-case $host_os in *\ *) host_os=`echo "$host_os" | sed 's/ /-/g'`;; esac
+cat >>confdefs.h <<_ACEOF
+#define SIZEOF_INT_P $ac_cv_sizeof_int_p
+_ACEOF
 
 
 
@@ -5492,6 +7853,11 @@ case "$CC" in
 		CFLAGS="-Wall -Wno-switch $CFLAGS"
 		;;
 esac
+case "$F77" in
+	g77*)
+		FFLAGS="-Wall $FFLAGS"
+	;;
+esac
 
 
 trad_bin_dir=$host
@@ -5504,42 +7870,60 @@ esac
 
 case "$host" in
 		*x86_64*linux*)
-				CFLAGS="-m32 -ansi -D_SVID_SOURCE -DOSS_AUDIO -D'ARCH=\"$host_cpu\"' $CFLAGS"
+				CFLAGS="-ansi -D_SVID_SOURCE -DOSS_AUDIO -D'ARCH=\"$host_cpu\"' $CFLAGS"
+				FFLAGS="$FFLAGS"
+				{ $as_echo "$as_me:$LINENO: checking whether to compile in 32-bit or 64-bit mode" >&5
+$as_echo_n "checking whether to compile in 32-bit or 64-bit mode... " >&6; }
+				if test x$ac_cv_sizeof_int_p = x"4"; then
+					{ $as_echo "$as_me:$LINENO: result: 32-bit" >&5
+$as_echo "32-bit" >&6; }
 				LDFLAGS="-L/usr/X11R6/lib $LDFLAGS"
+				elif test x$ac_cv_sizeof_int_p = x"8"; then
+					{ $as_echo "$as_me:$LINENO: result: 64-bit" >&5
+$as_echo "64-bit" >&6; }
+					LDFLAGS="-L/usr/X11R6/lib64 $LDFLAGS"
+				fi
 				ARCH=linux
 				trad_bin_dir=linux
 		;;
 		*linux*)
 				CFLAGS="-ansi -D_SVID_SOURCE -DOSS_AUDIO -D'ARCH=\"$host_cpu\"' $CFLAGS"
+				FFLAGS="$FFLAGS"
 				LDFLAGS="-L/usr/X11R6/lib $LDFLAGS"
 				ARCH=linux
 				trad_bin_dir=linux
 		;;
 		*pc-solaris*)
 				CFLAGS="-ansi -I/usr/openwin/include -O2 -DSOLARIS16_AUDIO -DBSD_COMP -D'ARCH=\"$host_cpu\"' $CFLAGS"
+				FFLAGS="-O2 $FFLAGS"
 				LDFLAGS="-L/usr/openwin/lib -ldl -lsocket -lnsl -lintl $LDFLAGS"
 		;;
 		*sun*)
 				CFLAGS="-ansi -I/usr/openwin/include -O2 -DSOLARIS16_AUDIO -DBSD_COMP -D'ARCH=\"$host_cpu\"' $CFLAGS"
+				FFLAGS="-O2 $FFLAGS"
 				LDFLAGS="-L/usr/openwin/lib -ldl -lsocket -lnsl -lintl $LDFLAGS"
 		;;
 		*sgi*)
 				CFLAGS="-O -DSGI_AUDIO  -D'ARCH=\"$host_cpu\"' $CFLAGS"
+				FFLAGS="$FFLAGS"
 				LDFLAGS="-laudio -lmalloc $LDFLAGS"
 		;;
 		*hp*)
 				CFLAGS="+e -O -I/usr/include/X11R5 -I/usr/include/audio -I/opt/audio/include -D_HPUX_SOURCE -Aa -DHPUX_AUDIO -DUSE_TIMER  -D'ARCH=\"$host_cpu\"' $CFLAGS"
+				FFLAGS="$FFLAGS"
 				LDFLAGS="-L/opt/audio/lib -lAlib $LDFLAGS"
 		;;
 		*cygwin)
 				CFLAGS="-ansi -DCYGWIN -D'ARCH=\"ASCII\"' $CFLAGS"
+				FFLAGS="$FFLAGS"
 				LDFLAGS="-L/usr/X11R6/lib $LDFLAGS"
 				ARCH=ASCII
-				CPU=darwin
+				CPU=cygwin
 				BINARY_EXTENSION=.exe
 		;;
 		i386*darwin*)
 				CFLAGS="-ansi -g -O2 -DNO_AUDIO -D'ARCH=\"darwin\"' -I/usr/include/malloc $CFLAGS"
+				FFLAGS="-gdwarf-2 -O2 $$FFLAGS"
 				LDFLAGS="-L/usr/X11R6/lib $LDFLAGS"
 				ARCH=darwin
 				Objcopy=echo
@@ -5548,8 +7932,9 @@ case "$host" in
 				SHRLF="-shared"
 				LIBEXT=dylib
 		;;
-		darwin)
-				CFLAGS="-ansi -g -O2 -DNO_AUDIO -D'ARCH=\"darwin\"' $CFLAGS"
+		*darwin*)
+				CFLAGS="-ansi -g -O2 -DNO_AUDIO -D'ARCH=\"darwin\"' -I/usr/include/malloc $CFLAGS"
+				FFLAGS="-gdwarf-2 -O2 $$FFLAGS"
 				LDFLAGS="-L/usr/X11R6/lib $LDFLAGS"
 				ARCH=darwin
 				Objcopy=echo
@@ -5560,6 +7945,43 @@ case "$host" in
 		;;
 esac
 
+
+if test -n "$MAXSTRLEN" -a $MAXSTRLEN!=1024; then
+	{ $as_echo "$as_me:$LINENO: checking user-defined maximum length of strings" >&5
+$as_echo_n "checking user-defined maximum length of strings... " >&6; }
+	CFLAGS="$CFLAGS -DMAXSTRLEN=$MAXSTRLEN"
+	{ $as_echo "$as_me:$LINENO: result: $MAXSTRLEN" >&5
+$as_echo "$MAXSTRLEN" >&6; }
+fi
+
+
+if test -n "$MAXFNAMELEN" -a $MAXFNAMELEN!=1024; then
+	{ $as_echo "$as_me:$LINENO: checking user-defined maximum length of file names" >&5
+$as_echo_n "checking user-defined maximum length of file names... " >&6; }
+	CFLAGS="$CFLAGS -DMAXFNAMELEN=$MAXFNAMELEN"
+	{ $as_echo "$as_me:$LINENO: result: $MAXFNAMELEN" >&5
+$as_echo "$MAXFNAMELEN" >&6; }
+fi
+
+
+if test -n "$PAT_LEN" -a $PAT_LEN!=2048; then
+	{ $as_echo "$as_me:$LINENO: checking user-defined maximum length of file names" >&5
+$as_echo_n "checking user-defined maximum length of file names... " >&6; }
+	CFLAGS="$CFLAGS -DPAT_LEN=$PAT_LEN"
+	{ $as_echo "$as_me:$LINENO: result: $PAT_LEN" >&5
+$as_echo "$PAT_LEN" >&6; }
+fi
+
+
+if test -n "$SMAX" -a $SMAX!=30; then
+	{ $as_echo "$as_me:$LINENO: checking user-defined maximum number of streams" >&5
+$as_echo_n "checking user-defined maximum number of streams... " >&6; }
+	CFLAGS="$CFLAGS -DSMAX=$SMAX"
+	{ $as_echo "$as_me:$LINENO: result: $SMAX" >&5
+$as_echo "$SMAX" >&6; }
+fi
+
+
 make_all=htktools
 make_install=install-htktools
 build_notes="Build notes: "
@@ -5570,23 +7992,25 @@ case "$enable_trad_htk" in
 	;;
 esac
 case "$enable_hlmtools" in
-     no)
-	build_notes="$build_notes The Language Modelling tools will not be built. You can build them manually later by running 'make hlmtools install-hlmtools'"
-	;;
-     *)
+     yes)
 	make_all="$make_all hlmtools"
 	make_install="$make_install install-hlmtools"
 	build_notes="$build_notes Language Modelling tools will be built."
 	;;
+     *)
+	build_notes="$build_notes The Language Modelling tools will not be built. You can build them manually later by running 'make hlmtools install-hlmtools'"
+	;;
 esac
 case "$enable_hdecode" in
      yes)
 	make_all="$make_all hdecode"
 	make_install="$make_install install-hdecode"
 	build_notes="$build_notes Large Vocabulary recogniser HDecode will be built."
+	LIBLV="HTKLiblv.a"
 	;;
      *)
 	build_notes="$build_notes HDecode will not be built. You can build it manually later by running 'make hdecode install-hdecode'"
+	LIBLV=""
 	;;
 esac
 case "$enable_htkbook" in
@@ -5652,11 +8077,12 @@ _ACEOF
     case $ac_val in #(
     *${as_nl}*)
       case $ac_var in #(
-      *_cv_*) { echo "$as_me:$LINENO: WARNING: Cache variable $ac_var contains a newline." >&5
-echo "$as_me: WARNING: Cache variable $ac_var contains a newline." >&2;} ;;
+      *_cv_*) { $as_echo "$as_me:$LINENO: WARNING: cache variable $ac_var contains a newline" >&5
+$as_echo "$as_me: WARNING: cache variable $ac_var contains a newline" >&2;} ;;
       esac
       case $ac_var in #(
       _ | IFS | as_nl) ;; #(
+      BASH_ARGV | BASH_SOURCE) eval $ac_var= ;; #(
       *) $as_unset $ac_var ;;
       esac ;;
     esac
@@ -5689,12 +8115,12 @@ echo "$as_me: WARNING: Cache variable $a
 if diff "$cache_file" confcache >/dev/null 2>&1; then :; else
   if test -w "$cache_file"; then
     test "x$cache_file" != "x/dev/null" &&
-      { echo "$as_me:$LINENO: updating cache $cache_file" >&5
-echo "$as_me: updating cache $cache_file" >&6;}
+      { $as_echo "$as_me:$LINENO: updating cache $cache_file" >&5
+$as_echo "$as_me: updating cache $cache_file" >&6;}
     cat confcache >$cache_file
   else
-    { echo "$as_me:$LINENO: not updating unwritable cache $cache_file" >&5
-echo "$as_me: not updating unwritable cache $cache_file" >&6;}
+    { $as_echo "$as_me:$LINENO: not updating unwritable cache $cache_file" >&5
+$as_echo "$as_me: not updating unwritable cache $cache_file" >&6;}
   fi
 fi
 rm -f confcache
@@ -5710,7 +8136,7 @@ ac_ltlibobjs=
 for ac_i in : $LIBOBJS; do test "x$ac_i" = x: && continue
   # 1. Remove the extension, and $U if already installed.
   ac_script='s/\$U\././;s/\.o$//;s/\.obj$//'
-  ac_i=`echo "$ac_i" | sed "$ac_script"`
+  ac_i=`$as_echo "$ac_i" | sed "$ac_script"`
   # 2. Prepend LIBOBJDIR.  When used with automake>=1.10 LIBOBJDIR
   #    will be set to the directory where LIBOBJS objects are built.
   ac_libobjs="$ac_libobjs \${LIBOBJDIR}$ac_i\$U.$ac_objext"
@@ -5722,12 +8148,14 @@ LTLIBOBJS=$ac_ltlibobjs
 
 
 
+
 : ${CONFIG_STATUS=./config.status}
+ac_write_fail=0
 ac_clean_files_save=$ac_clean_files
 ac_clean_files="$ac_clean_files $CONFIG_STATUS"
-{ echo "$as_me:$LINENO: creating $CONFIG_STATUS" >&5
-echo "$as_me: creating $CONFIG_STATUS" >&6;}
-cat >$CONFIG_STATUS <<_ACEOF
+{ $as_echo "$as_me:$LINENO: creating $CONFIG_STATUS" >&5
+$as_echo "$as_me: creating $CONFIG_STATUS" >&6;}
+cat >$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
 #! $SHELL
 # Generated by $as_me.
 # Run this file to recreate the current configuration.
@@ -5740,7 +8168,7 @@ ac_cs_silent=false
 SHELL=\${CONFIG_SHELL-$SHELL}
 _ACEOF
 
-cat >>$CONFIG_STATUS <<\_ACEOF
+cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1
 ## --------------------- ##
 ## M4sh Initialization.  ##
 ## --------------------- ##
@@ -5750,7 +8178,7 @@ DUALCASE=1; export DUALCASE # for MKS sh
 if test -n "${ZSH_VERSION+set}" && (emulate sh) >/dev/null 2>&1; then
   emulate sh
   NULLCMD=:
-  # Zsh 3.x and 4.x performs word splitting on ${1+"$@"}, which
+  # Pre-4.2 versions of Zsh do word splitting on ${1+"$@"}, which
   # is contrary to our usage.  Disable this feature.
   alias -g '${1+"$@"}'='"$@"'
   setopt NO_GLOB_SUBST
@@ -5772,17 +8200,45 @@ as_cr_Letters=$as_cr_letters$as_cr_LETTE
 as_cr_digits='0123456789'
 as_cr_alnum=$as_cr_Letters$as_cr_digits
 
+as_nl='
+'
+export as_nl
+# Printing a long string crashes Solaris 7 /usr/bin/printf.
+as_echo='\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'
+as_echo=$as_echo$as_echo$as_echo$as_echo$as_echo
+as_echo=$as_echo$as_echo$as_echo$as_echo$as_echo$as_echo
+if (test "X`printf %s $as_echo`" = "X$as_echo") 2>/dev/null; then
+  as_echo='printf %s\n'
+  as_echo_n='printf %s'
+else
+  if test "X`(/usr/ucb/echo -n -n $as_echo) 2>/dev/null`" = "X-n $as_echo"; then
+    as_echo_body='eval /usr/ucb/echo -n "$1$as_nl"'
+    as_echo_n='/usr/ucb/echo -n'
+  else
+    as_echo_body='eval expr "X$1" : "X\\(.*\\)"'
+    as_echo_n_body='eval
+      arg=$1;
+      case $arg in
+      *"$as_nl"*)
+	expr "X$arg" : "X\\(.*\\)$as_nl";
+	arg=`expr "X$arg" : ".*$as_nl\\(.*\\)"`;;
+      esac;
+      expr "X$arg" : "X\\(.*\\)" | tr -d "$as_nl"
+    '
+    export as_echo_n_body
+    as_echo_n='sh -c $as_echo_n_body as_echo'
+  fi
+  export as_echo_body
+  as_echo='sh -c $as_echo_body as_echo'
+fi
+
 # The user is always right.
 if test "${PATH_SEPARATOR+set}" != set; then
-  echo "#! /bin/sh" >conf$$.sh
-  echo  "exit 0"   >>conf$$.sh
-  chmod +x conf$$.sh
-  if (PATH="/nonexistent;."; conf$$.sh) >/dev/null 2>&1; then
-    PATH_SEPARATOR=';'
-  else
     PATH_SEPARATOR=:
-  fi
-  rm -f conf$$.sh
+  (PATH='/bin;/bin'; FPATH=$PATH; sh -c :) >/dev/null 2>&1 && {
+    (PATH='/bin:/bin'; FPATH=$PATH; sh -c :) >/dev/null 2>&1 ||
+      PATH_SEPARATOR=';'
+  }
 fi
 
 # Support unset when possible.
@@ -5798,8 +8254,6 @@ fi
 # there to prevent editors from complaining about space-tab.
 # (If _AS_PATH_WALK were called with IFS unset, it would disable word
 # splitting by setting IFS to empty value.)
-as_nl='
-'
 IFS=" ""	$as_nl"
 
 # Find who we are.  Look in the path if we contain no directory separator.
@@ -5822,7 +8276,7 @@ if test "x$as_myself" = x; then
   as_myself=$0
 fi
 if test ! -f "$as_myself"; then
-  echo "$as_myself: error: cannot find myself; rerun with an absolute file name" >&2
+  $as_echo "$as_myself: error: cannot find myself; rerun with an absolute file name" >&2
   { (exit 1); exit 1; }
 fi
 
@@ -5835,17 +8289,10 @@ PS2='> '
 PS4='+ '
 
 # NLS nuisances.
-for as_var in \
-  LANG LANGUAGE LC_ADDRESS LC_ALL LC_COLLATE LC_CTYPE LC_IDENTIFICATION \
-  LC_MEASUREMENT LC_MESSAGES LC_MONETARY LC_NAME LC_NUMERIC LC_PAPER \
-  LC_TELEPHONE LC_TIME
-do
-  if (set +x; test -z "`(eval $as_var=C; export $as_var) 2>&1`"); then
-    eval $as_var=C; export $as_var
-  else
-    ($as_unset $as_var) >/dev/null 2>&1 && $as_unset $as_var
-  fi
-done
+LC_ALL=C
+export LC_ALL
+LANGUAGE=C
+export LANGUAGE
 
 # Required to use basename.
 if expr a : '\(a\)' >/dev/null 2>&1 &&
@@ -5867,7 +8314,7 @@ as_me=`$as_basename -- "$0" ||
 $as_expr X/"$0" : '.*/\([^/][^/]*\)/*$' \| \
 	 X"$0" : 'X\(//\)$' \| \
 	 X"$0" : 'X\(/\)' \| . 2>/dev/null ||
-echo X/"$0" |
+$as_echo X/"$0" |
     sed '/^.*\/\([^/][^/]*\)\/*$/{
 	    s//\1/
 	    q
@@ -5918,7 +8365,7 @@ $as_unset CDPATH
       s/-\n.*//
     ' >$as_me.lineno &&
   chmod +x "$as_me.lineno" ||
-    { echo "$as_me: error: cannot create $as_me.lineno; rerun with a POSIX shell" >&2
+    { $as_echo "$as_me: error: cannot create $as_me.lineno; rerun with a POSIX shell" >&2
    { (exit 1); exit 1; }; }
 
   # Don't try to exec as it changes $[0], causing all sort of problems
@@ -5959,9 +8405,9 @@ if test -d conf$$.dir; then
   rm -f conf$$.dir/conf$$.file
 else
   rm -f conf$$.dir
-  mkdir conf$$.dir
+  mkdir conf$$.dir 2>/dev/null
 fi
-echo >conf$$.file
+if (echo >conf$$.file) 2>/dev/null; then
 if ln -s conf$$.file conf$$ 2>/dev/null; then
   as_ln_s='ln -s'
   # ... but there are two gotchas:
@@ -5975,6 +8421,9 @@ elif ln conf$$.file conf$$ 2>/dev/null; 
 else
   as_ln_s='cp -p'
 fi
+else
+  as_ln_s='cp -p'
+fi
 rm -f conf$$ conf$$.exe conf$$.dir/conf$$.file conf$$.file
 rmdir conf$$.dir 2>/dev/null
 
@@ -6021,8 +8470,8 @@ exec 6>&1
 # report actual input values of CONFIG_FILES etc. instead of their
 # values after options handling.
 ac_log="
-This file was extended by HTK $as_me 3.4.1, which was
-generated by GNU Autoconf 2.61.  Invocation command line was
+This file was extended by HTS $as_me 2.2, which was
+generated by GNU Autoconf 2.63.  Invocation command line was
 
   CONFIG_FILES    = $CONFIG_FILES
   CONFIG_HEADERS  = $CONFIG_HEADERS
@@ -6035,23 +8484,33 @@ on `(hostname || uname -n) 2>/dev/null |
 
 _ACEOF
 
-cat >>$CONFIG_STATUS <<_ACEOF
+case $ac_config_files in *"
+"*) set x $ac_config_files; shift; ac_config_files=$*;;
+esac
+
+case $ac_config_headers in *"
+"*) set x $ac_config_headers; shift; ac_config_headers=$*;;
+esac
+
+
+cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
 # Files that config.status was made for.
 config_files="$ac_config_files"
 config_headers="$ac_config_headers"
 
 _ACEOF
 
-cat >>$CONFIG_STATUS <<\_ACEOF
+cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1
 ac_cs_usage="\
 \`$as_me' instantiates files from templates according to the
 current configuration.
 
-Usage: $0 [OPTIONS] [FILE]...
+Usage: $0 [OPTION]... [FILE]...
 
   -h, --help       print this help, then exit
   -V, --version    print version number and configuration settings, then exit
-  -q, --quiet      do not print progress messages
+  -q, --quiet, --silent
+                   do not print progress messages
   -d, --debug      don't remove temporary files
       --recheck    update $as_me by reconfiguring in the same conditions
   --file=FILE[:TEMPLATE]
@@ -6068,24 +8527,25 @@ $config_headers
 Report bugs to <bug-autoconf@gnu.org>."
 
 _ACEOF
-cat >>$CONFIG_STATUS <<_ACEOF
+cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
 ac_cs_version="\\
-HTK config.status 3.4.1
-configured by $0, generated by GNU Autoconf 2.61,
-  with options \\"`echo "$ac_configure_args" | sed 's/^ //; s/[\\""\`\$]/\\\\&/g'`\\"
+HTS config.status 2.2
+configured by $0, generated by GNU Autoconf 2.63,
+  with options \\"`$as_echo "$ac_configure_args" | sed 's/^ //; s/[\\""\`\$]/\\\\&/g'`\\"
 
-Copyright (C) 2006 Free Software Foundation, Inc.
+Copyright (C) 2008 Free Software Foundation, Inc.
 This config.status script is free software; the Free Software Foundation
 gives unlimited permission to copy, distribute and modify it."
 
 ac_pwd='$ac_pwd'
 srcdir='$srcdir'
 INSTALL='$INSTALL'
+AWK='$AWK'
+test -n "\$AWK" || AWK=awk
 _ACEOF
 
-cat >>$CONFIG_STATUS <<\_ACEOF
-# If no file are specified by the user, then we need to provide default
-# value.  By we need to know if files were specified by the user.
+cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1
+# The default lists apply if the user does not specify any file.
 ac_need_defaults=:
 while test $# != 0
 do
@@ -6107,30 +8567,36 @@ do
   -recheck | --recheck | --rechec | --reche | --rech | --rec | --re | --r)
     ac_cs_recheck=: ;;
   --version | --versio | --versi | --vers | --ver | --ve | --v | -V )
-    echo "$ac_cs_version"; exit ;;
+    $as_echo "$ac_cs_version"; exit ;;
   --debug | --debu | --deb | --de | --d | -d )
     debug=: ;;
   --file | --fil | --fi | --f )
     $ac_shift
-    CONFIG_FILES="$CONFIG_FILES $ac_optarg"
+    case $ac_optarg in
+    *\'*) ac_optarg=`$as_echo "$ac_optarg" | sed "s/'/'\\\\\\\\''/g"` ;;
+    esac
+    CONFIG_FILES="$CONFIG_FILES '$ac_optarg'"
     ac_need_defaults=false;;
   --header | --heade | --head | --hea )
     $ac_shift
-    CONFIG_HEADERS="$CONFIG_HEADERS $ac_optarg"
+    case $ac_optarg in
+    *\'*) ac_optarg=`$as_echo "$ac_optarg" | sed "s/'/'\\\\\\\\''/g"` ;;
+    esac
+    CONFIG_HEADERS="$CONFIG_HEADERS '$ac_optarg'"
     ac_need_defaults=false;;
   --he | --h)
     # Conflict between --help and --header
-    { echo "$as_me: error: ambiguous option: $1
+    { $as_echo "$as_me: error: ambiguous option: $1
 Try \`$0 --help' for more information." >&2
    { (exit 1); exit 1; }; };;
   --help | --hel | -h )
-    echo "$ac_cs_usage"; exit ;;
+    $as_echo "$ac_cs_usage"; exit ;;
   -q | -quiet | --quiet | --quie | --qui | --qu | --q \
   | -silent | --silent | --silen | --sile | --sil | --si | --s)
     ac_cs_silent=: ;;
 
   # This is an error.
-  -*) { echo "$as_me: error: unrecognized option: $1
+  -*) { $as_echo "$as_me: error: unrecognized option: $1
 Try \`$0 --help' for more information." >&2
    { (exit 1); exit 1; }; } ;;
 
@@ -6149,30 +8615,32 @@ if $ac_cs_silent; then
 fi
 
 _ACEOF
-cat >>$CONFIG_STATUS <<_ACEOF
+cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
 if \$ac_cs_recheck; then
-  echo "running CONFIG_SHELL=$SHELL $SHELL $0 "$ac_configure_args \$ac_configure_extra_args " --no-create --no-recursion" >&6
-  CONFIG_SHELL=$SHELL
+  set X '$SHELL' '$0' $ac_configure_args \$ac_configure_extra_args --no-create --no-recursion
+  shift
+  \$as_echo "running CONFIG_SHELL=$SHELL \$*" >&6
+  CONFIG_SHELL='$SHELL'
   export CONFIG_SHELL
-  exec $SHELL "$0"$ac_configure_args \$ac_configure_extra_args --no-create --no-recursion
+  exec "\$@"
 fi
 
 _ACEOF
-cat >>$CONFIG_STATUS <<\_ACEOF
+cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1
 exec 5>>config.log
 {
   echo
   sed 'h;s/./-/g;s/^.../## /;s/...$/ ##/;p;x;p;x' <<_ASBOX
 ## Running $as_me. ##
 _ASBOX
-  echo "$ac_log"
+  $as_echo "$ac_log"
 } >&5
 
 _ACEOF
-cat >>$CONFIG_STATUS <<_ACEOF
+cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
 _ACEOF
 
-cat >>$CONFIG_STATUS <<\_ACEOF
+cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1
 
 # Handling of arguments.
 for ac_config_target in $ac_config_targets
@@ -6185,8 +8653,8 @@ do
     "HTKLVRec/Makefile") CONFIG_FILES="$CONFIG_FILES HTKLVRec/Makefile" ;;
     "Makefile") CONFIG_FILES="$CONFIG_FILES Makefile" ;;
 
-  *) { { echo "$as_me:$LINENO: error: invalid argument: $ac_config_target" >&5
-echo "$as_me: error: invalid argument: $ac_config_target" >&2;}
+  *) { { $as_echo "$as_me:$LINENO: error: invalid argument: $ac_config_target" >&5
+$as_echo "$as_me: error: invalid argument: $ac_config_target" >&2;}
    { (exit 1); exit 1; }; };;
   esac
 done
@@ -6226,137 +8694,143 @@ $debug ||
   (umask 077 && mkdir "$tmp")
 } ||
 {
-   echo "$me: cannot create a temporary directory in ." >&2
+   $as_echo "$as_me: cannot create a temporary directory in ." >&2
    { (exit 1); exit 1; }
 }
 
-#
-# Set up the sed scripts for CONFIG_FILES section.
-#
-
-# No need to generate the scripts if there are no CONFIG_FILES.
-# This happens for instance when ./config.status config.h
+# Set up the scripts for CONFIG_FILES section.
+# No need to generate them if there are no CONFIG_FILES.
+# This happens for instance with `./config.status config.h'.
 if test -n "$CONFIG_FILES"; then
 
-_ACEOF
 
+ac_cr=''
+ac_cs_awk_cr=`$AWK 'BEGIN { print "a\rb" }' </dev/null 2>/dev/null`
+if test "$ac_cs_awk_cr" = "a${ac_cr}b"; then
+  ac_cs_awk_cr='\\r'
+else
+  ac_cs_awk_cr=$ac_cr
+fi
+
+echo 'BEGIN {' >"$tmp/subs1.awk" &&
+_ACEOF
 
 
+{
+  echo "cat >conf$$subs.awk <<_ACEOF" &&
+  echo "$ac_subst_vars" | sed 's/.*/&!$&$ac_delim/' &&
+  echo "_ACEOF"
+} >conf$$subs.sh ||
+  { { $as_echo "$as_me:$LINENO: error: could not make $CONFIG_STATUS" >&5
+$as_echo "$as_me: error: could not make $CONFIG_STATUS" >&2;}
+   { (exit 1); exit 1; }; }
+ac_delim_num=`echo "$ac_subst_vars" | grep -c '$'`
 ac_delim='%!_!# '
 for ac_last_try in false false false false false :; do
-  cat >conf$$subs.sed <<_ACEOF
-SHELL!$SHELL$ac_delim
-PATH_SEPARATOR!$PATH_SEPARATOR$ac_delim
-PACKAGE_NAME!$PACKAGE_NAME$ac_delim
-PACKAGE_TARNAME!$PACKAGE_TARNAME$ac_delim
-PACKAGE_VERSION!$PACKAGE_VERSION$ac_delim
-PACKAGE_STRING!$PACKAGE_STRING$ac_delim
-PACKAGE_BUGREPORT!$PACKAGE_BUGREPORT$ac_delim
-exec_prefix!$exec_prefix$ac_delim
-prefix!$prefix$ac_delim
-program_transform_name!$program_transform_name$ac_delim
-bindir!$bindir$ac_delim
-sbindir!$sbindir$ac_delim
-libexecdir!$libexecdir$ac_delim
-datarootdir!$datarootdir$ac_delim
-datadir!$datadir$ac_delim
-sysconfdir!$sysconfdir$ac_delim
-sharedstatedir!$sharedstatedir$ac_delim
-localstatedir!$localstatedir$ac_delim
-includedir!$includedir$ac_delim
-oldincludedir!$oldincludedir$ac_delim
-docdir!$docdir$ac_delim
-infodir!$infodir$ac_delim
-htmldir!$htmldir$ac_delim
-dvidir!$dvidir$ac_delim
-pdfdir!$pdfdir$ac_delim
-psdir!$psdir$ac_delim
-libdir!$libdir$ac_delim
-localedir!$localedir$ac_delim
-mandir!$mandir$ac_delim
-DEFS!$DEFS$ac_delim
-ECHO_C!$ECHO_C$ac_delim
-ECHO_N!$ECHO_N$ac_delim
-ECHO_T!$ECHO_T$ac_delim
-LIBS!$LIBS$ac_delim
-build_alias!$build_alias$ac_delim
-host_alias!$host_alias$ac_delim
-target_alias!$target_alias$ac_delim
-SET_MAKE!$SET_MAKE$ac_delim
-AWK!$AWK$ac_delim
-CC!$CC$ac_delim
-CFLAGS!$CFLAGS$ac_delim
-LDFLAGS!$LDFLAGS$ac_delim
-CPPFLAGS!$CPPFLAGS$ac_delim
-ac_ct_CC!$ac_ct_CC$ac_delim
-EXEEXT!$EXEEXT$ac_delim
-OBJEXT!$OBJEXT$ac_delim
-INSTALL_PROGRAM!$INSTALL_PROGRAM$ac_delim
-INSTALL_SCRIPT!$INSTALL_SCRIPT$ac_delim
-INSTALL_DATA!$INSTALL_DATA$ac_delim
-LN_S!$LN_S$ac_delim
-RANLIB!$RANLIB$ac_delim
-XMKMF!$XMKMF$ac_delim
-CPP!$CPP$ac_delim
-GREP!$GREP$ac_delim
-EGREP!$EGREP$ac_delim
-LIBOBJS!$LIBOBJS$ac_delim
-POW_LIB!$POW_LIB$ac_delim
-build!$build$ac_delim
-build_cpu!$build_cpu$ac_delim
-build_vendor!$build_vendor$ac_delim
-build_os!$build_os$ac_delim
-host!$host$ac_delim
-host_cpu!$host_cpu$ac_delim
-host_vendor!$host_vendor$ac_delim
-host_os!$host_os$ac_delim
-TRADHTK!$TRADHTK$ac_delim
-TRADHTKBIN!$TRADHTKBIN$ac_delim
-make_all!$make_all$ac_delim
-make_install!$make_install$ac_delim
-HSLAB!$HSLAB$ac_delim
-HGRAF!$HGRAF$ac_delim
-BINARY_EXTENSION!$BINARY_EXTENSION$ac_delim
-LTLIBOBJS!$LTLIBOBJS$ac_delim
-_ACEOF
+  . ./conf$$subs.sh ||
+    { { $as_echo "$as_me:$LINENO: error: could not make $CONFIG_STATUS" >&5
+$as_echo "$as_me: error: could not make $CONFIG_STATUS" >&2;}
+   { (exit 1); exit 1; }; }
 
-  if test `sed -n "s/.*$ac_delim\$/X/p" conf$$subs.sed | grep -c X` = 73; then
+  ac_delim_n=`sed -n "s/.*$ac_delim\$/X/p" conf$$subs.awk | grep -c X`
+  if test $ac_delim_n = $ac_delim_num; then
     break
   elif $ac_last_try; then
-    { { echo "$as_me:$LINENO: error: could not make $CONFIG_STATUS" >&5
-echo "$as_me: error: could not make $CONFIG_STATUS" >&2;}
+    { { $as_echo "$as_me:$LINENO: error: could not make $CONFIG_STATUS" >&5
+$as_echo "$as_me: error: could not make $CONFIG_STATUS" >&2;}
    { (exit 1); exit 1; }; }
   else
     ac_delim="$ac_delim!$ac_delim _$ac_delim!! "
   fi
 done
+rm -f conf$$subs.sh
 
-ac_eof=`sed -n '/^CEOF[0-9]*$/s/CEOF/0/p' conf$$subs.sed`
-if test -n "$ac_eof"; then
-  ac_eof=`echo "$ac_eof" | sort -nru | sed 1q`
-  ac_eof=`expr $ac_eof + 1`
-fi
-
-cat >>$CONFIG_STATUS <<_ACEOF
-cat >"\$tmp/subs-1.sed" <<\CEOF$ac_eof
-/@[a-zA-Z_][a-zA-Z_0-9]*@/!b end
-_ACEOF
-sed '
-s/[,\\&]/\\&/g; s/@/@|#_!!_#|/g
-s/^/s,@/; s/!/@,|#_!!_#|/
-:n
-t n
-s/'"$ac_delim"'$/,g/; t
-s/$/\\/; p
-N; s/^.*\n//; s/[,\\&]/\\&/g; s/@/@|#_!!_#|/g; b n
-' >>$CONFIG_STATUS <conf$$subs.sed
-rm -f conf$$subs.sed
-cat >>$CONFIG_STATUS <<_ACEOF
-:end
-s/|#_!!_#|//g
-CEOF$ac_eof
+cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
+cat >>"\$tmp/subs1.awk" <<\\_ACAWK &&
 _ACEOF
+sed -n '
+h
+s/^/S["/; s/!.*/"]=/
+p
+g
+s/^[^!]*!//
+:repl
+t repl
+s/'"$ac_delim"'$//
+t delim
+:nl
+h
+s/\(.\{148\}\).*/\1/
+t more1
+s/["\\]/\\&/g; s/^/"/; s/$/\\n"\\/
+p
+n
+b repl
+:more1
+s/["\\]/\\&/g; s/^/"/; s/$/"\\/
+p
+g
+s/.\{148\}//
+t nl
+:delim
+h
+s/\(.\{148\}\).*/\1/
+t more2
+s/["\\]/\\&/g; s/^/"/; s/$/"/
+p
+b
+:more2
+s/["\\]/\\&/g; s/^/"/; s/$/"\\/
+p
+g
+s/.\{148\}//
+t delim
+' <conf$$subs.awk | sed '
+/^[^""]/{
+  N
+  s/\n//
+}
+' >>$CONFIG_STATUS || ac_write_fail=1
+rm -f conf$$subs.awk
+cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
+_ACAWK
+cat >>"\$tmp/subs1.awk" <<_ACAWK &&
+  for (key in S) S_is_set[key] = 1
+  FS = ""
 
+}
+{
+  line = $ 0
+  nfields = split(line, field, "@")
+  substed = 0
+  len = length(field[1])
+  for (i = 2; i < nfields; i++) {
+    key = field[i]
+    keylen = length(key)
+    if (S_is_set[key]) {
+      value = S[key]
+      line = substr(line, 1, len) "" value "" substr(line, len + keylen + 3)
+      len += length(value) + length(field[++i])
+      substed = 1
+    } else
+      len += 1 + keylen
+  }
+
+  print line
+}
+
+_ACAWK
+_ACEOF
+cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1
+if sed "s/$ac_cr//" < /dev/null > /dev/null 2>&1; then
+  sed "s/$ac_cr\$//; s/$ac_cr/$ac_cs_awk_cr/g"
+else
+  cat
+fi < "$tmp/subs1.awk" > "$tmp/subs.awk" \
+  || { { $as_echo "$as_me:$LINENO: error: could not setup config files machinery" >&5
+$as_echo "$as_me: error: could not setup config files machinery" >&2;}
+   { (exit 1); exit 1; }; }
+_ACEOF
 
 # VPATH may cause trouble with some makes, so we remove $(srcdir),
 # ${srcdir} and @srcdir@ from VPATH if srcdir is ".", strip leading and
@@ -6373,19 +8847,133 @@ s/^[^=]*=[	 ]*$//
 }'
 fi
 
-cat >>$CONFIG_STATUS <<\_ACEOF
+cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1
 fi # test -n "$CONFIG_FILES"
 
+# Set up the scripts for CONFIG_HEADERS section.
+# No need to generate them if there are no CONFIG_HEADERS.
+# This happens for instance with `./config.status Makefile'.
+if test -n "$CONFIG_HEADERS"; then
+cat >"$tmp/defines.awk" <<\_ACAWK ||
+BEGIN {
+_ACEOF
+
+# Transform confdefs.h into an awk script `defines.awk', embedded as
+# here-document in config.status, that substitutes the proper values into
+# config.h.in to produce config.h.
 
-for ac_tag in  :F $CONFIG_FILES  :H $CONFIG_HEADERS
+# Create a delimiter string that does not exist in confdefs.h, to ease
+# handling of long lines.
+ac_delim='%!_!# '
+for ac_last_try in false false :; do
+  ac_t=`sed -n "/$ac_delim/p" confdefs.h`
+  if test -z "$ac_t"; then
+    break
+  elif $ac_last_try; then
+    { { $as_echo "$as_me:$LINENO: error: could not make $CONFIG_HEADERS" >&5
+$as_echo "$as_me: error: could not make $CONFIG_HEADERS" >&2;}
+   { (exit 1); exit 1; }; }
+  else
+    ac_delim="$ac_delim!$ac_delim _$ac_delim!! "
+  fi
+done
+
+# For the awk script, D is an array of macro values keyed by name,
+# likewise P contains macro parameters if any.  Preserve backslash
+# newline sequences.
+
+ac_word_re=[_$as_cr_Letters][_$as_cr_alnum]*
+sed -n '
+s/.\{148\}/&'"$ac_delim"'/g
+t rset
+:rset
+s/^[	 ]*#[	 ]*define[	 ][	 ]*/ /
+t def
+d
+:def
+s/\\$//
+t bsnl
+s/["\\]/\\&/g
+s/^ \('"$ac_word_re"'\)\(([^()]*)\)[	 ]*\(.*\)/P["\1"]="\2"\
+D["\1"]=" \3"/p
+s/^ \('"$ac_word_re"'\)[	 ]*\(.*\)/D["\1"]=" \2"/p
+d
+:bsnl
+s/["\\]/\\&/g
+s/^ \('"$ac_word_re"'\)\(([^()]*)\)[	 ]*\(.*\)/P["\1"]="\2"\
+D["\1"]=" \3\\\\\\n"\\/p
+t cont
+s/^ \('"$ac_word_re"'\)[	 ]*\(.*\)/D["\1"]=" \2\\\\\\n"\\/p
+t cont
+d
+:cont
+n
+s/.\{148\}/&'"$ac_delim"'/g
+t clear
+:clear
+s/\\$//
+t bsnlc
+s/["\\]/\\&/g; s/^/"/; s/$/"/p
+d
+:bsnlc
+s/["\\]/\\&/g; s/^/"/; s/$/\\\\\\n"\\/p
+b cont
+' <confdefs.h | sed '
+s/'"$ac_delim"'/"\\\
+"/g' >>$CONFIG_STATUS || ac_write_fail=1
+
+cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
+  for (key in D) D_is_set[key] = 1
+  FS = ""
+}
+/^[\t ]*#[\t ]*(define|undef)[\t ]+$ac_word_re([\t (]|\$)/ {
+  line = \$ 0
+  split(line, arg, " ")
+  if (arg[1] == "#") {
+    defundef = arg[2]
+    mac1 = arg[3]
+  } else {
+    defundef = substr(arg[1], 2)
+    mac1 = arg[2]
+  }
+  split(mac1, mac2, "(") #)
+  macro = mac2[1]
+  prefix = substr(line, 1, index(line, defundef) - 1)
+  if (D_is_set[macro]) {
+    # Preserve the white space surrounding the "#".
+    print prefix "define", macro P[macro] D[macro]
+    next
+  } else {
+    # Replace #undef with comments.  This is necessary, for example,
+    # in the case of _POSIX_SOURCE, which is predefined and required
+    # on some systems where configure will not decide to define it.
+    if (defundef == "undef") {
+      print "/*", prefix defundef, macro, "*/"
+      next
+    }
+  }
+}
+{ print }
+_ACAWK
+_ACEOF
+cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1
+  { { $as_echo "$as_me:$LINENO: error: could not setup config headers machinery" >&5
+$as_echo "$as_me: error: could not setup config headers machinery" >&2;}
+   { (exit 1); exit 1; }; }
+fi # test -n "$CONFIG_HEADERS"
+
+
+eval set X "  :F $CONFIG_FILES  :H $CONFIG_HEADERS    "
+shift
+for ac_tag
 do
   case $ac_tag in
   :[FHLC]) ac_mode=$ac_tag; continue;;
   esac
   case $ac_mode$ac_tag in
   :[FHL]*:*);;
-  :L* | :C*:*) { { echo "$as_me:$LINENO: error: Invalid tag $ac_tag." >&5
-echo "$as_me: error: Invalid tag $ac_tag." >&2;}
+  :L* | :C*:*) { { $as_echo "$as_me:$LINENO: error: invalid tag $ac_tag" >&5
+$as_echo "$as_me: error: invalid tag $ac_tag" >&2;}
    { (exit 1); exit 1; }; };;
   :[FH]-) ac_tag=-:-;;
   :[FH]*) ac_tag=$ac_tag:$ac_tag.in;;
@@ -6414,26 +9002,38 @@ echo "$as_me: error: Invalid tag $ac_tag
 	   [\\/$]*) false;;
 	   *) test -f "$srcdir/$ac_f" && ac_f="$srcdir/$ac_f";;
 	   esac ||
-	   { { echo "$as_me:$LINENO: error: cannot find input file: $ac_f" >&5
-echo "$as_me: error: cannot find input file: $ac_f" >&2;}
+	   { { $as_echo "$as_me:$LINENO: error: cannot find input file: $ac_f" >&5
+$as_echo "$as_me: error: cannot find input file: $ac_f" >&2;}
    { (exit 1); exit 1; }; };;
       esac
-      ac_file_inputs="$ac_file_inputs $ac_f"
+      case $ac_f in *\'*) ac_f=`$as_echo "$ac_f" | sed "s/'/'\\\\\\\\''/g"`;; esac
+      ac_file_inputs="$ac_file_inputs '$ac_f'"
     done
 
     # Let's still pretend it is `configure' which instantiates (i.e., don't
     # use $as_me), people would be surprised to read:
     #    /* config.h.  Generated by config.status.  */
-    configure_input="Generated from "`IFS=:
-	  echo $* | sed 's|^[^:]*/||;s|:[^:]*/|, |g'`" by configure."
+    configure_input='Generated from '`
+	  $as_echo "$*" | sed 's|^[^:]*/||;s|:[^:]*/|, |g'
+	`' by configure.'
     if test x"$ac_file" != x-; then
       configure_input="$ac_file.  $configure_input"
-      { echo "$as_me:$LINENO: creating $ac_file" >&5
-echo "$as_me: creating $ac_file" >&6;}
+      { $as_echo "$as_me:$LINENO: creating $ac_file" >&5
+$as_echo "$as_me: creating $ac_file" >&6;}
     fi
+    # Neutralize special characters interpreted by sed in replacement strings.
+    case $configure_input in #(
+    *\&* | *\|* | *\\* )
+       ac_sed_conf_input=`$as_echo "$configure_input" |
+       sed 's/[\\\\&|]/\\\\&/g'`;; #(
+    *) ac_sed_conf_input=$configure_input;;
+    esac
 
     case $ac_tag in
-    *:-:* | *:-) cat >"$tmp/stdin";;
+    *:-:* | *:-) cat >"$tmp/stdin" \
+      || { { $as_echo "$as_me:$LINENO: error: could not create $ac_file" >&5
+$as_echo "$as_me: error: could not create $ac_file" >&2;}
+   { (exit 1); exit 1; }; } ;;
     esac
     ;;
   esac
@@ -6443,7 +9043,7 @@ $as_expr X"$ac_file" : 'X\(.*[^/]\)//*[^
 	 X"$ac_file" : 'X\(//\)[^/]' \| \
 	 X"$ac_file" : 'X\(//\)$' \| \
 	 X"$ac_file" : 'X\(/\)' \| . 2>/dev/null ||
-echo X"$ac_file" |
+$as_echo X"$ac_file" |
     sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{
 	    s//\1/
 	    q
@@ -6469,7 +9069,7 @@ echo X"$ac_file" |
     as_dirs=
     while :; do
       case $as_dir in #(
-      *\'*) as_qdir=`echo "$as_dir" | sed "s/'/'\\\\\\\\''/g"`;; #(
+      *\'*) as_qdir=`$as_echo "$as_dir" | sed "s/'/'\\\\\\\\''/g"`;; #'(
       *) as_qdir=$as_dir;;
       esac
       as_dirs="'$as_qdir' $as_dirs"
@@ -6478,7 +9078,7 @@ $as_expr X"$as_dir" : 'X\(.*[^/]\)//*[^/
 	 X"$as_dir" : 'X\(//\)[^/]' \| \
 	 X"$as_dir" : 'X\(//\)$' \| \
 	 X"$as_dir" : 'X\(/\)' \| . 2>/dev/null ||
-echo X"$as_dir" |
+$as_echo X"$as_dir" |
     sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{
 	    s//\1/
 	    q
@@ -6499,17 +9099,17 @@ echo X"$as_dir" |
       test -d "$as_dir" && break
     done
     test -z "$as_dirs" || eval "mkdir $as_dirs"
-  } || test -d "$as_dir" || { { echo "$as_me:$LINENO: error: cannot create directory $as_dir" >&5
-echo "$as_me: error: cannot create directory $as_dir" >&2;}
+  } || test -d "$as_dir" || { { $as_echo "$as_me:$LINENO: error: cannot create directory $as_dir" >&5
+$as_echo "$as_me: error: cannot create directory $as_dir" >&2;}
    { (exit 1); exit 1; }; }; }
   ac_builddir=.
 
 case "$ac_dir" in
 .) ac_dir_suffix= ac_top_builddir_sub=. ac_top_build_prefix= ;;
 *)
-  ac_dir_suffix=/`echo "$ac_dir" | sed 's,^\.[\\/],,'`
+  ac_dir_suffix=/`$as_echo "$ac_dir" | sed 's|^\.[\\/]||'`
   # A ".." for each directory in $ac_dir_suffix.
-  ac_top_builddir_sub=`echo "$ac_dir_suffix" | sed 's,/[^\\/]*,/..,g;s,/,,'`
+  ac_top_builddir_sub=`$as_echo "$ac_dir_suffix" | sed 's|/[^\\/]*|/..|g;s|/||'`
   case $ac_top_builddir_sub in
   "") ac_top_builddir_sub=. ac_top_build_prefix= ;;
   *)  ac_top_build_prefix=$ac_top_builddir_sub/ ;;
@@ -6549,12 +9149,13 @@ ac_abs_srcdir=$ac_abs_top_srcdir$ac_dir_
   esac
 _ACEOF
 
-cat >>$CONFIG_STATUS <<\_ACEOF
+cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1
 # If the template does not know about datarootdir, expand it.
 # FIXME: This hack should be removed a few years after 2.60.
 ac_datarootdir_hack=; ac_datarootdir_seen=
 
-case `sed -n '/datarootdir/ {
+ac_sed_dataroot='
+/datarootdir/ {
   p
   q
 }
@@ -6563,13 +9164,14 @@ case `sed -n '/datarootdir/ {
 /@infodir@/p
 /@localedir@/p
 /@mandir@/p
-' $ac_file_inputs` in
+'
+case `eval "sed -n \"\$ac_sed_dataroot\" $ac_file_inputs"` in
 *datarootdir*) ac_datarootdir_seen=yes;;
 *@datadir@*|*@docdir@*|*@infodir@*|*@localedir@*|*@mandir@*)
-  { echo "$as_me:$LINENO: WARNING: $ac_file_inputs seems to ignore the --datarootdir setting" >&5
-echo "$as_me: WARNING: $ac_file_inputs seems to ignore the --datarootdir setting" >&2;}
+  { $as_echo "$as_me:$LINENO: WARNING: $ac_file_inputs seems to ignore the --datarootdir setting" >&5
+$as_echo "$as_me: WARNING: $ac_file_inputs seems to ignore the --datarootdir setting" >&2;}
 _ACEOF
-cat >>$CONFIG_STATUS <<_ACEOF
+cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
   ac_datarootdir_hack='
   s&@datadir@&$datadir&g
   s&@docdir@&$docdir&g
@@ -6583,15 +9185,16 @@ _ACEOF
 # Neutralize VPATH when `$srcdir' = `.'.
 # Shell code in configure.ac might set extrasub.
 # FIXME: do we really want to maintain this feature?
-cat >>$CONFIG_STATUS <<_ACEOF
-  sed "$ac_vpsub
+cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
+ac_sed_extra="$ac_vpsub
 $extrasub
 _ACEOF
-cat >>$CONFIG_STATUS <<\_ACEOF
+cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1
 :t
 /@[a-zA-Z_][a-zA-Z_0-9]*@/!b
-s&@configure_input@&$configure_input&;t t
+s|@configure_input@|$ac_sed_conf_input|;t t
 s&@top_builddir@&$ac_top_builddir_sub&;t t
+s&@top_build_prefix@&$ac_top_build_prefix&;t t
 s&@srcdir@&$ac_srcdir&;t t
 s&@abs_srcdir@&$ac_abs_srcdir&;t t
 s&@top_srcdir@&$ac_top_srcdir&;t t
@@ -6601,119 +9204,58 @@ s&@abs_builddir@&$ac_abs_builddir&;t t
 s&@abs_top_builddir@&$ac_abs_top_builddir&;t t
 s&@INSTALL@&$ac_INSTALL&;t t
 $ac_datarootdir_hack
-" $ac_file_inputs | sed -f "$tmp/subs-1.sed" >$tmp/out
+"
+eval sed \"\$ac_sed_extra\" "$ac_file_inputs" | $AWK -f "$tmp/subs.awk" >$tmp/out \
+  || { { $as_echo "$as_me:$LINENO: error: could not create $ac_file" >&5
+$as_echo "$as_me: error: could not create $ac_file" >&2;}
+   { (exit 1); exit 1; }; }
 
 test -z "$ac_datarootdir_hack$ac_datarootdir_seen" &&
   { ac_out=`sed -n '/\${datarootdir}/p' "$tmp/out"`; test -n "$ac_out"; } &&
   { ac_out=`sed -n '/^[	 ]*datarootdir[	 ]*:*=/p' "$tmp/out"`; test -z "$ac_out"; } &&
-  { echo "$as_me:$LINENO: WARNING: $ac_file contains a reference to the variable \`datarootdir'
+  { $as_echo "$as_me:$LINENO: WARNING: $ac_file contains a reference to the variable \`datarootdir'
 which seems to be undefined.  Please make sure it is defined." >&5
-echo "$as_me: WARNING: $ac_file contains a reference to the variable \`datarootdir'
+$as_echo "$as_me: WARNING: $ac_file contains a reference to the variable \`datarootdir'
 which seems to be undefined.  Please make sure it is defined." >&2;}
 
   rm -f "$tmp/stdin"
   case $ac_file in
-  -) cat "$tmp/out"; rm -f "$tmp/out";;
-  *) rm -f "$ac_file"; mv "$tmp/out" $ac_file;;
-  esac
+  -) cat "$tmp/out" && rm -f "$tmp/out";;
+  *) rm -f "$ac_file" && mv "$tmp/out" "$ac_file";;
+  esac \
+  || { { $as_echo "$as_me:$LINENO: error: could not create $ac_file" >&5
+$as_echo "$as_me: error: could not create $ac_file" >&2;}
+   { (exit 1); exit 1; }; }
  ;;
   :H)
   #
   # CONFIG_HEADER
   #
-_ACEOF
-
-# Transform confdefs.h into a sed script `conftest.defines', that
-# substitutes the proper values into config.h.in to produce config.h.
-rm -f conftest.defines conftest.tail
-# First, append a space to every undef/define line, to ease matching.
-echo 's/$/ /' >conftest.defines
-# Then, protect against being on the right side of a sed subst, or in
-# an unquoted here document, in config.status.  If some macros were
-# called several times there might be several #defines for the same
-# symbol, which is useless.  But do not sort them, since the last
-# AC_DEFINE must be honored.
-ac_word_re=[_$as_cr_Letters][_$as_cr_alnum]*
-# These sed commands are passed to sed as "A NAME B PARAMS C VALUE D", where
-# NAME is the cpp macro being defined, VALUE is the value it is being given.
-# PARAMS is the parameter list in the macro definition--in most cases, it's
-# just an empty string.
-ac_dA='s,^\\([	 #]*\\)[^	 ]*\\([	 ]*'
-ac_dB='\\)[	 (].*,\\1define\\2'
-ac_dC=' '
-ac_dD=' ,'
-
-uniq confdefs.h |
-  sed -n '
-	t rset
-	:rset
-	s/^[	 ]*#[	 ]*define[	 ][	 ]*//
-	t ok
-	d
-	:ok
-	s/[\\&,]/\\&/g
-	s/^\('"$ac_word_re"'\)\(([^()]*)\)[	 ]*\(.*\)/ '"$ac_dA"'\1'"$ac_dB"'\2'"${ac_dC}"'\3'"$ac_dD"'/p
-	s/^\('"$ac_word_re"'\)[	 ]*\(.*\)/'"$ac_dA"'\1'"$ac_dB$ac_dC"'\2'"$ac_dD"'/p
-  ' >>conftest.defines
-
-# Remove the space that was appended to ease matching.
-# Then replace #undef with comments.  This is necessary, for
-# example, in the case of _POSIX_SOURCE, which is predefined and required
-# on some systems where configure will not decide to define it.
-# (The regexp can be short, since the line contains either #define or #undef.)
-echo 's/ $//
-s,^[	 #]*u.*,/* & */,' >>conftest.defines
-
-# Break up conftest.defines:
-ac_max_sed_lines=50
-
-# First sed command is:	 sed -f defines.sed $ac_file_inputs >"$tmp/out1"
-# Second one is:	 sed -f defines.sed "$tmp/out1" >"$tmp/out2"
-# Third one will be:	 sed -f defines.sed "$tmp/out2" >"$tmp/out1"
-# et cetera.
-ac_in='$ac_file_inputs'
-ac_out='"$tmp/out1"'
-ac_nxt='"$tmp/out2"'
-
-while :
-do
-  # Write a here document:
-    cat >>$CONFIG_STATUS <<_ACEOF
-    # First, check the format of the line:
-    cat >"\$tmp/defines.sed" <<\\CEOF
-/^[	 ]*#[	 ]*undef[	 ][	 ]*$ac_word_re[	 ]*\$/b def
-/^[	 ]*#[	 ]*define[	 ][	 ]*$ac_word_re[(	 ]/b def
-b
-:def
-_ACEOF
-  sed ${ac_max_sed_lines}q conftest.defines >>$CONFIG_STATUS
-  echo 'CEOF
-    sed -f "$tmp/defines.sed"' "$ac_in >$ac_out" >>$CONFIG_STATUS
-  ac_in=$ac_out; ac_out=$ac_nxt; ac_nxt=$ac_in
-  sed 1,${ac_max_sed_lines}d conftest.defines >conftest.tail
-  grep . conftest.tail >/dev/null || break
-  rm -f conftest.defines
-  mv conftest.tail conftest.defines
-done
-rm -f conftest.defines conftest.tail
-
-echo "ac_result=$ac_in" >>$CONFIG_STATUS
-cat >>$CONFIG_STATUS <<\_ACEOF
   if test x"$ac_file" != x-; then
-    echo "/* $configure_input  */" >"$tmp/config.h"
-    cat "$ac_result" >>"$tmp/config.h"
-    if diff $ac_file "$tmp/config.h" >/dev/null 2>&1; then
-      { echo "$as_me:$LINENO: $ac_file is unchanged" >&5
-echo "$as_me: $ac_file is unchanged" >&6;}
-    else
-      rm -f $ac_file
-      mv "$tmp/config.h" $ac_file
+    {
+      $as_echo "/* $configure_input  */" \
+      && eval '$AWK -f "$tmp/defines.awk"' "$ac_file_inputs"
+    } >"$tmp/config.h" \
+      || { { $as_echo "$as_me:$LINENO: error: could not create $ac_file" >&5
+$as_echo "$as_me: error: could not create $ac_file" >&2;}
+   { (exit 1); exit 1; }; }
+    if diff "$ac_file" "$tmp/config.h" >/dev/null 2>&1; then
+      { $as_echo "$as_me:$LINENO: $ac_file is unchanged" >&5
+$as_echo "$as_me: $ac_file is unchanged" >&6;}
+    else
+      rm -f "$ac_file"
+      mv "$tmp/config.h" "$ac_file" \
+	|| { { $as_echo "$as_me:$LINENO: error: could not create $ac_file" >&5
+$as_echo "$as_me: error: could not create $ac_file" >&2;}
+   { (exit 1); exit 1; }; }
     fi
   else
-    echo "/* $configure_input  */"
-    cat "$ac_result"
+    $as_echo "/* $configure_input  */" \
+      && eval '$AWK -f "$tmp/defines.awk"' "$ac_file_inputs" \
+      || { { $as_echo "$as_me:$LINENO: error: could not create -" >&5
+$as_echo "$as_me: error: could not create -" >&2;}
+   { (exit 1); exit 1; }; }
   fi
-  rm -f "$tmp/out12"
  ;;
 
 
@@ -6727,6 +9269,11 @@ _ACEOF
 chmod +x $CONFIG_STATUS
 ac_clean_files=$ac_clean_files_save
 
+test $ac_write_fail = 0 ||
+  { { $as_echo "$as_me:$LINENO: error: write failure creating $CONFIG_STATUS" >&5
+$as_echo "$as_me: error: write failure creating $CONFIG_STATUS" >&2;}
+   { (exit 1); exit 1; }; }
+
 
 # configure is writing to config.log, and then calls config.status.
 # config.status does its own redirection, appending to config.log.
@@ -6748,6 +9295,10 @@ if test "$no_create" != yes; then
   # would make configure fail if this is the last instruction.
   $ac_cs_success || { (exit 1); exit 1; }
 fi
+if test -n "$ac_unrecognized_opts" && test "$enable_option_checking" != no; then
+  { $as_echo "$as_me:$LINENO: WARNING: unrecognized options: $ac_unrecognized_opts" >&5
+$as_echo "$as_me: WARNING: unrecognized options: $ac_unrecognized_opts" >&2;}
+fi
 
 
 case "$enable_trad_htk" in
diff -pbBEwurNa --ignore-matching-lines='.*vc_id.*' HTK-3.4.1/configure.ac HTS-2.2_for_HTK-3.4.1/configure.ac
--- HTK-3.4.1/configure.ac	2009-03-25 23:45:47.000000000 +0900
+++ HTS-2.2_for_HTK-3.4.1/configure.ac	2011-06-20 09:01:29.000000000 +0900
@@ -20,10 +20,59 @@
 # File: configure.ac source file for generating configure script
 # ----------------------------------------------------------- 
 
+#  *** THIS IS A MODIFIED VERSION OF HTK ***                        #
+# ----------------------------------------------------------------- #
+#           The HMM-Based Speech Synthesis System (HTS)             #
+#           developed by HTS Working Group                          #
+#           http://hts.sp.nitech.ac.jp/                             #
+# ----------------------------------------------------------------- #
+#                                                                   #
+#  Copyright (c) 2001-2011  Nagoya Institute of Technology          #
+#                           Department of Computer Science          #
+#                                                                   #
+#                2001-2008  Tokyo Institute of Technology           #
+#                           Interdisciplinary Graduate School of    #
+#                           Science and Engineering                 #
+#                                                                   #
+# All rights reserved.                                              #
+#                                                                   #
+# Redistribution and use in source and binary forms, with or        #
+# without modification, are permitted provided that the following   #
+# conditions are met:                                               #
+#                                                                   #
+# - Redistributions of source code must retain the above copyright  #
+#   notice, this list of conditions and the following disclaimer.   #
+# - Redistributions in binary form must reproduce the above         #
+#   copyright notice, this list of conditions and the following     #
+#   disclaimer in the documentation and/or other materials provided #
+#   with the distribution.                                          #
+# - Neither the name of the HTS working group nor the names of its  #
+#   contributors may be used to endorse or promote products derived #
+#   from this software without specific prior written permission.   #
+#                                                                   #
+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND            #
+# CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,       #
+# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF          #
+# MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE          #
+# DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS #
+# BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,          #
+# EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED   #
+# TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,     #
+# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON #
+# ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,   #
+# OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY    #
+# OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE           #
+# POSSIBILITY OF SUCH DAMAGE.                                       #
+# ----------------------------------------------------------------- #
+
 # After editing this file, run "autoconf" to regenerate "configure".
 
-AC_INIT(HTK,3.4.1,htk-mgr@eng.cam.ac.uk)
+AC_INIT(HTS,2.2, hts-users@sp.nitech.ac.jp)
 AC_COPYRIGHT(Copyright 2003-2009 University of Cambridge)
+AC_COPYRIGHT(Copyright 2001-2011 Nagoya Institute of Technology)
+AC_COPYRIGHT(Copyright 2001-2008 Tokyo Institute of Technology)
+
+AC_PREFIX_DEFAULT(/usr/local/HTS-2.2beta)
 
 dnl Checks for programs.
 AC_PROG_MAKE_SET
@@ -33,9 +82,28 @@ AC_PROG_INSTALL
 AC_PROG_LN_S
 AC_PROG_RANLIB
 
+dnl Check for ar
+AN_MAKEVAR([AR], [AC_PROG_AR])
+AN_PROGRAM([ar], [AC_PROG_AR])
+AC_DEFUN([AC_PROG_AR], [AC_CHECK_TOOL(AR, ar, :)])
+AC_PROG_AR
+
 dnl Checks for libraries.
 AC_CHECK_LIB([X11], [main])
-AC_CHECK_LIB([m], [main])
+AC_CHECK_LIB([m], [main],,AC_MSG_ERROR(Cannot find libm))
+
+dnl Checks for FORTRAN
+AC_PROG_F77
+if test -z "$F77"; then
+	LBFGS=''
+	FLIBS=''
+else
+	LBFGS='lbfgs.o'
+	AC_F77_LIBRARY_LDFLAGS
+	CFLAGS="$CFLAGS -D_HAS_FORTRAN"
+fi
+AC_SUBST(FLIBS, $FLIBS)
+AC_SUBST(LBFGS, $LBFGS)
 
 dnl Checks for header files.
 AC_CONFIG_HEADERS
@@ -45,6 +113,7 @@ AC_CHECK_HEADERS(errno.h fcntl.h float.h
 
 dnl Checks for typedefs, structures, and compiler characteristics.
 AC_C_CONST
+AC_C_VOLATILE
 AC_TYPE_SIZE_T
 AC_HEADER_TIME
 AC_STRUCT_TM
@@ -53,13 +122,18 @@ dnl Checks for library functions.
 AC_PROG_GCC_TRADITIONAL
 AC_FUNC_MEMCMP
 AC_FUNC_MALLOC
+AC_FUNC_REALLOC
 AC_FUNC_STRTOD
 AC_TYPE_SIGNAL
 AC_FUNC_VPRINTF
+AC_HEADER_STDBOOL
 AC_CHECK_FUNCS(floor gettimeofday memmove memset modf pow socket sqrt strchr strcspn strrchr strspn strstr strtol)
+AC_CHECK_FUNCS(strdup)
 
 
 AC_CANONICAL_HOST
+AC_C_BIGENDIAN
+AC_CHECK_SIZEOF(int *)
 
 dnl Traditional HTK build?
 dnl if enabled this will install in $bindir.$host_cpu
@@ -74,8 +148,8 @@ AC_ARG_ENABLE(hdecode,
 
 dnl Build LM Tools
 AC_ARG_ENABLE(hlmtools,
-		AS_HELP_STRING([--disable-hlmtools],
-		[don't build Language Modelling tools]))
+		AS_HELP_STRING([--enable-hlmtools],
+		[build Language Modelling tools]))
 
 dnl Disable building for X
 dnl i.e. use HGraf.null, and don't build HSLab
@@ -95,6 +169,12 @@ case "$CC" in
 		CFLAGS="-Wall -Wno-switch $CFLAGS"
 		;;		
 esac
+dnl Use -Wall if using g77
+case "$F77" in
+	g77*)
+		FFLAGS="-Wall $FFLAGS"
+	;;
+esac
 
 
 dnl customise for htk comilpation
@@ -108,42 +188,57 @@ esac
 
 case "$host" in
 		*x86_64*linux*)
-				CFLAGS="-m32 -ansi -D_SVID_SOURCE -DOSS_AUDIO -D'ARCH=\"$host_cpu\"' $CFLAGS"
+				CFLAGS="-ansi -D_SVID_SOURCE -DOSS_AUDIO -D'ARCH=\"$host_cpu\"' $CFLAGS"
+				FFLAGS="$FFLAGS"
+				AC_MSG_CHECKING(whether to compile in 32-bit or 64-bit mode)
+				if test x$ac_cv_sizeof_int_p = x"4"; then
+					AC_MSG_RESULT(32-bit)
 				LDFLAGS="-L/usr/X11R6/lib $LDFLAGS"
+				elif test x$ac_cv_sizeof_int_p = x"8"; then
+					AC_MSG_RESULT(64-bit)
+					LDFLAGS="-L/usr/X11R6/lib64 $LDFLAGS"
+				fi
 				ARCH=linux
 				trad_bin_dir=linux
 		;;
 		*linux*)
 				CFLAGS="-ansi -D_SVID_SOURCE -DOSS_AUDIO -D'ARCH=\"$host_cpu\"' $CFLAGS"
+				FFLAGS="$FFLAGS"
 				LDFLAGS="-L/usr/X11R6/lib $LDFLAGS"
 				ARCH=linux
 				trad_bin_dir=linux
 		;;
 		*pc-solaris*)
 				CFLAGS="-ansi -I/usr/openwin/include -O2 -DSOLARIS16_AUDIO -DBSD_COMP -D'ARCH=\"$host_cpu\"' $CFLAGS"
+				FFLAGS="-O2 $FFLAGS"
 				LDFLAGS="-L/usr/openwin/lib -ldl -lsocket -lnsl -lintl $LDFLAGS"
 		;;
 		*sun*)
 				CFLAGS="-ansi -I/usr/openwin/include -O2 -DSOLARIS16_AUDIO -DBSD_COMP -D'ARCH=\"$host_cpu\"' $CFLAGS"
+				FFLAGS="-O2 $FFLAGS"
 				LDFLAGS="-L/usr/openwin/lib -ldl -lsocket -lnsl -lintl $LDFLAGS"
 		;;
 		*sgi*)
 				CFLAGS="-O -DSGI_AUDIO  -D'ARCH=\"$host_cpu\"' $CFLAGS"
+				FFLAGS="$FFLAGS"
 				LDFLAGS="-laudio -lmalloc $LDFLAGS"
 		;;
 		*hp*)
 				CFLAGS="+e -O -I/usr/include/X11R5 -I/usr/include/audio -I/opt/audio/include -D_HPUX_SOURCE -Aa -DHPUX_AUDIO -DUSE_TIMER  -D'ARCH=\"$host_cpu\"' $CFLAGS"
+				FFLAGS="$FFLAGS"
 				LDFLAGS="-L/opt/audio/lib -lAlib $LDFLAGS"
 		;;
 		*cygwin)
 				CFLAGS="-ansi -DCYGWIN -D'ARCH=\"ASCII\"' $CFLAGS"
+				FFLAGS="$FFLAGS"
 				LDFLAGS="-L/usr/X11R6/lib $LDFLAGS"
 				ARCH=ASCII
-				CPU=darwin
+				CPU=cygwin
 				BINARY_EXTENSION=.exe
 		;;				
 		i386*darwin*)
 				CFLAGS="-ansi -g -O2 -DNO_AUDIO -D'ARCH=\"darwin\"' -I/usr/include/malloc $CFLAGS"
+				FFLAGS="-gdwarf-2 -O2 $$FFLAGS"
 				LDFLAGS="-L/usr/X11R6/lib $LDFLAGS"
 				ARCH=darwin
 				Objcopy=echo
@@ -152,8 +247,9 @@ case "$host" in
 				SHRLF="-shared"
 				LIBEXT=dylib
 		;;				
-		darwin)
-				CFLAGS="-ansi -g -O2 -DNO_AUDIO -D'ARCH=\"darwin\"' $CFLAGS"
+		*darwin*)
+				CFLAGS="-ansi -g -O2 -DNO_AUDIO -D'ARCH=\"darwin\"' -I/usr/include/malloc $CFLAGS"
+				FFLAGS="-gdwarf-2 -O2 $$FFLAGS"
 				LDFLAGS="-L/usr/X11R6/lib $LDFLAGS"
 				ARCH=darwin
 				Objcopy=echo
@@ -164,6 +260,39 @@ case "$host" in
 		;;				
 esac
 
+dnl define MAXSTRLEN if users want to change it to other value
+AC_ARG_VAR([MAXSTRLEN],[max length of strings (default=1024)])
+if test -n "$MAXSTRLEN" -a $MAXSTRLEN!=1024; then
+	AC_MSG_CHECKING(user-defined maximum length of strings)
+	CFLAGS="$CFLAGS -DMAXSTRLEN=$MAXSTRLEN"
+	AC_MSG_RESULT($MAXSTRLEN)
+fi
+
+dnl define MAXFNAMELEN if users want to change it to other value
+AC_ARG_VAR([MAXFNAMELEN],[max length of file names (default=1024)])
+if test -n "$MAXFNAMELEN" -a $MAXFNAMELEN!=1024; then
+	AC_MSG_CHECKING(user-defined maximum length of file names)
+	CFLAGS="$CFLAGS -DMAXFNAMELEN=$MAXFNAMELEN"
+	AC_MSG_RESULT($MAXFNAMELEN)
+fi
+
+dnl define PAT_LEN if users want to change it to other value
+AC_ARG_VAR([PAT_LEN],[max length of patterns (default=2048)])
+if test -n "$PAT_LEN" -a $PAT_LEN!=2048; then
+	AC_MSG_CHECKING(user-defined maximum length of file names)
+	CFLAGS="$CFLAGS -DPAT_LEN=$PAT_LEN"
+	AC_MSG_RESULT($PAT_LEN)
+fi
+
+dnl define SMAX if users want to change it to other value
+AC_ARG_VAR([SMAX],[max number of streams (default=30)])
+if test -n "$SMAX" -a $SMAX!=30; then
+	AC_MSG_CHECKING(user-defined maximum number of streams)
+	CFLAGS="$CFLAGS -DSMAX=$SMAX"
+	AC_MSG_RESULT($SMAX)
+fi
+
+
 dnl Process customised options
 make_all=htktools
 make_install=install-htktools
@@ -177,23 +306,25 @@ case "$enable_trad_htk" in
 	;;
 esac
 case "$enable_hlmtools" in
-     no)
-	build_notes="$build_notes The Language Modelling tools will not be built. You can build them manually later by running 'make hlmtools install-hlmtools'"
-	;;
-     *)
+     yes)
 	make_all="$make_all hlmtools"
 	make_install="$make_install install-hlmtools"
 	build_notes="$build_notes Language Modelling tools will be built."
 	;;
+     *)
+	build_notes="$build_notes The Language Modelling tools will not be built. You can build them manually later by running 'make hlmtools install-hlmtools'"
+	;;
 esac
 case "$enable_hdecode" in
      yes)
 	make_all="$make_all hdecode"
 	make_install="$make_install install-hdecode"
 	build_notes="$build_notes Large Vocabulary recogniser HDecode will be built."
+	LIBLV="HTKLiblv.a"
 	;;
      *)
 	build_notes="$build_notes HDecode will not be built. You can build it manually later by running 'make hdecode install-hdecode'"
+	LIBLV=""
 	;;
 esac
 case "$enable_htkbook" in
@@ -222,6 +353,7 @@ AC_SUBST(make_install, $make_install)
 AC_SUBST(HSLAB, $HSLAB)
 AC_SUBST(HGRAF, $HGRAF)
 AC_SUBST(BINARY_EXTENSION, $BINARY_EXTENSION)
+AC_SUBST(LIBLV)
 
 AC_OUTPUT(HTKLib/Makefile HTKTools/Makefile HLMLib/Makefile HLMTools/Makefile HTKLVRec/Makefile Makefile)
 
